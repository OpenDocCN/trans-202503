- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GETTING STARTED**
  prefs: []
  type: TYPE_NORMAL
- en: '*You don’t have to see the whole staircase, just take the first step.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*—*Dr. Martin Luther King Jr.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned in the introduction, to learn a programming language, it’s not
    enough to read a book—not even one as good as this. Experimenting and writing
    programs yourself is essential. After absorbing a key concept in the book or running
    a code sample, try to construct variations of the code and run them. Writing your
    own variations will help you achieve fluency in the language.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter first covers how to install Julia on all the major operating systems,
    and then discusses the various types of coding environments. We’ll see how to
    install each one, and explore their unique features, advantages, and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installation Guide**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, to be able to do any of this you will need access to a Julia system.
    If you’re already set up to run Julia code, you can safely skip this whole section.
    If not, you can skip the subsections covering installation on operating systems
    that you don’t use, but you should probably read everything else.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hardware Requirements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For learning Julia, almost any computer will be sufficient. It should have at
    least 2GB of RAM, but twice that amount will be more comfortable. You’ll need
    about 0.5GB of free disk space to install Julia, but you should have at least
    3GB of additional space for the packages that you’ll install for plotting and
    other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: These modest requirements are fine for learning the language and even for doing
    many real calculations, although you may require beefier hardware for larger-scale
    projects. Julia is used for calculations at every scale, and it can make efficient
    use of all types of hardware from laptops to GPU array processors to the world’s
    largest supercomputers (see “Further Reading” on [page 23](ch01.xhtml#fur1) for
    an example). I have run every example calculation in this book on a very modestly
    powered laptop, so all of the code here should run with no problems on any machine
    that you’re likely to be using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia runs on Linux, FreeBSD, macOS, and Windows. At the time of writing, Julia
    is fully supported on these systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux 2.6.18+: x86-64 (64-bit), i686 (32-bit), and ARMv8 (64-bit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FreeBSD 11.0+: x86-64 (64-bit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'macOS 10.9+: x86-64 (64-bit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows 7+: x86-64 (32- and 64-bit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These installation requirements may change, so check [*https://julialang.org/downloads/*](https://julialang.org/downloads/)
    for up-to-date information.
  prefs: []
  type: TYPE_NORMAL
- en: Julia also runs on some system versions and architectures not listed here, but
    with reduced support, weaker guarantees, or possibly hampered functionality. It
    can also take advantage of more specialized hardware—for example, graphical processing
    unit array processors, which we’ll discuss in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '***Prerequisites***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use Julia effectively, you need to know a few things about how to operate
    your computer. You need a basic knowledge of the terminal and the command line:
    how to create and change directories (folders), view a list of files, find out
    how much storage space is available on your hard drive, and delete files.'
  prefs: []
  type: TYPE_NORMAL
- en: Every operating system has various graphical utilities for accomplishing those
    tasks, both built-in and as third-party software, but it is a good idea for the
    computational scientist to become familiar with the command line and use it routinely.
    There’s a good chance you’ll find yourself in a remote computing situation some
    day, where the command line may be the only way to communicate with the remote
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also a good idea, even if your personal computer uses some other operating
    system, to learn how to perform these rudimentary tasks on Linux, as that is by
    far the most common frontend OS on compute servers for scientific work. If your
    daily driver comes from Apple, that won’t be a problem, as the basic commands
    in the macOS BSD-derived terminal are nearly the same as on Linux. If you’re accustomed
    to Windows, you may need to learn some translations; however, that is beyond the
    scope of this book, and you won’t need to know the Linux dialect to use Julia
    on your personal computer.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to be familiar with an editor on your system that can save
    files in a plaintext format. Most programmers use Vim, Emacs, or a more elaborate
    integrated development environment (IDE)—options that we will discuss further
    in the next section. You can use any editor you’re familiar with, but graphical
    editors such as Word are not the best choice. However, if you really want to use
    such programs, they’ll work. Just be sure to save your creations as plaintext
    files, and use a monospaced font, which will work better for writing code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Julia Versions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most people, no matter their platform, will download Julia from the official
    Julia website at [*https://julialang.org/downloads/*](https://julialang.org/downloads/).
    Whether you get it there or somewhere else, keep in mind that Julia, although
    it’s been stable for several years, is still undergoing rapid development. *Stable*
    in this context means that you can expect no breaking changes: programs that you
    write now, or have written using any version of Julia from v1.0 onward, will continue
    to work as you upgrade your Julia installation in the future, with few exceptions.
    However, *rapid development* means that the particular version you have installed
    can make a substantial difference.'
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the language implementation itself, the Julia team has made continuous
    progress in speed and responsiveness since the first public release, and that’s
    likely to continue, which is reason enough to recommend using the most recent
    stable language version. Regarding the ecosystem generally, many important packages,
    which are libraries of Julia code that you can use in your own programs, are also
    progressing rapidly, and new ones are emerging every month. Older Julia versions
    may not be compatible with new, or newer versions of, important packages.
  prefs: []
  type: TYPE_NORMAL
- en: In the download section of the Julia website, you will find downloads corresponding
    to various “releases,” or recent versions, of Julia. Most people will be best
    served by the one identified as “Current stable release.” “Upcoming release” is
    a beta version of the next stable release. It will have more recently added features,
    but it will also have slightly more compatibility problems with various packages
    and may be afflicted with some minor bugs. Depending on when you are reading this,
    the “Long-term support” release may or may not have all of the features this book
    uses. In general, to avoid any confusion arising from possibly different behavior
    from the code samples here, ensure that you install Julia v1.6.0 or greater and
    avoid beta releases.
  prefs: []
  type: TYPE_NORMAL
- en: '***Installation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section contains instructions for various options to install Julia on every
    OS for which it is available. You only need to pay attention to the sections that
    apply to you.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to these instructions, which leave you with a Julia binary
    ready to run, you can download the Julia source code at the same location as the
    other download links. As Julia is completely free and open source software, the
    source is always available for experts to inspect and compile themselves. If you
    want to run Julia on an unusual system for which a binary is not supplied, this
    is your only option.
  prefs: []
  type: TYPE_NORMAL
- en: '**On Linux and FreeBSD**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Almost every Linux distribution has its own package management system: an official
    mechanism for installing programs and keeping them updated. Using the official
    package manager has two advantages. First, it is integrated, meaning that dependencies
    among all the installed programs should be automatically resolved and everything
    will work together. The second benefit is security: packages in the official repositories
    are generally vetted and unlikely to contain malicious code.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it takes considerable time for software to be packaged and included
    in the official repositories of most Linux distributions. Projects such as Julia
    that are undergoing rapid development should generally not be installed using
    the package manager. The distribution’s version will lag too far behind the current
    versions that you can get directly from the Julia project. This is less of a problem
    for certain Linux distributions that employ a rolling release schedule and keep
    their packages up to date, but it makes the use of the package manager in, for
    example, Debian-based distributions a poor choice for Julia.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, if you are on Linux, the best strategy is to go to the Julia
    download page at [*https://julialang.org/downloads/*](https://julialang.org/downloads/).
    Look for the heading “Current stable release” and, under that, find the entry
    for your machine’s architecture. Most people will want the 64-bit download for
    “Generic Linux on x86.” Clicking the download link copies a file to your computer
    with the extension *.tar.gz*. It will be a little more than 100MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default location for browser downloads for most people is the *Downloads*
    directory inside their home directory, but your browser may be configured differently.
    After you have found the download location, you should see the file you just acquired,
    named something like *julia-1.*X*.0-linux-x86_64.tar.gz*, which indicates v1.*X*.0
    of Julia, built for Linux systems with the x86, 64-bit architecture. The double
    extension indicates that this is a compressed tarfile. You can uncompress and
    un-archive the file with a single command (substituting the actual downloaded
    filename):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `tar` command should already be installed on any normal Linux system. After
    entering this command, you should see the names of a bit more than 2,000 files
    scroll by in your terminal, indicating the creation of subdirectories and the
    un-archiving of the files needed for an initial installation of Julia to work.
    You won’t need to do anything directly with any of these files except one. After
    the process is complete, which should take under a minute, you’ll have a new directory
    with a name taken from the beginning of the archive’s name. For the example *julia-1.*X*.0-linux-x86_64.tar.gz*
    download file, that directory is *julia-1.*X*.0*. The installation will take up
    about four times the space of the tarfile, which you can delete after the `tar`
    command completes successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to set up your system so that entering `julia` in the terminal
    starts the Julia program that you just installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the final installation step, first check your path by entering echo
    $PATH. If */usr/local/bin* is listed, navigate there. If it’s not, but there’s
    another directory in your path where you like to keep local commands, go there.
    Otherwise, it’s a good idea to establish such a directory, which can be */usr/local/bin*
    or something else. The method for doing that varies a bit depending on your shell.
    For the most common case of bash and bash-compatible shells, add this line to
    your *.bash_profile* startup file (which you can find in your home directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have navigated to */usr/local/bin* or to your local command directory
    of choice, make a symbolic link to the file */bin/julia* within your new Julia
    installation directory, and call it *julia*. For our example, the command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To create the link you need to be root, or use `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: You can keep your downloaded Julia installation anywhere, but you’ll need to
    update the link set in the command if you move it.
  prefs: []
  type: TYPE_NORMAL
- en: To check that your new Julia installation is working, open a fresh shell and
    enter `julia`. An interactive prompt should appear, waiting for you to type your
    first line of Julia code.
  prefs: []
  type: TYPE_NORMAL
- en: '**On macOS**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can install Julia on your Apple computer the same way you install any other
    application. Navigate to the Julia download page, find the section for your desired
    version, and click the 64-bit link in the table. A normal macOS*.dmg* file will
    be downloaded to your system, which should open itself. You should see the Julia
    icon of red, green, and purple circles arranged in a pyramid. Drag this to your
    *Applications* folder as usual.
  prefs: []
  type: TYPE_NORMAL
- en: When you double-click this icon, a terminal should open with the Julia interactive
    prompt ready for your first command.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to make arrangements so you can start Julia from the terminal
    command line and not need to click the icon, which will be convenient later on.
    These preparations also will allow you to run saved Julia programs without using
    the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling this behavior requires two steps. If the Julia interactive prompt
    is still waiting for you, press CTRL-D to quit the REPL or enter exit(). Next,
    at the shell command line, enter the following command to delete any existing
    `julia` command that might be left over from a previous installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then enter the following (change Julia-1.`X`.app to match the version that
    you have installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You may also want to check for the presence of `julia` commands elsewhere in
    your path, such as in `/usr/bin`, and delete them or move them out of the command
    path, so that you don’t inadvertently invoke an older executable from a previous
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: This command creates what’s known as a *symbolic link* to the actual Julia binary
    program stored deep within your *Applications* folder. Now you can type `julia`
    in any terminal to start the interactive Julia shell or to run Julia programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**On Windows**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some installations of Windows do not have a modern terminal set up. You will
    need such a program to run Julia effectively and to follow the examples in this
    book. If you don’t already have a good terminal installed, a reasonable option
    is the Windows Terminal, a free program available from the Microsoft Store. Before
    doing anything else, install this terminal or something equally capable and make
    sure that you know how to start and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Julia download page and find the section for your desired version
    (see “Julia Versions” on [page 5](ch01.xhtml#ch01lev1sec3)).
  prefs: []
  type: TYPE_NORMAL
- en: If you know you’re on a 64-bit version of Windows, click the 64-bit download
    link. If you’re on 32-bit or are not sure of the architecture, click the 32-bit
    link. This will get you a Julia install that will work on both architectures,
    but using the 64-bit build has some advantages if you know you can use it.
  prefs: []
  type: TYPE_NORMAL
- en: This will download a *.exe* installer, which you should run next. It will inform
    you of the installation directory; be sure to make a note of it.
  prefs: []
  type: TYPE_NORMAL
- en: The following instructions to set up Julia to run from a terminal will work
    for recent versions of Windows. If you’re running Windows 8 or earlier, you’ll
    find specific installation instructions linked from the Julia download page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recent versions of the installer offer a checkbox for setting the Julia path.
    If yours doesn’t, or you prefer to choose the path yourself, follow this procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Run` by pressing **Windows key-R** and enter the following command to
    open the System Variables window so you can edit the path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click **New** and enter (or paste) the path the installer told you about (you
    copied that information, right?). If you’ve lost the path, look for a program
    with “julia” in the name in *C:\Users\<your_username>\AppData\Local\Programs*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK**, open a terminal, and enter julia to test your setup. You should
    see a terminal-flavored rendering of the Julia logo, a brief message, and an interactive
    prompt, waiting for your first line of Julia code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another option on Windows is provided by package managers. The open source edition
    of the popular Chocolately package manager, for example, installs a reasonably
    up-to-date Julia version.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Docker**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Read this section if you know what Docker is and you are sure that you want
    to install Julia by using a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: If that’s you, you are fortunate that a Docker community exists for Julia. Go
    to [*https://hub.docker.com/_/julia*](https://hub.docker.com/_/julia), which contains
    a description of the image for using Julia. I won’t list the details of what systems
    and versions are supported, because those are likely to change frequently. The
    page has up-to-date information for installing and using the Julia container on
    your machine. Aside from that, everything else in this book applies identically
    to Julia run from within a Docker container and Julia installed in the conventional
    way.
  prefs: []
  type: TYPE_NORMAL
- en: '***Privacy Note***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Julia team is scrupulous in pointing out a privacy issue that, although
    of no concern to most people, and something that most would take for granted in
    any case, deserves to be mentioned. Julia’s package management system (something
    we’ll discuss in later chapters) is designed with the expectation that you are
    connected to the internet, and it will download software as needed for you to
    complete your tasks. This means that, of necessity, your IP address, what you
    downloaded, and when, are stored on a server somewhere, at least for a while.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Julia Coding Environment**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the basic Julia system installed, let’s turn to the various options for
    interacting with it. Different methods of talking to Julia are best suited for
    different situations. Also, if you have a favorite editor or IDE, this section
    will explain how you can program in Julia without changing your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 1-1](ch01.xhtml#ch1tab1) is a brief table of the coding environments
    discussed next and their salient advantages and disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-1:** Coding Environment Comparison'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Environment** | **Advantages** | **Disadvantages** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| REPL | Nothing to install, quick, useful modes | Graphics in separate windows,
    repetitive entry |'
  prefs: []
  type: TYPE_TB
- en: '| Text editors | File organization, editing convenience, REPL integration |
    No graphics, limited interactivity |'
  prefs: []
  type: TYPE_TB
- en: '| Jupyter | Huge community, inline graphics, interactivity, multiple languages,
    good for sharing | Poor organization, no version control, hidden state, browser
    text entry |'
  prefs: []
  type: TYPE_TB
- en: '| Pluto | Inline graphics, sophisticated interactive controls, reactive and
    consistent, full REPL integration, backed by normal Julia file | Julia only, browser
    text entry |'
  prefs: []
  type: TYPE_TB
- en: '| VS Code | Integrated editor, REPL, graphics, good language support | Less
    powerful as an editor than Vim or Emacs |'
  prefs: []
  type: TYPE_TB
- en: Let’s take a more detailed look at each of these options.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Julia REPL***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you enter `julia` in the terminal, you enter the *REPL*, or *read-eval-print
    loop*. You’ll see a welcome message and the prompt will change from your system’s
    shell prompt to Julia’s.
  prefs: []
  type: TYPE_NORMAL
- en: '**REPL Modes**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The REPL has several modes. The initial mode, with the `julia>` prompt, is the
    normal mode in which you will spend most of your REPL time. Here you can enter
    any Julia expression, press ENTER, and Julia will print the result of the expression.
    Even if you don’t know any Julia yet, try it out to make sure everything is working
    correctly. Enter an arithmetic expression such as `1 + 1`, and you should see
    the result immediately after pressing ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: This mode of operation will be familiar to you if you’ve used Python, Node,
    APL, or any other REPL-based language. Unlike Python, Julia is compiled rather
    than interpreted. This difference will have implications in how you use the REPL
    in later chapters, but for now, you can use the Julia interactive interface just
    like any other REPL you may have used before.
  prefs: []
  type: TYPE_NORMAL
- en: The Julia REPL’s normal mode is a sophisticated environment with a few tricks
    up its sleeve to make your work easier. It has a “paste mode” that lets you paste
    in code samples you may have copied, for instance, from a web page, and that may
    be littered with the `julia>` prompt and have code interleaved with explanatory
    text. The REPL will know to just execute the actual code on any line starting
    with `julia>`, provided the first line pasted starts with it. (At the time of
    writing, paste mode does not work on Windows.)
  prefs: []
  type: TYPE_NORMAL
- en: The REPL is fully readline capable. This means you can use the up arrow and
    down arrow to recall earlier commands and edit them before repeating them. This
    feature even works well for multiline code blocks such as function definitions.
    To search for a previous command, you can press CTRL-R and type some text contained
    within that command. Your command and code history is saved between REPL sessions,
    so you can quit the REPL, come back the next day, and still recall your commands
    with the arrow keys. The history is stored in the *.julia/logs/repl_history.jl*
    file within your home directory. This file contains all the code you enter, and
    it even timestamps each entry, but it does not record the results Julia returns.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful REPL mode is the help mode. Press **?**, and the prompt will
    change to `help?>`. Enter any Julia function, data type, operator, or library,
    and you will see a nicely formatted description of the item you entered, often
    with a useful collection of examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Later on you’ll learn how to document your own functions in a way that hooks
    into the REPL help system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The REPL also has a shell mode, activated by pressing `;`, that allows you
    to enter system shell commands from within the REPL session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can use shell mode for simple commands. As the listing shows, we can interpolate
    Julia variables, but piping and redirection won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Another REPL mode you will use often is the package mode, activated by pressing
    `]`, which we’ll cover in [Chapter 3](ch03.xhtml) when we explore how to use packages
    and modules. For now, just be aware that the package system in Julia is an integral
    part of the language and environment, so much so that it’s built into the REPL.
    Julia developers don’t need to wrestle with several competing third-party package
    systems, nor with the inevitable “dependency hell” that afflicts some other languages.
  prefs: []
  type: TYPE_NORMAL
- en: To exit out of any of these modes back into the normal (sometimes called “Julian”)
    REPL mode, press BACKSPACE while the cursor is at the starting position.
  prefs: []
  type: TYPE_NORMAL
- en: TAB works in any REPL mode to generate context-aware completions. If there is
    a unique completion, it is entered for you at the cursor; otherwise, the REPL
    presents you with a list of options.
  prefs: []
  type: TYPE_NORMAL
- en: '**REPL Colors**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To help you to know which mode you’re in, the REPL colors each of its prompts
    differently. The colors help visually separate the prompts from the expressions
    you enter and their results. The REPL also uses colors in certain types of output,
    such as help output, to distinguish elements like keywords and variables from
    normal text. The default colors work well when using a terminal with a black or
    dark background, which is the most popular choice. However, they are too light
    to be easily legible on a white or very light background. I use such a background
    for the illustrations in this book, as it prints better than the black background
    I usually use on my computer. If you use a light terminal background, or simply
    prefer a different appearance from the default, you can edit a configuration file
    to change any of the REPL colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your home directory, you will find a directory called *.julia* (note the
    dot: in most people’s shells, as they are typically configured, this directory
    will not be listed using the usual commands unless you add a flag to request listing
    of “invisible files,” and graphical file management tools may or may not show
    the directory by default). Within *.julia*, there may already be a *config* directory;
    if not, create one. Enter the *config* directory and edit the *startup.jl* file
    (or create it if it doesn’t exist). Add the following to *startup.jl*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You have just written your first Julia function. Julia runs the *startup.jl*
    file every time the REPL starts (the *.jl* extension is used for Julia programs).
    This function simply defines two variables: one for the color of the prompt in
    normal mode and the other for help mode. The two numbers in square brackets are
    ANSI color codes, which are understood by most modern terminal programs. I’ve
    chosen two colors that work well on my monitor when using a white terminal background.
    If you want to pick your own colors, you can find tables of the 256 ANSI colors
    and their codes by searching the web for “ANSI color codes.” I’ve redefined only
    these two colors because the other defaults happened to work well. If you want
    to change some other colors, you can define the `repl.shell_color`, `repl.input_color`,
    and `repl.answer_color` variables as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Julia also understands several color *names*, but too few to allow an ideal
    selection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode Characters**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Julia allows the use of Unicode characters in variable names and for other identifiers.
    This means you can make formulas in your Julia programs look more like real math,
    using, for instance, Greek letters and subscripts. Some people have set up their
    systems to allow them to type such characters easily. Even if you haven’t, you
    can still use these characters thanks to a Unicode input mode provided by the
    REPL. If you enter a backslash (`\`) followed by a string of ASCII characters,
    then press TAB, one of three things will happen. If the REPL recognizes the string
    as one of its codes for a Unicode character, the entire entry, beginning with
    the backslash, will be replaced by that character. If the code you typed is the
    beginning of a character code or one of several possible codes, the tab completion
    mechanism will work in the normal way. If the REPL does not recognize what you
    typed, it will do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: A complete list of the Unicode character codes recognized by the REPL is maintained
    at [*https://docs.julialang.org/en/v1/manual/unicode-input/*](https://docs.julialang.org/en/v1/manual/unicode-input/).
    Those familiar with LaTeX syntax will be happy to know that all the Greek letters
    and some other symbols that have LaTeX commands are on the list unchanged. For
    example, to input *α* in the REPL, type \alpha and then press TAB. There is much
    more—even a wide selection of emoji.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know the LaTeX-style abbreviation for a particular Unicode character,
    perhaps one that you’ve copied from the documentation, enter the help mode in
    the REPL, paste in the character, and press ENTER. If an abbreviation exists,
    the help system will tell you what it is.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](ch01.xhtml#ch1fig1) shows a simple example of what you can do
    with an expanded character set.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: Using Unicode in the REPL*'
  prefs: []
  type: TYPE_NORMAL
- en: This is more than just fun and games. The ability to employ a wider collection
    of characters, including Greek letters and subscripts, allows us to make our code
    more concise and expressive.
  prefs: []
  type: TYPE_NORMAL
- en: '****Text Editors****'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia programmers use text editors routinely, either in addition to or in coordination
    with the REPL. I’ll go over some of the relevant features of the most-used programmer’s
    editors here. If you use something else, be sure to search for any enhancements,
    either built-in or in the form of third-party plug-ins, specific to Julia. These
    enhancements typically include syntax highlighting, which helps immensely in avoiding
    typos in your code, and can include more sophisticated features, such as code
    formatting and execution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vim**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Vim is an excellent editor for programming in any language, and it has valuable
    Julia support. I recommend installing the `julia-vim` plug-in, available at [*https://github.com/JuliaEditorSupport/julia-vim*](https://github.com/JuliaEditorSupport/julia-vim),
    where you will also find its documentation. The plug-in requires Vim version 7.4
    or greater. To take the best advantage of `julia-vim`, ensure that the built-in
    `matchit` plug-in is enabled by executing the :runtime macros/matchit.vim Vim
    command, which should be in your Vim startup file. This plug-in adds a Julia file
    type with syntax coloring and awareness of the block structure of Julia syntax.
    It extends the `matchit` operation by allowing you to jump to the end or beginning
    of function definitions and other blocks by entering `%`. You can also select
    or delete blocks, or the bodies of blocks, in the same way that Vim allows you
    to operate on other text objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plug-in also emulates the REPL’s LaTeX-style entry of Unicode characters.
    For this it provides two options: you can have it wait for you to press TAB, as
    the REPL does, or it can expand the entry on the fly as soon as it sees a character
    (usually a space) that seems to indicate the end of the entry (the on-the-fly
    mode does not support emoji, however).'
  prefs: []
  type: TYPE_NORMAL
- en: Another option for recent versions of NeoVim or Vim is to install language support
    for tree-sitter, which adds syntax-aware highlighting and other features to the
    editor. If you have Vim version 8.0 or greater, which I highly recommend, or the
    NeoVim fork, you can interact with *any* REPL directly, including the Julia REPL.
    By “interact,” I mean that you can remain in an editing buffer containing your
    Julia program and send selected lines, expressions, or blocks directly to the
    REPL for execution. The execution is asynchronous, so you can continue editing
    while Julia is churning through a time-consuming command. Communication with the
    REPL is two-way, so you can also send results printed in the REPL back into the
    editing buffer. The following instructions apply to Vim, but NeoVim users should
    be able to adapt them to that program.
  prefs: []
  type: TYPE_NORMAL
- en: First, install the `vim-sendtowindow` plug-in, which lives at [*https://github.com/karoliskoncevicius/vim-sendtowindow*](https://github.com/karoliskoncevicius/vim-sendtowindow).
    After opening the editing buffer of choice, execute the :term julia Vim command.
    If you have the `julia` command set up properly (see [“Installation”](ch01.xhtml#ch01lev1)
    on [page 6](ch01.xhtml#ch01lev1)), a new Vim buffer should open with the Julia
    REPL running within it, below the editing window.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can select any text in the editing window and press the spacebar followed
    by `j` to send it to the REPL. If you’d prefer some other shortcut for this operation,
    the `vim-sendtowindow` web page explains how to set it up. You can also define
    shortcuts for sending text to the right, left, and up, which is handy for sending
    text *from* the REPL and in case you prefer to split your windows vertically.
    The `:term` command, with its asynchronous execution of commands, is built into
    Vim. The plug-in provides a convenient way to send text back and forth between
    the editing and terminal buffers. The author of `vim-sendtowindow` maintains a
    list of plug-ins with similar functionality on its website.
  prefs: []
  type: TYPE_NORMAL
- en: Similar REPL interactions are possible with earlier versions of Vim, using plug-ins
    such as `ScreenSend`, but the `term` command in version 8 makes REPL interaction
    smoother and less error prone.
  prefs: []
  type: TYPE_NORMAL
- en: '**Emacs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Emacs is a powerful programmer’s editor with sophisticated Julia support available.
    The official Julia major mode for Emacs, called `julia-emacs`, is developed on
    GitHub at [*https://github.com/JuliaEditorSupport/julia-emacs*](https://github.com/JuliaEditorSupport/julia-emacs).
    The creators of the Julia language are contributors to the project, which is probably
    one of the reasons that a deep and detailed knowledge of the language’s structure
    and syntax is built into the mode. Once installed, Emacs will display Julia code
    using a variety of colors and font styles to clarify its syntax. It also provides
    movement among and manipulation of code structures such as blocks.
  prefs: []
  type: TYPE_NORMAL
- en: To install `julia-emacs`, first enable the MELPA repository ([*https://melpa.org*](https://melpa.org))
    and add (require 'julia-mode) to your Emacs initialization file. For most people,
    this will be *.emacs* in their home directory. For a smooth experience, you should
    be running a version of Emacs that is at least 24.1\. If your version is earlier,
    an upgrade would be advisable for using Emacs and Julia together.
  prefs: []
  type: TYPE_NORMAL
- en: Emacs shines at interacting with REPL-based languages, and Julia is no exception.
    Several minor modes are available specifically for Julia interaction. One of the
    most popular is `julia-repl`, also developed on GitHub and available at [*https://github.com/tpapp/julia-repl*](https://github.com/tpapp/julia-repl).
    It’s designed to work with the aforementioned `julia-emacs`, and you must have
    at least version 25 of Emacs installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `julia-repl`, edit your *.emacs* initialization file, adding the
    following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now you can start a Julia REPL right from within Emacs. It will run in an ANSI
    terminal, with the full complement of text colors and formatting. A table of keyboard
    shortcuts is available on the mode’s GitHub page. You can perform the usual sending
    of fragments, whole blocks, or the entire buffer to the REPL for execution. In
    addition, the built-in knowledge of Julia allows the mode to do such things as
    listing all the methods of a function, which will make more sense after you read
    [Chapter 8](ch08.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '***Jupyter Notebooks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use Julia from within a web browser, in two main ways, in what is referred
    to as a *notebook* interface. The older way is the Jupyter Notebook. Jupyter popularized
    the notebook concept in the free software arena, and it’s widely used in the Julia,
    Python, and R communities. In fact, the word *Jupyter* is a mashup of the names
    of those three programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use or explore a notebook interface and do not have a particular
    reason to use Jupyter, proceed directly to the next section and learn about Pluto.
    Pluto offers the same style of notebook interactivity as Jupyter while improving
    on the concept. For those who need to use Jupyter to collaborate with others using
    the system, who want to use other languages (besides Julia) with the same notebook
    interface, or who desire to explore existing Jupyter Notebooks, this section is
    designed to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have Jupyter set up and working on your computer, you merely
    need to install the Julia backend. In the Julia REPL, press **]** to enter the
    package mode (see [page 11](ch01.xhtml#page_11)). Make sure you’re connected to
    the internet, and enter the add IJulia command to download and install the Julia
    backend for the notebook and the packages that it depends on. This is a fairly
    big install and will take some time, but the REPL will keep you informed with
    an animated display showing the progress of the downloads and the precompilation
    of modules. When the process is complete, enter jupyter notebook either at a separate
    system shell prompt or using the REPL shell mode to launch the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t already have Jupyter installed, after the installation described
    earlier is complete, enter the following lines in the Julia REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Julia will ask if you want to install Jupyter using the `Conda` package. Answer
    in the affirmative. This next phase of installation should be quicker than the
    `IJulia` install, but may still take some time. When the software is ready, Julia
    will open a window or tab in your default browser with the starting Jupyter page.
    To start up Jupyter in future sessions, repeat these commands in a Julia REPL.
  prefs: []
  type: TYPE_NORMAL
- en: When the Jupyter Notebook page opens, you’ll have a drop-down list of installed
    kernels, or language backends. Choose the Julia kernel, and a new tab or window
    will open. On that page, you can enter Julia expressions in “cells.” When you
    press CTRL-ENTER while the cursor is in a cell, Julia will evaluate the expression
    and print the result in an output cell underneath it.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are in a web browser, the system can take advantage of the ability
    to format text and display graphics. [Figure 1-2](ch01.xhtml#ch1fig2) shows a
    Jupyter Notebook after I’ve executed a few cells.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: Using Jupyter with Julia*'
  prefs: []
  type: TYPE_NORMAL
- en: The last cell is a command to create a surface plot, which directly embeds the
    plot in the page.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to worry about saving your work with Jupyter, as it makes frequent
    autosaves, as indicated with the notice near the top of the page in [Figure 1-2](ch01.xhtml#ch1fig2).
  prefs: []
  type: TYPE_NORMAL
- en: Sharing your work is as simple as sending the on-disk form of the notebook to
    your colleagues. Everything is in one file, including the graphs and other images,
    which by default are encoded as SVG. Jupyter Notebook files have the *.ipynb*
    extension, and are stored in the directory where you started the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to use Jupyter extensively, consult the detailed documentation
    at [*https://jupyter.org*](https://jupyter.org) to learn more about all of its
    features.
  prefs: []
  type: TYPE_NORMAL
- en: '***Pluto: A Better Notebook***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pluto is a notebook interface to Julia that uses a web browser, similarly to
    Jupyter. Although it’s a young project, it’s already used routinely by a large
    community and has significant advantages over Jupyter. Its only shortcoming is
    that it is Julia-only, but this specialization allows Pluto to take better advantage
    of what Julia has to offer than frontends that support multiple kernels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pluto does not depend on anything aside from a modern web browser and Julia.
    To install it, press `]` to enter the package mode in the Julia REPL and execute
    the add Pluto command. After everything downloads and installs, press BACKSPACE
    to exit the package mode, and execute this code in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A new window or tab will open in your default web browser with the Pluto welcome
    page, which looks like [Figure 1-3](ch01.xhtml#ch1fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: The Pluto welcome page*'
  prefs: []
  type: TYPE_NORMAL
- en: Here you’ll see links for opening a fresh notebook, continuing work on an existing
    one, or examining sample notebooks. The sample notebooks cover a variety of subjects
    and are well done and instructive.
  prefs: []
  type: TYPE_NORMAL
- en: A Pluto notebook is a web page where you can enter Julia expressions in “cells.”
    Pressing CTRL-ENTER while the cursor is in a cell will cause Julia to execute
    the code in that cell as well as all the cells that depend on it. If, for example,
    you define, or redefine, a variable in a cell and execute it, and you have a second
    cell that uses that variable, Pluto will execute that second cell after the first
    one is done. If a third cell depends on the result from the second cell, Pluto
    will execute that one next, and so on. After each cell is run, its result is displayed
    *above* the input cell. You can watch the progress of execution passing from cell
    to cell by observing the animated progress bars on their left borders.
  prefs: []
  type: TYPE_NORMAL
- en: Pluto determines the order of execution by calculating a *dependency graph*
    for all the cells on the page. Using the dependency graph means that the results
    shown on the page are independent of the visual order in which they are arranged,
    and of the order in which you decide to execute cells. What you see is completely
    determined by the code in the cells, so you can share your notebooks with collaborators
    and everyone will see the same, consistent notebook. This is the major advance
    over other notebooks, such as Jupyter, where the results displayed on the page
    are the consequence of the order in which the cells were run and may even depend
    on cells that have been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Pluto’s behavior is, in some ways, similar to a spreadsheet, and offers the
    same live, reactive experience. Even die-hard terminal users such as myself enjoy
    using Pluto for certain kinds of exploratory computation. Its ability to embed
    graphics and, as we’ll see in later chapters, incorporate graphical controls such
    as sliders and color pickers creates a rich environment for experimenting with
    code and data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-4](ch01.xhtml#ch1fig4) shows a Pluto page with a simple matrix calculation.
    I created it by clicking the link to start a new notebook in the welcome page.
    Pluto opened a new tab and the browser switched to it, and I entered expressions
    in three cells and pressed CTRL-ENTER to evaluate them.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: Matrix calculations in the Pluto notebook*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-4](ch01.xhtml#ch1fig4) shows the main elements of the Pluto interface.
    At the top is the path of the notebook file. Until you type this in, a message
    in that space will invite you to do so. To the right of that is a save button,
    but you only need to use it if you change the location of the file and want to
    save immediately. Every time you execute a cell, Pluto saves your work automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first two code cells I’ve defined two small matrices, `m` and `n`, and
    in the third cell, I asked for their matrix product. (This is a preview of the
    array operations that we’ll explore in [Chapter 2](ch02.xhtml).) Keep in mind
    that in Pluto, the results are printed above the input cells.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we could have done this the same way in the REPL. The difference here
    is that if we change any of the numbers in `m` or `n` and run the cell with its
    new definition, the matrix product is instantly recalculated and the revised result
    replaces the old one without any further action by the user. In the REPL, we would
    have to type `m * n` again, and the new result would be printed below that, possibly
    scrolling other information off the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In Pluto, because the results displayed are independent of the order in which
    they appear on the page, we can rearrange the cells to provide a good exposition,
    without worrying about affecting the calculations. We can combine Julia expressions
    with text formatted using Markdown or HTML, and turn our notebook into an article
    or a live explanatory text.
  prefs: []
  type: TYPE_NORMAL
- en: In the final cell, I’ve entered a question mark (`?`) followed by the name of
    a data type, `Matrix`. As soon as you enter the question mark and begin typing,
    a live help window opens, displaying documentation about what you’ve typed so
    far. As you add letters, the documentation changes to reflect what you’ve typed,
    and you can stop when you see what you want.
  prefs: []
  type: TYPE_NORMAL
- en: The help window stays there, displaying documentation about whatever you type
    into any cell, whether or not you ask for help. If it becomes distracting, click
    the little down arrow to tuck the window away. Because of Pluto’s close integration
    with Julia, it has other conveniences, such as tab completion, that work the same
    way as in the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: The text file that backs the notebook page, stored at the location you entered
    at the top, is a normal Julia module file. You can import it into other Julia
    programs, edit it directly, and put it into version control. You are not locked
    into the Pluto notebook, but can use the code you develop there in other Julia
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Pluto is a new and innovative way to develop programs and carry out exploratory
    computation that is fun to use. Even if you turn to it only now and then, you
    should install it and become familiar with the interface. Follow Pluto developments
    and find more documentation at [*https://github.com/fonsp/Pluto.jl*](https://github.com/fonsp/Pluto.jl).
  prefs: []
  type: TYPE_NORMAL
- en: '***Integrated Development Environments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both Vim and Emacs can serve as capable IDEs for Julia by installing the plug-ins
    described in their respective sections earlier. Traditional IDEs don’t afford
    as much of a critical advantage for languages like Julia as they might for more
    verbose and ceremony-laden languages such as Java or C++, where many developers
    consider them essential. A text editor is all you need for writing Julia programs.
  prefs: []
  type: TYPE_NORMAL
- en: However, some users prefer a “real” IDE or may already be accustomed to one.
    The Julia IDE situation is in flux at the moment of writing. An IDE called Juno,
    consisting of a plug-in for the Atom editor, was essentially the official IDE
    for Julia, but work on it has ceased. As the language moves forward, Juno will
    not keep up. IDE development for Julia has shifted to a plug-in for VS Code, a
    popular IDE from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: You can download VS Code from its GitHub repository at [*https://github.com/microsoft/vscode*](https://github.com/microsoft/vscode)
    and compile for your system. A quicker route for Linux, macOS, or Windows is to
    download the appropriate package file from [*https://code.visualstudio.com/Download*](https://code.visualstudio.com/Download)
    and follow your system’s normal install procedure. Microsoft also offers branded
    versions as binary downloads. These may contain small enhancements, and are released
    under a Microsoft product license.
  prefs: []
  type: TYPE_NORMAL
- en: After installing the base VS Code program, you will install the Julia plug-in,
    which you can do from within the IDE. [Figure 1-5](ch01.xhtml#ch1fig5) illustrates
    how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: Installing the Julia plug-in within VS Code*'
  prefs: []
  type: TYPE_NORMAL
- en: The screenshot shows the left-hand area of the VS Code window, with the extension
    icon selected. I’ve entered “Julia” into the extension search box at the top,
    and the program is displaying a list of publicly available extensions that match.
    When you perform this search, the list will likely look different, but you want
    the extension titled simply “Julia,” which, in this case, is at the top of the
    list. Click the blue **Install** button to download and install the plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quit VS Code and restart it after installing the plug-in. If you have set your
    path properly, as described in “Installation” on 6, press CTRL-SHIFT-P (CMD-SHIFT-P
    on macOS) to open a command window and execute the Julia: Start REPL command.
    A Julia REPL should open in a pane at the bottom of the window. It behaves just
    like the normal REPL described on [page 10](ch01.xhtml#ch01lev1sec6), with all
    REPL modes available, and using your color and other customizations.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to typing directly in the REPL, you can open an existing or new
    file for editing. Julia code is syntax colored, and there are syntax-aware commands
    for moving through the code and manipulating its structures. The documentation
    at [*https://www.julia-vscode.org/docs/stable/*](https://www.julia-vscode.org/docs/stable/)
    consists largely of blank pages at the time of writing, but I expect this situation
    to be improved soon. Open the command window and type `Julia:` to discover Julia-specific
    commands and then scroll through the list. If you see a command you’ll be using
    often, this list contains buttons next to each command that allow you to define
    keyboard shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend defining a shortcut for the “Send Current Line or Selection to REPL”
    command. This allows you to send any expression or statement directly from the
    editor to the REPL for execution.
  prefs: []
  type: TYPE_NORMAL
- en: If you execute a plot command in the REPL, the plot appears in its own dedicated
    pane within the VS Code window. [Figure 1-6](ch01.xhtml#ch1fig6) shows the main
    part of the window as it appears on my laptop, with the light background selected
    from among VS Code’s three appearance options.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-6: Using the Julia plug-in in VS Code*'
  prefs: []
  type: TYPE_NORMAL
- en: In the top pane, I’m editing a file with a few lines of Julia code, which I’ve
    sent directly to the REPL in the bottom pane. Although you may not understand
    all the language syntax yet, you may be able to form an idea of what the expressions
    are intended to return. After trying some arithmetic to see if the setup is working,
    I define a range of numbers, assigned to the `x` variable, and then plot a function
    applied to each value in the list. At the top right, the plot window has appeared.
  prefs: []
  type: TYPE_NORMAL
- en: '**Recommendations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the choice of tools is a matter of personal preference, I’ve tried to provide
    enough information about all the main ways of interacting with Julia and editing
    Julia programs to allow you to choose the methods that most appeal to you. If
    you are already in the habit of using Vim, Emacs, or any other tool for programming,
    you don’t need to learn anything new or change your workflows to use Julia. Use
    what you are familiar with, as Julia can easily adapt to it.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you’re not yet committed to any specific tooling, I have a recommendation.
    I suggest that you install Vim, along with the Julia-specific plug-ins described
    in “Text Editors” on [page 14](ch01.xhtml#ch01lev1sec7). Vim takes some getting
    used to, but the long-term rewards are worthwhile, as it is an efficient and flexible
    editor, and it makes working alongside the REPL easy.
  prefs: []
  type: TYPE_NORMAL
- en: If Vim is new to you, to ease the burden of learning both a new language and
    an unfamiliar editor simultaneously, consider working through Pluto, as well as
    in the REPL directly, while you take your time to become comfortable with a new
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that this reflects my personal preferences, and you may prefer a different
    environment. For example, if you find working in a browser-based notebook appealing,
    there is no reason you can’t do all of your Julia work within Pluto. My only negative
    recommendation is not to stick with a primitive editor that has no REPL or language
    support, as doing so will hold you back in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: My article “The Scientist’s Linux Toolbox” in *Linux Pro Magazine* ([*https://www.linuxpromagazine.com/Issues/2020/241/Scientist-s-Toolbox*](https://www.linuxpromagazine.com/Issues/2020/241/Scientist-s-Toolbox))
    provides more information about Julia and other software useful to scientists
    computing on Linux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In “An Introduction to Pluto” ([*https://lwn.net/Articles/835930/*](https://lwn.net/Articles/835930/)),
    I describe the development of the Pluto notebook, give some examples of its use,
    and contrast it with the popular Jupyter Notebook interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A useful ANSI color code table is available at [*https://misc.flogisoft.com/_media/bash/colors_format/256_colors_bg.png*](https://misc.flogisoft.com/_media/bash/colors_format/256_colors_bg.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to [*https://gitforwindows.org*](https://gitforwindows.org) for a Windows
    solution that provides Git, a terminal program, and some more conveniences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
