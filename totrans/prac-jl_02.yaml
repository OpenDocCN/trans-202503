- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: GETTING STARTED**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**开始使用**'
- en: '*You don’t have to see the whole staircase, just take the first step.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*你不需要看到整个楼梯，只需迈出第一步。*'
- en: '*—*Dr. Martin Luther King Jr.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*—*马丁·路德·金博士'
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: As mentioned in the introduction, to learn a programming language, it’s not
    enough to read a book—not even one as good as this. Experimenting and writing
    programs yourself is essential. After absorbing a key concept in the book or running
    a code sample, try to construct variations of the code and run them. Writing your
    own variations will help you achieve fluency in the language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在介绍中提到的，要学习一门编程语言，光读书是不够的——即使是像本书这样优秀的书籍也不行。亲自实验和编写程序是至关重要的。在书中掌握一个关键概念或运行一个代码示例后，尝试构建代码的变体并运行它们。编写自己的变体将帮助你熟练掌握这门语言。
- en: This chapter first covers how to install Julia on all the major operating systems,
    and then discusses the various types of coding environments. We’ll see how to
    install each one, and explore their unique features, advantages, and disadvantages.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍如何在所有主要操作系统上安装Julia，然后讨论各种类型的编码环境。我们将学习如何安装每种环境，并探索它们的独特功能、优缺点。
- en: '**Installation Guide**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装指南**'
- en: Of course, to be able to do any of this you will need access to a Julia system.
    If you’re already set up to run Julia code, you can safely skip this whole section.
    If not, you can skip the subsections covering installation on operating systems
    that you don’t use, but you should probably read everything else.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要能够完成这些，你需要访问一个Julia系统。如果你已经配置好了运行Julia代码的环境，你可以安全地跳过这一整部分。如果没有，你可以跳过你不使用的操作系统的安装子章节，但你应该阅读其他所有内容。
- en: '***Hardware Requirements***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***硬件要求***'
- en: For learning Julia, almost any computer will be sufficient. It should have at
    least 2GB of RAM, but twice that amount will be more comfortable. You’ll need
    about 0.5GB of free disk space to install Julia, but you should have at least
    3GB of additional space for the packages that you’ll install for plotting and
    other purposes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于学习Julia，几乎任何计算机都足够。它应该至少有2GB的RAM，但拥有双倍内存将更加舒适。安装Julia大约需要0.5GB的空闲磁盘空间，但你应该至少预留3GB的额外空间，用于安装绘图和其他用途的包。
- en: These modest requirements are fine for learning the language and even for doing
    many real calculations, although you may require beefier hardware for larger-scale
    projects. Julia is used for calculations at every scale, and it can make efficient
    use of all types of hardware from laptops to GPU array processors to the world’s
    largest supercomputers (see “Further Reading” on [page 23](ch01.xhtml#fur1) for
    an example). I have run every example calculation in this book on a very modestly
    powered laptop, so all of the code here should run with no problems on any machine
    that you’re likely to be using.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些适中的要求足以用于学习语言，甚至可以进行许多实际计算，尽管对于大规模项目，你可能需要更强大的硬件。Julia可用于各种规模的计算，它能高效地利用从笔记本电脑到GPU阵列处理器再到世界上最大的超级计算机等各种硬件（有关示例，请参见[第23页](ch01.xhtml#fur1)的“进一步阅读”）。我已经在一台非常普通的笔记本电脑上运行了本书中的所有示例计算，因此本书中的所有代码应该可以在你使用的任何计算机上顺利运行。
- en: 'Julia runs on Linux, FreeBSD, macOS, and Windows. At the time of writing, Julia
    is fully supported on these systems:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Julia可以在Linux、FreeBSD、macOS和Windows上运行。截止到写作时，Julia在这些系统上完全受支持：
- en: 'Linux 2.6.18+: x86-64 (64-bit), i686 (32-bit), and ARMv8 (64-bit)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 2.6.18+: x86-64（64位）、i686（32位）和ARMv8（64位）'
- en: 'FreeBSD 11.0+: x86-64 (64-bit)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FreeBSD 11.0+: x86-64（64位）'
- en: 'macOS 10.9+: x86-64 (64-bit)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS 10.9+: x86-64（64位）'
- en: 'Windows 7+: x86-64 (32- and 64-bit)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows 7+: x86-64（32位和64位）'
- en: These installation requirements may change, so check [*https://julialang.org/downloads/*](https://julialang.org/downloads/)
    for up-to-date information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些安装要求可能会发生变化，因此请查看[*https://julialang.org/downloads/*](https://julialang.org/downloads/)以获取最新信息。
- en: Julia also runs on some system versions and architectures not listed here, but
    with reduced support, weaker guarantees, or possibly hampered functionality. It
    can also take advantage of more specialized hardware—for example, graphical processing
    unit array processors, which we’ll discuss in later chapters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Julia还可以在一些未列出的系统版本和架构上运行，但其支持较弱，保证性较差，或可能功能受限。它还可以利用更多专用硬件——例如，我们将在后续章节中讨论的图形处理单元阵列处理器。
- en: '***Prerequisites***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***先决条件***'
- en: 'To use Julia effectively, you need to know a few things about how to operate
    your computer. You need a basic knowledge of the terminal and the command line:
    how to create and change directories (folders), view a list of files, find out
    how much storage space is available on your hard drive, and delete files.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效使用Julia，你需要了解一些关于如何操作计算机的基础知识。你需要对终端和命令行有基本的了解：如何创建和更改目录（文件夹）、查看文件列表、查看硬盘上可用的存储空间以及删除文件。
- en: Every operating system has various graphical utilities for accomplishing those
    tasks, both built-in and as third-party software, but it is a good idea for the
    computational scientist to become familiar with the command line and use it routinely.
    There’s a good chance you’ll find yourself in a remote computing situation some
    day, where the command line may be the only way to communicate with the remote
    machine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都有各种图形化工具来完成这些任务，包括内置工具和第三方软件，但对于计算科学家来说，熟悉命令行并常规使用它是一个好主意。你很可能有一天会遇到远程计算环境，在这种情况下，命令行可能是与远程机器进行通信的唯一方式。
- en: It’s also a good idea, even if your personal computer uses some other operating
    system, to learn how to perform these rudimentary tasks on Linux, as that is by
    far the most common frontend OS on compute servers for scientific work. If your
    daily driver comes from Apple, that won’t be a problem, as the basic commands
    in the macOS BSD-derived terminal are nearly the same as on Linux. If you’re accustomed
    to Windows, you may need to learn some translations; however, that is beyond the
    scope of this book, and you won’t need to know the Linux dialect to use Julia
    on your personal computer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的个人计算机使用的是其他操作系统，学习如何在Linux上执行这些基本任务也是个好主意，因为Linux在科学计算服务器中作为前端操作系统最为常见。如果你使用的是苹果设备，应该不会有问题，因为macOS的BSD派生终端中的基本命令几乎与Linux相同。如果你习惯了Windows，可能需要学习一些转换，但这超出了本书的范围，而且你并不需要了解Linux方言就能在个人计算机上使用Julia。
- en: You’ll also need to be familiar with an editor on your system that can save
    files in a plaintext format. Most programmers use Vim, Emacs, or a more elaborate
    integrated development environment (IDE)—options that we will discuss further
    in the next section. You can use any editor you’re familiar with, but graphical
    editors such as Word are not the best choice. However, if you really want to use
    such programs, they’ll work. Just be sure to save your creations as plaintext
    files, and use a monospaced font, which will work better for writing code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要熟悉你系统上的一个编辑器，该编辑器能够将文件保存为纯文本格式。大多数程序员使用Vim、Emacs或更复杂的集成开发环境（IDE）——我们将在下一节进一步讨论这些选项。你可以使用任何你熟悉的编辑器，但图形化编辑器如Word并不是最佳选择。不过，如果你真的想使用这些程序，它们是可以工作的。只要确保将你的作品保存为纯文本文件，并使用等宽字体，这对编写代码更为合适。
- en: '***Julia Versions***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Julia版本***'
- en: 'Most people, no matter their platform, will download Julia from the official
    Julia website at [*https://julialang.org/downloads/*](https://julialang.org/downloads/).
    Whether you get it there or somewhere else, keep in mind that Julia, although
    it’s been stable for several years, is still undergoing rapid development. *Stable*
    in this context means that you can expect no breaking changes: programs that you
    write now, or have written using any version of Julia from v1.0 onward, will continue
    to work as you upgrade your Julia installation in the future, with few exceptions.
    However, *rapid development* means that the particular version you have installed
    can make a substantial difference.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人，无论使用何种平台，都会从官方Julia网站下载[**https://julialang.org/downloads/**](https://julialang.org/downloads/)。无论你是在那里下载还是从其他地方获得，请记住，尽管Julia已经稳定了几年，但它仍在快速发展。在这个上下文中，*稳定*意味着你可以期待没有破坏性更改：你现在编写的程序，或者你使用任何版本的Julia从v1.0起写的程序，在未来升级Julia安装时依然可以正常工作，只有少数例外。然而，*快速发展*意味着你所安装的特定版本可能会带来显著差异。
- en: Regarding the language implementation itself, the Julia team has made continuous
    progress in speed and responsiveness since the first public release, and that’s
    likely to continue, which is reason enough to recommend using the most recent
    stable language version. Regarding the ecosystem generally, many important packages,
    which are libraries of Julia code that you can use in your own programs, are also
    progressing rapidly, and new ones are emerging every month. Older Julia versions
    may not be compatible with new, or newer versions of, important packages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于语言实现本身，自从首次公开发布以来，Julia 团队在速度和响应性方面取得了持续的进展，这种进展很可能会继续下去，这也是推荐使用最新稳定语言版本的充分理由。关于生态系统，许多重要的软件包（即你可以在自己程序中使用的
    Julia 代码库）也在快速进展，并且每个月都有新的软件包出现。较旧的 Julia 版本可能与重要软件包的新版本或更新版本不兼容。
- en: In the download section of the Julia website, you will find downloads corresponding
    to various “releases,” or recent versions, of Julia. Most people will be best
    served by the one identified as “Current stable release.” “Upcoming release” is
    a beta version of the next stable release. It will have more recently added features,
    but it will also have slightly more compatibility problems with various packages
    and may be afflicted with some minor bugs. Depending on when you are reading this,
    the “Long-term support” release may or may not have all of the features this book
    uses. In general, to avoid any confusion arising from possibly different behavior
    from the code samples here, ensure that you install Julia v1.6.0 or greater and
    avoid beta releases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 网站的下载区，你会找到对应不同“发布版”或最近版本的 Julia 下载。大多数人最适合选择被标识为“当前稳定版”的下载。“即将发布版”是下一个稳定版的测试版本。它会有一些最近添加的新功能，但也可能会和一些软件包存在兼容性问题，且可能会出现一些小的
    bug。根据你阅读本书的时间，“长期支持”版可能不包含本书使用的所有功能。通常，为了避免由于代码示例的行为不同而产生的混淆，确保你安装 Julia v1.6.0
    或更高版本，并避免使用测试版。
- en: '***Installation***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装***'
- en: This section contains instructions for various options to install Julia on every
    OS for which it is available. You only need to pay attention to the sections that
    apply to you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含了在所有可用的操作系统上安装 Julia 的各种选项的说明。你只需要关注适用于你的部分。
- en: As an alternative to these instructions, which leave you with a Julia binary
    ready to run, you can download the Julia source code at the same location as the
    other download links. As Julia is completely free and open source software, the
    source is always available for experts to inspect and compile themselves. If you
    want to run Julia on an unusual system for which a binary is not supplied, this
    is your only option.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些说明的替代方案，你可以在与其他下载链接相同的位置下载 Julia 的源代码。由于 Julia 是完全免费的开源软件，源代码始终可以供专家检查和自行编译。如果你希望在某个没有提供二进制文件的特殊系统上运行
    Julia，这是唯一的选择。
- en: '**On Linux and FreeBSD**'
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在 Linux 和 FreeBSD 上**'
- en: 'Almost every Linux distribution has its own package management system: an official
    mechanism for installing programs and keeping them updated. Using the official
    package manager has two advantages. First, it is integrated, meaning that dependencies
    among all the installed programs should be automatically resolved and everything
    will work together. The second benefit is security: packages in the official repositories
    are generally vetted and unlikely to contain malicious code.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个 Linux 发行版都有自己的软件包管理系统：一种官方机制，用于安装程序并保持它们的更新。使用官方的软件包管理器有两个优势。首先，它是集成的，这意味着所有安装程序之间的依赖关系应该会自动解决，一切都能协同工作。第二个好处是安全性：官方仓库中的软件包通常都会经过审查，不太可能包含恶意代码。
- en: Unfortunately, it takes considerable time for software to be packaged and included
    in the official repositories of most Linux distributions. Projects such as Julia
    that are undergoing rapid development should generally not be installed using
    the package manager. The distribution’s version will lag too far behind the current
    versions that you can get directly from the Julia project. This is less of a problem
    for certain Linux distributions that employ a rolling release schedule and keep
    their packages up to date, but it makes the use of the package manager in, for
    example, Debian-based distributions a poor choice for Julia.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，将软件打包并纳入大多数 Linux 发行版的官方仓库需要相当长的时间。像 Julia 这样快速发展的项目通常不应通过包管理器进行安装。发行版的版本会远远落后于你可以直接从
    Julia 项目获取的当前版本。对于某些采用滚动发布策略并保持包更新的 Linux 发行版来说，这个问题较小，但例如对于基于 Debian 的发行版来说，使用包管理器安装
    Julia 不是一个好的选择。
- en: For these reasons, if you are on Linux, the best strategy is to go to the Julia
    download page at [*https://julialang.org/downloads/*](https://julialang.org/downloads/).
    Look for the heading “Current stable release” and, under that, find the entry
    for your machine’s architecture. Most people will want the 64-bit download for
    “Generic Linux on x86.” Clicking the download link copies a file to your computer
    with the extension *.tar.gz*. It will be a little more than 100MB.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，如果你使用的是 Linux，最好的策略是访问 Julia 下载页面 [*https://julialang.org/downloads/*](https://julialang.org/downloads/)。找到“当前稳定版本”标题，并在其下查找适合你机器架构的条目。大多数人需要下载“通用
    Linux x86 64 位”版本。点击下载链接会将一个扩展名为 *.tar.gz* 的文件复制到你的计算机上，大小大约为 100MB 多一点。
- en: 'The default location for browser downloads for most people is the *Downloads*
    directory inside their home directory, but your browser may be configured differently.
    After you have found the download location, you should see the file you just acquired,
    named something like *julia-1.*X*.0-linux-x86_64.tar.gz*, which indicates v1.*X*.0
    of Julia, built for Linux systems with the x86, 64-bit architecture. The double
    extension indicates that this is a compressed tarfile. You can uncompress and
    un-archive the file with a single command (substituting the actual downloaded
    filename):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人的浏览器默认下载位置是在其主目录下的 *Downloads* 目录，但你的浏览器可能配置有所不同。找到下载位置后，你应该会看到刚刚下载的文件，名称类似
    *julia-1.*X*.0-linux-x86_64.tar.gz*，这表示为 Linux 系统上的 x86 64 位架构构建的 Julia v1.*X*.0。双重扩展名表示这是一个压缩的
    tar 文件。你可以使用一个命令来解压和解档文件（替换为实际下载的文件名）：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `tar` command should already be installed on any normal Linux system. After
    entering this command, you should see the names of a bit more than 2,000 files
    scroll by in your terminal, indicating the creation of subdirectories and the
    un-archiving of the files needed for an initial installation of Julia to work.
    You won’t need to do anything directly with any of these files except one. After
    the process is complete, which should take under a minute, you’ll have a new directory
    with a name taken from the beginning of the archive’s name. For the example *julia-1.*X*.0-linux-x86_64.tar.gz*
    download file, that directory is *julia-1.*X*.0*. The installation will take up
    about four times the space of the tarfile, which you can delete after the `tar`
    command completes successfully.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`tar` 命令应该已经在任何正常的 Linux 系统中安装好了。输入此命令后，你应该会看到大约 2000 个文件的名称在终端中滚动，表示正在创建子目录并解压初始安装
    Julia 所需的文件。除了一个文件外，你不需要直接处理这些文件。整个过程完成后，应该在一分钟内，你会得到一个新目录，名称来自压缩包的前缀。例如，针对 *julia-1.*X*.0-linux-x86_64.tar.gz*
    下载文件，这个目录是 *julia-1.*X*.0*。安装过程会占用大约是 tar 文件四倍的空间，安装完成后，你可以删除该 tar 文件。'
- en: The next step is to set up your system so that entering `julia` in the terminal
    starts the Julia program that you just installed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置你的系统，使得在终端输入 `julia` 可以启动你刚刚安装的 Julia 程序。
- en: 'To make the final installation step, first check your path by entering echo
    $PATH. If */usr/local/bin* is listed, navigate there. If it’s not, but there’s
    another directory in your path where you like to keep local commands, go there.
    Otherwise, it’s a good idea to establish such a directory, which can be */usr/local/bin*
    or something else. The method for doing that varies a bit depending on your shell.
    For the most common case of bash and bash-compatible shells, add this line to
    your *.bash_profile* startup file (which you can find in your home directory):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成最后的安装步骤，首先通过输入`echo $PATH`检查你的路径。如果路径中列出了*/usr/local/bin*，则进入该目录。如果没有，但路径中有你想用来存放本地命令的其他目录，则进入该目录。否则，最好创建这样一个目录，可以是*/usr/local/bin*或其他目录。根据你的Shell类型，执行方法略有不同。对于最常见的bash及兼容bash的Shell，在你的*.bash_profile*启动文件中添加以下行（该文件位于你的主目录中）：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After you have navigated to */usr/local/bin* or to your local command directory
    of choice, make a symbolic link to the file */bin/julia* within your new Julia
    installation directory, and call it *julia*. For our example, the command is:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进入*/usr/local/bin*或选择的本地命令目录后，创建一个指向新Julia安装目录中*/bin/julia*文件的符号链接，并将其命名为*julia*。例如，命令如下：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To create the link you need to be root, or use `sudo`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建链接时，你需要具备root权限，或者使用`sudo`。
- en: You can keep your downloaded Julia installation anywhere, but you’ll need to
    update the link set in the command if you move it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将下载的Julia安装文件保存在任何位置，但如果你将其移动，需要更新命令中设置的链接路径。
- en: To check that your new Julia installation is working, open a fresh shell and
    enter `julia`. An interactive prompt should appear, waiting for you to type your
    first line of Julia code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查你新的Julia安装是否工作正常，打开一个新的Shell并输入`julia`。交互式提示符应该会出现，等待你输入第一行Julia代码。
- en: '**On macOS**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在macOS上**'
- en: You can install Julia on your Apple computer the same way you install any other
    application. Navigate to the Julia download page, find the section for your desired
    version, and click the 64-bit link in the table. A normal macOS*.dmg* file will
    be downloaded to your system, which should open itself. You should see the Julia
    icon of red, green, and purple circles arranged in a pyramid. Drag this to your
    *Applications* folder as usual.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像安装其他应用程序一样在你的Apple电脑上安装Julia。进入Julia下载页面，找到你需要的版本部分，点击表格中的64位链接。系统将下载一个普通的macOS*.dmg*文件，并自动打开。你应该看到一个由红色、绿色和紫色圆圈排列成金字塔形状的Julia图标。按照惯例将其拖动到*应用程序*文件夹中。
- en: When you double-click this icon, a terminal should open with the Julia interactive
    prompt ready for your first command.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你双击这个图标时，终端应该会打开，并显示Julia的交互式提示符，准备接受你的第一个命令。
- en: The next step is to make arrangements so you can start Julia from the terminal
    command line and not need to click the icon, which will be convenient later on.
    These preparations also will allow you to run saved Julia programs without using
    the REPL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是进行一些设置，以便你可以从终端命令行启动Julia，而无需点击图标，这样以后会更加方便。这些准备工作还将允许你在不使用REPL的情况下运行已保存的Julia程序。
- en: 'Enabling this behavior requires two steps. If the Julia interactive prompt
    is still waiting for you, press CTRL-D to quit the REPL or enter exit(). Next,
    at the shell command line, enter the following command to delete any existing
    `julia` command that might be left over from a previous installation:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此行为需要两个步骤。如果Julia的交互式提示符仍在等待你输入，按下CTRL-D退出REPL或输入`exit()`。接下来，在Shell命令行中输入以下命令，以删除可能由以前的安装留下的任何`julia`命令：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then enter the following (change Julia-1.`X`.app to match the version that
    you have installed):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后输入以下命令（将Julia-1.`X`.app替换为你已安装的版本）：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may also want to check for the presence of `julia` commands elsewhere in
    your path, such as in `/usr/bin`, and delete them or move them out of the command
    path, so that you don’t inadvertently invoke an older executable from a previous
    installation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以检查路径中其他地方是否存在`julia`命令，例如在`/usr/bin`目录下，并删除它们或将它们移出命令路径，以避免意外调用旧版本的可执行文件。
- en: This command creates what’s known as a *symbolic link* to the actual Julia binary
    program stored deep within your *Applications* folder. Now you can type `julia`
    in any terminal to start the interactive Julia shell or to run Julia programs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建了一个*符号链接*，指向存储在你*应用程序*文件夹深处的实际Julia二进制程序。现在你可以在任何终端中输入`julia`来启动交互式Julia
    Shell或运行Julia程序。
- en: '**On Windows**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在Windows上**'
- en: Some installations of Windows do not have a modern terminal set up. You will
    need such a program to run Julia effectively and to follow the examples in this
    book. If you don’t already have a good terminal installed, a reasonable option
    is the Windows Terminal, a free program available from the Microsoft Store. Before
    doing anything else, install this terminal or something equally capable and make
    sure that you know how to start and use it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Windows 安装中没有设置现代终端。你将需要这样的程序才能有效运行 Julia，并跟随本书中的示例。如果你尚未安装合适的终端，一个合理的选择是
    Windows Terminal，这是一个可以从 Microsoft Store 获取的免费程序。在做任何事情之前，请安装这个终端或其他同样强大的程序，并确保你知道如何启动和使用它。
- en: Navigate to the Julia download page and find the section for your desired version
    (see “Julia Versions” on [page 5](ch01.xhtml#ch01lev1sec3)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Julia 下载页面，找到你所需版本的部分（见 [第 5 页](ch01.xhtml#ch01lev1sec3)中的“Julia 版本”）。
- en: If you know you’re on a 64-bit version of Windows, click the 64-bit download
    link. If you’re on 32-bit or are not sure of the architecture, click the 32-bit
    link. This will get you a Julia install that will work on both architectures,
    but using the 64-bit build has some advantages if you know you can use it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道自己使用的是 64 位版本的 Windows，请点击 64 位下载链接。如果你使用的是 32 位版本或不确定系统架构，请点击 32 位链接。这将为你下载适用于两种架构的
    Julia 安装包，但如果你确定可以使用 64 位版本，使用该版本会有一些优势。
- en: This will download a *.exe* installer, which you should run next. It will inform
    you of the installation directory; be sure to make a note of it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载一个 *.exe* 安装程序，接下来你应该运行它。它会告诉你安装目录；请务必记下该目录。
- en: The following instructions to set up Julia to run from a terminal will work
    for recent versions of Windows. If you’re running Windows 8 or earlier, you’ll
    find specific installation instructions linked from the Julia download page.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下在终端中运行 Julia 的设置说明适用于最近版本的 Windows。如果你使用的是 Windows 8 或更早版本，可以在 Julia 下载页面找到具体的安装说明。
- en: 'Recent versions of the installer offer a checkbox for setting the Julia path.
    If yours doesn’t, or you prefer to choose the path yourself, follow this procedure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的安装程序提供了一个复选框来设置 Julia 路径。如果你的安装程序没有提供这个选项，或者你更喜欢自己选择路径，请按照以下步骤操作：
- en: 'Open `Run` by pressing **Windows key-R** and enter the following command to
    open the System Variables window so you can edit the path:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **Windows 键-R** 打开 `Run`，输入以下命令打开系统变量窗口，以便编辑路径：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Click **New** and enter (or paste) the path the installer told you about (you
    copied that information, right?). If you’ve lost the path, look for a program
    with “julia” in the name in *C:\Users\<your_username>\AppData\Local\Programs*.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **New** 并输入（或粘贴）安装程序告知你的路径（你应该已经复制了这些信息，对吧？）。如果你丢失了路径，可以在 *C:\Users\<your_username>\AppData\Local\Programs*
    中查找一个名称中包含“julia”的程序。
- en: Click **OK**, open a terminal, and enter julia to test your setup. You should
    see a terminal-flavored rendering of the Julia logo, a brief message, and an interactive
    prompt, waiting for your first line of Julia code.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **OK**，打开终端，输入 julia 测试你的设置。你应该会看到一个终端风格的 Julia 标志、简短的消息以及一个交互式提示，等待你输入第一行
    Julia 代码。
- en: Another option on Windows is provided by package managers. The open source edition
    of the popular Chocolately package manager, for example, installs a reasonably
    up-to-date Julia version.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Windows 上的选择是通过包管理器提供的。以流行的开源包管理器 Chocolately 为例，它可以安装一个相对较新的 Julia 版本。
- en: '**Using Docker**'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Docker**'
- en: Read this section if you know what Docker is and you are sure that you want
    to install Julia by using a Docker image.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解 Docker，并且确信想通过 Docker 镜像安装 Julia，请阅读此部分。
- en: If that’s you, you are fortunate that a Docker community exists for Julia. Go
    to [*https://hub.docker.com/_/julia*](https://hub.docker.com/_/julia), which contains
    a description of the image for using Julia. I won’t list the details of what systems
    and versions are supported, because those are likely to change frequently. The
    page has up-to-date information for installing and using the Julia container on
    your machine. Aside from that, everything else in this book applies identically
    to Julia run from within a Docker container and Julia installed in the conventional
    way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是你，那么你很幸运，Julia 有一个社区支持的 Docker 版本。访问 [*https://hub.docker.com/_/julia*](https://hub.docker.com/_/julia)，该页面提供了关于使用
    Julia 的镜像说明。我不会列出支持的系统和版本的详细信息，因为这些信息可能会频繁更改。该页面包含有关在你的机器上安装和使用 Julia 容器的最新信息。除此之外，本书中其他的所有内容同样适用于从
    Docker 容器中运行的 Julia 和传统安装方式的 Julia。
- en: '***Privacy Note***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***隐私提示***'
- en: The Julia team is scrupulous in pointing out a privacy issue that, although
    of no concern to most people, and something that most would take for granted in
    any case, deserves to be mentioned. Julia’s package management system (something
    we’ll discuss in later chapters) is designed with the expectation that you are
    connected to the internet, and it will download software as needed for you to
    complete your tasks. This means that, of necessity, your IP address, what you
    downloaded, and when, are stored on a server somewhere, at least for a while.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 团队非常细心地指出了一个隐私问题，虽然这对大多数人来说不成问题，且在任何情况下大多数人都会理所当然地接受，但仍然值得一提。Julia 的包管理系统（我们将在后续章节中讨论）是基于你已连接互联网的前提下设计的，它会根据需要为你下载软件，帮助你完成任务。这意味着，不可避免地，你的
    IP 地址、你下载的内容以及下载时间将被存储在某个服务器上，至少会存储一段时间。
- en: '**The Julia Coding Environment**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Julia 编程环境**'
- en: With the basic Julia system installed, let’s turn to the various options for
    interacting with it. Different methods of talking to Julia are best suited for
    different situations. Also, if you have a favorite editor or IDE, this section
    will explain how you can program in Julia without changing your workflow.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了基本的 Julia 系统后，接下来我们来看看与其互动的各种方式。不同的与 Julia 对话的方法适用于不同的场景。而且，如果你有喜欢的编辑器或 IDE，本节将解释如何在不改变工作流程的情况下用
    Julia 编程。
- en: '[Table 1-1](ch01.xhtml#ch1tab1) is a brief table of the coding environments
    discussed next and their salient advantages and disadvantages:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](ch01.xhtml#ch1tab1) 是接下来讨论的编程环境的简要表格，以及它们的主要优缺点：'
- en: '**Table 1-1:** Coding Environment Comparison'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-1：** 编程环境比较'
- en: '| **Environment** | **Advantages** | **Disadvantages** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **环境** | **优点** | **缺点** |'
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| REPL | Nothing to install, quick, useful modes | Graphics in separate windows,
    repetitive entry |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| REPL | 无需安装，快速，有用的模式 | 图形显示在单独的窗口中，输入重复 |'
- en: '| Text editors | File organization, editing convenience, REPL integration |
    No graphics, limited interactivity |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 文本编辑器 | 文件组织，编辑方便，REPL 集成 | 无图形支持，交互性有限 |'
- en: '| Jupyter | Huge community, inline graphics, interactivity, multiple languages,
    good for sharing | Poor organization, no version control, hidden state, browser
    text entry |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| Jupyter | 大量社区支持，内嵌图形，交互性，支持多种语言，适合分享 | 组织结构差，无法版本控制，隐藏状态，浏览器文本输入 |'
- en: '| Pluto | Inline graphics, sophisticated interactive controls, reactive and
    consistent, full REPL integration, backed by normal Julia file | Julia only, browser
    text entry |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Pluto | 内嵌图形，复杂的交互式控件，反应式且一致，完全支持 REPL，基于普通 Julia 文件 | 仅限 Julia，浏览器文本输入 |'
- en: '| VS Code | Integrated editor, REPL, graphics, good language support | Less
    powerful as an editor than Vim or Emacs |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| VS Code | 集成编辑器，REPL，图形支持，良好的语言支持 | 相较于 Vim 或 Emacs，作为编辑器功能较弱 |'
- en: Let’s take a more detailed look at each of these options.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每种选项。
- en: '***The Julia REPL***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Julia REPL***'
- en: When you enter `julia` in the terminal, you enter the *REPL*, or *read-eval-print
    loop*. You’ll see a welcome message and the prompt will change from your system’s
    shell prompt to Julia’s.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在终端输入 `julia` 时，你进入了 *REPL*，即 *读取-求值-打印循环*。你将看到一条欢迎信息，提示符从系统的 Shell 提示符变为
    Julia 的提示符。
- en: '**REPL Modes**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**REPL 模式**'
- en: The REPL has several modes. The initial mode, with the `julia>` prompt, is the
    normal mode in which you will spend most of your REPL time. Here you can enter
    any Julia expression, press ENTER, and Julia will print the result of the expression.
    Even if you don’t know any Julia yet, try it out to make sure everything is working
    correctly. Enter an arithmetic expression such as `1 + 1`, and you should see
    the result immediately after pressing ENTER.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 有几种模式。初始模式下，提示符是 `julia>`，这是你将在 REPL 中花费大部分时间的正常模式。在这里，你可以输入任何 Julia 表达式，按下
    ENTER，Julia 会打印出该表达式的结果。即使你还不懂 Julia，也可以试试看，确保一切正常运行。输入一个算术表达式，如 `1 + 1`，按下 ENTER
    后，你应该能立刻看到结果。
- en: This mode of operation will be familiar to you if you’ve used Python, Node,
    APL, or any other REPL-based language. Unlike Python, Julia is compiled rather
    than interpreted. This difference will have implications in how you use the REPL
    in later chapters, but for now, you can use the Julia interactive interface just
    like any other REPL you may have used before.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过 Python、Node、APL 或任何其他基于 REPL 的语言，这种操作模式对你来说应该很熟悉。与 Python 不同，Julia 是编译型语言，而非解释型。这一差异将在后续章节中影响你使用
    REPL 的方式，但现在，你可以像使用其他 REPL 一样使用 Julia 的交互界面。
- en: The Julia REPL’s normal mode is a sophisticated environment with a few tricks
    up its sleeve to make your work easier. It has a “paste mode” that lets you paste
    in code samples you may have copied, for instance, from a web page, and that may
    be littered with the `julia>` prompt and have code interleaved with explanatory
    text. The REPL will know to just execute the actual code on any line starting
    with `julia>`, provided the first line pasted starts with it. (At the time of
    writing, paste mode does not work on Windows.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Julia REPL 的常规模式是一个功能强大的环境，内置了几个小技巧，可以让你的工作变得更加轻松。它有一个“粘贴模式”，可以让你粘贴从网页等地方复制的代码示例，通常这些代码示例会带有
    `julia>` 提示符，并且代码与说明文字交织在一起。REPL 会知道只执行任何以 `julia>` 开头的行，前提是粘贴的第一行也以该提示符开头。（截至写作时，粘贴模式在
    Windows 上无法使用。）
- en: The REPL is fully readline capable. This means you can use the up arrow and
    down arrow to recall earlier commands and edit them before repeating them. This
    feature even works well for multiline code blocks such as function definitions.
    To search for a previous command, you can press CTRL-R and type some text contained
    within that command. Your command and code history is saved between REPL sessions,
    so you can quit the REPL, come back the next day, and still recall your commands
    with the arrow keys. The history is stored in the *.julia/logs/repl_history.jl*
    file within your home directory. This file contains all the code you enter, and
    it even timestamps each entry, but it does not record the results Julia returns.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 完全支持 readline。这意味着你可以使用上下箭头来回顾之前的命令，并在重新执行之前进行编辑。这个功能即使对于多行代码块（如函数定义）也能很好地工作。要搜索之前的命令，你可以按
    CTRL-R 并输入命令中包含的文本。你的命令和代码历史会在 REPL 会话之间保存，因此你可以退出 REPL，第二天再回来时仍然可以通过箭头键回顾之前的命令。历史记录保存在你主目录下的
    *.julia/logs/repl_history.jl* 文件中。该文件包含你输入的所有代码，甚至为每条记录加上时间戳，但它不会记录 Julia 返回的结果。
- en: Another useful REPL mode is the help mode. Press **?**, and the prompt will
    change to `help?>`. Enter any Julia function, data type, operator, or library,
    and you will see a nicely formatted description of the item you entered, often
    with a useful collection of examples.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 REPL 模式是帮助模式。按 **?**，提示符会变为 `help?>`。输入任何 Julia 函数、数据类型、操作符或库，你将看到该项的格式化描述，通常还会附带一些有用的示例。
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Later on you’ll learn how to document your own functions in a way that hooks
    into the REPL help system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后你将学习如何以一种方式记录你自己的函数，从而与 REPL 帮助系统连接。
- en: 'The REPL also has a shell mode, activated by pressing `;`, that allows you
    to enter system shell commands from within the REPL session:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 还具有一个 shell 模式，通过按 `;` 激活，允许你在 REPL 会话中输入系统 shell 命令：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can use shell mode for simple commands. As the listing shows, we can interpolate
    Julia variables, but piping and redirection won’t work.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 shell 模式来执行简单的命令。正如列表所示，我们可以插入 Julia 变量，但管道和重定向功能无法使用。
- en: Another REPL mode you will use often is the package mode, activated by pressing
    `]`, which we’ll cover in [Chapter 3](ch03.xhtml) when we explore how to use packages
    and modules. For now, just be aware that the package system in Julia is an integral
    part of the language and environment, so much so that it’s built into the REPL.
    Julia developers don’t need to wrestle with several competing third-party package
    systems, nor with the inevitable “dependency hell” that afflicts some other languages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你会经常使用的 REPL 模式是包管理模式，通过按 `]` 激活，我们将在[第 3 章](ch03.xhtml)中探讨如何使用包和模块。现在，首先要知道的是，Julia
    的包系统是语言和环境的一个重要组成部分，甚至已经内建于 REPL 中。Julia 开发者不需要与多个竞争的第三方包系统作斗争，也不需要面对一些其他语言中不可避免的“依赖地狱”问题。
- en: To exit out of any of these modes back into the normal (sometimes called “Julian”)
    REPL mode, press BACKSPACE while the cursor is at the starting position.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出这些模式并返回到常规的（有时称为“Julian”）REPL 模式，请在光标处于起始位置时按 BACKSPACE 键。
- en: TAB works in any REPL mode to generate context-aware completions. If there is
    a unique completion, it is entered for you at the cursor; otherwise, the REPL
    presents you with a list of options.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: TAB 在任何 REPL 模式下都可以生成上下文感知的补全。如果有唯一的补全，它会在光标处自动填入；否则，REPL 会展示一个选项列表给你选择。
- en: '**REPL Colors**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**REPL 颜色**'
- en: To help you to know which mode you’re in, the REPL colors each of its prompts
    differently. The colors help visually separate the prompts from the expressions
    you enter and their results. The REPL also uses colors in certain types of output,
    such as help output, to distinguish elements like keywords and variables from
    normal text. The default colors work well when using a terminal with a black or
    dark background, which is the most popular choice. However, they are too light
    to be easily legible on a white or very light background. I use such a background
    for the illustrations in this book, as it prints better than the black background
    I usually use on my computer. If you use a light terminal background, or simply
    prefer a different appearance from the default, you can edit a configuration file
    to change any of the REPL colors.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你了解自己处于哪种模式，REPL会为每个提示符使用不同的颜色。颜色有助于在视觉上区分提示符与你输入的表达式及其结果。REPL还会在某些类型的输出中使用颜色，例如帮助输出，用来区分关键词和变量等元素与普通文本。默认的颜色在使用黑色或深色背景的终端时效果良好，这是最流行的选择。然而，这些颜色在白色或非常浅的背景上容易看不清楚。在本书的插图中，我使用了这样的背景，因为它比我通常在电脑上使用的黑色背景打印效果更好。如果你使用浅色终端背景，或者仅仅希望外观与默认值不同，你可以编辑配置文件来更改任何REPL颜色。
- en: 'In your home directory, you will find a directory called *.julia* (note the
    dot: in most people’s shells, as they are typically configured, this directory
    will not be listed using the usual commands unless you add a flag to request listing
    of “invisible files,” and graphical file management tools may or may not show
    the directory by default). Within *.julia*, there may already be a *config* directory;
    if not, create one. Enter the *config* directory and edit the *startup.jl* file
    (or create it if it doesn’t exist). Add the following to *startup.jl*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的主目录中，你会找到一个名为*.julia*的目录（注意有一个点：在大多数人的shell配置中，除非你添加标志请求列出“隐藏文件”，否则使用常规命令时该目录通常不会列出，图形化文件管理工具可能会或可能不会默认显示该目录）。在*.julia*目录下，可能已经存在一个*config*目录；如果没有，请创建一个。进入*config*目录并编辑*startup.jl*文件（如果该文件不存在，则创建它）。将以下内容添加到*startup.jl*中：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You have just written your first Julia function. Julia runs the *startup.jl*
    file every time the REPL starts (the *.jl* extension is used for Julia programs).
    This function simply defines two variables: one for the color of the prompt in
    normal mode and the other for help mode. The two numbers in square brackets are
    ANSI color codes, which are understood by most modern terminal programs. I’ve
    chosen two colors that work well on my monitor when using a white terminal background.
    If you want to pick your own colors, you can find tables of the 256 ANSI colors
    and their codes by searching the web for “ANSI color codes.” I’ve redefined only
    these two colors because the other defaults happened to work well. If you want
    to change some other colors, you can define the `repl.shell_color`, `repl.input_color`,
    and `repl.answer_color` variables as well.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚写了你的第一个Julia函数。Julia每次启动REPL时都会运行*startup.jl*文件（*.jl*扩展名用于Julia程序）。这个函数简单地定义了两个变量：一个用于正常模式下提示符的颜色，另一个用于帮助模式下的颜色。方括号中的两个数字是ANSI颜色代码，现代大多数终端程序都能理解这些代码。我选择了两种在我的显示器上使用白色终端背景时效果良好的颜色。如果你想选择自己的颜色，可以通过在网上搜索“ANSI颜色代码”来找到256种ANSI颜色及其代码表。我只重新定义了这两种颜色，因为其他默认颜色恰好合适。如果你想改变其他颜色，你也可以定义`repl.shell_color`、`repl.input_color`和`repl.answer_color`变量。
- en: Julia also understands several color *names*, but too few to allow an ideal
    selection.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Julia还理解几种颜色*名称*，但数量太少，无法提供理想的选择。
- en: '**Unicode Characters**'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Unicode字符**'
- en: Julia allows the use of Unicode characters in variable names and for other identifiers.
    This means you can make formulas in your Julia programs look more like real math,
    using, for instance, Greek letters and subscripts. Some people have set up their
    systems to allow them to type such characters easily. Even if you haven’t, you
    can still use these characters thanks to a Unicode input mode provided by the
    REPL. If you enter a backslash (`\`) followed by a string of ASCII characters,
    then press TAB, one of three things will happen. If the REPL recognizes the string
    as one of its codes for a Unicode character, the entire entry, beginning with
    the backslash, will be replaced by that character. If the code you typed is the
    beginning of a character code or one of several possible codes, the tab completion
    mechanism will work in the normal way. If the REPL does not recognize what you
    typed, it will do nothing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 允许在变量名和其他标识符中使用 Unicode 字符。这意味着你可以在 Julia 程序中让公式看起来更像真实的数学公式，例如使用希腊字母和下标。有些人已经设置了他们的系统，以便轻松输入这些字符。即使你没有这样的设置，得益于
    REPL 提供的 Unicode 输入模式，你仍然可以使用这些字符。如果你输入一个反斜杠（`\`），后跟一串 ASCII 字符，然后按下 TAB 键，接下来会发生三种情况之一。如果
    REPL 识别该字符串为某个 Unicode 字符的代码，整个输入（包括反斜杠）将被该字符替换。如果你输入的代码是某个字符代码的开头，或者是多个可能代码中的一个，Tab
    补全机制会以正常方式工作。如果 REPL 无法识别你输入的内容，它将不会做任何反应。
- en: A complete list of the Unicode character codes recognized by the REPL is maintained
    at [*https://docs.julialang.org/en/v1/manual/unicode-input/*](https://docs.julialang.org/en/v1/manual/unicode-input/).
    Those familiar with LaTeX syntax will be happy to know that all the Greek letters
    and some other symbols that have LaTeX commands are on the list unchanged. For
    example, to input *α* in the REPL, type \alpha and then press TAB. There is much
    more—even a wide selection of emoji.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 识别的 Unicode 字符代码的完整列表可以在 [*https://docs.julialang.org/en/v1/manual/unicode-input/*](https://docs.julialang.org/en/v1/manual/unicode-input/)
    查找。熟悉 LaTeX 语法的人会高兴地知道，所有希腊字母和一些其他具有 LaTeX 命令的符号都在列表中，并且没有变化。例如，要在 REPL 中输入 *α*，只需输入
    \alpha 然后按 TAB 键。还有更多内容——甚至包括大量的表情符号。
- en: If you want to know the LaTeX-style abbreviation for a particular Unicode character,
    perhaps one that you’ve copied from the documentation, enter the help mode in
    the REPL, paste in the character, and press ENTER. If an abbreviation exists,
    the help system will tell you what it is.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道某个特定 Unicode 字符的 LaTeX 风格缩写，可能是你从文档中复制的字符，可以在 REPL 中进入帮助模式，粘贴该字符并按下 ENTER。如果该字符有缩写，帮助系统会告诉你它是什么。
- en: '[Figure 1-1](ch01.xhtml#ch1fig1) shows a simple example of what you can do
    with an expanded character set.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](ch01.xhtml#ch1fig1) 展示了使用扩展字符集时的一些简单示例。'
- en: '![Image](../images/ch01fig01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch01fig01.jpg)'
- en: '*Figure 1-1: Using Unicode in the REPL*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：在 REPL 中使用 Unicode*'
- en: This is more than just fun and games. The ability to employ a wider collection
    of characters, including Greek letters and subscripts, allows us to make our code
    more concise and expressive.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是为了好玩。能够使用更多种类的字符，包括希腊字母和下标，让我们可以让代码更加简洁和富有表现力。
- en: '****Text Editors****'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '****文本编辑器****'
- en: Julia programmers use text editors routinely, either in addition to or in coordination
    with the REPL. I’ll go over some of the relevant features of the most-used programmer’s
    editors here. If you use something else, be sure to search for any enhancements,
    either built-in or in the form of third-party plug-ins, specific to Julia. These
    enhancements typically include syntax highlighting, which helps immensely in avoiding
    typos in your code, and can include more sophisticated features, such as code
    formatting and execution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 程序员通常使用文本编辑器，或是与 REPL 配合使用，或是作为补充。我将在这里介绍一些最常用的程序员编辑器的相关功能。如果你使用的是其他编辑器，务必搜索是否有特定于
    Julia 的增强功能，无论是内置的，还是第三方插件形式的。这些增强功能通常包括语法高亮，有助于避免代码中的拼写错误，还可以包括更复杂的功能，如代码格式化和执行。
- en: '**Vim**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Vim**'
- en: Vim is an excellent editor for programming in any language, and it has valuable
    Julia support. I recommend installing the `julia-vim` plug-in, available at [*https://github.com/JuliaEditorSupport/julia-vim*](https://github.com/JuliaEditorSupport/julia-vim),
    where you will also find its documentation. The plug-in requires Vim version 7.4
    or greater. To take the best advantage of `julia-vim`, ensure that the built-in
    `matchit` plug-in is enabled by executing the :runtime macros/matchit.vim Vim
    command, which should be in your Vim startup file. This plug-in adds a Julia file
    type with syntax coloring and awareness of the block structure of Julia syntax.
    It extends the `matchit` operation by allowing you to jump to the end or beginning
    of function definitions and other blocks by entering `%`. You can also select
    or delete blocks, or the bodies of blocks, in the same way that Vim allows you
    to operate on other text objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Vim是一个非常优秀的编程编辑器，支持任何语言的开发，并且对Julia有很好的支持。我建议安装`julia-vim`插件，插件地址为[*https://github.com/JuliaEditorSupport/julia-vim*](https://github.com/JuliaEditorSupport/julia-vim)，在那里你还可以找到它的文档。该插件要求Vim版本为7.4或更高。为了最大程度地利用`julia-vim`，确保启用了内置的`matchit`插件，通过执行`:runtime
    macros/matchit.vim` Vim命令来启用，它应该已经在你的Vim启动文件中。该插件增加了一个Julia文件类型，提供语法高亮并识别Julia语法的代码块结构。它通过允许你在输入`%`时跳转到函数定义或其他代码块的开始或结束，扩展了`matchit`的功能。你还可以像在Vim中操作其他文本对象一样，选择或删除代码块或代码块的主体。
- en: 'The plug-in also emulates the REPL’s LaTeX-style entry of Unicode characters.
    For this it provides two options: you can have it wait for you to press TAB, as
    the REPL does, or it can expand the entry on the fly as soon as it sees a character
    (usually a space) that seems to indicate the end of the entry (the on-the-fly
    mode does not support emoji, however).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件还模拟了REPL的LaTeX风格的Unicode字符输入。为此，它提供了两个选项：你可以让它等待你按下TAB键，就像REPL一样，或者它可以在看到一个字符（通常是空格）表示输入结束时立即展开输入（然而，实时模式不支持表情符号）。
- en: Another option for recent versions of NeoVim or Vim is to install language support
    for tree-sitter, which adds syntax-aware highlighting and other features to the
    editor. If you have Vim version 8.0 or greater, which I highly recommend, or the
    NeoVim fork, you can interact with *any* REPL directly, including the Julia REPL.
    By “interact,” I mean that you can remain in an editing buffer containing your
    Julia program and send selected lines, expressions, or blocks directly to the
    REPL for execution. The execution is asynchronous, so you can continue editing
    while Julia is churning through a time-consuming command. Communication with the
    REPL is two-way, so you can also send results printed in the REPL back into the
    editing buffer. The following instructions apply to Vim, but NeoVim users should
    be able to adapt them to that program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最近版本的NeoVim或Vim，另一个选择是安装tree-sitter的语言支持，它为编辑器增加了语法感知的高亮和其他功能。如果你使用的是Vim 8.0或更高版本（我强烈推荐使用该版本）或NeoVim分支，你可以直接与*任何*
    REPL进行交互，包括Julia REPL。所谓“交互”，是指你可以保持在一个包含Julia程序的编辑缓冲区内，并将选中的行、表达式或代码块直接发送到REPL执行。执行是异步进行的，所以你可以在Julia处理一个耗时的命令时继续编辑。与REPL的通信是双向的，因此你还可以将REPL中打印的结果发送回编辑缓冲区。以下说明适用于Vim，但NeoVim用户应该能够将其适配到该程序中。
- en: First, install the `vim-sendtowindow` plug-in, which lives at [*https://github.com/karoliskoncevicius/vim-sendtowindow*](https://github.com/karoliskoncevicius/vim-sendtowindow).
    After opening the editing buffer of choice, execute the :term julia Vim command.
    If you have the `julia` command set up properly (see [“Installation”](ch01.xhtml#ch01lev1)
    on [page 6](ch01.xhtml#ch01lev1)), a new Vim buffer should open with the Julia
    REPL running within it, below the editing window.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装`vim-sendtowindow`插件，插件地址为[*https://github.com/karoliskoncevicius/vim-sendtowindow*](https://github.com/karoliskoncevicius/vim-sendtowindow)。打开你选择的编辑缓冲区后，执行`:term
    julia` Vim命令。如果你正确设置了`julia`命令（参见[“安装”](ch01.xhtml#ch01lev1)，位于[第6页](ch01.xhtml#ch01lev1)），一个新的Vim缓冲区应该会打开，Julia
    REPL会在其中运行，并显示在编辑窗口下方。
- en: Now you can select any text in the editing window and press the spacebar followed
    by `j` to send it to the REPL. If you’d prefer some other shortcut for this operation,
    the `vim-sendtowindow` web page explains how to set it up. You can also define
    shortcuts for sending text to the right, left, and up, which is handy for sending
    text *from* the REPL and in case you prefer to split your windows vertically.
    The `:term` command, with its asynchronous execution of commands, is built into
    Vim. The plug-in provides a convenient way to send text back and forth between
    the editing and terminal buffers. The author of `vim-sendtowindow` maintains a
    list of plug-ins with similar functionality on its website.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在编辑窗口中选择任意文本，按空格键后再按 `j` 将其发送到 REPL。如果你希望使用其他快捷键来执行此操作，`vim-sendtowindow`
    网页上有关于如何设置快捷键的说明。你还可以为将文本发送到右侧、左侧和上方定义快捷键，这对于从 REPL 发送文本，或者如果你喜欢将窗口垂直拆分时非常方便。`:term`
    命令内置于 Vim，支持异步执行命令。该插件提供了在编辑和终端缓冲区之间便捷地发送文本的方式。`vim-sendtowindow` 的作者在其网站上维护了类似功能插件的列表。
- en: Similar REPL interactions are possible with earlier versions of Vim, using plug-ins
    such as `ScreenSend`, but the `term` command in version 8 makes REPL interaction
    smoother and less error prone.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用早期版本的 Vim，也可以通过类似 `ScreenSend` 的插件实现类似的 REPL 交互，但在版本 8 中的 `term` 命令使 REPL
    交互更加流畅且减少错误。
- en: '**Emacs**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Emacs**'
- en: Emacs is a powerful programmer’s editor with sophisticated Julia support available.
    The official Julia major mode for Emacs, called `julia-emacs`, is developed on
    GitHub at [*https://github.com/JuliaEditorSupport/julia-emacs*](https://github.com/JuliaEditorSupport/julia-emacs).
    The creators of the Julia language are contributors to the project, which is probably
    one of the reasons that a deep and detailed knowledge of the language’s structure
    and syntax is built into the mode. Once installed, Emacs will display Julia code
    using a variety of colors and font styles to clarify its syntax. It also provides
    movement among and manipulation of code structures such as blocks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Emacs 是一款功能强大的程序员编辑器，支持高级的 Julia 语言。Emacs 的官方 Julia 主要模式叫做 `julia-emacs`，该模式在
    GitHub 上由 [*https://github.com/JuliaEditorSupport/julia-emacs*](https://github.com/JuliaEditorSupport/julia-emacs)
    开发。Julia 语言的创造者是该项目的贡献者，这可能是该模式深度集成语言结构和语法的原因之一。安装后，Emacs 会使用各种颜色和字体样式显示 Julia
    代码，以清晰地呈现其语法。同时，它还提供了对代码结构（如代码块）的导航和操作功能。
- en: To install `julia-emacs`, first enable the MELPA repository ([*https://melpa.org*](https://melpa.org))
    and add (require 'julia-mode) to your Emacs initialization file. For most people,
    this will be *.emacs* in their home directory. For a smooth experience, you should
    be running a version of Emacs that is at least 24.1\. If your version is earlier,
    an upgrade would be advisable for using Emacs and Julia together.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `julia-emacs`，首先启用 MELPA 仓库 ([*https://melpa.org*](https://melpa.org))，并在你的
    Emacs 初始化文件中添加 (require 'julia-mode) 。对于大多数人来说，这个文件会位于家目录中的 *.emacs*。为了获得更顺畅的体验，你应该使用至少
    24.1 版本的 Emacs。如果你的版本较早，建议升级以便更好地使用 Emacs 和 Julia。
- en: Emacs shines at interacting with REPL-based languages, and Julia is no exception.
    Several minor modes are available specifically for Julia interaction. One of the
    most popular is `julia-repl`, also developed on GitHub and available at [*https://github.com/tpapp/julia-repl*](https://github.com/tpapp/julia-repl).
    It’s designed to work with the aforementioned `julia-emacs`, and you must have
    at least version 25 of Emacs installed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Emacs 在与基于 REPL 的语言交互方面表现出色，Julia 也不例外。有几个专门用于 Julia 交互的次要模式。其中最受欢迎的是 `julia-repl`，同样在
    GitHub 上开发，地址为 [*https://github.com/tpapp/julia-repl*](https://github.com/tpapp/julia-repl)。该模式设计用于与前述的
    `julia-emacs` 配合使用，且你必须安装至少 25 版本的 Emacs。
- en: 'To install `julia-repl`, edit your *.emacs* initialization file, adding the
    following lines:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `julia-repl`，请编辑你的 *.emacs* 初始化文件，并添加以下几行：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now you can start a Julia REPL right from within Emacs. It will run in an ANSI
    terminal, with the full complement of text colors and formatting. A table of keyboard
    shortcuts is available on the mode’s GitHub page. You can perform the usual sending
    of fragments, whole blocks, or the entire buffer to the REPL for execution. In
    addition, the built-in knowledge of Julia allows the mode to do such things as
    listing all the methods of a function, which will make more sense after you read
    [Chapter 8](ch08.xhtml).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以直接在 Emacs 中启动 Julia REPL。它将在 ANSI 终端中运行，支持完整的文本颜色和格式设置。有关键盘快捷键的表格可以在该模式的
    GitHub 页面找到。你可以像往常一样将片段、整个代码块或整个缓冲区发送到 REPL 进行执行。此外，Julia 的内建知识允许该模式执行一些操作，比如列出一个函数的所有方法，理解这些操作会在阅读
    [第 8 章](ch08.xhtml) 后更加清晰。
- en: '***Jupyter Notebooks***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Jupyter Notebooks***'
- en: You can use Julia from within a web browser, in two main ways, in what is referred
    to as a *notebook* interface. The older way is the Jupyter Notebook. Jupyter popularized
    the notebook concept in the free software arena, and it’s widely used in the Julia,
    Python, and R communities. In fact, the word *Jupyter* is a mashup of the names
    of those three programming languages.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种主要方式在网页浏览器中使用 Julia，这种方式被称为 *笔记本* 界面。较旧的方式是 Jupyter Notebook。Jupyter
    在自由软件领域推广了笔记本概念，并广泛应用于 Julia、Python 和 R 社区。实际上，*Jupyter* 这个词是这三种编程语言名称的拼接。
- en: If you want to use or explore a notebook interface and do not have a particular
    reason to use Jupyter, proceed directly to the next section and learn about Pluto.
    Pluto offers the same style of notebook interactivity as Jupyter while improving
    on the concept. For those who need to use Jupyter to collaborate with others using
    the system, who want to use other languages (besides Julia) with the same notebook
    interface, or who desire to explore existing Jupyter Notebooks, this section is
    designed to get you started.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用或探索笔记本界面，而没有特别的理由使用 Jupyter，直接进入下一部分，了解 Pluto。Pluto 提供了与 Jupyter 相同风格的笔记本交互性，同时在概念上有所改进。对于那些需要使用
    Jupyter 与他人合作、希望在相同的笔记本界面中使用其他语言（除了 Julia），或是希望探索现有 Jupyter Notebooks 的用户，本节旨在帮助你入门。
- en: If you already have Jupyter set up and working on your computer, you merely
    need to install the Julia backend. In the Julia REPL, press **]** to enter the
    package mode (see [page 11](ch01.xhtml#page_11)). Make sure you’re connected to
    the internet, and enter the add IJulia command to download and install the Julia
    backend for the notebook and the packages that it depends on. This is a fairly
    big install and will take some time, but the REPL will keep you informed with
    an animated display showing the progress of the downloads and the precompilation
    of modules. When the process is complete, enter jupyter notebook either at a separate
    system shell prompt or using the REPL shell mode to launch the notebook.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在电脑上设置并运行 Jupyter，只需要安装 Julia 后端。在 Julia REPL 中，按 **]** 进入包管理模式（见 [第 11
    页](ch01.xhtml#page_11)）。确保你的设备已连接到互联网，然后输入 add IJulia 命令以下载并安装用于笔记本的 Julia 后端以及其依赖的包。这是一个相对较大的安装过程，需要一些时间，但
    REPL 会通过动画显示下载进度和模块的预编译进度，时刻通知你。安装完成后，输入 jupyter notebook 无论是在单独的系统 shell 提示符下，还是使用
    REPL shell 模式，都可以启动笔记本。
- en: 'If you don’t already have Jupyter installed, after the installation described
    earlier is complete, enter the following lines in the Julia REPL:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 Jupyter，完成之前描述的安装步骤后，在 Julia REPL 中输入以下命令：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Julia will ask if you want to install Jupyter using the `Conda` package. Answer
    in the affirmative. This next phase of installation should be quicker than the
    `IJulia` install, but may still take some time. When the software is ready, Julia
    will open a window or tab in your default browser with the starting Jupyter page.
    To start up Jupyter in future sessions, repeat these commands in a Julia REPL.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 会询问是否通过 `Conda` 包安装 Jupyter。请选择肯定答案。此安装阶段应比 `IJulia` 安装更快，但仍可能需要一些时间。当软件准备好后，Julia
    会在你的默认浏览器中打开一个窗口或标签页，展示 Jupyter 启动页面。要在未来的会话中启动 Jupyter，只需在 Julia REPL 中重复这些命令。
- en: When the Jupyter Notebook page opens, you’ll have a drop-down list of installed
    kernels, or language backends. Choose the Julia kernel, and a new tab or window
    will open. On that page, you can enter Julia expressions in “cells.” When you
    press CTRL-ENTER while the cursor is in a cell, Julia will evaluate the expression
    and print the result in an output cell underneath it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Jupyter Notebook 页面打开时，你会看到一个下拉列表，列出了已安装的内核或语言后端。选择 Julia 内核，一个新标签页或窗口将打开。在该页面中，你可以在“单元格”中输入
    Julia 表达式。当光标位于单元格内时，按 CTRL-ENTER，Julia 将计算表达式并在其下方的输出单元格中打印结果。
- en: Because we are in a web browser, the system can take advantage of the ability
    to format text and display graphics. [Figure 1-2](ch01.xhtml#ch1fig2) shows a
    Jupyter Notebook after I’ve executed a few cells.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在网页浏览器中，系统可以利用格式化文本和显示图形的能力。[图 1-2](ch01.xhtml#ch1fig2)展示了我执行了几个单元格后的 Jupyter
    Notebook。
- en: '![Image](../images/ch01fig02.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch01fig02.jpg)'
- en: '*Figure 1-2: Using Jupyter with Julia*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：在 Julia 中使用 Jupyter*'
- en: The last cell is a command to create a surface plot, which directly embeds the
    plot in the page.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一单元是创建一个表面图的命令，该图会直接嵌入到页面中。
- en: You don’t need to worry about saving your work with Jupyter, as it makes frequent
    autosaves, as indicated with the notice near the top of the page in [Figure 1-2](ch01.xhtml#ch1fig2).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jupyter 时，你无需担心保存工作内容，因为它会频繁自动保存，如[图 1-2](ch01.xhtml#ch1fig2)中页面顶部的提示所示。
- en: Sharing your work is as simple as sending the on-disk form of the notebook to
    your colleagues. Everything is in one file, including the graphs and other images,
    which by default are encoded as SVG. Jupyter Notebook files have the *.ipynb*
    extension, and are stored in the directory where you started the REPL.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 分享你的工作非常简单，只需将笔记本的磁盘版发送给同事即可。所有内容都保存在一个文件中，包括图表和其他图像，默认情况下，这些图像是以 SVG 格式编码的。Jupyter
    Notebook 文件的扩展名为 *.ipynb*，并保存在你启动 REPL 的目录中。
- en: If you are going to use Jupyter extensively, consult the detailed documentation
    at [*https://jupyter.org*](https://jupyter.org) to learn more about all of its
    features.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算广泛使用 Jupyter，可以参考[详细文档](https://jupyter.org)，了解更多功能。
- en: '***Pluto: A Better Notebook***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Pluto: 一个更好的笔记本***'
- en: Pluto is a notebook interface to Julia that uses a web browser, similarly to
    Jupyter. Although it’s a young project, it’s already used routinely by a large
    community and has significant advantages over Jupyter. Its only shortcoming is
    that it is Julia-only, but this specialization allows Pluto to take better advantage
    of what Julia has to offer than frontends that support multiple kernels.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Pluto 是一个基于网页浏览器的 Julia 笔记本界面，类似于 Jupyter。尽管它是一个较新的项目，但已经被一个庞大的社区广泛使用，并且相较于
    Jupyter，它有着显著的优势。它唯一的缺点是仅支持 Julia，但这种专注使得 Pluto 比支持多内核的前端更能充分利用 Julia 的优势。
- en: 'Pluto does not depend on anything aside from a modern web browser and Julia.
    To install it, press `]` to enter the package mode in the Julia REPL and execute
    the add Pluto command. After everything downloads and installs, press BACKSPACE
    to exit the package mode, and execute this code in the REPL:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Pluto 除了依赖现代网页浏览器和 Julia 外，不需要其他任何东西。要安装它，按 `]` 进入 Julia REPL 的包管理模式，并执行添加 Pluto
    的命令。下载和安装完成后，按 BACKSPACE 退出包管理模式，然后在 REPL 中执行以下代码：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A new window or tab will open in your default web browser with the Pluto welcome
    page, which looks like [Figure 1-3](ch01.xhtml#ch1fig3).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的网页浏览器中，将打开一个新窗口或标签页，显示 Pluto 欢迎页面，样式如[图 1-3](ch01.xhtml#ch1fig3)所示。
- en: '![Image](../images/ch01fig03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch01fig03.jpg)'
- en: '*Figure 1-3: The Pluto welcome page*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-3：Pluto 欢迎页面*'
- en: Here you’ll see links for opening a fresh notebook, continuing work on an existing
    one, or examining sample notebooks. The sample notebooks cover a variety of subjects
    and are well done and instructive.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你会看到打开一个新笔记本、继续现有笔记本工作或查看示例笔记本的链接。示例笔记本涵盖了各种主题，内容制作精良且富有教学意义。
- en: A Pluto notebook is a web page where you can enter Julia expressions in “cells.”
    Pressing CTRL-ENTER while the cursor is in a cell will cause Julia to execute
    the code in that cell as well as all the cells that depend on it. If, for example,
    you define, or redefine, a variable in a cell and execute it, and you have a second
    cell that uses that variable, Pluto will execute that second cell after the first
    one is done. If a third cell depends on the result from the second cell, Pluto
    will execute that one next, and so on. After each cell is run, its result is displayed
    *above* the input cell. You can watch the progress of execution passing from cell
    to cell by observing the animated progress bars on their left borders.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Pluto笔记本是一个网页，你可以在其中的“单元格”中输入Julia表达式。在单元格中光标处按CTRL-ENTER将使Julia执行该单元格中的代码以及所有依赖于它的单元格。例如，如果你在一个单元格中定义或重新定义了一个变量并执行了它，且有第二个单元格使用了该变量，Pluto将在第一个单元格完成后执行第二个单元格。如果第三个单元格依赖于第二个单元格的结果，Pluto将接着执行第三个单元格，依此类推。每次执行单元格后，其结果将显示在*输入单元格的上方*。你可以通过观察单元格左边的动态进度条，看到执行进度在单元格之间传递。
- en: Pluto determines the order of execution by calculating a *dependency graph*
    for all the cells on the page. Using the dependency graph means that the results
    shown on the page are independent of the visual order in which they are arranged,
    and of the order in which you decide to execute cells. What you see is completely
    determined by the code in the cells, so you can share your notebooks with collaborators
    and everyone will see the same, consistent notebook. This is the major advance
    over other notebooks, such as Jupyter, where the results displayed on the page
    are the consequence of the order in which the cells were run and may even depend
    on cells that have been deleted.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Pluto通过计算页面上所有单元格的*依赖图*来决定执行顺序。使用依赖图意味着页面上显示的结果与它们排列的视觉顺序以及你决定执行单元格的顺序无关。你所看到的完全由单元格中的代码决定，因此你可以将你的笔记本分享给合作者，大家看到的都是相同且一致的笔记本。这是相较于其他笔记本的重大进步，例如Jupyter，其中页面上显示的结果是单元格执行顺序的结果，甚至可能依赖于已经删除的单元格。
- en: Pluto’s behavior is, in some ways, similar to a spreadsheet, and offers the
    same live, reactive experience. Even die-hard terminal users such as myself enjoy
    using Pluto for certain kinds of exploratory computation. Its ability to embed
    graphics and, as we’ll see in later chapters, incorporate graphical controls such
    as sliders and color pickers creates a rich environment for experimenting with
    code and data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Pluto的行为在某些方面类似于电子表格，并提供相同的实时、响应式体验。即使是像我这样的死忠终端用户，也喜欢在某些类型的探索性计算中使用Pluto。它能够嵌入图形，并且正如我们将在后续章节中看到的那样，集成图形控件，如滑块和颜色选择器，为代码和数据实验提供了丰富的环境。
- en: '[Figure 1-4](ch01.xhtml#ch1fig4) shows a Pluto page with a simple matrix calculation.
    I created it by clicking the link to start a new notebook in the welcome page.
    Pluto opened a new tab and the browser switched to it, and I entered expressions
    in three cells and pressed CTRL-ENTER to evaluate them.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-4](ch01.xhtml#ch1fig4)显示了一个包含简单矩阵计算的Pluto页面。我通过点击欢迎页面上的链接来创建这个页面并开始一个新的笔记本。Pluto打开了一个新标签页，浏览器切换到了它，我在三个单元格中输入了表达式，并按CTRL-ENTER进行求值。'
- en: '![Image](../images/ch01fig04.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch01fig04.jpg)'
- en: '*Figure 1-4: Matrix calculations in the Pluto notebook*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-4：Pluto笔记本中的矩阵计算*'
- en: '[Figure 1-4](ch01.xhtml#ch1fig4) shows the main elements of the Pluto interface.
    At the top is the path of the notebook file. Until you type this in, a message
    in that space will invite you to do so. To the right of that is a save button,
    but you only need to use it if you change the location of the file and want to
    save immediately. Every time you execute a cell, Pluto saves your work automatically.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-4](ch01.xhtml#ch1fig4)显示了Pluto界面的主要元素。顶部是笔记本文件的路径。在你输入路径之前，界面上会有提示信息邀请你填写。路径右侧是保存按钮，但只有在你更改文件位置并希望立即保存时才需要使用它。每次你执行一个单元格时，Pluto会自动保存你的工作。'
- en: In the first two code cells I’ve defined two small matrices, `m` and `n`, and
    in the third cell, I asked for their matrix product. (This is a preview of the
    array operations that we’ll explore in [Chapter 2](ch02.xhtml).) Keep in mind
    that in Pluto, the results are printed above the input cells.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个代码单元格中，我定义了两个小矩阵`m`和`n`，在第三个单元格中，我请求它们的矩阵乘积。（这预览了我们将在[第二章](ch02.xhtml)中探索的数组操作。）请记住，在Pluto中，结果会显示在输入单元格的上方。
- en: So far, we could have done this the same way in the REPL. The difference here
    is that if we change any of the numbers in `m` or `n` and run the cell with its
    new definition, the matrix product is instantly recalculated and the revised result
    replaces the old one without any further action by the user. In the REPL, we would
    have to type `m * n` again, and the new result would be printed below that, possibly
    scrolling other information off the screen.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们也可以在 REPL 中以相同的方式做这件事。这里的不同之处在于，如果我们改变 `m` 或 `n` 中的任何数字，并运行带有新定义的单元格，矩阵乘积会立即重新计算，并且修订后的结果会替换掉旧结果，用户无需做任何其他操作。在
    REPL 中，我们必须重新输入 `m * n`，然后新结果会显示在下方，可能会把其他信息滚动出屏幕。
- en: In Pluto, because the results displayed are independent of the order in which
    they appear on the page, we can rearrange the cells to provide a good exposition,
    without worrying about affecting the calculations. We can combine Julia expressions
    with text formatted using Markdown or HTML, and turn our notebook into an article
    or a live explanatory text.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pluto 中，由于显示的结果与它们在页面上出现的顺序无关，我们可以重新排列单元格，以提供良好的展示效果，而无需担心影响计算。我们可以将 Julia
    表达式与使用 Markdown 或 HTML 格式化的文本结合起来，将笔记本转变为文章或实时解释文本。
- en: In the final cell, I’ve entered a question mark (`?`) followed by the name of
    a data type, `Matrix`. As soon as you enter the question mark and begin typing,
    a live help window opens, displaying documentation about what you’ve typed so
    far. As you add letters, the documentation changes to reflect what you’ve typed,
    and you can stop when you see what you want.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个单元格中，我输入了一个问号（`?`），后跟一个数据类型的名称，`Matrix`。只要你输入问号并开始输入，实时帮助窗口就会打开，显示关于你已输入内容的文档。当你继续输入字母时，文档会随之变化，以反映你输入的内容，直到你看到你想要的内容为止。
- en: The help window stays there, displaying documentation about whatever you type
    into any cell, whether or not you ask for help. If it becomes distracting, click
    the little down arrow to tuck the window away. Because of Pluto’s close integration
    with Julia, it has other conveniences, such as tab completion, that work the same
    way as in the REPL.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助窗口会一直显示，提供关于你在任何单元格中输入内容的文档，无论你是否请求帮助。如果它变得分散注意力，可以点击小箭头将窗口收起。由于 Pluto 与 Julia
    紧密集成，它还提供了其他便利功能，比如与 REPL 中一样的 Tab 补全功能。
- en: The text file that backs the notebook page, stored at the location you entered
    at the top, is a normal Julia module file. You can import it into other Julia
    programs, edit it directly, and put it into version control. You are not locked
    into the Pluto notebook, but can use the code you develop there in other Julia
    projects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 支持笔记本页面的文本文件存储在你在顶部输入的位置，是一个普通的 Julia 模块文件。你可以将其导入到其他 Julia 程序中，直接编辑它，并进行版本控制。你并不被
    Pluto 笔记本锁定，而是可以在其他 Julia 项目中使用你在那里开发的代码。
- en: Pluto is a new and innovative way to develop programs and carry out exploratory
    computation that is fun to use. Even if you turn to it only now and then, you
    should install it and become familiar with the interface. Follow Pluto developments
    and find more documentation at [*https://github.com/fonsp/Pluto.jl*](https://github.com/fonsp/Pluto.jl).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Pluto 是一种全新且创新的方式来开发程序并进行探索性计算，它使用起来非常有趣。即使你只是偶尔使用它，你也应该安装它，并熟悉其界面。关注 Pluto
    的发展，查看更多文档，请访问 [*https://github.com/fonsp/Pluto.jl*](https://github.com/fonsp/Pluto.jl)。
- en: '***Integrated Development Environments***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集成开发环境***'
- en: Both Vim and Emacs can serve as capable IDEs for Julia by installing the plug-ins
    described in their respective sections earlier. Traditional IDEs don’t afford
    as much of a critical advantage for languages like Julia as they might for more
    verbose and ceremony-laden languages such as Java or C++, where many developers
    consider them essential. A text editor is all you need for writing Julia programs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过安装各自部分中描述的插件，Vim 和 Emacs 都可以作为 Julia 的强大 IDE。传统的 IDE 对像 Julia 这样的语言并不像对 Java
    或 C++ 这种冗长且仪式感十足的语言那样具有决定性的优势，在那些语言中，许多开发者认为它们是必不可少的。而编写 Julia 程序所需的，实际上只是一个文本编辑器。
- en: However, some users prefer a “real” IDE or may already be accustomed to one.
    The Julia IDE situation is in flux at the moment of writing. An IDE called Juno,
    consisting of a plug-in for the Atom editor, was essentially the official IDE
    for Julia, but work on it has ceased. As the language moves forward, Juno will
    not keep up. IDE development for Julia has shifted to a plug-in for VS Code, a
    popular IDE from Microsoft.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些用户更喜欢使用“真实”的集成开发环境（IDE），或者已经习惯了某个 IDE。Julia 的 IDE 形势在本文写作时正处于变化之中。曾经由 Atom
    编辑器的插件构成的 Juno 是 Julia 的官方 IDE，但目前已经停止开发。随着语言的发展，Juno 无法继续跟上脚步。Julia 的 IDE 开发已转向
    Microsoft 的流行 IDE VS Code 的插件。
- en: You can download VS Code from its GitHub repository at [*https://github.com/microsoft/vscode*](https://github.com/microsoft/vscode)
    and compile for your system. A quicker route for Linux, macOS, or Windows is to
    download the appropriate package file from [*https://code.visualstudio.com/Download*](https://code.visualstudio.com/Download)
    and follow your system’s normal install procedure. Microsoft also offers branded
    versions as binary downloads. These may contain small enhancements, and are released
    under a Microsoft product license.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从其 GitHub 仓库下载 VS Code，网址是[*https://github.com/microsoft/vscode*](https://github.com/microsoft/vscode)，并为你的系统进行编译。对于
    Linux、macOS 或 Windows 用户，更快捷的方式是从 [*https://code.visualstudio.com/Download*](https://code.visualstudio.com/Download)
    下载适当的安装包并按照系统的正常安装流程进行安装。微软还提供了品牌版本的二进制安装包，这些版本可能包含一些小的增强功能，并且是根据 Microsoft 产品许可证发布的。
- en: After installing the base VS Code program, you will install the Julia plug-in,
    which you can do from within the IDE. [Figure 1-5](ch01.xhtml#ch1fig5) illustrates
    how to do this.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完基础的 VS Code 程序后，你可以从 IDE 内部安装 Julia 插件。[图 1-5](ch01.xhtml#ch1fig5) 展示了如何操作。
- en: '![Image](../images/ch01fig05.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch01fig05.jpg)'
- en: '*Figure 1-5: Installing the Julia plug-in within VS Code*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-5：在 VS Code 中安装 Julia 插件*'
- en: The screenshot shows the left-hand area of the VS Code window, with the extension
    icon selected. I’ve entered “Julia” into the extension search box at the top,
    and the program is displaying a list of publicly available extensions that match.
    When you perform this search, the list will likely look different, but you want
    the extension titled simply “Julia,” which, in this case, is at the top of the
    list. Click the blue **Install** button to download and install the plug-in.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了 VS Code 窗口的左侧区域，并且选择了扩展图标。我在顶部的扩展搜索框中输入了“Julia”，程序显示了与之匹配的公开扩展列表。当你执行此搜索时，列表可能会有所不同，但你要寻找的扩展名为“Julia”，在本例中位于列表顶部。点击蓝色的**安装**按钮进行下载和安装插件。
- en: 'Quit VS Code and restart it after installing the plug-in. If you have set your
    path properly, as described in “Installation” on 6, press CTRL-SHIFT-P (CMD-SHIFT-P
    on macOS) to open a command window and execute the Julia: Start REPL command.
    A Julia REPL should open in a pane at the bottom of the window. It behaves just
    like the normal REPL described on [page 10](ch01.xhtml#ch01lev1sec6), with all
    REPL modes available, and using your color and other customizations.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '安装插件后，退出并重新启动 VS Code。如果你已按照“安装”部分的描述正确设置了路径，按下 CTRL-SHIFT-P（在 macOS 上为 CMD-SHIFT-P）打开命令窗口，执行
    Julia: Start REPL 命令。此时，Julia REPL 应该会在窗口底部的一个面板中打开。它的行为与[第 10 页](ch01.xhtml#ch01lev1sec6)上描述的正常
    REPL 一样，所有 REPL 模式都可用，并且支持你自定义的颜色和其他设置。'
- en: In addition to typing directly in the REPL, you can open an existing or new
    file for editing. Julia code is syntax colored, and there are syntax-aware commands
    for moving through the code and manipulating its structures. The documentation
    at [*https://www.julia-vscode.org/docs/stable/*](https://www.julia-vscode.org/docs/stable/)
    consists largely of blank pages at the time of writing, but I expect this situation
    to be improved soon. Open the command window and type `Julia:` to discover Julia-specific
    commands and then scroll through the list. If you see a command you’ll be using
    often, this list contains buttons next to each command that allow you to define
    keyboard shortcuts.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接在 REPL 中输入，你还可以打开现有文件或新文件进行编辑。Julia 代码具有语法高亮，并且提供了语法感知的命令，用于浏览代码并操作其结构。在编写本文时，[*https://www.julia-vscode.org/docs/stable/*](https://www.julia-vscode.org/docs/stable/)
    上的文档大部分是空白页面，但我预计这种情况很快会得到改善。打开命令窗口，输入 `Julia:` 来发现 Julia 特有的命令，然后滚动浏览命令列表。如果你发现一个常用的命令，列表中会显示每个命令旁边的按钮，允许你为其定义键盘快捷键。
- en: I recommend defining a shortcut for the “Send Current Line or Selection to REPL”
    command. This allows you to send any expression or statement directly from the
    editor to the REPL for execution.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议为“将当前行或选中的内容发送到 REPL”命令定义一个快捷键。这样你可以将任何表达式或语句直接从编辑器发送到 REPL 执行。
- en: If you execute a plot command in the REPL, the plot appears in its own dedicated
    pane within the VS Code window. [Figure 1-6](ch01.xhtml#ch1fig6) shows the main
    part of the window as it appears on my laptop, with the light background selected
    from among VS Code’s three appearance options.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 REPL 中执行绘图命令，绘图会出现在 VS Code 窗口内一个专用的面板中。[图 1-6](ch01.xhtml#ch1fig6) 显示了我的笔记本电脑上该窗口的主要部分，选用了
    VS Code 三个外观选项中的浅色背景。
- en: '![Image](../images/ch01fig06.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch01fig06.jpg)'
- en: '*Figure 1-6: Using the Julia plug-in in VS Code*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-6：在 VS Code 中使用 Julia 插件*'
- en: In the top pane, I’m editing a file with a few lines of Julia code, which I’ve
    sent directly to the REPL in the bottom pane. Although you may not understand
    all the language syntax yet, you may be able to form an idea of what the expressions
    are intended to return. After trying some arithmetic to see if the setup is working,
    I define a range of numbers, assigned to the `x` variable, and then plot a function
    applied to each value in the list. At the top right, the plot window has appeared.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的面板中，我正在编辑一个包含几行 Julia 代码的文件，并将其直接发送到下面面板中的 REPL。虽然你可能还不完全理解所有的语言语法，但你可能已经能大致了解这些表达式的预期输出。在尝试了一些算术操作来检查设置是否有效之后，我定义了一系列数字，并将其赋值给
    `x` 变量，然后绘制了应用于列表中每个值的函数。在右上方，绘图窗口已出现。
- en: '**Recommendations**'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**建议**'
- en: As the choice of tools is a matter of personal preference, I’ve tried to provide
    enough information about all the main ways of interacting with Julia and editing
    Julia programs to allow you to choose the methods that most appeal to you. If
    you are already in the habit of using Vim, Emacs, or any other tool for programming,
    you don’t need to learn anything new or change your workflows to use Julia. Use
    what you are familiar with, as Julia can easily adapt to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工具的选择是个人偏好问题，我尝试提供足够的信息，介绍所有与 Julia 交互和编辑 Julia 程序的主要方式，以便你可以选择最适合自己的方法。如果你已经习惯使用
    Vim、Emacs 或其他编程工具，你无需学习任何新东西或改变工作流程来使用 Julia。使用你熟悉的工具，因为 Julia 可以轻松适应它。
- en: If, however, you’re not yet committed to any specific tooling, I have a recommendation.
    I suggest that you install Vim, along with the Julia-specific plug-ins described
    in “Text Editors” on [page 14](ch01.xhtml#ch01lev1sec7). Vim takes some getting
    used to, but the long-term rewards are worthwhile, as it is an efficient and flexible
    editor, and it makes working alongside the REPL easy.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你还没有决定使用特定的工具，我有一个建议。我建议你安装 Vim，并安装《文本编辑器》一节中描述的 Julia 专用插件（见 [第 14 页](ch01.xhtml#ch01lev1sec7)）。Vim
    需要一些时间来适应，但从长远来看是值得的，它是一个高效且灵活的编辑器，并且使得与 REPL 一起工作变得轻松。
- en: If Vim is new to you, to ease the burden of learning both a new language and
    an unfamiliar editor simultaneously, consider working through Pluto, as well as
    in the REPL directly, while you take your time to become comfortable with a new
    editor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 Vim 的新手，为了减轻同时学习新语言和陌生编辑器的负担，考虑在 Pluto 中操作并直接使用 REPL，同时花些时间适应新的编辑器。
- en: Be aware that this reflects my personal preferences, and you may prefer a different
    environment. For example, if you find working in a browser-based notebook appealing,
    there is no reason you can’t do all of your Julia work within Pluto. My only negative
    recommendation is not to stick with a primitive editor that has no REPL or language
    support, as doing so will hold you back in the long run.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这反映了我的个人偏好，你可能更喜欢不同的环境。例如，如果你觉得在基于浏览器的笔记本中工作很有吸引力，完全可以在 Pluto 中完成所有的 Julia
    工作。我唯一不推荐的是坚持使用没有 REPL 或语言支持的原始编辑器，因为这样会在长期内拖慢你的进步。
- en: '**FURTHER READING**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: My article “The Scientist’s Linux Toolbox” in *Linux Pro Magazine* ([*https://www.linuxpromagazine.com/Issues/2020/241/Scientist-s-Toolbox*](https://www.linuxpromagazine.com/Issues/2020/241/Scientist-s-Toolbox))
    provides more information about Julia and other software useful to scientists
    computing on Linux.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的文章《科学家的 Linux 工具箱》在 *Linux Pro Magazine* 中刊登（[*https://www.linuxpromagazine.com/Issues/2020/241/Scientist-s-Toolbox*](https://www.linuxpromagazine.com/Issues/2020/241/Scientist-s-Toolbox)）提供了更多关于
    Julia 和其他对在 Linux 上进行计算的科学家有用的软件的信息。
- en: In “An Introduction to Pluto” ([*https://lwn.net/Articles/835930/*](https://lwn.net/Articles/835930/)),
    I describe the development of the Pluto notebook, give some examples of its use,
    and contrast it with the popular Jupyter Notebook interface.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《Pluto简介》([*https://lwn.net/Articles/835930/*](https://lwn.net/Articles/835930/))中，我描述了
    Pluto 笔记本的开发过程，给出了它的一些使用示例，并将其与流行的 Jupyter Notebook 界面进行了对比。
- en: A useful ANSI color code table is available at [*https://misc.flogisoft.com/_media/bash/colors_format/256_colors_bg.png*](https://misc.flogisoft.com/_media/bash/colors_format/256_colors_bg.png).
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有用的 ANSI 颜色代码表可以在[*https://misc.flogisoft.com/_media/bash/colors_format/256_colors_bg.png*](https://misc.flogisoft.com/_media/bash/colors_format/256_colors_bg.png)上找到。
- en: Go to [*https://gitforwindows.org*](https://gitforwindows.org) for a Windows
    solution that provides Git, a terminal program, and some more conveniences.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问[*https://gitforwindows.org*](https://gitforwindows.org)，获取提供 Git、终端程序和其他一些便捷功能的
    Windows 解决方案。
