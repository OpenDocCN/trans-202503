- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: GETTING STARTED**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**开始使用**'
- en: '*You don’t have to see the whole staircase, just take the first step.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*你不需要看到整个楼梯，只需迈出第一步。*'
- en: '*—*Dr. Martin Luther King Jr.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*—*马丁·路德·金博士'
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: As mentioned in the introduction, to learn a programming language, it’s not
    enough to read a book—not even one as good as this. Experimenting and writing
    programs yourself is essential. After absorbing a key concept in the book or running
    a code sample, try to construct variations of the code and run them. Writing your
    own variations will help you achieve fluency in the language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在介绍中提到的，要学习一门编程语言，光读书是不够的——即使是像本书这样优秀的书籍也不行。亲自实验和编写程序是至关重要的。在书中掌握一个关键概念或运行一个代码示例后，尝试构建代码的变体并运行它们。编写自己的变体将帮助你熟练掌握这门语言。
- en: This chapter first covers how to install Julia on all the major operating systems,
    and then discusses the various types of coding environments. We’ll see how to
    install each one, and explore their unique features, advantages, and disadvantages.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍如何在所有主要操作系统上安装Julia，然后讨论各种类型的编码环境。我们将学习如何安装每种环境，并探索它们的独特功能、优缺点。
- en: '**Installation Guide**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装指南**'
- en: Of course, to be able to do any of this you will need access to a Julia system.
    If you’re already set up to run Julia code, you can safely skip this whole section.
    If not, you can skip the subsections covering installation on operating systems
    that you don’t use, but you should probably read everything else.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要能够完成这些，你需要访问一个Julia系统。如果你已经配置好了运行Julia代码的环境，你可以安全地跳过这一整部分。如果没有，你可以跳过你不使用的操作系统的安装子章节，但你应该阅读其他所有内容。
- en: '***Hardware Requirements***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***硬件要求***'
- en: For learning Julia, almost any computer will be sufficient. It should have at
    least 2GB of RAM, but twice that amount will be more comfortable. You’ll need
    about 0.5GB of free disk space to install Julia, but you should have at least
    3GB of additional space for the packages that you’ll install for plotting and
    other purposes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于学习Julia，几乎任何计算机都足够。它应该至少有2GB的RAM，但拥有双倍内存将更加舒适。安装Julia大约需要0.5GB的空闲磁盘空间，但你应该至少预留3GB的额外空间，用于安装绘图和其他用途的包。
- en: These modest requirements are fine for learning the language and even for doing
    many real calculations, although you may require beefier hardware for larger-scale
    projects. Julia is used for calculations at every scale, and it can make efficient
    use of all types of hardware from laptops to GPU array processors to the world’s
    largest supercomputers (see “Further Reading” on [page 23](ch01.xhtml#fur1) for
    an example). I have run every example calculation in this book on a very modestly
    powered laptop, so all of the code here should run with no problems on any machine
    that you’re likely to be using.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些适中的要求足以用于学习语言，甚至可以进行许多实际计算，尽管对于大规模项目，你可能需要更强大的硬件。Julia可用于各种规模的计算，它能高效地利用从笔记本电脑到GPU阵列处理器再到世界上最大的超级计算机等各种硬件（有关示例，请参见[第23页](ch01.xhtml#fur1)的“进一步阅读”）。我已经在一台非常普通的笔记本电脑上运行了本书中的所有示例计算，因此本书中的所有代码应该可以在你使用的任何计算机上顺利运行。
- en: 'Julia runs on Linux, FreeBSD, macOS, and Windows. At the time of writing, Julia
    is fully supported on these systems:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Julia可以在Linux、FreeBSD、macOS和Windows上运行。截止到写作时，Julia在这些系统上完全受支持：
- en: 'Linux 2.6.18+: x86-64 (64-bit), i686 (32-bit), and ARMv8 (64-bit)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 2.6.18+: x86-64（64位）、i686（32位）和ARMv8（64位）'
- en: 'FreeBSD 11.0+: x86-64 (64-bit)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FreeBSD 11.0+: x86-64（64位）'
- en: 'macOS 10.9+: x86-64 (64-bit)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS 10.9+: x86-64（64位）'
- en: 'Windows 7+: x86-64 (32- and 64-bit)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows 7+: x86-64（32位和64位）'
- en: These installation requirements may change, so check [*https://julialang.org/downloads/*](https://julialang.org/downloads/)
    for up-to-date information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些安装要求可能会发生变化，因此请查看[*https://julialang.org/downloads/*](https://julialang.org/downloads/)以获取最新信息。
- en: Julia also runs on some system versions and architectures not listed here, but
    with reduced support, weaker guarantees, or possibly hampered functionality. It
    can also take advantage of more specialized hardware—for example, graphical processing
    unit array processors, which we’ll discuss in later chapters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Julia还可以在一些未列出的系统版本和架构上运行，但其支持较弱，保证性较差，或可能功能受限。它还可以利用更多专用硬件——例如，我们将在后续章节中讨论的图形处理单元阵列处理器。
- en: '***Prerequisites***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***先决条件***'
- en: 'To use Julia effectively, you need to know a few things about how to operate
    your computer. You need a basic knowledge of the terminal and the command line:
    how to create and change directories (folders), view a list of files, find out
    how much storage space is available on your hard drive, and delete files.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Every operating system has various graphical utilities for accomplishing those
    tasks, both built-in and as third-party software, but it is a good idea for the
    computational scientist to become familiar with the command line and use it routinely.
    There’s a good chance you’ll find yourself in a remote computing situation some
    day, where the command line may be the only way to communicate with the remote
    machine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: It’s also a good idea, even if your personal computer uses some other operating
    system, to learn how to perform these rudimentary tasks on Linux, as that is by
    far the most common frontend OS on compute servers for scientific work. If your
    daily driver comes from Apple, that won’t be a problem, as the basic commands
    in the macOS BSD-derived terminal are nearly the same as on Linux. If you’re accustomed
    to Windows, you may need to learn some translations; however, that is beyond the
    scope of this book, and you won’t need to know the Linux dialect to use Julia
    on your personal computer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to be familiar with an editor on your system that can save
    files in a plaintext format. Most programmers use Vim, Emacs, or a more elaborate
    integrated development environment (IDE)—options that we will discuss further
    in the next section. You can use any editor you’re familiar with, but graphical
    editors such as Word are not the best choice. However, if you really want to use
    such programs, they’ll work. Just be sure to save your creations as plaintext
    files, and use a monospaced font, which will work better for writing code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '***Julia Versions***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most people, no matter their platform, will download Julia from the official
    Julia website at [*https://julialang.org/downloads/*](https://julialang.org/downloads/).
    Whether you get it there or somewhere else, keep in mind that Julia, although
    it’s been stable for several years, is still undergoing rapid development. *Stable*
    in this context means that you can expect no breaking changes: programs that you
    write now, or have written using any version of Julia from v1.0 onward, will continue
    to work as you upgrade your Julia installation in the future, with few exceptions.
    However, *rapid development* means that the particular version you have installed
    can make a substantial difference.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the language implementation itself, the Julia team has made continuous
    progress in speed and responsiveness since the first public release, and that’s
    likely to continue, which is reason enough to recommend using the most recent
    stable language version. Regarding the ecosystem generally, many important packages,
    which are libraries of Julia code that you can use in your own programs, are also
    progressing rapidly, and new ones are emerging every month. Older Julia versions
    may not be compatible with new, or newer versions of, important packages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于语言实现本身，自从首次公开发布以来，Julia 团队在速度和响应性方面取得了持续的进展，这种进展很可能会继续下去，这也是推荐使用最新稳定语言版本的充分理由。关于生态系统，许多重要的软件包（即你可以在自己程序中使用的
    Julia 代码库）也在快速进展，并且每个月都有新的软件包出现。较旧的 Julia 版本可能与重要软件包的新版本或更新版本不兼容。
- en: In the download section of the Julia website, you will find downloads corresponding
    to various “releases,” or recent versions, of Julia. Most people will be best
    served by the one identified as “Current stable release.” “Upcoming release” is
    a beta version of the next stable release. It will have more recently added features,
    but it will also have slightly more compatibility problems with various packages
    and may be afflicted with some minor bugs. Depending on when you are reading this,
    the “Long-term support” release may or may not have all of the features this book
    uses. In general, to avoid any confusion arising from possibly different behavior
    from the code samples here, ensure that you install Julia v1.6.0 or greater and
    avoid beta releases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 网站的下载区，你会找到对应不同“发布版”或最近版本的 Julia 下载。大多数人最适合选择被标识为“当前稳定版”的下载。“即将发布版”是下一个稳定版的测试版本。它会有一些最近添加的新功能，但也可能会和一些软件包存在兼容性问题，且可能会出现一些小的
    bug。根据你阅读本书的时间，“长期支持”版可能不包含本书使用的所有功能。通常，为了避免由于代码示例的行为不同而产生的混淆，确保你安装 Julia v1.6.0
    或更高版本，并避免使用测试版。
- en: '***Installation***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装***'
- en: This section contains instructions for various options to install Julia on every
    OS for which it is available. You only need to pay attention to the sections that
    apply to you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含了在所有可用的操作系统上安装 Julia 的各种选项的说明。你只需要关注适用于你的部分。
- en: As an alternative to these instructions, which leave you with a Julia binary
    ready to run, you can download the Julia source code at the same location as the
    other download links. As Julia is completely free and open source software, the
    source is always available for experts to inspect and compile themselves. If you
    want to run Julia on an unusual system for which a binary is not supplied, this
    is your only option.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些说明的替代方案，你可以在与其他下载链接相同的位置下载 Julia 的源代码。由于 Julia 是完全免费的开源软件，源代码始终可以供专家检查和自行编译。如果你希望在某个没有提供二进制文件的特殊系统上运行
    Julia，这是唯一的选择。
- en: '**On Linux and FreeBSD**'
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在 Linux 和 FreeBSD 上**'
- en: 'Almost every Linux distribution has its own package management system: an official
    mechanism for installing programs and keeping them updated. Using the official
    package manager has two advantages. First, it is integrated, meaning that dependencies
    among all the installed programs should be automatically resolved and everything
    will work together. The second benefit is security: packages in the official repositories
    are generally vetted and unlikely to contain malicious code.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个 Linux 发行版都有自己的软件包管理系统：一种官方机制，用于安装程序并保持它们的更新。使用官方的软件包管理器有两个优势。首先，它是集成的，这意味着所有安装程序之间的依赖关系应该会自动解决，一切都能协同工作。第二个好处是安全性：官方仓库中的软件包通常都会经过审查，不太可能包含恶意代码。
- en: Unfortunately, it takes considerable time for software to be packaged and included
    in the official repositories of most Linux distributions. Projects such as Julia
    that are undergoing rapid development should generally not be installed using
    the package manager. The distribution’s version will lag too far behind the current
    versions that you can get directly from the Julia project. This is less of a problem
    for certain Linux distributions that employ a rolling release schedule and keep
    their packages up to date, but it makes the use of the package manager in, for
    example, Debian-based distributions a poor choice for Julia.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, if you are on Linux, the best strategy is to go to the Julia
    download page at [*https://julialang.org/downloads/*](https://julialang.org/downloads/).
    Look for the heading “Current stable release” and, under that, find the entry
    for your machine’s architecture. Most people will want the 64-bit download for
    “Generic Linux on x86.” Clicking the download link copies a file to your computer
    with the extension *.tar.gz*. It will be a little more than 100MB.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The default location for browser downloads for most people is the *Downloads*
    directory inside their home directory, but your browser may be configured differently.
    After you have found the download location, you should see the file you just acquired,
    named something like *julia-1.*X*.0-linux-x86_64.tar.gz*, which indicates v1.*X*.0
    of Julia, built for Linux systems with the x86, 64-bit architecture. The double
    extension indicates that this is a compressed tarfile. You can uncompress and
    un-archive the file with a single command (substituting the actual downloaded
    filename):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `tar` command should already be installed on any normal Linux system. After
    entering this command, you should see the names of a bit more than 2,000 files
    scroll by in your terminal, indicating the creation of subdirectories and the
    un-archiving of the files needed for an initial installation of Julia to work.
    You won’t need to do anything directly with any of these files except one. After
    the process is complete, which should take under a minute, you’ll have a new directory
    with a name taken from the beginning of the archive’s name. For the example *julia-1.*X*.0-linux-x86_64.tar.gz*
    download file, that directory is *julia-1.*X*.0*. The installation will take up
    about four times the space of the tarfile, which you can delete after the `tar`
    command completes successfully.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to set up your system so that entering `julia` in the terminal
    starts the Julia program that you just installed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the final installation step, first check your path by entering echo
    $PATH. If */usr/local/bin* is listed, navigate there. If it’s not, but there’s
    another directory in your path where you like to keep local commands, go there.
    Otherwise, it’s a good idea to establish such a directory, which can be */usr/local/bin*
    or something else. The method for doing that varies a bit depending on your shell.
    For the most common case of bash and bash-compatible shells, add this line to
    your *.bash_profile* startup file (which you can find in your home directory):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After you have navigated to */usr/local/bin* or to your local command directory
    of choice, make a symbolic link to the file */bin/julia* within your new Julia
    installation directory, and call it *julia*. For our example, the command is:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To create the link you need to be root, or use `sudo`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: You can keep your downloaded Julia installation anywhere, but you’ll need to
    update the link set in the command if you move it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: To check that your new Julia installation is working, open a fresh shell and
    enter `julia`. An interactive prompt should appear, waiting for you to type your
    first line of Julia code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**On macOS**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can install Julia on your Apple computer the same way you install any other
    application. Navigate to the Julia download page, find the section for your desired
    version, and click the 64-bit link in the table. A normal macOS*.dmg* file will
    be downloaded to your system, which should open itself. You should see the Julia
    icon of red, green, and purple circles arranged in a pyramid. Drag this to your
    *Applications* folder as usual.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: When you double-click this icon, a terminal should open with the Julia interactive
    prompt ready for your first command.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to make arrangements so you can start Julia from the terminal
    command line and not need to click the icon, which will be convenient later on.
    These preparations also will allow you to run saved Julia programs without using
    the REPL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling this behavior requires two steps. If the Julia interactive prompt
    is still waiting for you, press CTRL-D to quit the REPL or enter exit(). Next,
    at the shell command line, enter the following command to delete any existing
    `julia` command that might be left over from a previous installation:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then enter the following (change Julia-1.`X`.app to match the version that
    you have installed):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may also want to check for the presence of `julia` commands elsewhere in
    your path, such as in `/usr/bin`, and delete them or move them out of the command
    path, so that you don’t inadvertently invoke an older executable from a previous
    installation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This command creates what’s known as a *symbolic link* to the actual Julia binary
    program stored deep within your *Applications* folder. Now you can type `julia`
    in any terminal to start the interactive Julia shell or to run Julia programs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**On Windows**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some installations of Windows do not have a modern terminal set up. You will
    need such a program to run Julia effectively and to follow the examples in this
    book. If you don’t already have a good terminal installed, a reasonable option
    is the Windows Terminal, a free program available from the Microsoft Store. Before
    doing anything else, install this terminal or something equally capable and make
    sure that you know how to start and use it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Windows 安装中没有设置现代终端。你将需要这样的程序才能有效运行 Julia，并跟随本书中的示例。如果你尚未安装合适的终端，一个合理的选择是
    Windows Terminal，这是一个可以从 Microsoft Store 获取的免费程序。在做任何事情之前，请安装这个终端或其他同样强大的程序，并确保你知道如何启动和使用它。
- en: Navigate to the Julia download page and find the section for your desired version
    (see “Julia Versions” on [page 5](ch01.xhtml#ch01lev1sec3)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Julia 下载页面，找到你所需版本的部分（见 [第 5 页](ch01.xhtml#ch01lev1sec3)中的“Julia 版本”）。
- en: If you know you’re on a 64-bit version of Windows, click the 64-bit download
    link. If you’re on 32-bit or are not sure of the architecture, click the 32-bit
    link. This will get you a Julia install that will work on both architectures,
    but using the 64-bit build has some advantages if you know you can use it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道自己使用的是 64 位版本的 Windows，请点击 64 位下载链接。如果你使用的是 32 位版本或不确定系统架构，请点击 32 位链接。这将为你下载适用于两种架构的
    Julia 安装包，但如果你确定可以使用 64 位版本，使用该版本会有一些优势。
- en: This will download a *.exe* installer, which you should run next. It will inform
    you of the installation directory; be sure to make a note of it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载一个 *.exe* 安装程序，接下来你应该运行它。它会告诉你安装目录；请务必记下该目录。
- en: The following instructions to set up Julia to run from a terminal will work
    for recent versions of Windows. If you’re running Windows 8 or earlier, you’ll
    find specific installation instructions linked from the Julia download page.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下在终端中运行 Julia 的设置说明适用于最近版本的 Windows。如果你使用的是 Windows 8 或更早版本，可以在 Julia 下载页面找到具体的安装说明。
- en: 'Recent versions of the installer offer a checkbox for setting the Julia path.
    If yours doesn’t, or you prefer to choose the path yourself, follow this procedure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的安装程序提供了一个复选框来设置 Julia 路径。如果你的安装程序没有提供这个选项，或者你更喜欢自己选择路径，请按照以下步骤操作：
- en: 'Open `Run` by pressing **Windows key-R** and enter the following command to
    open the System Variables window so you can edit the path:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **Windows 键-R** 打开 `Run`，输入以下命令打开系统变量窗口，以便编辑路径：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Click **New** and enter (or paste) the path the installer told you about (you
    copied that information, right?). If you’ve lost the path, look for a program
    with “julia” in the name in *C:\Users\<your_username>\AppData\Local\Programs*.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **New** 并输入（或粘贴）安装程序告知你的路径（你应该已经复制了这些信息，对吧？）。如果你丢失了路径，可以在 *C:\Users\<your_username>\AppData\Local\Programs*
    中查找一个名称中包含“julia”的程序。
- en: Click **OK**, open a terminal, and enter julia to test your setup. You should
    see a terminal-flavored rendering of the Julia logo, a brief message, and an interactive
    prompt, waiting for your first line of Julia code.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **OK**，打开终端，输入 julia 测试你的设置。你应该会看到一个终端风格的 Julia 标志、简短的消息以及一个交互式提示，等待你输入第一行
    Julia 代码。
- en: Another option on Windows is provided by package managers. The open source edition
    of the popular Chocolately package manager, for example, installs a reasonably
    up-to-date Julia version.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Windows 上的选择是通过包管理器提供的。以流行的开源包管理器 Chocolately 为例，它可以安装一个相对较新的 Julia 版本。
- en: '**Using Docker**'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Docker**'
- en: Read this section if you know what Docker is and you are sure that you want
    to install Julia by using a Docker image.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解 Docker，并且确信想通过 Docker 镜像安装 Julia，请阅读此部分。
- en: If that’s you, you are fortunate that a Docker community exists for Julia. Go
    to [*https://hub.docker.com/_/julia*](https://hub.docker.com/_/julia), which contains
    a description of the image for using Julia. I won’t list the details of what systems
    and versions are supported, because those are likely to change frequently. The
    page has up-to-date information for installing and using the Julia container on
    your machine. Aside from that, everything else in this book applies identically
    to Julia run from within a Docker container and Julia installed in the conventional
    way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是你，那么你很幸运，Julia 有一个社区支持的 Docker 版本。访问 [*https://hub.docker.com/_/julia*](https://hub.docker.com/_/julia)，该页面提供了关于使用
    Julia 的镜像说明。我不会列出支持的系统和版本的详细信息，因为这些信息可能会频繁更改。该页面包含有关在你的机器上安装和使用 Julia 容器的最新信息。除此之外，本书中其他的所有内容同样适用于从
    Docker 容器中运行的 Julia 和传统安装方式的 Julia。
- en: '***Privacy Note***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***隐私提示***'
- en: The Julia team is scrupulous in pointing out a privacy issue that, although
    of no concern to most people, and something that most would take for granted in
    any case, deserves to be mentioned. Julia’s package management system (something
    we’ll discuss in later chapters) is designed with the expectation that you are
    connected to the internet, and it will download software as needed for you to
    complete your tasks. This means that, of necessity, your IP address, what you
    downloaded, and when, are stored on a server somewhere, at least for a while.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 团队非常细心地指出了一个隐私问题，虽然这对大多数人来说不成问题，且在任何情况下大多数人都会理所当然地接受，但仍然值得一提。Julia 的包管理系统（我们将在后续章节中讨论）是基于你已连接互联网的前提下设计的，它会根据需要为你下载软件，帮助你完成任务。这意味着，不可避免地，你的
    IP 地址、你下载的内容以及下载时间将被存储在某个服务器上，至少会存储一段时间。
- en: '**The Julia Coding Environment**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Julia 编程环境**'
- en: With the basic Julia system installed, let’s turn to the various options for
    interacting with it. Different methods of talking to Julia are best suited for
    different situations. Also, if you have a favorite editor or IDE, this section
    will explain how you can program in Julia without changing your workflow.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了基本的 Julia 系统后，接下来我们来看看与其互动的各种方式。不同的与 Julia 对话的方法适用于不同的场景。而且，如果你有喜欢的编辑器或 IDE，本节将解释如何在不改变工作流程的情况下用
    Julia 编程。
- en: '[Table 1-1](ch01.xhtml#ch1tab1) is a brief table of the coding environments
    discussed next and their salient advantages and disadvantages:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](ch01.xhtml#ch1tab1) 是接下来讨论的编程环境的简要表格，以及它们的主要优缺点：'
- en: '**Table 1-1:** Coding Environment Comparison'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-1：** 编程环境比较'
- en: '| **Environment** | **Advantages** | **Disadvantages** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **环境** | **优点** | **缺点** |'
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| REPL | Nothing to install, quick, useful modes | Graphics in separate windows,
    repetitive entry |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| REPL | 无需安装，快速，有用的模式 | 图形显示在单独的窗口中，输入重复 |'
- en: '| Text editors | File organization, editing convenience, REPL integration |
    No graphics, limited interactivity |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 文本编辑器 | 文件组织，编辑方便，REPL 集成 | 无图形支持，交互性有限 |'
- en: '| Jupyter | Huge community, inline graphics, interactivity, multiple languages,
    good for sharing | Poor organization, no version control, hidden state, browser
    text entry |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| Jupyter | 大量社区支持，内嵌图形，交互性，支持多种语言，适合分享 | 组织结构差，无法版本控制，隐藏状态，浏览器文本输入 |'
- en: '| Pluto | Inline graphics, sophisticated interactive controls, reactive and
    consistent, full REPL integration, backed by normal Julia file | Julia only, browser
    text entry |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Pluto | 内嵌图形，复杂的交互式控件，反应式且一致，完全支持 REPL，基于普通 Julia 文件 | 仅限 Julia，浏览器文本输入 |'
- en: '| VS Code | Integrated editor, REPL, graphics, good language support | Less
    powerful as an editor than Vim or Emacs |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| VS Code | 集成编辑器，REPL，图形支持，良好的语言支持 | 相较于 Vim 或 Emacs，作为编辑器功能较弱 |'
- en: Let’s take a more detailed look at each of these options.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每种选项。
- en: '***The Julia REPL***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Julia REPL***'
- en: When you enter `julia` in the terminal, you enter the *REPL*, or *read-eval-print
    loop*. You’ll see a welcome message and the prompt will change from your system’s
    shell prompt to Julia’s.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在终端输入 `julia` 时，你进入了 *REPL*，即 *读取-求值-打印循环*。你将看到一条欢迎信息，提示符从系统的 Shell 提示符变为
    Julia 的提示符。
- en: '**REPL Modes**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**REPL 模式**'
- en: The REPL has several modes. The initial mode, with the `julia>` prompt, is the
    normal mode in which you will spend most of your REPL time. Here you can enter
    any Julia expression, press ENTER, and Julia will print the result of the expression.
    Even if you don’t know any Julia yet, try it out to make sure everything is working
    correctly. Enter an arithmetic expression such as `1 + 1`, and you should see
    the result immediately after pressing ENTER.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 有几种模式。初始模式下，提示符是 `julia>`，这是你将在 REPL 中花费大部分时间的正常模式。在这里，你可以输入任何 Julia 表达式，按下
    ENTER，Julia 会打印出该表达式的结果。即使你还不懂 Julia，也可以试试看，确保一切正常运行。输入一个算术表达式，如 `1 + 1`，按下 ENTER
    后，你应该能立刻看到结果。
- en: This mode of operation will be familiar to you if you’ve used Python, Node,
    APL, or any other REPL-based language. Unlike Python, Julia is compiled rather
    than interpreted. This difference will have implications in how you use the REPL
    in later chapters, but for now, you can use the Julia interactive interface just
    like any other REPL you may have used before.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过 Python、Node、APL 或任何其他基于 REPL 的语言，这种操作模式对你来说应该很熟悉。与 Python 不同，Julia 是编译型语言，而非解释型。这一差异将在后续章节中影响你使用
    REPL 的方式，但现在，你可以像使用其他 REPL 一样使用 Julia 的交互界面。
- en: The Julia REPL’s normal mode is a sophisticated environment with a few tricks
    up its sleeve to make your work easier. It has a “paste mode” that lets you paste
    in code samples you may have copied, for instance, from a web page, and that may
    be littered with the `julia>` prompt and have code interleaved with explanatory
    text. The REPL will know to just execute the actual code on any line starting
    with `julia>`, provided the first line pasted starts with it. (At the time of
    writing, paste mode does not work on Windows.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The REPL is fully readline capable. This means you can use the up arrow and
    down arrow to recall earlier commands and edit them before repeating them. This
    feature even works well for multiline code blocks such as function definitions.
    To search for a previous command, you can press CTRL-R and type some text contained
    within that command. Your command and code history is saved between REPL sessions,
    so you can quit the REPL, come back the next day, and still recall your commands
    with the arrow keys. The history is stored in the *.julia/logs/repl_history.jl*
    file within your home directory. This file contains all the code you enter, and
    it even timestamps each entry, but it does not record the results Julia returns.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Another useful REPL mode is the help mode. Press **?**, and the prompt will
    change to `help?>`. Enter any Julia function, data type, operator, or library,
    and you will see a nicely formatted description of the item you entered, often
    with a useful collection of examples.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Later on you’ll learn how to document your own functions in a way that hooks
    into the REPL help system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The REPL also has a shell mode, activated by pressing `;`, that allows you
    to enter system shell commands from within the REPL session:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can use shell mode for simple commands. As the listing shows, we can interpolate
    Julia variables, but piping and redirection won’t work.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Another REPL mode you will use often is the package mode, activated by pressing
    `]`, which we’ll cover in [Chapter 3](ch03.xhtml) when we explore how to use packages
    and modules. For now, just be aware that the package system in Julia is an integral
    part of the language and environment, so much so that it’s built into the REPL.
    Julia developers don’t need to wrestle with several competing third-party package
    systems, nor with the inevitable “dependency hell” that afflicts some other languages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: To exit out of any of these modes back into the normal (sometimes called “Julian”)
    REPL mode, press BACKSPACE while the cursor is at the starting position.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: TAB works in any REPL mode to generate context-aware completions. If there is
    a unique completion, it is entered for you at the cursor; otherwise, the REPL
    presents you with a list of options.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**REPL Colors**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To help you to know which mode you’re in, the REPL colors each of its prompts
    differently. The colors help visually separate the prompts from the expressions
    you enter and their results. The REPL also uses colors in certain types of output,
    such as help output, to distinguish elements like keywords and variables from
    normal text. The default colors work well when using a terminal with a black or
    dark background, which is the most popular choice. However, they are too light
    to be easily legible on a white or very light background. I use such a background
    for the illustrations in this book, as it prints better than the black background
    I usually use on my computer. If you use a light terminal background, or simply
    prefer a different appearance from the default, you can edit a configuration file
    to change any of the REPL colors.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你了解自己处于哪种模式，REPL会为每个提示符使用不同的颜色。颜色有助于在视觉上区分提示符与你输入的表达式及其结果。REPL还会在某些类型的输出中使用颜色，例如帮助输出，用来区分关键词和变量等元素与普通文本。默认的颜色在使用黑色或深色背景的终端时效果良好，这是最流行的选择。然而，这些颜色在白色或非常浅的背景上容易看不清楚。在本书的插图中，我使用了这样的背景，因为它比我通常在电脑上使用的黑色背景打印效果更好。如果你使用浅色终端背景，或者仅仅希望外观与默认值不同，你可以编辑配置文件来更改任何REPL颜色。
- en: 'In your home directory, you will find a directory called *.julia* (note the
    dot: in most people’s shells, as they are typically configured, this directory
    will not be listed using the usual commands unless you add a flag to request listing
    of “invisible files,” and graphical file management tools may or may not show
    the directory by default). Within *.julia*, there may already be a *config* directory;
    if not, create one. Enter the *config* directory and edit the *startup.jl* file
    (or create it if it doesn’t exist). Add the following to *startup.jl*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的主目录中，你会找到一个名为*.julia*的目录（注意有一个点：在大多数人的shell配置中，除非你添加标志请求列出“隐藏文件”，否则使用常规命令时该目录通常不会列出，图形化文件管理工具可能会或可能不会默认显示该目录）。在*.julia*目录下，可能已经存在一个*config*目录；如果没有，请创建一个。进入*config*目录并编辑*startup.jl*文件（如果该文件不存在，则创建它）。将以下内容添加到*startup.jl*中：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You have just written your first Julia function. Julia runs the *startup.jl*
    file every time the REPL starts (the *.jl* extension is used for Julia programs).
    This function simply defines two variables: one for the color of the prompt in
    normal mode and the other for help mode. The two numbers in square brackets are
    ANSI color codes, which are understood by most modern terminal programs. I’ve
    chosen two colors that work well on my monitor when using a white terminal background.
    If you want to pick your own colors, you can find tables of the 256 ANSI colors
    and their codes by searching the web for “ANSI color codes.” I’ve redefined only
    these two colors because the other defaults happened to work well. If you want
    to change some other colors, you can define the `repl.shell_color`, `repl.input_color`,
    and `repl.answer_color` variables as well.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚写了你的第一个Julia函数。Julia每次启动REPL时都会运行*startup.jl*文件（*.jl*扩展名用于Julia程序）。这个函数简单地定义了两个变量：一个用于正常模式下提示符的颜色，另一个用于帮助模式下的颜色。方括号中的两个数字是ANSI颜色代码，现代大多数终端程序都能理解这些代码。我选择了两种在我的显示器上使用白色终端背景时效果良好的颜色。如果你想选择自己的颜色，可以通过在网上搜索“ANSI颜色代码”来找到256种ANSI颜色及其代码表。我只重新定义了这两种颜色，因为其他默认颜色恰好合适。如果你想改变其他颜色，你也可以定义`repl.shell_color`、`repl.input_color`和`repl.answer_color`变量。
- en: Julia also understands several color *names*, but too few to allow an ideal
    selection.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Julia还理解几种颜色*名称*，但数量太少，无法提供理想的选择。
- en: '**Unicode Characters**'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Unicode字符**'
- en: Julia allows the use of Unicode characters in variable names and for other identifiers.
    This means you can make formulas in your Julia programs look more like real math,
    using, for instance, Greek letters and subscripts. Some people have set up their
    systems to allow them to type such characters easily. Even if you haven’t, you
    can still use these characters thanks to a Unicode input mode provided by the
    REPL. If you enter a backslash (`\`) followed by a string of ASCII characters,
    then press TAB, one of three things will happen. If the REPL recognizes the string
    as one of its codes for a Unicode character, the entire entry, beginning with
    the backslash, will be replaced by that character. If the code you typed is the
    beginning of a character code or one of several possible codes, the tab completion
    mechanism will work in the normal way. If the REPL does not recognize what you
    typed, it will do nothing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: A complete list of the Unicode character codes recognized by the REPL is maintained
    at [*https://docs.julialang.org/en/v1/manual/unicode-input/*](https://docs.julialang.org/en/v1/manual/unicode-input/).
    Those familiar with LaTeX syntax will be happy to know that all the Greek letters
    and some other symbols that have LaTeX commands are on the list unchanged. For
    example, to input *α* in the REPL, type \alpha and then press TAB. There is much
    more—even a wide selection of emoji.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know the LaTeX-style abbreviation for a particular Unicode character,
    perhaps one that you’ve copied from the documentation, enter the help mode in
    the REPL, paste in the character, and press ENTER. If an abbreviation exists,
    the help system will tell you what it is.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](ch01.xhtml#ch1fig1) shows a simple example of what you can do
    with an expanded character set.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: Using Unicode in the REPL*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: This is more than just fun and games. The ability to employ a wider collection
    of characters, including Greek letters and subscripts, allows us to make our code
    more concise and expressive.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '****Text Editors****'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia programmers use text editors routinely, either in addition to or in coordination
    with the REPL. I’ll go over some of the relevant features of the most-used programmer’s
    editors here. If you use something else, be sure to search for any enhancements,
    either built-in or in the form of third-party plug-ins, specific to Julia. These
    enhancements typically include syntax highlighting, which helps immensely in avoiding
    typos in your code, and can include more sophisticated features, such as code
    formatting and execution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**Vim**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Vim is an excellent editor for programming in any language, and it has valuable
    Julia support. I recommend installing the `julia-vim` plug-in, available at [*https://github.com/JuliaEditorSupport/julia-vim*](https://github.com/JuliaEditorSupport/julia-vim),
    where you will also find its documentation. The plug-in requires Vim version 7.4
    or greater. To take the best advantage of `julia-vim`, ensure that the built-in
    `matchit` plug-in is enabled by executing the :runtime macros/matchit.vim Vim
    command, which should be in your Vim startup file. This plug-in adds a Julia file
    type with syntax coloring and awareness of the block structure of Julia syntax.
    It extends the `matchit` operation by allowing you to jump to the end or beginning
    of function definitions and other blocks by entering `%`. You can also select
    or delete blocks, or the bodies of blocks, in the same way that Vim allows you
    to operate on other text objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The plug-in also emulates the REPL’s LaTeX-style entry of Unicode characters.
    For this it provides two options: you can have it wait for you to press TAB, as
    the REPL does, or it can expand the entry on the fly as soon as it sees a character
    (usually a space) that seems to indicate the end of the entry (the on-the-fly
    mode does not support emoji, however).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Another option for recent versions of NeoVim or Vim is to install language support
    for tree-sitter, which adds syntax-aware highlighting and other features to the
    editor. If you have Vim version 8.0 or greater, which I highly recommend, or the
    NeoVim fork, you can interact with *any* REPL directly, including the Julia REPL.
    By “interact,” I mean that you can remain in an editing buffer containing your
    Julia program and send selected lines, expressions, or blocks directly to the
    REPL for execution. The execution is asynchronous, so you can continue editing
    while Julia is churning through a time-consuming command. Communication with the
    REPL is two-way, so you can also send results printed in the REPL back into the
    editing buffer. The following instructions apply to Vim, but NeoVim users should
    be able to adapt them to that program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: First, install the `vim-sendtowindow` plug-in, which lives at [*https://github.com/karoliskoncevicius/vim-sendtowindow*](https://github.com/karoliskoncevicius/vim-sendtowindow).
    After opening the editing buffer of choice, execute the :term julia Vim command.
    If you have the `julia` command set up properly (see [“Installation”](ch01.xhtml#ch01lev1)
    on [page 6](ch01.xhtml#ch01lev1)), a new Vim buffer should open with the Julia
    REPL running within it, below the editing window.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Now you can select any text in the editing window and press the spacebar followed
    by `j` to send it to the REPL. If you’d prefer some other shortcut for this operation,
    the `vim-sendtowindow` web page explains how to set it up. You can also define
    shortcuts for sending text to the right, left, and up, which is handy for sending
    text *from* the REPL and in case you prefer to split your windows vertically.
    The `:term` command, with its asynchronous execution of commands, is built into
    Vim. The plug-in provides a convenient way to send text back and forth between
    the editing and terminal buffers. The author of `vim-sendtowindow` maintains a
    list of plug-ins with similar functionality on its website.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Similar REPL interactions are possible with earlier versions of Vim, using plug-ins
    such as `ScreenSend`, but the `term` command in version 8 makes REPL interaction
    smoother and less error prone.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '**Emacs**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Emacs is a powerful programmer’s editor with sophisticated Julia support available.
    The official Julia major mode for Emacs, called `julia-emacs`, is developed on
    GitHub at [*https://github.com/JuliaEditorSupport/julia-emacs*](https://github.com/JuliaEditorSupport/julia-emacs).
    The creators of the Julia language are contributors to the project, which is probably
    one of the reasons that a deep and detailed knowledge of the language’s structure
    and syntax is built into the mode. Once installed, Emacs will display Julia code
    using a variety of colors and font styles to clarify its syntax. It also provides
    movement among and manipulation of code structures such as blocks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: To install `julia-emacs`, first enable the MELPA repository ([*https://melpa.org*](https://melpa.org))
    and add (require 'julia-mode) to your Emacs initialization file. For most people,
    this will be *.emacs* in their home directory. For a smooth experience, you should
    be running a version of Emacs that is at least 24.1\. If your version is earlier,
    an upgrade would be advisable for using Emacs and Julia together.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Emacs shines at interacting with REPL-based languages, and Julia is no exception.
    Several minor modes are available specifically for Julia interaction. One of the
    most popular is `julia-repl`, also developed on GitHub and available at [*https://github.com/tpapp/julia-repl*](https://github.com/tpapp/julia-repl).
    It’s designed to work with the aforementioned `julia-emacs`, and you must have
    at least version 25 of Emacs installed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `julia-repl`, edit your *.emacs* initialization file, adding the
    following lines:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now you can start a Julia REPL right from within Emacs. It will run in an ANSI
    terminal, with the full complement of text colors and formatting. A table of keyboard
    shortcuts is available on the mode’s GitHub page. You can perform the usual sending
    of fragments, whole blocks, or the entire buffer to the REPL for execution. In
    addition, the built-in knowledge of Julia allows the mode to do such things as
    listing all the methods of a function, which will make more sense after you read
    [Chapter 8](ch08.xhtml).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '***Jupyter Notebooks***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use Julia from within a web browser, in two main ways, in what is referred
    to as a *notebook* interface. The older way is the Jupyter Notebook. Jupyter popularized
    the notebook concept in the free software arena, and it’s widely used in the Julia,
    Python, and R communities. In fact, the word *Jupyter* is a mashup of the names
    of those three programming languages.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use or explore a notebook interface and do not have a particular
    reason to use Jupyter, proceed directly to the next section and learn about Pluto.
    Pluto offers the same style of notebook interactivity as Jupyter while improving
    on the concept. For those who need to use Jupyter to collaborate with others using
    the system, who want to use other languages (besides Julia) with the same notebook
    interface, or who desire to explore existing Jupyter Notebooks, this section is
    designed to get you started.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: If you already have Jupyter set up and working on your computer, you merely
    need to install the Julia backend. In the Julia REPL, press **]** to enter the
    package mode (see [page 11](ch01.xhtml#page_11)). Make sure you’re connected to
    the internet, and enter the add IJulia command to download and install the Julia
    backend for the notebook and the packages that it depends on. This is a fairly
    big install and will take some time, but the REPL will keep you informed with
    an animated display showing the progress of the downloads and the precompilation
    of modules. When the process is complete, enter jupyter notebook either at a separate
    system shell prompt or using the REPL shell mode to launch the notebook.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t already have Jupyter installed, after the installation described
    earlier is complete, enter the following lines in the Julia REPL:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Julia will ask if you want to install Jupyter using the `Conda` package. Answer
    in the affirmative. This next phase of installation should be quicker than the
    `IJulia` install, but may still take some time. When the software is ready, Julia
    will open a window or tab in your default browser with the starting Jupyter page.
    To start up Jupyter in future sessions, repeat these commands in a Julia REPL.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: When the Jupyter Notebook page opens, you’ll have a drop-down list of installed
    kernels, or language backends. Choose the Julia kernel, and a new tab or window
    will open. On that page, you can enter Julia expressions in “cells.” When you
    press CTRL-ENTER while the cursor is in a cell, Julia will evaluate the expression
    and print the result in an output cell underneath it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Because we are in a web browser, the system can take advantage of the ability
    to format text and display graphics. [Figure 1-2](ch01.xhtml#ch1fig2) shows a
    Jupyter Notebook after I’ve executed a few cells.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig02.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: Using Jupyter with Julia*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The last cell is a command to create a surface plot, which directly embeds the
    plot in the page.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to worry about saving your work with Jupyter, as it makes frequent
    autosaves, as indicated with the notice near the top of the page in [Figure 1-2](ch01.xhtml#ch1fig2).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Sharing your work is as simple as sending the on-disk form of the notebook to
    your colleagues. Everything is in one file, including the graphs and other images,
    which by default are encoded as SVG. Jupyter Notebook files have the *.ipynb*
    extension, and are stored in the directory where you started the REPL.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to use Jupyter extensively, consult the detailed documentation
    at [*https://jupyter.org*](https://jupyter.org) to learn more about all of its
    features.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '***Pluto: A Better Notebook***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pluto is a notebook interface to Julia that uses a web browser, similarly to
    Jupyter. Although it’s a young project, it’s already used routinely by a large
    community and has significant advantages over Jupyter. Its only shortcoming is
    that it is Julia-only, but this specialization allows Pluto to take better advantage
    of what Julia has to offer than frontends that support multiple kernels.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Pluto does not depend on anything aside from a modern web browser and Julia.
    To install it, press `]` to enter the package mode in the Julia REPL and execute
    the add Pluto command. After everything downloads and installs, press BACKSPACE
    to exit the package mode, and execute this code in the REPL:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A new window or tab will open in your default web browser with the Pluto welcome
    page, which looks like [Figure 1-3](ch01.xhtml#ch1fig3).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: The Pluto welcome page*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Here you’ll see links for opening a fresh notebook, continuing work on an existing
    one, or examining sample notebooks. The sample notebooks cover a variety of subjects
    and are well done and instructive.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: A Pluto notebook is a web page where you can enter Julia expressions in “cells.”
    Pressing CTRL-ENTER while the cursor is in a cell will cause Julia to execute
    the code in that cell as well as all the cells that depend on it. If, for example,
    you define, or redefine, a variable in a cell and execute it, and you have a second
    cell that uses that variable, Pluto will execute that second cell after the first
    one is done. If a third cell depends on the result from the second cell, Pluto
    will execute that one next, and so on. After each cell is run, its result is displayed
    *above* the input cell. You can watch the progress of execution passing from cell
    to cell by observing the animated progress bars on their left borders.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Pluto determines the order of execution by calculating a *dependency graph*
    for all the cells on the page. Using the dependency graph means that the results
    shown on the page are independent of the visual order in which they are arranged,
    and of the order in which you decide to execute cells. What you see is completely
    determined by the code in the cells, so you can share your notebooks with collaborators
    and everyone will see the same, consistent notebook. This is the major advance
    over other notebooks, such as Jupyter, where the results displayed on the page
    are the consequence of the order in which the cells were run and may even depend
    on cells that have been deleted.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Pluto’s behavior is, in some ways, similar to a spreadsheet, and offers the
    same live, reactive experience. Even die-hard terminal users such as myself enjoy
    using Pluto for certain kinds of exploratory computation. Its ability to embed
    graphics and, as we’ll see in later chapters, incorporate graphical controls such
    as sliders and color pickers creates a rich environment for experimenting with
    code and data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-4](ch01.xhtml#ch1fig4) shows a Pluto page with a simple matrix calculation.
    I created it by clicking the link to start a new notebook in the welcome page.
    Pluto opened a new tab and the browser switched to it, and I entered expressions
    in three cells and pressed CTRL-ENTER to evaluate them.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig04.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: Matrix calculations in the Pluto notebook*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-4](ch01.xhtml#ch1fig4) shows the main elements of the Pluto interface.
    At the top is the path of the notebook file. Until you type this in, a message
    in that space will invite you to do so. To the right of that is a save button,
    but you only need to use it if you change the location of the file and want to
    save immediately. Every time you execute a cell, Pluto saves your work automatically.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In the first two code cells I’ve defined two small matrices, `m` and `n`, and
    in the third cell, I asked for their matrix product. (This is a preview of the
    array operations that we’ll explore in [Chapter 2](ch02.xhtml).) Keep in mind
    that in Pluto, the results are printed above the input cells.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: So far, we could have done this the same way in the REPL. The difference here
    is that if we change any of the numbers in `m` or `n` and run the cell with its
    new definition, the matrix product is instantly recalculated and the revised result
    replaces the old one without any further action by the user. In the REPL, we would
    have to type `m * n` again, and the new result would be printed below that, possibly
    scrolling other information off the screen.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In Pluto, because the results displayed are independent of the order in which
    they appear on the page, we can rearrange the cells to provide a good exposition,
    without worrying about affecting the calculations. We can combine Julia expressions
    with text formatted using Markdown or HTML, and turn our notebook into an article
    or a live explanatory text.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In the final cell, I’ve entered a question mark (`?`) followed by the name of
    a data type, `Matrix`. As soon as you enter the question mark and begin typing,
    a live help window opens, displaying documentation about what you’ve typed so
    far. As you add letters, the documentation changes to reflect what you’ve typed,
    and you can stop when you see what you want.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The help window stays there, displaying documentation about whatever you type
    into any cell, whether or not you ask for help. If it becomes distracting, click
    the little down arrow to tuck the window away. Because of Pluto’s close integration
    with Julia, it has other conveniences, such as tab completion, that work the same
    way as in the REPL.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The text file that backs the notebook page, stored at the location you entered
    at the top, is a normal Julia module file. You can import it into other Julia
    programs, edit it directly, and put it into version control. You are not locked
    into the Pluto notebook, but can use the code you develop there in other Julia
    projects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Pluto is a new and innovative way to develop programs and carry out exploratory
    computation that is fun to use. Even if you turn to it only now and then, you
    should install it and become familiar with the interface. Follow Pluto developments
    and find more documentation at [*https://github.com/fonsp/Pluto.jl*](https://github.com/fonsp/Pluto.jl).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '***Integrated Development Environments***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both Vim and Emacs can serve as capable IDEs for Julia by installing the plug-ins
    described in their respective sections earlier. Traditional IDEs don’t afford
    as much of a critical advantage for languages like Julia as they might for more
    verbose and ceremony-laden languages such as Java or C++, where many developers
    consider them essential. A text editor is all you need for writing Julia programs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: However, some users prefer a “real” IDE or may already be accustomed to one.
    The Julia IDE situation is in flux at the moment of writing. An IDE called Juno,
    consisting of a plug-in for the Atom editor, was essentially the official IDE
    for Julia, but work on it has ceased. As the language moves forward, Juno will
    not keep up. IDE development for Julia has shifted to a plug-in for VS Code, a
    popular IDE from Microsoft.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: You can download VS Code from its GitHub repository at [*https://github.com/microsoft/vscode*](https://github.com/microsoft/vscode)
    and compile for your system. A quicker route for Linux, macOS, or Windows is to
    download the appropriate package file from [*https://code.visualstudio.com/Download*](https://code.visualstudio.com/Download)
    and follow your system’s normal install procedure. Microsoft also offers branded
    versions as binary downloads. These may contain small enhancements, and are released
    under a Microsoft product license.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: After installing the base VS Code program, you will install the Julia plug-in,
    which you can do from within the IDE. [Figure 1-5](ch01.xhtml#ch1fig5) illustrates
    how to do this.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig05.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: Installing the Julia plug-in within VS Code*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The screenshot shows the left-hand area of the VS Code window, with the extension
    icon selected. I’ve entered “Julia” into the extension search box at the top,
    and the program is displaying a list of publicly available extensions that match.
    When you perform this search, the list will likely look different, but you want
    the extension titled simply “Julia,” which, in this case, is at the top of the
    list. Click the blue **Install** button to download and install the plug-in.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Quit VS Code and restart it after installing the plug-in. If you have set your
    path properly, as described in “Installation” on 6, press CTRL-SHIFT-P (CMD-SHIFT-P
    on macOS) to open a command window and execute the Julia: Start REPL command.
    A Julia REPL should open in a pane at the bottom of the window. It behaves just
    like the normal REPL described on [page 10](ch01.xhtml#ch01lev1sec6), with all
    REPL modes available, and using your color and other customizations.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In addition to typing directly in the REPL, you can open an existing or new
    file for editing. Julia code is syntax colored, and there are syntax-aware commands
    for moving through the code and manipulating its structures. The documentation
    at [*https://www.julia-vscode.org/docs/stable/*](https://www.julia-vscode.org/docs/stable/)
    consists largely of blank pages at the time of writing, but I expect this situation
    to be improved soon. Open the command window and type `Julia:` to discover Julia-specific
    commands and then scroll through the list. If you see a command you’ll be using
    often, this list contains buttons next to each command that allow you to define
    keyboard shortcuts.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: I recommend defining a shortcut for the “Send Current Line or Selection to REPL”
    command. This allows you to send any expression or statement directly from the
    editor to the REPL for execution.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: If you execute a plot command in the REPL, the plot appears in its own dedicated
    pane within the VS Code window. [Figure 1-6](ch01.xhtml#ch1fig6) shows the main
    part of the window as it appears on my laptop, with the light background selected
    from among VS Code’s three appearance options.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch01fig06.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-6: Using the Julia plug-in in VS Code*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In the top pane, I’m editing a file with a few lines of Julia code, which I’ve
    sent directly to the REPL in the bottom pane. Although you may not understand
    all the language syntax yet, you may be able to form an idea of what the expressions
    are intended to return. After trying some arithmetic to see if the setup is working,
    I define a range of numbers, assigned to the `x` variable, and then plot a function
    applied to each value in the list. At the top right, the plot window has appeared.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Recommendations**'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the choice of tools is a matter of personal preference, I’ve tried to provide
    enough information about all the main ways of interacting with Julia and editing
    Julia programs to allow you to choose the methods that most appeal to you. If
    you are already in the habit of using Vim, Emacs, or any other tool for programming,
    you don’t need to learn anything new or change your workflows to use Julia. Use
    what you are familiar with, as Julia can easily adapt to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you’re not yet committed to any specific tooling, I have a recommendation.
    I suggest that you install Vim, along with the Julia-specific plug-ins described
    in “Text Editors” on [page 14](ch01.xhtml#ch01lev1sec7). Vim takes some getting
    used to, but the long-term rewards are worthwhile, as it is an efficient and flexible
    editor, and it makes working alongside the REPL easy.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: If Vim is new to you, to ease the burden of learning both a new language and
    an unfamiliar editor simultaneously, consider working through Pluto, as well as
    in the REPL directly, while you take your time to become comfortable with a new
    editor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that this reflects my personal preferences, and you may prefer a different
    environment. For example, if you find working in a browser-based notebook appealing,
    there is no reason you can’t do all of your Julia work within Pluto. My only negative
    recommendation is not to stick with a primitive editor that has no REPL or language
    support, as doing so will hold you back in the long run.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: My article “The Scientist’s Linux Toolbox” in *Linux Pro Magazine* ([*https://www.linuxpromagazine.com/Issues/2020/241/Scientist-s-Toolbox*](https://www.linuxpromagazine.com/Issues/2020/241/Scientist-s-Toolbox))
    provides more information about Julia and other software useful to scientists
    computing on Linux.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In “An Introduction to Pluto” ([*https://lwn.net/Articles/835930/*](https://lwn.net/Articles/835930/)),
    I describe the development of the Pluto notebook, give some examples of its use,
    and contrast it with the popular Jupyter Notebook interface.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A useful ANSI color code table is available at [*https://misc.flogisoft.com/_media/bash/colors_format/256_colors_bg.png*](https://misc.flogisoft.com/_media/bash/colors_format/256_colors_bg.png).
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to [*https://gitforwindows.org*](https://gitforwindows.org) for a Windows
    solution that provides Git, a terminal program, and some more conveniences.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
