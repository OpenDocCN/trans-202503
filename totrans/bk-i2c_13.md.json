["```\nvoid MultiChannel_I2CInit\n(\n    int     moduleNum = DEFAULT_I2C_MODULE,\n    uint8_t slave_Addr = 0x08,\n    uint8_t freqdiv = 0x3C \n);\n\nuint8_t MultiChannel_I2CSendBuf\n(\n int      moduleNum,\n    uint8_t  addr,\n    puint8_t buf,\n    int      num,\n    bool     stop = true \n);\n```", "````The NetBurner library provides a fair number of other functions you can use to manipulate the I²C bus. For more detail, see the NetBurner documentation linked in “For More Information.”    The program in [Listing 10-1](#listing10-1) is the usual triangle wave DAC output sample program. Other than a few µC/OS peculiarities (outside the scope of this book), this program is equivalent to the demonstration program from other chapters.    ``` // Listing 10-1 (main.cpp)  //  // DAC output example for µC/OS.    #include \"predef.h\"  #include <stdio.h>  #include <startnet.h>  #include <autoupdate.h>  #include <multichanneli2c.h>    #define ever ;;    #define I2C_CHANNEL 0      // Going to use I2C0 on NetBurner  #define mcp4725     0x60   // DAC I2C address  extern \"C\"   {      void UserMain( void * pd );  }    // DACout-  //  // Draws one cycle of a triangle waveform on  // the MCP4725 I2C DAC device (for example,   // Adafruit MCP4725 breakout board).  //  // Argument: I2C address for the DAC. For  // Adafruit MCP4725 breakout boards, this  // is either 0x62 or 0x63\\. For SparkFun  // boards, this is either 0x60 or 0x61.    void DACout( int adrs )  {      uint8_t buf[2];            // Send the rising edge of a triangle wave:        for( uint16_t dacOut = 0; dacOut < 0xfff; ++dacOut )      {          // Note: MCP4725 requires that you write          // the HO byte first and the LO byte second!                    buf[0] = (dacOut << 8) & 0xff;          buf[1] = dacOut & 0xff;                    // Transmit the data from the buffer:                  ❶ MultiChannel_I2CSendBuf          (              I2C_CHANNEL,              adrs,      // Device address              buf,       // Data to write              2,         // 2 bytes to write              true       // Send stop condition          );      }        // Send the falling edge of the triangle wave.        for( uint16_t dacOut = 0xffe; dacOut > 0; --dacOut )      {          // HO then LO byte:                    buf[0] = (dacOut << 8) & 0xff;          buf[1] = dacOut & 0xff;          MultiChannel_I2CSendBuf          (              I2C_CHANNEL,              adrs,       // Device address              buf,        // Data to write              2,          // 2 bytes to write              true        // Send stop condition          );      }  }    void UserMain( void * pd )   {       int cntr = 0;        // Standard NetBurner initialization stuff:            InitializeStack();      EnableAutoUpdate(); // Allow Ethernet update of code        // Initialize I2C0 on the NetBurner MOD54415:      ❷ MultiChannel_I2CInit( I2C_CHANNEL );      for( ever )       {          // Print status information to the serial console          // every now and then to show that something is          // happening:                            iprintf( \"main loop, cntr=%d\\n\", cntr++ );                    // Draw one cycle of the triangle waveform          // on the DAC:                            DACout( mcp4725 ); // MCP4725 output                } // endfor  } // UserMain ```    The `MultiChannel_I2CInit()` ❷ and `MultiChannel_I2CSendBuf()`❶ functions are the µC/OS I²C initialization and I²C output routines.    [Figure 10-1](#figure10-1) shows the oscilloscope output from the program in [Listing 10-1](#listing10-1). Note that the frequency is much closer to the Arduino example (see Figure 8-2 in Chapter 8) than the Raspberry Pi example (see Figure 9-3 in Chapter 9). The slower frequency in the Pi example is, undoubtedly, due to all the extra work happening under the multitasking Pi OS (Linux).  ![](image_fi/502468c10/f10001.png)    Figure 10-1: Oscilloscope output from [Listing 10-1](#listing10-1)      Since µC/OS supports multitasking, you might wonder, why not write some code to generate two separate triangle waves concurrently? Of course, two tasks cannot access the same I²C device concurrently, but you might reason that you could fix that issue by putting two different DACs on the I²C bus. One task could write to the first DAC, and the second task could write to the second DAC.    Unfortunately, under a pure priority-based system such as µC/OS, this won’t work out well. The higher-priority task always runs, and the lower-priority task never gets a chance to execute (unless you put in code to explicitly suspend the higher-priority task).    [Listing 10-2](#listing10-2) provides the source code to the version of the code that demonstrates one way to do this.    ``` // Listing 10-2 (main.cpp)  //  // Multi-threaded I2C demonstration #2.  // This program writes to two separate  // MCP4725 devices on the same I2C bus  // using separate threads for each of the  // DACs, with a semaphore to protect  // writes to the I2C port.     #include \"predef.h\"  #include <stdio.h>  #include <startnet.h>  #include <autoupdate.h>  #include <pins.h>  #include <multichanneli2c.h>    #define ever ;;    #define I2C_CHANNEL0 0          // Going to use I2C0     #define dac1 0x62               // MCP4725 #1 address  #define dac2 0x63               // MCP4725 #2 address    extern \"C\"   {      void UserMain(void * pd);  }    // Stack for DACthread:    #define DACthread_STK_SIZE (4096)  static  DWORD   DACthread_stack[ DACthread_STK_SIZE ]                           __attribute__((aligned(4)));    // Critical section protecting console I/O:    OS_CRIT ioCS;    ❶ OS_SEM  threadSem;  OS_SEM  mainSem;    // DACout-  //  // Draws one cycle of a triangle waveform on  // the MCP4725 I2C DAC device (e.g., Adafruit  // MCP4725 breakout board).  //  // Argument: I2C address for the DAC. For  // Adafruit MCP4725 breakout boards, this  // is either 0x62 or 0x63\\. For SparkFun  // boards, this is either 0x60 or 0x61.    void DACout( int adrs, OS_SEM *enter, OS_SEM *leave )  {      uint8_t buf[2];            // Send the rising edge of a triangle wave:        for( uint16_t dacOut = 0; dacOut < 0xfff; ++dacOut )      {          // Note: MCP4725 requires that you write          // the HO byte first and the LO byte second!                    buf[0] = (dacOut << 8) & 0xff;          buf[1] = dacOut & 0xff;                    // Transmit the data from the buffer:                  ❷ OSSemPend( enter, 0 );  // Protect call              ❸ MultiChannel_I2CSendBuf              (                  I2C_CHANNEL0,                  adrs,           // Device address                  buf,            // Data to write                  2,              // 2 bytes to write                  true            // Send stop condition              );                    ❹ OSSemPost( leave );     // Enable other thread      }        // Send the falling edge of the triangle wave.        for( uint16_t dacOut = 0xffe; dacOut > 0; --dacOut )      {          // HO then LO byte:                    buf[0] = (dacOut << 8) & 0xff;          buf[1] = dacOut & 0xff;          OSSemPend( enter, 0 );   // Protect call                MultiChannel_I2CSendBuf   (                  I2C_CHANNEL0,                  adrs,           // Device address                  buf,            // Data to write                  2,              // 2 bytes to write                  true            // Send stop condition              );                        OSSemPost( leave );     // Enable other thread      }  }    void DACthread( void *parm )  {      int cntr = 0;            for( ever )       {          // Print a message each time the thread          // completes one cycle of the triangle          // wave. Note that iprintf must be          // protected by a critical section.                    OSCritEnter( &ioCS, 0 );                             iprintf( \"thread loop, cntr=%d\\n\", cntr++ );                        OSCritLeave( &ioCS );                    // Draw one cycle of the triangle waveform          // on the DAC at address 0x63:            DACout( dac2, &threadSem, &mainSem );                         } // endfor  }    void UserMain( void * pd )   {       int cntr = 0;        // Standard NetBurner initialization stuff:            InitializeStack();      EnableAutoUpdate(); // Allow Ethernet update of code        // Initialize the critical sections used to protect       // console I/O and the I2C output.            OSCritInit( &ioCS );      OSSemInit( &threadSem, 1 );      OSSemInit( &mainSem, 0 );     // Initialize I2C0 pins on the NetBurner MOD54415:            MultiChannel_I2CInit( I2C_CHANNEL0 );            // Start a thread running that will write to the      // DAC at address 0x63\\. Give the thread a higher      // priority than that of the main thread.      //      // The parameters are the following:      //      //  1\\. Address of function to invoke as the      //     new thread (\"task\" in NBRTOS terminology).      //      //  2\\. Parameter to pass to the thread.        //      //  3\\. Address of the first byte beyond the      //     stack space allocated for the thread.      //      //  4\\. Address of the start of the task.      //      //  5\\. Thread priority (lower number is      //     higher priority).          ❺ OSTaskCreate      (          DACthread,           NULL,          (void*)&DACthread_stack[DACthread_STK_SIZE],          (void *)DACthread_stack,           MAIN_PRIO + 1      );            for( ever )       {          // Print a message each time the main thread          // completes one cycle of the triangle          // wave. Note that iprintf must be          // protected by a critical section.                       OSCritEnter( &ioCS, 0 );                             iprintf( \"main loop, cntr=%d\\n\", cntr++ );                        OSCritLeave( &ioCS );                    // Draw one cycle of the triangle waveform          // on the DAC at address 0x62:                            DACout( dac1, &mainSem, &threadSem );      } // endfor  } // UserMain ```    Unfortunately, you cannot use µC/OS critical section variables (`OS_CRIT`) to protect access to the I²C bus. As noted earlier, because µC/OS is strictly a priority-based system, the lower-priority thread will not get a chance to run unless some system call explicitly blocks the main thread. To overcome this problem, the code in [Listing 10-2](#listing10-2) uses semaphores.    Semaphores are similar to critical sections insofar as you can use them to protect a section of code. They differ from critical sections in that they have a counter associated with them. When you enter a critical section (a µC/OS `OSSemPend()` call), the system first checks to see if this counter is 0\\. If so, the code blocks; if not, the code decrements the counter and enters the critical section. Note that if you initialize a semaphore with 1, it behaves like a critical section variable.    µC/OS semaphores use three main functions: `OSSemInit()`, `OSSemPend()`, and `OSSemPost()`. In addition to initializing internal data structures, the `OSSemInit()` function allows you to initialize the counter with the integer; for managing critical sections, the initial value is usually 0 or 1\\. As already noted, the `OSSemPend()` function checks the counter for 0 (and blocks if 0) and decrements the counter if it is nonzero, as well as allowing entry into the critical section. `OSSemPost()` increments the counter associated with the semaphore. This means you would normally use `OSSemPend()` to enter a critical section and `OSSemPost()` to leave a critical section.    The trick in [Listing 10-2](#listing10-2) is to use two semaphores, `mainSem` and `threadSem`, to protect access to the DACs by multiple tasks ❶. Whenever one of these semaphores contains 1, the associated task can execute; when the semaphore is 0, the task will block. The trick is to make sure that the two threads alternate setting the semaphores to 0 or 1 to allow execution to “ping-pong” between the two tasks.    If you look at the `DACout()` function in [Listing 10-2](#listing10-2), you’ll see that a task enters its critical section by executing `OSSemPend()` on the semaphore associated with that task ❷. To exit the critical section, the code executes the `OSSemPost()` function on the semaphore associated with the other thread ❹. This might seem incorrect, but let’s consider this sequence step-by-step:    1.  Assume the `mainSem` (enter parameter) counter is 1 and the `threadSem` (leave parameter) is 0. 2.  Upon executing `OSSemPend( enter, 0 );`, the system decrements the counter to 0 and enters the critical section (because the counter wasn’t already 0). Note that because the `UserMain()` task has a higher priority than the `DACthread()` task, the `UserMain()` task continues execution (and the `DACthread()` task is currently blocked). 3.  The `UserMain()` task writes data to the I²C bus ❸. 4.  The `UserMain()` task executes `OSSemPend()` on the `threadSem` semaphore (`leave` parameter) ❹. This increments the counter associated with `threadSem`; note that the `mainSem` counter is still 0. 5.  The `UserMain()` task continues execution, which in this case means repeating the loop and re-executing the `OSSemPend()` function at ❸. Because the counter is now 0, the task blocks. 6.  Once `UserMain()` blocks, the `DACthread()` task begins execution and eventually winds up in `DACout()` executing the `OSSemPend()` call. Because the `OSSemPost( leave );` call in the `UserMain()` task incremented the `threadSem` counter, the counter now contains 1 so the `DACthread()` task can enter its critical section. 7.  The `DACthread()` task calls `DACout()` to write a value to the DAC. 8.  The `DACthread()` task exits its critical section by calling `OSSemPost()` but passing the `mainSem` semaphore variable. This increments the `mainSem` counter; note that the `threadSem` counter is still 0. 9.  Because the `UserMain()` thread has the highest priority, it immediately takes over, and this process repeats itself.    Note that both tasks in [Listing 10-2](#listing10-2) call the `DACout()` function to actually write the data to the DAC (the DAC address and the two semaphores are passed as arguments). The calls to `DACout()` swap the two semaphore arguments so that `UserMain()` passes `mainSem` as the first semaphore argument, whereas `DACthread()` passes `threadSem` as the first semaphore argument.    [Figure 10-2](#figure10-2) shows the oscilloscope output for the program in [Listing 10-2](#listing10-2).  ![](image_fi/502468c10/f10002.png)    Figure 10-2: Oscilloscope output from [Listing 10-2](#listing10-2)      As you can see, both tasks are producing proper triangle waves. The frequency of the triangle waves in [Figure 10-2](#figure10-2) is about half that of [Figure 10-1](#figure10-1) (note the time scale for the oscilloscope in the two figures). The reason for this discrepancy is that the frequency is completely determined by the speed at which the program transmits data to the MCP4725\\. In [Listing 10-2](#listing10-2), twice as much data is transmitted by sending roughly the same data to both MCP4725 devices, so the frequency is cut roughly in half.    ### 10.2.2 FreeRTOS I²C Programming    FreeRTOS is, in its developer’s words, “the market leading, de facto standard, and cross platform RTOS kernel.” You’ll likely encounter this popular open source kernel if you work with many different RTOSs.    To use FreeRTOS, you’ll need a port of the OS to your particular device (or you’ll have to port it yourself). In this chapter I’m going to use the Teensy 4.0 port created by Julian Desvignes running under the PlatformIO IDE ([https://platformio.org/lib/show/6737/FreeRTOS-Teensy4](https://platformio.org/lib/show/6737/FreeRTOS-Teensy4)). The PlatformIO, FreeRTOS, and Teensy4 port uses the Arduino library and Teensyduino support to run FreeRTOS code in an Arduino environment. This makes it possible to create multithreaded applications while using Arduino-style programming.    Because FreeRTOS is just a scheduler that provides basic task switching functionality along with synchronization primitives, you’ll have to provide your own I²C library code. Fortunately, such code is easy to find from the Arduino libraries and elsewhere. However, the Arduino libraries are not reentrant, so you have to ensure that only one task is calling a particular library function (or family of functions) using mutexes, critical sections, semaphores, or other synchronization operations. See [https://www.freertos.org/a00113.xhtml](https://www.freertos.org/a00113.xhtml) for more details on FreeRTOS synchronization primitives.    [Listing 10-3](#listing10-3) presents the usual triangle wave output demo under FreeRTOS that creates two tasks; one of the tasks will blink the Teensy’s LED, and the other will output the triangle wave data to the MCP4725 DAC device:    ``` // Listing 10-3 (main.cpp)  //   // Simple demonstration of I2C programming  // under FreeRTOS running on a Teensy 4.0.    #include <FreeRTOS_TEENSY4.h>  #include <Wire.h>    #define ever ;;    // The LED is attached to pin 13 on the Teensy 4.0.    const uint8_t LED_PIN = 13;    // Thread1-  //  // This task blinks the Teensy 4.0's LED  // every second (1/2 second on, 1/2 second off).    static void Thread1( void* arg )  {      for( ever )      {            // Turn LED on:     digitalWrite( LED_PIN, HIGH );            // Delay 1/2 second:            vTaskDelay( (500 * configTICK_RATE_HZ) / 1000 );            // Turn LED off:            digitalWrite( LED_PIN, LOW );            // Delay 1/2 second:            vTaskDelay( (500 * configTICK_RATE_HZ) / 1000 );      }  }    // Thread2-  //  // This task outputs a triangle wave  // to the MCP4725 device at address 0x62  // (i.e., an Adafruit MCP4725 breakout board).    static void Thread2( void* arg )  {    for( ever )      {          for( uint16_t dacOut = 0; dacOut < 0xfff; ++dacOut )          {              // Transmit the address byte (and a zero R/W bit):                Wire.beginTransmission( 0x62 );                // Transmit the 12-bit DAC value (HO 4 bits first,              // LO 8 bits second) along with a 4-bit              // \"fast write\" command (0000 in the HO 4 bits              // of the first byte):                Wire.write( (dacOut << 8) & 0xf );              Wire.write( dacOut & 0xff );                // Send the stop condition onto the I2C bus:                Wire.endTransmission( true );          }   // for            // Send the falling edge of the triangle wave:            for( uint16_t dacOut = 0xffe; dacOut > 0; --dacOut )          {              // See comments in previous loop.                Wire.beginTransmission( 0x62 );              Wire.write( (dacOut << 8) & 0xf );              Wire.write( dacOut & 0xff );   Wire.endTransmission( true );          }   // for      }       // forever  } // Thread2    // In FreeRTOS for the Teensy 4.0, the  // Arduino \"setup\" function is really the  // equivalent of the main program.    void setup()  {      portBASE_TYPE s1, s2;        pinMode( LED_PIN, OUTPUT ); // LED is output      Wire.begin();               // Initialize I2C library        // Create task at priority two      // Arguments:      //      //  1\\.  Address of function to serve as task code.      //  2\\.  A descriptive name for the task (can be NULL).      //  3\\.  Stack depth for the task.      //  4\\.  Parameter to pass to task.      //  5\\.  Task priority.      //  6\\.  Task handle returned here (ignored if NULL).        s1 =    xTaskCreate              (                  Thread1,                  NULL,                  configMINIMAL_STACK_SIZE,                  NULL,                  2,                  NULL              );        // Create task at priority one      // (see comments above concerning parms).        s2 =    xTaskCreate              (                  Thread2,                  NULL,                  configMINIMAL_STACK_SIZE,                  NULL,                  1,                  NULL              );        if ( s1 == pdPASS && s2 == pdPASS )   {            // Start scheduler:            vTaskStartScheduler();      }        // Drop down here if there was      // insufficient RAM to create      // the tasks or if there was      // any other problem in their      // creation.        for( ever );  }    // WARNING: idle loop has a very small stack  // (configMINIMAL_STACK_SIZE), so  // loop must never block.    void loop()  {      // Not used.  } ```    The actual I²C code was taken straight out of Listing 8-1 (Arduino code), which is not reentrant code. The key thing to note is that the tasks do not call common library code. `Thread1()` calls only the Arduino `digitalWrite()` function, and `Thread2()` calls only the `Wire` class functions. Had this example tried to write to I²C devices from two separate tasks (even devices on separate I²C buses), it would have required mutexes to ensure that only one task at a time could actually execute those function calls. Here’s an example:    ``` SemaphoreHandle_t xSemaphore = NULL;      .      .      .  xSemaphore = xSemaphoreCreateMutex();      .      .      .  if( xSemaphoreTake( xSemaphore, portMAX_DELAY ) == pdTRUE )  {            // Own the critical section.         .         .  // In critical section, access I2C device here.         .     xSemaphoreGive( xSemaphore );  }  ```    [Figure 10-3](#figure10-3) shows the oscilloscope output from the program in the FreeRTOS demonstration program.  ![](image_fi/502468c10/f10003.png)    Figure 10-3: Oscilloscope output from [Listing 10-3](#listing10-3)      Because this program is writing only one stream of data to the MCP4725, the frequency is back up to about 0.5 Hz (again, this is limited by the 100-kHz data transmission speed).    ### 10.2.3 Teensy Threads I²C Programming    There are thread scheduling packages written for many low-end SBCs that you can grab off the Internet and use in simple applications. In this section, I’ll demonstrate how to use one such package: the Teensy Threading Library, created by Fernando Trias. This section also uses the Teensy 4.0 I²C library by Richard Gemmell. (See “For More Information” for the links.) It supports the Teensy 3.*x* and 4.*x* CPU modules from PJRC and it has the ability to create multiple threads—up to eight, by default, though this can be changed—along with some simple synchronization primitives and various thread utilities. Because the Teensy Threads package uses the term *threads*, I will use that specific term in this section rather than *tasks*.    The Teensy Threading Library is an Arduino library that assumes code is being developed in the Arduino programming model; as such, when you work with Teensy Threads, use the standard Arduino (or Teensy-specific) I²C programming libraries to communicate with I²C devices. Remember that Arduino code is not reentrant and must be protected when called from various threads. The example in this section will avoid calling the same function in different threads so that synchronization is not required.    The program in [Listing 10-4](#listing10-4) demonstrates multithreading using the Teensy Threading Library. It creates three additional threads (plus the main thread that continues execution). One thread blinks the LED every second, two threads transmit triangle waves to MCP 4725 DAC devices (on separate I²C buses), and the main thread writes “loop” to the serial output every two seconds.    ``` // Listing 10-4 (Listing10-4.ino)  //  // Simple demonstration of I2C programming  // using Teensy Threads running on a Teensy 4.0.    #include <TeensyThreads.h>  #include <i2c_driver_wire.h>    #define ever ;;    #define dac1 0x62  #define dac2 0x60    // The LED is attached to pin 13 on the Teensy 4.0.    const uint8_t LED_PIN = 13;    // Thread1-  //  // This thread blinks the Teensy 4.0's LED  // every second (1/2 second on, 1/2 second off).    ❶ static void Thread1( int arg )  {      for( ever )      {            // Turn LED on:            digitalWrite( LED_PIN, HIGH );            // Delay 1/2 second:            delay( 500 );            // Turn LED off:            digitalWrite( LED_PIN, LOW );            // Delay 1/2 second:            delay( 500 );      }  }    // Thread2-  //  // This thread outputs a triangle wave  // to the MCP4725 device at address 0x62 on  // I2C bus zero (SDA0/SCL0 on Teensy 4.0)  // (i.e., an Adafruit MCP4725 breakout board).    ❷ static void Thread2( int arg )  {      for( ever )      {          for( uint16_t dacOut = 0; dacOut < 0xfff; ++dacOut )          {              // Transmit the adrs byte (and a 0 R/W bit):                Wire.beginTransmission( dac1 );                // Transmit the 12-bit value (HO 4 bits first,              // LO 8 bits second) along with a 4-bit              // \"fast write\" command (0000 in the HO 4 bits              // of the first byte):                Wire.write( (dacOut << 8) & 0xf );              Wire.write( dacOut & 0xff );                // Send the stop condition onto the I2C bus:                Wire.endTransmission( true );          }   // for            // Send the falling edge of the triangle wave:            for( uint16_t dacOut = 0xffe; dacOut > 0; --dacOut )          {              // See comments in previous loop.                Wire.beginTransmission( dac1 );              Wire.write( (dacOut << 8) & 0xf );              Wire.write( dacOut & 0xff );              Wire.endTransmission( true );          }   // for      }       // forever  } // Thread2    // Thread3-  //  // This thread outputs a triangle wave  // to the MCP4725 device at address dac2 on  // I2C bus one (SDA1/SCL1 on Teensy 4.0)  // (i.e., an Adafruit MCP4725 breakout board).    ❸ static void Thread3( int arg )  {      for( ever )      {          for( uint16_t dacOut = 0; dacOut < 0xfff; ++dacOut )          {              // Transmit the adrs byte (and a 0 R/W bit):                Wire1.beginTransmission( dac2 );                // Transmit the 12-bit DAC value (HO 4 bits               // first, LO 8 bits second) along with a    // 4-bit \"fast write\" command (0000 in the HO               // 4 bits of the first byte):                Wire1.write( (dacOut << 8) & 0xf );              Wire1.write( dacOut & 0xff );                // Send the stop condition onto the I2C bus:                Wire1.endTransmission( true );          }   // for            // Send the falling edge of the triangle wave:            for( uint16_t dacOut = 0xffe; dacOut > 0; --dacOut )          {              // See comments in previous loop.                Wire1.beginTransmission( dac2 );              Wire1.write( (dacOut << 8) & 0xf );              Wire1.write( dacOut & 0xff );              Wire1.endTransmission( true );          }   // for      }       // forever  } // Thread3    // In TeensyThreads for the Teensy 4.0, the  // Arduino \"setup\" function is really the  // equivalent of the main program.    void setup()  {        Serial.begin( 9600 );      pinMode( LED_PIN, OUTPUT ); // LED is output      Wire.begin();               // Initialize I2C port 0      Wire1.begin();              // Initialize I2C port 1        // Create thread      // Arguments:      //      //  1\\.  Address of function to serve as thread code.      //  2\\.  Optional argument passed to thread function.      //  3\\.  Stack size (default is 1024).      //  4\\.  Stack address (default is on heap).      ❹ int id1 = threads.addThread( Thread1,  0 );      if ( id1 == -1 )      {            Serial.println( \"Thread 1 creation failed\" );          for( ever );      }        // Create task at priority one      // (see comments above concerning parms).   ❺ int id2 = threads.addThread( Thread2, 0 );      if ( id2 == -1 )      {            Serial.println( \"Thread 2 creation failed\" );          for( ever );      }        // Create task at priority three      // (see comments above concerning parms).  \t    ❻ int id3 = threads.addThread( Thread3, 0 );      if ( id3 == -1 )      {            Serial.println( \"Thread 3 creation failed\" );          for( ever );      }  }    // The loop function is, essentially, a fourth thread  // of execution.    ❼ void loop()  {      Serial.println( \"loop\" );      delay( 2000 );  } ```    The `Thread1()` function executes for the first thread, blinking the LED on the Teensy ❶. The `Thread2()` function writes a triangle wave to the DAC at address `dac1` (0x62) connected to the Teensy’s I²C port 0 ❷. The `Thread3()` function writes a triangle wave to the DAC at address `dac2` (0x60) connected to the Teensy’s I²C port 1 ❸. Note that because the two DACs are on different I²C ports, the code does not need to synchronize access to the devices.    The `setup()` function starts the three threads by calling `threads.addThread()` ❹, ❺, and ❻ and passing in the addresses of the three thread functions. The `loop()` function effectively becomes a fourth thread ❼.    Because the `i2c_driver_wire` library allocates separate memory objects for `wire` (SDA0 and SCL0) and `wire1` (SDA1 and SCL1), calls through these two separate objects do not interfere with one another when called from different threads. Were two different threads to call `wire` simultaneously, the code would have needed to protect the calls using the Teensy Threads `lock()` and `unlock()` functions:    ``` Threads::Mutex wire_lock;      .      .      .     wire_lock.lock();     Wire.beginTransmission( 0x62 );            Wire.write( (dacOut << 8) & 0xf );            Wire.write( dacOut & 0xff );            Wire.endTransmission( true );       wire_lock.unlock(); ```    [Figure 10-4](#figure10-4) shows the oscilloscope output for the program in [Listing 10-4](#listing10-4). The time base has changed for this display (two seconds per major division rather than one).  ![](image_fi/502468c10/f10004.png)    Figure 10-4: Oscilloscope output from [Listing 10-4](#listing10-4)      As you can see, the frequency here is much slower than in previous examples (note the time scale on the oscilloscope). This is likely due to the interaction between the synchronous I²C library calls and the Teensy Threads package, a typical issue when you bolt on a threading library to a nonthreading package (like Arduino) versus running a true RTOS.    ### 10.2.4 Mbed I^(*2*)C Programming    Mbed is an RTOS developed by ARM Limited for use on ARM CPUs. It is marketed as an IoT development system, though it is certainly useful for normal embedded applications. Unlike many RTOSs, which tend to be very generic, Mbed fully supports features found on typical ARM MCUs, including I²C and other peripherals. The Mbed RTOS provides a rich set of I²C functions you can use in your applications. The library is thread safe, so you don’t have to worry about protecting calls across various threads (of course, your applications must synchronize access to specific devices on the I²C bus).    ARM also provides the Mbed Studio IDE that runs under Linux, macOS, or Windows (see “For More Information” for the link). Mbed Studio allows you to edit, compile, run, and debug your applications on any Mbed-enabled SBC.    [Listing 10-5](#listing10-5) provides the standard MCP4725 triangle wave output program running under Mbed. This program has two threads: the main thread and a second thread that it starts. Each thread produces a triangle wave output on separate MCP4725 devices. This particular program runs on an STMicroelectronics Nucleo-F767ZI board ([https://www.st.com/en/evaluation-tools/nucleo-f767zi.xhtml](https://www.st.com/en/evaluation-tools/nucleo-f767zi.xhtml)) that I found on Amazon for around $35; you can also use the NUCLEO-WB55RG available from SparkFun for around $40 ([https://www.sparkfun.com/products/17943](https://www.sparkfun.com/products/17943)). Of the several I²C ports this board supports, I used ports one and two for the program in [Listing 10-5](#listing10-5).    ``` // [Listing10-5](#listinganchor10-5).cpp  //  // Mbed RTOS I2C programming example.  //  // This program writes triangle wave  // data to two MCP4725 DAC devices at  // addresses 0x62 and 0x63 on I2C ports  // one and two on a Nucleo-F767ZI board.  // Or ports one and three on a  // Nucleo-WB55RG board.    #include \"PinNames.h\"  #include \"mbed.h\"  #include \"mbed_wait_api.h\"    #define ever ;;  #define mcp4725a (0x62 << 1)  #define mcp4725b (0x63 << 1)    // Thread1-  //  // Writes a triangle wave to the  // MCP4726 at address 0x62 on  // I2C port 1.    ❶ void Thread1( void )  {      int  cntr = 0;      char data[2];      I2C i2c1( I2C_SDA, I2C_SCL );            // Set bus frequency to 100 kHz      // (this is actually the default,      // this call appears here for      // testing purposes).            i2c1.frequency( 100000 );        // Create a continuous triangle      // wave output:            for( ever )   {          // Create the rising edge of the          // triangle wave:                    for( int tri=0; tri < 4095; ++tri )          {              // Note: MCP4725 requires that you              // transmit the HO byte first, followed              // by the LO byte of the 16-bit              // DAC value (HO 4 bits are zeros).                            data[0] = (char) (tri >> 8) & 0xff;              data[1] = (char) (tri & 0xff);              i2c1.write ( mcp4725a, data, 2, false );          }                    // Create the falling edge of the          // triangle wave:                            for( int tri=4094; tri > 0; --tri )          {              data[0] = (char) (tri >> 8) & 0xff;              data[1] = (char) (tri & 0xff);              i2c1.write ( mcp4725a, data, 2, false );          }      }  }    // Application main program and main thread.  // This starts Thread1 and then emits the  // triangle wave on the second MCP4725:    int main()   {      int  cntr = 0;      char data[2];      Thread thread1;        // Nucleo-F767ZI: PB_11, PB_10      // Nucleo-WB55RG: A1, A0        I2C i2c2( PB_11, PB_10 );        i2c2.frequency( 100000 );           // Start the thread:            thread1.start( Thread1 );            // Emit the second triangle wave to      // the MCP4725 at address 0x63 on      // I2C bus two:            for( ever )   {        ❷ // See comments in Thread1.                    for( int tri=0; tri < 4095; ++tri )          {              data[0] = (char) (tri >> 8) & 0xff;              data[1] = (char) (tri & 0xff);              i2c2.write ( mcp4725b, data, 2, false );          }                  for( int tri=4094; tri > 0; --tri )          {              data[0] = (char) (tri >> 8) & 0xff;              data[1] = (char) (tri & 0xff);              i2c2.write ( mcp4725b, data, 2, false );          }      }      } ```    The code for the first thread writes a triangle wave to the DAC on I²C bus 1 ❶. It sets the I²C clock frequency to 100 kHz and then writes out 4,000 increasing DAC values followed by 4K decreasing DAC values. The code for the second thread (the main program ❷) writes a triangle wave to the DAC on I²C bus 2 using the same algorithm as employed by `Thread1()`.    Once again, the sample program in [Listing 10-5](#listing10-5) avoids synchronization issues by writing to DAC devices on two separate buses. The triangle wave outputs on the oscilloscope appear in [Figure 10-5](#figure10-5).  ![](image_fi/502468c10/f10005.png)    Figure 10-5: Triangle wave output from [Listing 10-5](#listing10-5)      If you look closely at [Figure 10-5](#figure10-5), you’ll notice that the frequency is about half of what you normally get for this application. Though two separate ports should be able to operate independently, these two ports alternate outputting data to the DACs, as shown by the logic analyzer output in [Figure 10-6](#figure10-6). The top two traces are from port one; the bottom two traces are from port two.  ![](image_fi/502468c10/f10006.png)    Figure 10-6: Logic analyzer output from the program in [Listing 10-5](#listing10-5)      I can’t say for sure whether the two ports operating at half speed is because of a limitation of the hardware (or the particular I²C device driver for the hardware port) or the fact that Mbed’s thread-safe code doesn’t allow concurrent I²C transmissions. Whatever the case, the result is that it’s only about half the bandwidth on each bus that you’d expect, and you probably could have gotten the same performance by putting both devices on the same I²C bus.    ## 10.3 Other Real-Time Operating System I²C Programming    Several RTOSs beyond those discussed in this chapter support I²C devices. Due to limited space in this chapter and the lack of development systems on my part, I won’t include example code for these operating systems, but they still deserve mention.    1.  QNX One of the older microcomputer RTOSs. Pronounced “cue-nix,” it was originally named Qunix; although it changed its name to avoid trademark infringement, it started out as a “Unix-like” microkernel operating system running on the original IBM PC (an 8088 CPU). It then quickly morphed into an RTOS supporting embedded systems and became very popular in that field. 2.  QNX was originally developed by Quantum Software Systems (QSS), who changed the company’s name to QNX Software Systems. QNX Software Systems was bought out by BlackBerry, and QNX became the basis for BlackBerry’s tablet and phone offerings after the rise of the Apple iPad. Though the BlackBerry phones and tablets eventually died out, QNX prospered as an OS specifically targeted at automotive and safety-based applications. 3.  QNX provides I²C communications “baked into” the OS. You can read about the I²C API at the QNX website at [http://www.qnx.com/developers/docs/6.5.0_sp1/index.jsp?topic=%2Fcom.qnx.doc.neutrino_technotes%2Fi2c_framework.xhtml](http://www.qnx.com/developers/docs/6.5.0_sp1/index.jsp?topic=%2Fcom.qnx.doc.neutrino_technotes%2Fi2c_framework.xhtml) (or just search for “QNX I²C Programming”). 4.  VxWorks Another early RTOS that appeared in the late 1980s from Wind River Associates. It was based on an earlier operating system, VRTX, which was created by Mentor Graphics (see [https://en.wikipedia.org/wiki/VxWorks](https://en.wikipedia.org/wiki/VxWorks) for more history). VxWorks has been very popular in hardcore embedded systems requiring safety, including aerospace, medical, and nuclear applications. If QNX is best known for automotive applications, VxWorks is best known for aerospace applications. 5.  As you can imagine, VxWorks is not a low-cost or open source system hobbyists often use. It does, however, have a no-cost license available for noncommercial or hobbyist use (see [https://labs.windriver.com/vxworks-sdk](https://labs.windriver.com/vxworks-sdk)) that runs on Raspberry Pi and other SBCs. Like QNX, VxWorks includes built-in support for I²C device programming. For more information on the VxWorks I²C library, see [https://docs.windriver.com/bundle/vxworks_7_application_core_os_sr0630-enus/page/VXBUS/vxbI2cLib.xhtml](https://docs.windriver.com/bundle/vxworks_7_application_core_os_sr0630-enus/page/VXBUS/vxbI2cLib.xhtml). 6.  eCos The embedded configurable operating system (eCos) was originally developed by Cygnus (of Windows and Unix shell fame) and was later bought out by Red Hat. Eventually, Red Hat abandoned eCos, releasing it as open source, and some of the original developers created eCos Pro as a commercial product. For a couple of years now, they’ve been promising to deliver a version that runs on Raspberry Pi systems. However, as I’m writing this, that version is yet to appear. 7.  For more about eCos’s built-in support for I²C programming, see [https://ecos.sourceware.org/docs-latest/ref/i2c-porting.xhtml](https://ecos.sourceware.org/docs-latest/ref/i2c-porting.xhtml). You can find additional eCos information at [https://doc.ecoscentric.com/user-guide](https://doc.ecoscentric.com/user-guide). 8.  ChibiOS/RT A small-footprint, open source, real-time operating system. Although ChibiOS has been ported to a wide range of microcontrollers (see [https://en.wikipedia.org/wiki/ChibiOS/RT](https://en.wikipedia.org/wiki/ChibiOS/RT)), perhaps its biggest claim to fame is that it has been successfully ported to the Raspberry Pi, providing an honest-to-goodness RTOS for the Pi (see [https://www.stevebate.net/chibios-rpi/GettingStarted.xhtml](https://www.stevebate.net/chibios-rpi/GettingStarted.xhtml)). 9.  See [http://chibios.sourceforge.net/docs3/hal/group___i2_c.xhtml](http://chibios.sourceforge.net/docs3/hal/group___i2_c.xhtml) for more details on ChibiOS’s I²C capabilities.    ## 10.4 Chapter Summary    This chapter introduced I²C programming under multithreaded, real-time operating systems. It began with a gentle introduction to RTOSs and then provided some simple I²C examples using four different RTOSs: µC/OS, FreeRTOS, Teensy Threads, and Mbed. Finally, it concluded by briefly discussing four other RTOSs you might find in the real world.````"]