["```\nfunction reverseString(stringToReverse) {\n  var reversedString = \"\";\n  for (var i = stringToReverse.length - 1; i >= 0; i--) {\n    reversedString += stringToReverse[i];\n  }\n  return reversedString;\n}\n```", "```\ndocument.write(reverseString(\"aibohphobia\"));\n```", "```\nfunction reverseString(stringToReverse) {\n  if (stringToReverse === \"\") {\n    return \"\";\n  } else {\n    return reverseString(stringToReverse.substr(1)) \n      + stringToReverse.charAt(0);\n  }\n}\n```", "```\nfunction reverseString(stringToReverse) {\n  return stringToReverse.split(\"\").reverse().join(\"\");\n}\n```", "```\nvar caesarCipher = function(str, shift) {\n  if (shift < 0) return caesarCipher(str, shift+26);\n  var output = '';\n  str = str.toUpperCase();\n  for (var i = 0; i < str.length; i++) {\n    var c = str[i];\n    if (c.match(/[a-z]/i)) {\n      var code = str.charCodeAt(i);\n      var asciiA = 'A'.charCodeAt();\n      c = String.fromCharCode(((code- asciiA+shift)%26)+asciiA);\n    }\n    output += c;\n  }\n  return output;\n}\n```", "```\ndocument.write(caesarCipher('Hello, Classmate', 11));\n```", "```\nvar caesarCipher = function(str, shift) {\n  //Check for negative number shifts\n  if (shift < 0) return caesarCipher(str, shift+26);\n  var output = '';\n  //Convert to uppercase to avoid checking lowercase unicodes\n  str = str.toUpperCase();\n  for (var i = 0; i < str.length; i++) {\n    var c = str[i];\n    //Check if its alphabetic\n    if (c.match(/[a-z]/i)) {\n      //Get the unicode value for it\n      var code = str.charCodeAt(i);\n      //Get the unicode value for A\n      var asciiA = 'A'.charCodeAt();\n      //Shift the unicode value and return the character\n      c = String.fromCharCode(((code-asciiA+shift)%26)+asciiA);\n    }\n    output += c;\n  }\n  return output;\n}\n```", "```\nvar caesarCipherDecode = function(str, shift) {\n  return caesarCipher(str, (shift * -1));\n}\n```", "```\nvar caesarCipherCracker = function(str) {\n  var output = \"\";\n  for (var i = -25; i < 1; i++) {\n    output += i + \" \" + caesarCipher(str, i) + \"<br/>\";\n  }\n  return output;\n}\n```", "```\ndocument.write(caesarCipherCracker('MJQQT HQFXXRFYJ'));\n```", "```\nvar rotatingCaesarCipher = function(str, shift, rotate) {\n  var output = \"\";\n  for (var i = 0; i < str.length; i++) {\n    shift += rotate;\n    output += caesarCipher(str[i], shift);\n  }\n  return output;\n}\n```", "```\n1\\. Create a grid.\n2\\. Start with the top-left cell.\n3\\. Mark the current cell as visited.\n4\\. Get a list of its orthogonal neighbors. \n5\\. Start with a random neighbor, for each neighbor:\n  a. If that neighbor hasn't been visited:\n    I. Remove the wall between this cell and the unvisited neighbor.\n    II. Return to step 3.\n```", "```\nfunction maze(width,height) {\n  var cells=height*width-1;\n  if (cells<0) {alert(\"illegal maze dimensions\");return;}\n  //Horizontal walls.\n  var horiz =[]; for (var j= 0; j<height+1; j++) horiz[j]= [],\n  //Vertical walls.\n    verti =[]; for (var j= 0; j<height+1; j++) verti[j]= [],\n  //Start at the top-left cell.\n    here = [0, 0],\n    path = [here],\n    unvisited = [];\n  //Build an array of unvisited cells.\n  for (var j = 0; j<height+2; j++) {\n    unvisited[j] = [];\n    for (var k= 0; k<width+1; k++)\n      unvisited[j].push(\n        j>0 && j<height+1 && k>0 && (j != here[0]+1 || k != here[1]+1)\n      );\n  }\n  while (0<cells) {\n    //Build an array of potential neighbors.\n    var potential = [[here[0]+1, here[1]], [here[0],here[1]+1],\n        [here[0]-1, here[1]], [here[0],here[1]-1]];\n    //Build an array of unvisited neighbors.\n    var neighbors = [];\n    for (var j = 0; j < 4; j++) {\n      if (unvisited[potential[j][0]+1][potential[j][1]+1])\n        neighbors.push(potential[j]);\n    }\n    if (neighbors.length) {\n      cells = cells-1;\n      //Get the next random neighbors.\n      next= neighbors[Math.floor(Math.random()*neighbors.length)];\n      unvisited[next[0]+1][next[1]+1] = false;\n      //If neighboring horizontally\n      if (next[0] == here[0])\n        horiz[next[0]][(next[1]+here[1]-1)/2] = true;\n      else //Vertically\n        verti[(next[0]+here[0]-1)/2][next[1]] = true;\n      path.push(here = next);\n    } else {\n      //Pull the last element in the path.\n      here = path.pop();\n    }\n  }\n  return {height: height, width: width, horiz: horiz, verti: verti};\n}\n```", "```\nfunction display(m) {\n  var text= [];\n  for (var j= 0; j<m.height*2+1; j++) {\n    var line= [];\n    if (0 == j%2)\n      for (var k=0; k<m.width*4+1; k++)\n        if (0 == k%4) \n          line[k]= '+';\n        else\n          if (j>0 && m.verti[j/2-1][Math.floor(k/4)])\n            line[k]= ' ';\n          else\n            line[k]= '-';\n    else\n      for (var k=0; k<m.width*4+1; k++)\n        if (0 == k%4)\n          if (k>0 && m.horiz[(j-1)/2][k/4-1])\n            line[k]= ' ';\n          else\n            line[k]= '|';\n        else\n          line[k]= ' ';\n    if (0 == j) line[1]= line[2]= line[3]= ' ';\n    if (m.height*2-1 == j) line[4*m.width]= ' ';\n    text.push(line.join('')+'\\r\\n');\n  }\n  return text.join('');\t\n}\n```", "```\n<pre id=\"out\"></pre>\n<script>\ndocument.getElementById('out').innerHTML= display(maze(10,10)); \n</script>\n```"]