- en: Chapter 7. Memory Allocation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章. 内存分配
- en: Many system programs need to be able to allocate extra memory for dynamic data
    structures (e.g., linked lists and binary trees), whose size depends on information
    that is available only at run time. This chapter describes the functions that
    are used to allocate memory on the heap or the stack.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统程序需要能够为动态数据结构（例如，链表和二叉树）分配额外的内存，这些数据结构的大小取决于仅在运行时才能获得的信息。本章描述了用于在堆或栈上分配内存的函数。
- en: Allocating Memory on the Heap
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆上分配内存
- en: A process can allocate memory by increasing the size of the heap, a variable-size
    segment of contiguous virtual memory that begins just after the uninitialized
    data segment of a process and grows and shrinks as memory is allocated and freed
    (see [Figure 6-1](ch06.html#typical_memory_layout_of_a_process_on_li "Figure 6-1. Typical
    memory layout of a process on Linux/x86-32") in [Virtual Memory Management](ch06.html#virtual_memory_management
    "Virtual Memory Management")). The current limit of the heap is referred to as
    the *program break*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以通过增加堆的大小来分配内存，堆是一个变动大小的连续虚拟内存段，开始于进程的未初始化数据段之后，并随着内存的分配和释放而增大或缩小（请参见[图6-1](ch06.html#typical_memory_layout_of_a_process_on_li
    "图6-1. Linux/x86-32 进程的典型内存布局")，以及[虚拟内存管理](ch06.html#virtual_memory_management
    "虚拟内存管理")）。堆的当前限制被称为 *程序断点*。
- en: To allocate memory, C programs normally use the *malloc* family of functions,
    which we describe shortly. However, we begin with a description of *brk()* and
    *sbrk()*, upon which the *malloc* functions are based.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 程序中，通常使用 *malloc* 系列函数来分配内存，我们将在稍后描述这些函数。然而，我们首先介绍 *brk()* 和 *sbrk()* 函数，它们是
    *malloc* 函数的基础。
- en: 'Adjusting the Program Break: *brk()* and *sbrk()*'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整程序断点：*brk()* 和 *sbrk()*
- en: Resizing the heap (i.e., allocating or deallocating memory) is actually as simple
    as telling the kernel to adjust its idea of where the process’s program break
    is. Initially, the program break lies just past the end of the uninitialized data
    segment (i.e., the same location as *&end*, shown in [Figure 6-1](ch06.html#typical_memory_layout_of_a_process_on_li
    "Figure 6-1. Typical memory layout of a process on Linux/x86-32")).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 调整堆的大小（即分配或释放内存）实际上就像告诉内核调整它对进程程序断点位置的理解一样简单。最初，程序断点位于未初始化数据段的末尾之后（即与 *&end*
    相同的位置，如[图6-1](ch06.html#typical_memory_layout_of_a_process_on_li "图6-1. Linux/x86-32
    进程的典型内存布局")所示）。
- en: After the program break is increased, the program may access any address in
    the newly allocated area, but no physical memory pages are allocated yet. The
    kernel automatically allocates new physical pages on the first attempt by the
    process to access addresses in those pages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序断点增加后，程序可以访问新分配区域中的任何地址，但此时尚未分配任何物理内存页。当进程首次访问这些页中的地址时，内核会自动分配新的物理内存页。
- en: 'Traditionally, the UNIX system has provided two system calls for manipulating
    the program break, and these are both available on Linux: *brk()* and *sbrk()*.
    Although these system calls are seldom used directly in programs, understanding
    them helps clarify how memory allocation works.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，UNIX 系统提供了两个用于操作程序断点的系统调用，这两个系统调用在 Linux 上都可用：*brk()* 和 *sbrk()*。尽管这些系统调用在程序中很少直接使用，但理解它们有助于澄清内存分配的工作原理。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns previous program break on success, or *(void *)* -1 on error
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回先前的程序断点，出错时返回 *(void *)* -1
- en: The *brk()* system call sets the program break to the location specified by
    *end_data_segment*. Since virtual memory is allocated in units of pages, *end_data_segment*
    is effectively rounded up to the next page boundary.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*brk()* 系统调用将程序断点设置为 *end_data_segment* 指定的位置。由于虚拟内存是按页分配的，*end_data_segment*
    会有效地向上舍入到下一个页边界。'
- en: 'Attempts to set the program break below its initial value (i.e., below *&end*)
    are likely to result in unexpected behavior, such as a segmentation fault (the
    `SIGSEGV` signal, described in [Signal Types and Default Actions](ch20.html#signal_types_and_default_actions
    "Signal Types and Default Actions")) when trying to access data in now nonexistent
    parts of the initialized or uninitialized data segments. The precise upper limit
    on where the program break can be set depends on a range of factors, including:
    the process resource limit for the size of the data segment (`RLIMIT_DATA`, described
    in [Details of Specific Resource Limits](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")); and the location of memory mappings,
    shared memory segments, and shared libraries.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将程序断点设置到其初始值以下（即低于*&end*）可能会导致意外行为，例如当尝试访问现已不存在的初始化或未初始化的数据段时发生段错误（`SIGSEGV`信号，参见[信号类型和默认行为](ch20.html#signal_types_and_default_actions
    "信号类型和默认行为")）。程序断点可以设置的精确上限取决于多个因素，包括：数据段大小的进程资源限制（`RLIMIT_DATA`，参见[特定资源限制的详细信息](ch36.html#details_of_specific_resource_limits
    "特定资源限制的详细信息")）；以及内存映射、共享内存段和共享库的位置。
- en: A call to *sbrk()* adjusts the program break by adding *increment* to it. (On
    Linux, *sbrk()* is a library function implemented on top of *brk()*.) The *intptr_t*
    type used to declare *increment* is an integer data type. On success, *sbrk()*
    returns the previous address of the program break. In other words, if we have
    increased the program break, the return value points to the start of the newly
    allocated block of memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*sbrk()*通过将*increment*加到程序断点上来调整程序断点。（在Linux中，*sbrk()*是建立在*brk()*基础上的库函数。）用于声明*increment*的*intptr_t*类型是一种整数数据类型。成功时，*sbrk()*返回程序断点的先前地址。换句话说，如果我们增加了程序断点，返回值指向新分配内存块的起始位置。
- en: The call *sbrk(0)* returns the current setting of the program break without
    changing it. This can be useful if we want to track the size of the heap, perhaps
    in order to monitor the behavior of a memory allocation package.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*sbrk(0)*返回当前程序断点的设置，而不会改变它。如果我们想跟踪堆的大小，可能会用到这个功能，譬如为了监控内存分配包的行为。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv2 specified *brk()* and *sbrk()* (marking them LEGACY). SUSv3 removed their
    specifications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv2规定了*brk()*和*sbrk()*（并将它们标记为遗留功能）。SUSv3取消了它们的规范。
- en: 'Allocating Memory on the Heap: *malloc()* and *free()*'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在堆上分配内存：*malloc()*和*free()*
- en: 'In general, C programs use the *malloc* family of functions to allocate and
    deallocate memory on the heap. These functions offer several advantages over *brk()*
    and *sbrk()*. In particular, they:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C程序使用*malloc*系列函数在堆上分配和释放内存。这些函数相对于*brk()*和*sbrk()*具有几个优势，特别是：
- en: are standardized as part of the C language;
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为C语言的一部分进行了标准化；
- en: are easier to use in threaded programs;
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多线程程序中使用更加简便；
- en: provide a simple interface that allows memory to be allocated in small units;
    and
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一个简单的接口，允许以小单位分配内存；
- en: allow us to arbitrarily deallocate blocks of memory, which are maintained on
    a free list and recycled in future calls to allocate memory.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们任意地释放内存块，这些内存块会被保存在空闲列表中，并在未来的内存分配调用中被回收。
- en: The *malloc()* function allocates *size* bytes from the heap and returns a pointer
    to the start of the newly allocated block of memory. The allocated memory is not
    initialized.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*malloc()*函数从堆中分配*size*字节，并返回指向新分配内存块起始位置的指针。分配的内存未初始化。'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to allocated memory on success, or `NULL` on error
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向分配内存的指针，出错时返回`NULL`
- en: Because *malloc()* returns *void **, we can assign it to any type of C pointer.
    The block of memory returned by *malloc()* is always aligned on a byte boundary
    suitable for any type of C data structure. In practice, this means that it is
    allocated on an 8-byte or 16-byte boundary on most architectures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*malloc()*返回*void **，我们可以将其赋值给任何类型的C指针。*malloc()*返回的内存块总是按照适合任何C数据结构的字节对齐方式进行分配。实际上，这意味着它在大多数架构上会以8字节或16字节对齐进行分配。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 specifies that the call *malloc(0)* may return either `NULL` or a pointer
    to a small piece of memory that can (and should) be freed with *free()*. On Linux,
    *malloc(0)* follows the latter behavior.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，调用*malloc(0)*可能返回`NULL`或指向一小块内存的指针，该内存可以（并且应该）通过*free()*释放。在Linux中，*malloc(0)*遵循后者的行为。
- en: If memory could not be allocated (perhaps because we reached the limit to which
    the program break could be raised), then *malloc()* returns `NULL` and sets *errno*
    to indicate the error. Although the possibility of failure in allocating memory
    is small, all calls to *malloc()*, and the related functions that we describe
    later, should check for this error return.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内存无法分配（可能是因为我们达到了程序 break 可以提升的限制），那么 *malloc()* 会返回 `NULL` 并将 *errno* 设置为指示错误的值。尽管分配内存失败的可能性较小，但所有对
    *malloc()* 的调用，以及我们稍后描述的相关函数，都应该检查此错误返回。
- en: The *free()* function deallocates the block of memory pointed to by its *ptr*
    argument, which should be an address previously returned by *malloc()* or one
    of the other heap memory allocation functions that we describe later in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*free()* 函数会释放其 *ptr* 参数所指向的内存块，*ptr* 应该是先前由 *malloc()* 或我们稍后在本章中描述的其他堆内存分配函数返回的地址。'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In general, *free()* doesn’t lower the program break, but instead adds the
    block of memory to a list of free blocks that are recycled by future calls to
    *malloc()*. This is done for several reasons:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，*free()* 并不会降低程序 break，而是将内存块添加到一个空闲块列表中，这些空闲块会被后续调用 *malloc()* 时回收。这样做有几个原因：
- en: The block of memory being freed is typically somewhere in the middle of the
    heap, rather than at the end, so that lowering the program break is not possible.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被释放的内存块通常位于堆的中间位置，而不是堆的末端，因此无法降低程序 break。
- en: It minimizes the number of *sbrk()* calls that the program must perform. (As
    noted in [System Calls](ch03.html#system_calls "System Calls"), system calls have
    a small but significant overhead.)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它最小化了程序必须执行的 *sbrk()* 调用次数。（如 [系统调用](ch03.html#system_calls "系统调用") 中所述，系统调用有一个小但重要的开销。）
- en: In many cases, lowering the break would not help programs that allocate large
    amounts of memory, since they typically tend to hold on to allocated memory or
    repeatedly release and reallocate memory, rather than release it all and then
    continue to run for an extended period of time.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多情况下，降低 break 并不会帮助那些分配大量内存的程序，因为这些程序通常倾向于保持已分配的内存，或者反复释放和重新分配内存，而不是释放所有内存后继续长时间运行。
- en: If the argument given to *free()* is a `NULL` pointer, then the call does nothing.
    (In other words, it is not an error to give a `NULL` pointer to *free()*.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给 *free()* 的参数是 `NULL` 指针，则该调用什么也不做。（换句话说，传递 `NULL` 指针给 *free()* 并不是错误。）
- en: Making any use of *ptr* after the call to *free()*—for example, passing it to
    *free()* a second time—is an error that can lead to unpredictable results.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 *free()* 后再使用 *ptr*——例如，第二次将其传递给 *free()*——是一个错误，可能导致不可预测的结果。
- en: Example program
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The program in [Example 7-1](ch07.html#demonstrate_what_happens_to_the_program
    "Example 7-1. Demonstrate what happens to the program break when memory is freed")
    can be used to illustrate the effect of *free()* on the program break. This program
    allocates multiple blocks of memory and then frees some or all of them, depending
    on its (optional) command-line arguments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-1](ch07.html#demonstrate_what_happens_to_the_program "示例 7-1. 演示释放内存时程序
    break 会发生什么") 中的程序可用于说明 *free()* 对程序 break 的影响。该程序分配多个内存块，然后根据其（可选的）命令行参数，释放其中一些或全部内存块。'
- en: The first two command-line arguments specify the number and size of blocks to
    allocate. The third command-line argument specifies the loop step unit to be used
    when freeing memory blocks. If we specify 1 here (which is also the default if
    this argument is omitted), then the program frees every memory block; if 2, then
    every second allocated block; and so on. The fourth and fifth command-line arguments
    specify the range of blocks that we wish to free. If these arguments are omitted,
    then all allocated blocks (in steps given by the third command-line argument)
    are freed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个命令行参数指定了要分配的块的数量和大小。第三个命令行参数指定了在释放内存块时使用的循环步长单位。如果我们在此处指定 1（如果省略此参数，则默认为
    1），则程序会释放每一个内存块；如果指定 2，则释放每第二个分配的块，以此类推。第四个和第五个命令行参数指定了我们希望释放的块的范围。如果这些参数被省略，则释放所有已分配的块（按第三个命令行参数给定的步长释放）。
- en: Example 7-1. Demonstrate what happens to the program break when memory is freed
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-1. 演示释放内存时程序 break 会发生什么
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running the program in [Example 7-1](ch07.html#demonstrate_what_happens_to_the_program
    "Example 7-1. Demonstrate what happens to the program break when memory is freed")
    with the following command line causes the program to allocate 1000 blocks of
    memory and then free every second block:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [示例 7-1](ch07.html#demonstrate_what_happens_to_the_program "示例 7-1. 演示释放内存时程序断点的变化")
    运行程序，并使用以下命令行使程序分配 1000 个内存块，然后释放每隔一个块：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output shows that after these blocks have been freed, the program break
    is left unchanged from the level it reached when all memory blocks were allocated:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，在这些块被释放之后，程序断点保持不变，仍然停留在所有内存块分配时达到的水平：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The following command line specifies that all but the last of the allocated
    blocks should be freed. Again, the program break remains at its “high-water mark.”
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令行指定除了最后一个分配的块之外，其他所有块都应被释放。再次强调，程序中断点保持在其“最高水位”处。
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If, however, we free a complete set of blocks at the top end of the heap, we
    see that the program break decreases from its peak value, indicating that *free()*
    has used *sbrk()* to lower the program break. Here, we free the last 500 blocks
    of allocated memory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们释放堆顶的完整内存块集，我们会看到程序断点从其峰值下降，这表明 *free()* 已使用 *sbrk()* 来降低程序断点。在这里，我们释放最后
    500 个分配的内存块：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the (*glibc*) *free()* function is able to recognize that an entire
    region at the top end of the heap is free, since, when releasing blocks, it coalesces
    neighboring free blocks into a single larger block. (Such coalescing is done to
    avoid having a large number of small fragments on the free list, all of which
    may be too small to satisfy subsequent *malloc()* requests.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，(*glibc*) *free()* 函数能够识别堆顶整个区域是空闲的，因为在释放块时，它会将相邻的空闲块合并成一个更大的块。（这样做是为了避免在空闲列表中出现大量过小的碎片，而这些碎片可能太小以至于无法满足后续的
    *malloc()* 请求。）
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *glibc free()* function calls *sbrk()* to lower the program break only when
    the free block at the top end is “sufficiently” large, where “sufficient” is determined
    by parameters controlling the operation of the *malloc* package (128 kB is a typical
    value). This reduces the number of *sbrk()* calls (i.e., the number of *brk()*
    system calls) that must be made.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*glibc free()* 函数只有在堆顶的空闲块“足够”大时，才会调用 *sbrk()* 来降低程序断点，其中“足够”是由控制 *malloc*
    包操作的参数决定的（128 kB 是一个典型值）。这减少了必须执行的 *sbrk()* 调用次数（即 *brk()* 系统调用的次数）。'
- en: To *free()* or not to *free()*?
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 是否应该调用 *free()*？
- en: When a process terminates, all of its memory is returned to the system, including
    heap memory allocated by functions in the *malloc* package. In programs that allocate
    memory and continue using it until program termination, it is common to omit calls
    to *free()*, relying on this behavior to automatically free the memory. This can
    be especially useful in programs that allocate many blocks of memory, since adding
    multiple calls to *free()* could be expensive in terms of CPU time, as well as
    perhaps being complicated to code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程终止时，所有内存都会返回给系统，包括由 *malloc* 包中的函数分配的堆内存。在那些分配内存并在程序终止之前持续使用它的程序中，通常会省略对
    *free()* 的调用，依赖这一行为来自动释放内存。这在分配了大量内存块的程序中尤其有用，因为添加多次调用 *free()* 可能会消耗大量 CPU 时间，并且可能会使代码变得复杂。
- en: 'Although relying on process termination to automatically free memory is acceptable
    for many programs, there are a couple of reasons why it can be desirable to explicitly
    free all allocated memory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然依赖进程终止来自动释放内存对于许多程序来说是可接受的，但有几个原因表明显式释放所有分配的内存是更理想的做法：
- en: Explicitly calling *free()* may make the program more readable and maintainable
    in the face of future modifications.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式调用 *free()* 可能使程序在面对未来修改时更具可读性和可维护性。
- en: If we are using a *malloc* debugging library (described below) to find memory
    leaks in a program, then any memory that is not explicitly freed will be reported
    as a memory leak. This can complicate the task of finding real memory leaks.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用 *malloc* 调试库（如下所述）来查找程序中的内存泄漏，那么任何没有显式释放的内存都会被报告为内存泄漏。这可能会使查找真正的内存泄漏变得更加复杂。
- en: Implementation of *malloc()* and *free()*
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*malloc()* 和 *free()* 的实现'
- en: Although *malloc()* and *free()* provide an interface for allocating memory
    that is much easier to use than *brk()* and *sbrk()*, it is still possible to
    make various programming errors when using them. Understanding how *malloc()*
    and *free()* are implemented provides us with insights into the causes of these
    errors and how we can avoid them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*malloc()*和*free()*提供的内存分配接口比*brk()*和*sbrk()*更容易使用，但在使用它们时仍然可能会犯各种编程错误。了解*malloc()*和*free()*的实现方式，能够帮助我们理解这些错误的原因，以及如何避免它们。
- en: The implementation of *malloc()* is straightforward. It first scans the list
    of memory blocks previously released by *free()* in order to find one whose size
    is larger than or equal to its requirements. (Different strategies may be employed
    for this scan, depending on the implementation; for example, *first-fit* or *best-fit*.)
    If the block is exactly the right size, then it is returned to the caller. If
    it is larger, then it is split, so that a block of the correct size is returned
    to the caller and a smaller free block is left on the free list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*malloc()*的实现很简单。它首先扫描之前通过*free()*释放的内存块列表，以找到一个大小大于或等于需求的内存块。（根据实现的不同，扫描时可能采用不同的策略，例如*first-fit*或*best-fit*。）如果该块的大小正好合适，它就会返回给调用者。如果它更大，则会将其拆分，返回一个正确大小的内存块给调用者，并将一个较小的空闲块留在空闲列表上。'
- en: If no block on the free list is large enough, then *malloc()* calls *sbrk()*
    to allocate more memory. To reduce the number of calls to *sbrk()*, rather than
    allocating exactly the number of bytes required, *malloc()* increases the program
    break in larger units (some multiple of the virtual memory page size), putting
    the excess memory onto the free list.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果空闲列表中的所有块都不够大，*malloc()*会调用*sbrk()*来分配更多的内存。为了减少调用*sbrk()*的次数，*malloc()*会以更大的单位增加程序断点（是虚拟内存页面大小的某个倍数），并将多余的内存放入空闲列表中。
- en: Looking at the implementation of *free()*, things start to become more interesting.
    When *free()* places a block of memory onto the free list, how does it know what
    size that block is? This is done via a trick. When *malloc()* allocates the block,
    it allocates extra bytes to hold an integer containing the size of the block.
    This integer is located at the beginning of the block; the address actually returned
    to the caller points to the location just past this length value, as shown in
    [Figure 7-1](ch07.html#memory_block_returned_by_malloc_open_par "Figure 7-1. Memory
    block returned by malloc()").
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 看看*free()*的实现，事情变得更有趣了。当*free()*将一个内存块放入空闲列表时，它是如何知道该块的大小的？这是通过一个技巧实现的。当*malloc()*分配内存块时，它会额外分配一些字节来存放一个整数，表示该块的大小。这个整数位于内存块的开头；实际上返回给调用者的地址指向该长度值之后的位置，如[图
    7-1](ch07.html#memory_block_returned_by_malloc_open_par "图 7-1. malloc()返回的内存块")所示。
- en: '![Memory block returned by malloc()](figs/web/07-1_MEMALLOC-malloc.png.jpg)Figure 7-1. Memory
    block returned by *malloc()*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![malloc()返回的内存块](figs/web/07-1_MEMALLOC-malloc.png.jpg)图 7-1. malloc()返回的内存块'
- en: When a block is placed on the (doubly linked) free list, *free()* uses the bytes
    of the block itself in order to add the block to the list, as shown in [Figure 7-2](ch07.html#a_block_on_the_free_list
    "Figure 7-2. A block on the free list").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个块被放入（双向链表）空闲列表时，*free()*使用该块本身的字节将其添加到列表中，如[图 7-2](ch07.html#a_block_on_the_free_list
    "图 7-2. 空闲列表中的一个块")所示。
- en: '![A block on the free list](figs/web/07-2_MEMALLOC-free-block.png.jpg)Figure 7-2. A
    block on the free list'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![空闲列表中的一个块](figs/web/07-2_MEMALLOC-free-block.png.jpg)图 7-2. 空闲列表中的一个块'
- en: As blocks are deallocated and reallocated over time, the blocks of the free
    list will become intermingled with blocks of allocated, in-use memory, as shown
    in [Figure 7-3](ch07.html#heap_containing_allocated_blocks_and_a_f "Figure 7-3. Heap
    containing allocated blocks and a free list").
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 随着内存块的不断释放和重新分配，空闲列表中的块会与已分配的、正在使用的内存块混杂在一起，如[图 7-3](ch07.html#heap_containing_allocated_blocks_and_a_f
    "图 7-3. 包含已分配块和空闲列表的堆")所示。
- en: '![Heap containing allocated blocks and a free list](figs/web/07-3_MEMALLOC-free-list.png.jpg)Figure 7-3. Heap
    containing allocated blocks and a free list'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![包含已分配块和空闲列表的堆](figs/web/07-3_MEMALLOC-free-list.png.jpg)图 7-3. 包含已分配块和空闲列表的堆'
- en: Now consider the fact that C allows us to create pointers to any location in
    the heap, and modify the locations they point to, including the *length*, *previous
    free block*, and *next free block* pointers maintained by *free()* and *malloc()*.
    Add this to the preceding description, and we have a fairly combustible mix when
    it comes to creating obscure programming bugs. For example, if, via a misdirected
    pointer, we accidentally increase one of the length values preceding an allocated
    block of memory, and subsequently deallocate that block, then *free()* will record
    the wrong size block of memory on the free list. Subsequently, *malloc()* may
    reallocate this block, leading to a scenario where the program has pointers to
    two blocks of allocated memory that it understands to be distinct, but which actually
    overlap. Numerous other pictures of what could go wrong can be drawn.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑到 C 语言允许我们创建指向堆中任意位置的指针，并修改它们指向的位置，包括由*free()*和*malloc()*维护的*长度*、*上一个空闲块*和*下一个空闲块*指针。将这一点加入到之前的描述中，我们就得到了一个相当易燃的组合，容易导致难以察觉的编程错误。例如，如果通过一个错误的指针，我们不小心增加了一个已分配内存块前面的某个长度值，并随后释放该块内存，那么*free()*将会在空闲列表中记录一个错误大小的内存块。接着，*malloc()*可能会重新分配这个内存块，导致程序拥有指向两个已分配内存块的指针，这两个块看似独立，但实际上它们是重叠的。可以绘制出许多其他可能出错的情景。
- en: 'To avoid these types of errors, we should observe the following rules:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些类型的错误，我们应该遵守以下规则：
- en: After we allocate a block of memory, we should be careful not to touch any bytes
    outside the range of that block. This could occur, for example, as a result of
    faulty pointer arithmetic or off-by-one errors in loops updating the contents
    of a block.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分配了一块内存后，我们应该小心不要触碰该块内存范围之外的任何字节。例如，这可能是由于指针运算错误或循环中更新块内容时的越界错误造成的。
- en: It is an error to free the same piece of allocated memory more than once. With
    *glibc* on Linux, we often get a segmentation violation (`SIGSEGV` signal). This
    is good, because it alerts us that we’ve made a programming error. However, more
    generally, freeing the same memory twice leads to unpredictable behavior.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多次释放同一块已分配的内存是错误的。在 Linux 上使用*glibc*时，我们通常会遇到段错误（`SIGSEGV`信号）。这是好事，因为它提醒我们犯了编程错误。然而，更一般来说，释放同一块内存两次会导致不可预测的行为。
- en: We should never call *free()* with a pointer value that wasn’t obtained by a
    call to one of the functions in the *malloc* package.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应该使用没有通过*malloc*包中的某个函数获得的指针值来调用*free()*。
- en: If we are writing a long-running program (e.g., a shell or a network daemon
    process) that repeatedly allocates memory for various purposes, then we should
    ensure that we deallocate any memory after we have finished using it. Failure
    to do so means that the heap will steadily grow until we reach the limits of available
    virtual memory, at which point further attempts to allocate memory fail. Such
    a condition is known as a *memory leak*.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在编写一个长时间运行的程序（例如，一个 shell 或一个网络守护进程），该程序会反复为各种用途分配内存，那么我们应该确保在使用完内存后及时释放它。否则，堆将持续增长，直到达到虚拟内存的上限，此时进一步的内存分配将失败。这种情况被称为*内存泄漏*。
- en: Tools and libraries for *malloc* debugging
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*malloc*调试工具和库'
- en: Failure to observe the rules listed above can lead to the creation of bugs that
    are obscure and difficult to reproduce. The task of finding such bugs can be eased
    considerably by using the *malloc* debugging tools provided by *glibc* or one
    of a number of *malloc* debugging libraries that are designed for this purpose.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 没有遵循上述规则可能会导致创建出一些晦涩且难以复现的错误。使用*glibc*提供的*malloc*调试工具或专门为此目的设计的多个*malloc*调试库，可以大大简化查找这些错误的任务。
- en: 'Among the *malloc* debugging tools provided by *glibc* are the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*glibc* 提供的*malloc*调试工具包括以下内容：'
- en: The *mtrace()* and *muntrace()* functions allow a program to turn tracing of
    memory allocation calls on and off. These functions are used in conjunction with
    the `MALLOC_TRACE` environment variable, which should be defined to contain the
    name of a file to which tracing information should be written. When *mtrace()*
    is called, it checks to see whether this file is defined and can be opened for
    writing; if so, then all calls to functions in the *malloc* package are traced
    and recorded in the file. Since the resulting file is not easily human-readable,
    a script—also called *mtrace*—is provided to analyze the file and produce a readable
    summary. For security reasons, calls to *mtrace()* are ignored by set-user-ID
    and set-group-ID programs.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mtrace()*和*muntrace()*函数允许程序开启和关闭内存分配调用的追踪。这些函数与`MALLOC_TRACE`环境变量配合使用，该变量应定义为包含追踪信息应写入的文件名。当调用*mtrace()*时，它会检查该文件是否已定义并且能够打开以进行写入；如果可以，那么所有对*malloc*包中函数的调用都会被追踪并记录在该文件中。由于生成的文件不容易被人类阅读，提供了一个脚本——也叫*mtrace*——来分析该文件并生成可读的摘要。出于安全原因，set-user-ID和set-group-ID程序会忽略对*mtrace()*的调用。'
- en: The *mcheck()* and *mprobe()* functions allow a program to perform consistency
    checks on blocks of allocated memory; for example, catching errors such as attempting
    to write to a location past the end of a block of allocated memory. These functions
    provide functionality that somewhat overlaps with the *malloc* debugging libraries
    described below. Programs that employ these functions must be linked with the
    *mcheck* library using the *cc -lmcheck* option.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mcheck()*和*mprobe()*函数允许程序对分配的内存块执行一致性检查；例如，捕获诸如尝试写入分配的内存块末尾之后位置的错误。这些函数提供的功能在某种程度上与下面描述的*malloc*调试库重叠。使用这些函数的程序必须使用*cc
    -lmcheck*选项与*mcheck*库链接。'
- en: 'The `MALLOC_CHECK_` environment variable (note the trailing underscore) serves
    a similar purpose to *mcheck()* and *mprobe()*. (One notable difference between
    the two techniques is that using `MALLOC_CHECK_` doesn’t require modification
    and recompilation of the program.) By setting this variable to different integer
    values, we can control how a program responds to memory allocation errors. Possible
    settings are: 0, meaning ignore errors; 1, meaning print diagnostic errors on
    *stderr*; and 2, meaning call *abort()* to terminate the program. Not all memory
    allocation and deallocation errors are detected via the use of `MALLOC_CHECK_`;
    it finds just the common ones. However, this technique is fast, easy to use, and
    has low run-time overhead compared with the use of *malloc* debugging libraries.
    For security reasons, the setting of `MALLOC_CHECK_` is ignored by set-user-ID
    and set-group-ID programs.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MALLOC_CHECK_`环境变量（注意末尾的下划线）与*mcheck()*和*mprobe()*的作用类似。（这两种技术之间的一个显著区别是，使用`MALLOC_CHECK_`不需要修改和重新编译程序。）通过将此变量设置为不同的整数值，我们可以控制程序如何响应内存分配错误。可能的设置值为：0，表示忽略错误；1，表示在*stderr*上打印诊断错误；2，表示调用*abort()*终止程序。并非所有的内存分配和释放错误都会通过使用`MALLOC_CHECK_`来检测到；它只会发现常见的错误。然而，与使用*malloc*调试库相比，这种技术运行速度快、易于使用，并且具有较低的运行时开销。出于安全原因，set-user-ID和set-group-ID程序会忽略`MALLOC_CHECK_`的设置。'
- en: Further information about all of the above features can be found in the *glibc*
    manual.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有关上述所有功能的更多信息，请参见*glibc*手册。
- en: A *malloc* debugging library offers the same API as the standard *malloc* package,
    but does extra work to catch memory allocation bugs. In order to use such a library,
    we link our application against that library instead of the *malloc* package in
    the standard C library. Because these libraries typically operate at the cost
    of slower run-time operation, increased memory consumption, or both, we should
    use them only for debugging purposes, and then return to linking with the standard
    *malloc* package for the production version of an application. Among such libraries
    are *Electric Fence* ([http://www.perens.com/FreeSoftware/](http://www.perens.com/FreeSoftware/)),
    *dmalloc* ([http://dmalloc.com/](http://dmalloc.com/)), *Valgrind* ([http://valgrind.org/](http://valgrind.org/)),
    and *Insure++* ([http://www.parasoft.com/](http://www.parasoft.com/)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *malloc* 调试库提供与标准 *malloc* 包相同的 API，但额外执行一些工作以捕捉内存分配错误。为了使用此类库，我们将应用程序链接到该库，而不是标准
    C 库中的 *malloc* 包。由于这些库通常会牺牲较慢的运行时操作、增加的内存消耗或两者，因此我们应仅在调试时使用它们，并且在应用程序的生产版本中返回使用标准
    *malloc* 包进行链接。这类库包括 *Electric Fence* ([http://www.perens.com/FreeSoftware/](http://www.perens.com/FreeSoftware/))，*dmalloc*
    ([http://dmalloc.com/](http://dmalloc.com/))，*Valgrind* ([http://valgrind.org/](http://valgrind.org/))，和
    *Insure++* ([http://www.parasoft.com/](http://www.parasoft.com/))。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both *Valgrind* and *Insure++* are capable of detecting many other kinds of
    bugs aside from those associated with heap allocation. See their respective web
    sites for details.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*Valgrind* 和 *Insure++* 都能够检测到除堆内存分配相关的错误之外的许多其他类型的错误。有关详细信息，请查看它们各自的网站。'
- en: Controlling and monitoring the *malloc* package
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制和监控 *malloc* 包
- en: 'The *glibc* manual describes a range of nonstandard functions that can be used
    to monitor and control the allocation of memory by functions in the *malloc* package,
    including the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*glibc* 手册描述了一些非标准函数，这些函数可以用于监控和控制 *malloc* 包中函数的内存分配，包括以下内容：'
- en: The *mallopt()* function modifies various parameters that control the algorithm
    used by *malloc()*. For example, one such parameter specifies the minimum amount
    of releasable space that must exist at the end of the free list before *sbrk()*
    is used to shrink the heap. Another parameter specifies an upper limit for the
    size of blocks that will be allocated from the heap; blocks larger than this are
    allocated using the *mmap()* system call (refer to [Anonymous Mappings](ch49.html#anonymous_mappings
    "Anonymous Mappings")).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mallopt()* 函数修改控制 *malloc()* 使用的算法的各种参数。例如，某个参数指定了在使用 *sbrk()* 来缩小堆之前，空闲链表的末尾必须存在的最小可释放空间。另一个参数指定了堆上分配的块的大小上限；超过该大小的块将使用
    *mmap()* 系统调用进行分配（请参见 [匿名映射](ch49.html#anonymous_mappings "匿名映射")）。'
- en: The *mallinfo()* function returns a structure containing various statistics
    about the memory allocated by *malloc()*.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mallinfo()* 函数返回一个结构体，包含关于 *malloc()* 分配的内存的各种统计信息。'
- en: Many UNIX implementations provide versions of *mallopt()* and *mallinfo()*.
    However, the interfaces offered by these functions vary across implementations,
    so they are not portable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 UNIX 实现提供了 *mallopt()* 和 *mallinfo()* 的版本。然而，这些函数提供的接口在不同实现之间有所不同，因此它们不可移植。
- en: Other Methods of Allocating Memory on the Heap
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆上分配内存的其他方法
- en: As well as *malloc()*, the C library provides a range of other functions for
    allocating memory on the heap, and we describe those functions here.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 *malloc()*，C 标准库还提供了一系列其他函数，用于在堆上分配内存，本文将介绍这些函数。
- en: Allocating memory with *calloc()* and *realloc()*
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 *calloc()* 和 *realloc()* 分配内存
- en: The *calloc()* function allocates memory for an array of identical items.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*calloc()* 函数为一组相同的元素分配内存。'
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to allocated memory on success, or `NULL` on error
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向分配内存的指针，失败时返回 `NULL`
- en: The *numitems* argument specifies how many items to allocate, and *size* specifies
    their size. After allocating a block of memory of the appropriate size, *calloc()*
    returns a pointer to the start of the block (or `NULL` if the memory could not
    be allocated). Unlike *malloc()*, *calloc()* initializes the allocated memory
    to 0.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*numitems* 参数指定要分配的项数，*size* 参数指定这些项的大小。在分配适当大小的内存块后，*calloc()* 返回指向块起始位置的指针（如果内存无法分配，则返回
    `NULL`）。与 *malloc()* 不同，*calloc()* 会将分配的内存初始化为 0。'
- en: 'Here is an example of the use of *calloc()*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 *calloc()* 的示例：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The *realloc()* function is used to resize (usually enlarge) a block of memory
    previously allocated by one of the functions in the *malloc* package.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*realloc()*函数用于调整（通常是增大）由*malloc*包中的某个函数之前分配的内存块的大小。'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to allocated memory on success, or `NULL` on error
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向分配内存的指针，出错时返回`NULL`。
- en: The *ptr* argument is a pointer to the block of memory that is to be resized.
    The *size* argument specifies the desired new size of the block.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*ptr*参数是指向要调整大小的内存块的指针。*size*参数指定内存块的新大小。'
- en: On success, *realloc()* returns a pointer to the location of the resized block.
    This may be different from its location before the call. On error, *realloc()*
    returns `NULL` and leaves the block pointed to by *ptr* untouched (SUSv3 requires
    this).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*realloc()*返回指向调整大小后的内存块位置的指针。这个位置可能与调用前的位置不同。出错时，*realloc()*返回`NULL`，并保持*ptr*指向的内存块不变（SUSv3要求如此）。
- en: When *realloc()* increases the size of a block of allocated memory, it doesn’t
    initialize the additionally allocated bytes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当*realloc()*增大已分配内存块的大小时，它不会初始化新增的字节。
- en: Memory allocated using *calloc()* or *realloc()* should be deallocated with
    *free()*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*calloc()*或*realloc()*分配的内存应使用*free()*释放。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The call *realloc(ptr, 0)* is equivalent to calling *free(ptr)* followed by
    *malloc(0)*. If *ptr* is specified as `NULL`, then *realloc()* is equivalent to
    calling *malloc(size)*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*realloc(ptr, 0)*等同于先调用*free(ptr)*，然后再调用*malloc(0)*。如果*ptr*指定为`NULL`，则*realloc()*等同于调用*malloc(size)*。
- en: For the usual case, where we are increasing the size of the block of memory,
    *realloc()* attempts to coalesce the block with an immediately following block
    of memory on the free list, if one exists and is large enough. If the block lies
    at the end of the heap, then *realloc()* expands the heap. If the block of memory
    lies in the middle of the heap, and there is insufficient free space immediately
    following it, *realloc()* allocates a new block of memory and copies all existing
    data from the old block to the new block. This last case is common and CPU-intensive.
    In general, it is advisable to minimize the use of *realloc()*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通常的情况，即我们增加内存块的大小，*realloc()*尝试将该块与空闲列表中紧接其后的内存块合并（如果存在并且足够大）。如果该块位于堆的末尾，*realloc()*会扩展堆。如果内存块位于堆的中间，并且其后没有足够的空闲空间，*realloc()*会分配一个新的内存块，并将旧块中的所有数据复制到新块中。这种情况很常见，并且对CPU的要求较高。一般建议尽量减少使用*realloc()*。
- en: 'Since *realloc()* may relocate the block of memory, we must use the returned
    pointer from *realloc()* for future references to the memory block. We can employ
    *realloc()* to reallocate a block pointed to by the variable *ptr* as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*realloc()*可能会重新定位内存块，我们必须使用*realloc()*返回的指针来作为未来引用该内存块的依据。我们可以如下使用*realloc()*重新分配由变量*ptr*指向的内存块：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we didn’t assign the return value of *realloc()* directly to
    *ptr* because, if *realloc()* had failed, then *ptr* would have been set to `NULL`,
    making the existing block inaccessible.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们没有将*realloc()*的返回值直接赋给*ptr*，因为如果*realloc()*失败，则*ptr*将被设置为`NULL`，从而使现有的内存块不可访问。
- en: Because *realloc()* may move the block of memory, any pointers that referred
    to locations inside the block before the *realloc()* call may no longer be valid
    after the call. The only type of reference to a location within the block that
    is guaranteed to remain valid is one formed by adding an offset to the pointer
    to the start of the block. We discuss this point in more detail in Section 48.6.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*realloc()*可能会移动内存块，任何在*realloc()*调用前指向该内存块内位置的指针，在调用后可能不再有效。唯一保证仍然有效的对块内位置的引用类型是通过向指向块起始位置的指针添加偏移量来形成的。我们将在第48.6节中详细讨论这一点。
- en: 'Allocating aligned memory: *memalign()* and *posix_memalign()*'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分配对齐内存：*memalign()*和*posix_memalign()*。
- en: The *memalign()* and *posix_memalign()* functions are designed to allocate memory
    starting at an address aligned at a specified power-of-two boundary, a feature
    that is useful for some applications (see, for example, [Example 13-1](ch13.html#using_o_underscore_direct_to_bypass_the
    "Example 13-1. Using O_DIRECT to bypass the buffer cache"), in [Alignment restrictions
    for direct I/O](ch13.html#alignment_restrictions_for_direct_i-id1 "Alignment restrictions
    for direct I/O")).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*memalign()* 和 *posix_memalign()* 函数的设计目的是分配从指定的 2 的幂对齐的地址开始的内存，这对于某些应用程序非常有用（例如，参见
    [示例 13-1](ch13.html#using_o_underscore_direct_to_bypass_the "示例 13-1. 使用 O_DIRECT
    绕过缓冲区缓存"), 在 [直接 I/O 的对齐限制](ch13.html#alignment_restrictions_for_direct_i-id1
    "直接 I/O 的对齐限制") 中）。'
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to allocated memory on success, or `NULL` on error
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向已分配内存的指针，出错时返回 `NULL`
- en: The *memalign()* function allocates *size* bytes starting at an address aligned
    to a multiple of *boundary*, which must be a power of two. The address of the
    allocated memory is returned as the function result.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*memalign()* 函数从对齐到 *boundary* 的倍数的地址开始分配 *size* 字节的内存，*boundary* 必须是 2 的幂。已分配内存的地址作为函数结果返回。'
- en: The *memalign()* function is not present on all UNIX implementations. Most other
    UNIX implementations that provide *memalign()* require the inclusion of `<stdlib.h>`
    instead of `<malloc.h>` in order to obtain the function declaration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*memalign()* 函数并非所有 UNIX 实现中都有。大多数其他提供 *memalign()* 的 UNIX 实现需要包含 `<stdlib.h>`
    而不是 `<malloc.h>`，以获得该函数声明。'
- en: SUSv3 doesn’t specify *memalign()*, but instead specifies a similar function,
    named *posix_memalign()*. This function is a recent creation of the standards
    committees, and appears on only a few UNIX implementations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 并没有指定 *memalign()*，而是指定了一个类似的函数，名为 *posix_memalign()*。该函数是标准委员会最近创建的，只出现在少数几个
    UNIX 实现中。
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回正的错误号
- en: 'The *posix_memalign()* function differs from *memalign()* in two respects:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*posix_memalign()* 函数与 *memalign()* 函数在两个方面有所不同：'
- en: The address of the allocated memory is returned in *memptr*.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已分配内存的地址将通过 *memptr* 返回。
- en: The memory is aligned to a multiple of *alignment*, which must be a power-of-two
    multiple of *sizeof(void *)* (4 or 8 bytes on most hardware architectures).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存将按 *alignment* 的倍数进行对齐，*alignment* 必须是 *sizeof(void *)*（大多数硬件架构上为 4 或 8 字节）的
    2 的幂倍数。
- en: Note also the unusual return value of this function—rather than returning -1
    on error, it returns an error number (i.e., a positive integer of the type normally
    returned in *errno*).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意该函数的返回值不同寻常——它不会在出错时返回 -1，而是返回一个错误号（即，通常在 *errno* 中返回的正整数）。
- en: 'If *sizeof(void *)* is 4, then we can use *posix_memalign()* to allocate 65,536
    bytes of memory aligned on a 4096-byte boundary as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *sizeof(void *)* 为 4，则可以使用 *posix_memalign()* 按照如下方式分配 65,536 字节的内存，并确保其对齐到
    4096 字节边界：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Blocks of memory allocated using *memalign()* or *posix_memalign()* should be
    deallocated with *free()*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *memalign()* 或 *posix_memalign()* 分配的内存块应该使用 *free()* 进行释放。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On some UNIX implementations, it is not possible to call *free()* on a block
    of memory allocated via *memalign()*, because the *memalign()* implementation
    uses *malloc()* to allocate a block of memory, and then returns a pointer to an
    address with a suitable alignment in that block. The *glibc* implementation of
    *memalign()* doesn’t suffer this limitation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 UNIX 实现中，无法对通过 *memalign()* 分配的内存块调用 *free()*，因为 *memalign()* 实现使用 *malloc()*
    分配一块内存块，然后返回指向该内存块中适当对齐地址的指针。*glibc* 实现的 *memalign()* 不会遇到此限制。
- en: 'Allocating Memory on the Stack: *alloca()*'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈上分配内存：*alloca()*
- en: Like the functions in the *malloc* package, *alloca()* allocates memory dynamically.
    However, instead of obtaining memory from the heap, *alloca()* obtains memory
    from the stack by increasing the size of the stack frame. This is possible because
    the calling function is the one whose stack frame is, by definition, on the top
    of the stack. Therefore, there is space above the frame for expansion, which can
    be accomplished by simply modifying the value of the stack pointer.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *malloc* 包中的函数类似，*alloca()* 也会动态分配内存。然而，*alloca()* 并非从堆中获取内存，而是通过增大栈帧的大小从栈中获取内存。这是可能的，因为调用函数的栈帧在栈顶，因此栈帧上方有空间可供扩展，这可以通过简单地修改栈指针的值来完成。
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to allocated block of memory
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向分配的内存块的指针
- en: The *size* argument specifies the number of bytes to allocate on the stack.
    The *alloca()* function returns a pointer to the allocated memory as its function
    result.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*size* 参数指定在栈上分配的字节数。*alloca()* 函数返回一个指向分配内存的指针，作为其函数结果。'
- en: We need not—indeed, must not—call *free()* to deallocate memory allocated with
    *alloca()*. Likewise, it is not possible to use *realloc()* to resize a block
    of memory allocated by *alloca()*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要——实际上，也绝不能——调用 *free()* 来释放使用 *alloca()* 分配的内存。同样，无法使用 *realloc()* 来调整由
    *alloca()* 分配的内存块的大小。
- en: Although *alloca()* is not part of SUSv3, it is provided on most UNIX implementations
    and is thus reasonably portable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *alloca()* 不是 SUSv3 的一部分，但它在大多数 UNIX 实现中都有提供，因此具有合理的可移植性。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Older versions of *glibc*, and some other UNIX implementations (mainly BSD derivatives),
    require the inclusion of `<stdlib.h>` instead of `<alloca.h>` to obtain the declaration
    of *alloca()*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧版本的 *glibc* 和一些其他 UNIX 实现（主要是 BSD 衍生版本）要求包含 `<stdlib.h>` 而不是 `<alloca.h>`
    来获取 *alloca()* 的声明。
- en: 'If the stack overflows as a consequence of calling *alloca()*, then program
    behavior is unpredictable. In particular, we don’t get a `NULL` return to inform
    us of the error. (In fact, in this circumstance, we may receive a `SIGSEGV` signal.
    Refer to [Handling a Signal on an Alternate Stack: *sigaltstack()*](ch21.html#handling_a_signal_on_an_alternate_stack
    "Handling a Signal on an Alternate Stack: sigaltstack()") for further details.)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '如果由于调用 *alloca()* 导致栈溢出，那么程序的行为将不可预测。特别地，我们不会得到 `NULL` 返回值来通知我们发生了错误。（实际上，在这种情况下，我们可能会收到
    `SIGSEGV` 信号。有关更多细节，请参见 [在备用栈上处理信号：*sigaltstack()*](ch21.html#handling_a_signal_on_an_alternate_stack
    "Handling a Signal on an Alternate Stack: sigaltstack()")。）'
- en: 'Note that we can’t use *alloca()* within a function argument list, as in this
    example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能在函数参数列表中使用 *alloca()*，如下面的例子所示：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is because the stack space allocated by *alloca()* would appear in the
    middle of the space for the function arguments (which are placed at fixed locations
    within the stack frame). Instead, we must use code such as this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 *alloca()* 分配的栈空间会出现在函数参数空间的中间（这些参数在栈帧内具有固定位置）。因此，我们必须使用类似下面的代码：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using *alloca()* to allocate memory has a few advantages over *malloc()*. One
    of these is that allocating blocks of memory is faster with *alloca()* than with
    *malloc()*, because *alloca()* is implemented by the compiler as inline code that
    directly adjusts the stack pointer. Furthermore, *alloca()* doesn’t need to maintain
    a list of free blocks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *alloca()* 分配内存相比 *malloc()* 有一些优势。其一是，使用 *alloca()* 分配内存块比使用 *malloc()*
    更快，因为 *alloca()* 由编译器实现为内联代码，直接调整栈指针。此外，*alloca()* 不需要维护空闲块的列表。
- en: Another advantage of *alloca()* is that the memory that it allocates is automatically
    freed when the stack frame is removed; that is, when the function that called
    *alloca()* returns. This is so because the code executed during function return
    resets the value of the stack pointer register to the end of the previous frame
    (i.e., assuming a downwardly growing stack, to the address just above the start
    of the current frame). Since we don’t need to do the work of ensuring that allocated
    memory is freed on all return paths from a function, coding of some functions
    becomes much simpler.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*alloca()* 的另一个优势是，它分配的内存会在栈帧被移除时自动释放；也就是说，当调用 *alloca()* 的函数返回时。这是因为函数返回时执行的代码会将栈指针寄存器的值重置为前一个栈帧的结束位置（即，假设栈向下增长，为当前栈帧起始位置上方的地址）。由于我们不需要确保在函数的所有返回路径上释放分配的内存，因此某些函数的编码变得更加简单。'
- en: 'Using *alloca()* can be especially useful if we employ *longjmp()* ([Performing
    a Nonlocal Goto: *setjmp()* and *long jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp
    "Performing a Nonlocal Goto: setjmp() and long jmp()")) or *siglongjmp()* ([Performing
    a Nonlocal Goto from a Signal Handler](ch21.html#performing_a_nonlocal_goto_from_a_signal
    "Performing a Nonlocal Goto from a Signal Handler")) to perform a nonlocal goto
    from a signal handler. In this case, it is difficult or even impossible to avoid
    memory leaks if we allocated memory in the jumped-over functions using *malloc()*.
    By contrast, *alloca()* avoids this problem completely, since, as the stack is
    unwound by these calls, the allocated memory is automatically freed.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*alloca()*特别有用，如果我们使用*longjmp()*（[执行非局部跳转：*setjmp()*和*long jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp
    "执行非局部跳转：setjmp()和long jmp()")）或*siglongjmp()*（[从信号处理程序执行非局部跳转](ch21.html#performing_a_nonlocal_goto_from_a_signal
    "从信号处理程序执行非局部跳转")）来执行来自信号处理程序的非局部跳转。在这种情况下，如果我们在跳过的函数中使用*malloc()*分配内存，避免内存泄漏是困难甚至不可能的。相反，*alloca()*完全避免了这个问题，因为随着这些调用展开栈，分配的内存会被自动释放。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Using the *malloc* family of functions, a process can dynamically allocate and
    release memory on the heap. In considering the implementation of these functions,
    we saw that various things can go wrong in a program that mishandles the blocks
    of allocated memory, and we noted that a number of debugging tools are available
    to help locate the source of such errors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*malloc*系列函数，进程可以动态地在堆上分配和释放内存。在考虑这些函数的实现时，我们看到程序在错误处理分配的内存块时可能会出现各种问题，并且注意到有许多调试工具可用于帮助定位这些错误的源头。
- en: The *alloca()* function allocates memory on the stack. This memory is automatically
    deallocated when the function that calls *alloca()* returns.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*alloca()*函数在栈上分配内存。当调用*alloca()*的函数返回时，这块内存会自动被释放。'
- en: Exercises
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Modify the program in [Example 7-1](ch07.html#demonstrate_what_happens_to_the_program
    "Example 7-1. Demonstrate what happens to the program break when memory is freed")
    (`free_and_sbrk.c`) to print out the current value of the program break after
    each execution of *malloc()*. Run the program specifying a small allocation block
    size. This will demonstrate that *malloc()* doesn’t employ *sbrk()* to adjust
    the program break on each call, but instead periodically allocates larger chunks
    of memory from which it passes back small pieces to the caller.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例7-1](ch07.html#demonstrate_what_happens_to_the_program "示例7-1。演示内存释放后程序断点发生了什么")（`free_and_sbrk.c`）中的程序，在每次执行*malloc()*后打印当前的程序断点值。运行该程序并指定一个小的分配块大小。这将演示*malloc()*并不会在每次调用时使用*sbrk()*来调整程序断点，而是定期从中分配更大的内存块，并从中将小块内存分配给调用者。
- en: (Advanced) Implement *malloc()* and *free()*.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （高级）实现*malloc()*和*free()*。
