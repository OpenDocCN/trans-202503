["```\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"io\"\n    \"io/ioutil\"\n    \"net\"\n    \"net/http\"\n    \"testing\"\n    \"time\"\n\n    \"github.com/awoodbeck/gnp/ch09/handlers\"\n)\n\nfunc TestSimpleHTTPServer(t *testing.T) {\n    srv := &http.Server{\n        Addr: \"127.0.0.1:8081\",\n        Handler: 1http.TimeoutHandler(\n            handlers.DefaultHandler(), 2*time.Minute, \"\"),\n        IdleTimeout:       5 * time.Minute,\n        ReadHeaderTimeout: time.Minute,\n    }\n\n    l, err := 2net.Listen(\"tcp\", srv.Addr)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    go func() {\n        err := 3srv.Serve(l)\n        if err != http.ErrServerClosed {\n            t.Error(err)\n        }\n    }()\n```", "```\n`--snip--`\n\n    testCases := []struct {\n        method   string\n        body     io.Reader\n        code     int\n        response string\n    }{\n      1{http.MethodGet, nil, http.StatusOK, \"Hello, friend!\"},\n      2{http.MethodPost, bytes.NewBufferString(\"<world>\"), http.StatusOK,\n            \"Hello, &lt;world&gt;!\"},\n      3{http.MethodHead, nil, http.StatusMethodNotAllowed, \"\"},\n    }\n\n client := new(http.Client)\n    path := fmt.Sprintf(\"http://%s/\", srv.Addr)\n```", "```\n`--snip--`\n\n    for i, c := range testCases {\n        r, err := 1http.NewRequest(c.method, path, c.body)\n        if err != nil {\n            t.Errorf(\"%d: %v\", i, err)\n            continue\n        }\n\n        resp, err := 2client.Do(r)\n        if err != nil {\n            t.Errorf(\"%d: %v\", i, err)\n            continue\n        }\n\n        if resp.StatusCode != c.code {\n            t.Errorf(\"%d: unexpected status code: %q\", i, resp.Status)\n        }\n\n        b, err := 3ioutil.ReadAll(resp.Body)\n        if err != nil {\n            t.Errorf(\"%d: %v\", i, err)\n            continue\n        }\n        _ = 4resp.Body.Close()\n\n        if c.response != string(b) {\n            t.Errorf(\"%d: expected %q; actual %q\", i, c.response, b)\n        }\n    }\n\n if err := 5srv.Close(); err != nil {\n        t.Fatal(err)\n    }\n}\n```", "```\nsrv := &http.Server{\n    Addr:              \"127.0.0.1:8081\",\n    Handler:           mux,\n    IdleTimeout:       5 * time.Minute,\n    ReadHeaderTimeout: time.Minute,\n}\n```", "```\n srv := &http.Server{\n        Addr:            1\"127.0.0.1:8443\",\n        Handler:           mux,\n        IdleTimeout:       5 * time.Minute,\n        ReadHeaderTimeout: time.Minute,\n    }\n\n    l, err := net.Listen(\"tcp\", srv.Addr)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    go func() {\n     2 err := srv.ServeTLS(l, \"cert.pem\", \"key.pem\")\n        if err != http.ErrServerClosed {\n t.Error(err)\n        }\n    }()\n```", "```\ntype Handler interface {\n    ServeHTTP(http.ResponseWriter, *http.Request)\n}\n```", "```\nhandler := http.HandlerFunc(\n    func(w http.ResponseWriter, r *http.Request) {\n        _, _ = w.Write([]byte(\"Hello, world!\"))\n    },\n)\n```", "```\npackage handlers\n\nimport (\n    \"html/template\"\n    \"io\"\n    \"io/ioutil\"\n    \"net/http\"\n)\n\nvar t = 1template.Must(template.New(\"hello\").Parse(\"Hello, {{.}}!\"))\n\nfunc DefaultHandler() http.Handler {\n    return http.HandlerFunc(\n        func(w http.ResponseWriter, r *http.Request) {\n         2 defer func(r io.ReadCloser) {\n                _, _ = io.Copy(ioutil.Discard, r)\n                _ = r.Close()\n            }(r.Body)\n\n            var b []byte\n\n         3 switch r.Method {\n            case http.MethodGet:\n                b = []byte(\"friend\")\n            case http.MethodPost:\n                var err error\n                b, err = ioutil.ReadAll(r.Body)\n                if err != nil {\n             4 http.Error(w, \"Internal server error\",\n                    http.StatusInternalServerError)\n                return\n                }\n            default:\n                // not RFC-compliant due to lack of \"Allow\" header\n             5 http.Error(w, \"Method not allowed\", \n                    http.StatusMethodNotAllowed)\n                return\n            }\n\n            _ = 6t.Execute(w, string(b))\n        },\n    )\n}\n```", "```\nfunc NewRequest(method, target string, body io.Reader) *http.Request\n```", "```\npackage handlers\n\nimport (\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n)\n\nfunc TestHandlerWriteHeader(t *testing.T) {\n    handler := func(w http.ResponseWriter, r *http.Request) {\n        _, _ = 1w.Write([]byte(\"Bad request\"))\n      2w.WriteHeader(http.StatusBadRequest)\n    }\n    r := httptest.NewRequest(http.MethodGet, \"http://test\", nil)\n    w := httptest.NewRecorder()\n    handler(w, r)\n    t.Logf(\"Response status: %q\", 3w.Result().Status)\n\n    handler = func(w http.ResponseWriter, r *http.Request) {\n      4w.WriteHeader(http.StatusB)\n        _, _ = 5w.Write([]byte(\"Bad request\"))\n    }\n r = httptest.NewRequest(http.MethodGet, \"http://test\", nil)\n    w = httptest.NewRecorder()\n    handler(w, r)\n    t.Logf(\"Response status: %q\", 6w.Result().Status)\n}\n```", "```\n=== RUN   TestHandlerWriteHeader\n    TestHandlerWriteHeader: pitfall_test.go:17: Response status: \"200 OK\"\n    TestHandlerWriteHeader: pitfall_test.go:26: Response status: \"400 Bad Request\"\n--- PASS: TestHandlerWriteHeader (0.00s)\nPASS\n```", "```\nhttp.Error(w, \"Bad request\", http.StatusBadRequest)\n```", "```\npackage handlers\n\nimport (\n    \"fmt\"\n    \"html\"\n    \"io\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"sort\"\n    \"strings\"\n)\n\n1 type Methods map[string]http.Handler\n\nfunc (h Methods) 2ServeHTTP(w http.ResponseWriter, r *http.Request) {\n 3 defer func(r io.ReadCloser) {\n        _, _ = io.Copy(ioutil.Discard, r)\n        _ = r.Close()\n    }(r.Body)\n\n    if handler, ok := h[r.Method]; ok {\n        if handler == nil {\n     4 http.Error(w, \"Internal server error\",\n                http.StatusInternalServerError)\n        } else {\n     5 handler.ServeHTTP(w, r)\n        }\n\n        return\n    }\n\n 6 w.Header().Add(\"Allow\", h.allowedMethods())\n    if r.Method != 7http.MethodOptions {\n        http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n    }\n}\n\nfunc (h Methods) allowedMethods() string {\n    a := make([]string, 0, len(h))\n\n    for k := range h {\n        a = append(a, k)\n }\n    sort.Strings(a)\n\n    return strings.Join(a, \", \")\n}\n```", "```\n`--snip--`\n\nfunc DefaultMethodsHandler() http.Handler {\n    return Methods{\n     1 http.MethodGet: http.HandlerFunc(\n            func(w http.ResponseWriter, r *http.Request) {\n                _, _ = w.Write([]byte(\"Hello, friend!\"))\n            },\n        ),\n     2 http.MethodPost: http.HandlerFunc(\n            func(w http.ResponseWriter, r *http.Request) {\n                b, err := ioutil.ReadAll(r.Body)\n                if err != nil {\n                    http.Error(w, \"Internal server error\",\n                        http.StatusInternalServerError)\n                    return\n                }\n\n                _, _ = fmt.Fprintf(w, \"Hello, %s!\",\n                    html.EscapeString(string(b)))\n },\n        ),\n    }\n}\n```", "```\nHandler: http.TimeoutHandler(handlers.DefaultHandler(), 2*time.Minute, \"\"),\n```", "```\nHandler: http.TimeoutHandler(handlers.DefaultMethodsHandler(), 2*time.Minute, \"\"),\n```", "```\ndbHandler := func(1db *sql.DB) http.Handler {\n    return http.HandlerFunc(\n        func(w http.ResponseWriter, r *http.Request) {\n            err := 2db.Ping()\n            // do something with the database hereâ€¦\n        },\n    )\n}\n\nhttp.Handle(\"/three\", 3dbHandler(db))\n```", "```\ntype Handlers struct {\n    db *sql.DB\n  1log *log.Logger\n}\n\nfunc (h *Handlers) Handler1() http.Handler {\n    return http.HandlerFunc(\n        func(w http.ResponseWriter, r *http.Request) {\n            err := h.db.Ping()\n            if err != nil {\n              2h.log.Printf(\"db ping: %v\", err)\n            }\n            // do something with the database here\n        },\n    )\n}\n\nfunc (h *Handlers) Handler2() http.Handler {\n    return http.HandlerFunc(\n        func(w http.ResponseWriter, r *http.Request) {\n            // ...\n        },\n    )\n}\n```", "```\nh := &Handlers{\n    db: 1db,\n    log: log.New(os.Stderr, \"handlers: \", log.Lshortfile),\n}\nhttp.Handle(\"/one\", h.Handler1())\nhttp.Handle(\"/two\", h.Handler2())\n```", "```\nfunc(http.Handler) http.Handler\n```", "```\nfunc Middleware(next http.Handler) http.Handler {\n    return 1http.HandlerFunc(\n     2 func(w http.ResponseWriter, r *http.Request) {\n            if r.Method == http.MethodTrace {\n              3http.Error(w, \"Method not allowed\",\n                    http.StatusMethodNotAllowed)\n            }\n\n          4w.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n\n            start := time.Now()\n          5next.ServeHTTP(w, r)\n          6log.Printf(\"Next handler duration %v\", time.Now().Sub(start))\n        },\n    )\n}\n```", "```\npackage middleware\n\nimport (\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n    \"time\"\n)\n\nfunc TestTimeoutMiddleware(t *testing.T) {\n    handler := 1http.TimeoutHandler(\n        http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            w.WriteHeader(http.StatusNoContent)\n          2time.Sleep(time.Minute)\n        }),\n        time.Second,\n        \"Timed out while reading response\",\n    )\n\n    r := httptest.NewRequest(http.MethodGet, \"http://test/\", nil)\n    w := httptest.NewRecorder()\n handler.ServeHTTP(w, r)\n\n    resp := w.Result()\n    if resp.StatusCode != 3http.StatusServiceUnavailable {\n        t.Fatalf(\"unexpected status code: %q\", resp.Status)\n    }\n\n    b, err := 4ioutil.ReadAll(resp.Body)\n    if err != nil {\n        t.Fatal(err)\n    }\n    _ = resp.Body.Close()\n\n 5 if actual := string(b); actual != \"Timed out while reading response\" {\n        t.Logf(\"unexpected body: %q\", actual)\n    }\n}\n```", "```\npackage middleware\n\nimport (\n    \"net/http\"\n    \"path\"\n \"strings\"\n)\n\nfunc RestrictPrefix(prefix string, next http.Handler) http.Handler {\n    return 1http.HandlerFunc(\n        func(w http.ResponseWriter, r *http.Request) {\n         2 for _, p := range strings.Split(path.Clean(r.URL.Path), \"/\") {\n                if strings.HasPrefix(p, prefix) {\n                 3 http.Error(w, \"Not Found\", http.StatusNotFound)\n                    return\n                }\n            }\n          next.ServeHTTP(w, r)\n        },\n    )\n}\n```", "```\npackage middleware\n\nimport (\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n)\n\nfunc TestRestrictPrefix(t *testing.T) {\n    handler := 1http.StripPrefix(\"/static/\",\n      2RestrictPrefix(\".\", 3http.FileServer(http.Dir(\"../files/\"))),\n    )\n\n    testCases := []struct {\n        path string\n        code int\n    }{\n      4{\"http://test/static/sage.svg\", http.StatusOK},\n        {\"http://test/static/.secret\", http.StatusNotFound},\n        {\"http://test/static/.dir/secret\", http.StatusNotFound},\n    }\n\n    for i, c := range testCases {\n        r := httptest.NewRequest(http.MethodGet, c.path, nil)\n        w := httptest.NewRecorder()\n        handler.ServeHTTP(w, r)\n\n actual := w.Result().StatusCode\n        if c.code != actual {\n            t.Errorf(\"%d: expected %d; actual %d\", i, c.code, actual)\n        }\n    }\n}\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n)\n\n1 func drainAndClose(next http.Handler) http.Handler {\n    return http.HandlerFunc(\n        func(w http.ResponseWriter, r *http.Request) {\n          2next.ServeHTTP(w, r)\n            _, _ = io.Copy(ioutil.Discard, r.Body)\n            _ = r.Body.Close()\n        },\n    )\n}\n\nfunc TestSimpleMux(t *testing.T) {\n    serveMux := http.NewServeMux()\n 3 serveMux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        w.WriteHeader(http.StatusNoContent)\n    })\n    serveMux.HandleFunc(4\"/hello\", func(w http.ResponseWriter,\n        r *http.Request) {\n        _, _ = fmt.Fprint(w, \"Hello friend.\")\n    })\n    serveMux.HandleFunc(5\"/hello/there/\", func(w http.ResponseWriter,\n r *http.Request) {\n        _, _ = fmt.Fprint(w, \"Why, hello there.\")\n    })\n    mux := drainAndClose(serveMux)\n```", "```\n`--snip--`\n\n    testCases := []struct {\n        path     string\n        response string\n        code     int\n    }{\n     1 {\"http://test/\", \"\", http.StatusNoContent},\n        {\"http://test/hello\", \"Hello friend.\", http.StatusOK},\n        {\"http://test/hello/there/\", \"Why, hello there.\", http.StatusOK},\n     2 {\"http://test/hello/there\",\n \"<a href=\\\"/hello/there/\\\">Moved Permanently</a>.\\n\\n\",\n            http.StatusMovedPermanently},\n     3 {\"http://test/hello/there/you\", \"Why, hello there.\", http.StatusOK},\n     4 {\"http://test/hello/and/goodbye\", \"\", http.StatusNoContent},\n        {\"http://test/something/else/entirely\", \"\", http.StatusNoContent},\n        {\"http://test/hello/you\", \"\", http.StatusNoContent},\n    }\n\n    for i, c := range testCases {\n        r := httptest.NewRequest(http.MethodGet, c.path, nil)\n        w := httptest.NewRecorder()\n        mux.ServeHTTP(w, r)\n        resp := w.Result()\n\n        if actual := resp.StatusCode; c.code != actual {\n            t.Errorf(\"%d: expected code %d; actual %d\", i, c.code, actual)\n        }\n\n        b, err := 5ioutil.ReadAll(resp.Body)\n        if err != nil {\n            t.Fatal(err)\n        }\n        _ = 6resp.Body.Close()\n\n        if actual := string(b); c.response != actual {\n            t.Errorf(\"%d: expected response %q; actual %q\", i,\n                c.response, actual)\n        }\n    }\n}\n```", "```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>H2 Server Push</title>\n 1 <link href=\"/static/style.css\" rel=\"stylesheet\">\n</head>\n<body>\n 2 <img src=\"/static/hiking.svg\" alt=\"hiking gopher\">\n</body>\n</html>\n```", "```\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"os/signal\"\n    \"path/filepath\"\n    \"time\"\n\n    \"github.com/awoodbeck/gnp/ch09/handlers\"\n    \"github.com/awoodbeck/gnp/ch09/middleware\"\n)\n\nvar (\n    addr  = flag.String(\"listen\", \"127.0.0.1:8080\", \"listen address\")\n 1 cert  = flag.String(\"cert\", \"\", \"certificate\")\n 2 pkey  = flag.String(\"key\", \"\", \"private key\")\n    files = flag.String(\"files\", \"./files\", \"static file directory\")\n)\n\nfunc main() {\n    flag.Parse()\n\n    err := 3run(*addr, *files, *cert, *pkey)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Println(\"Server gracefully shutdown\")\n}\n```", "```\n`--snip--`\n\nfunc run(addr, files, cert, pkey string) error {\n    mux := http.NewServeMux()\n 1 mux.Handle(\"/static/\",\n        http.StripPrefix(\"/static/\",\n            middleware.RestrictPrefix(\n                \".\", http.FileServer(http.Dir(files)),\n            ),\n        ),\n    )\n 2 mux.Handle(\"/\",\n        handlers.Methods{\n            http.MethodGet: http.HandlerFunc(\n                func(w http.ResponseWriter, r *http.Request) {\n                 3 if pusher, ok := w.(http.Pusher); ok {\n                        targets := []string{\n                          4\"/static/style.css\",\n                            \"/static/hiking.svg\",\n                        }\n                        for _, target := range targets {\n                            if err := 5pusher.Push(target, nil); err != nil {\n                                log.Printf(\"%s push failed: %v\", target, err)\n                            }\n                        }\n                    }\n\n                 6 http.ServeFile(w, r, filepath.Join(files, \"index.html\"))\n                },\n            ),\n        },\n    )\n 7 mux.Handle(\"/2\",\n        handlers.Methods{\n            http.MethodGet: http.HandlerFunc(\n                func(w http.ResponseWriter, r *http.Request) {\n                    http.ServeFile(w, r, filepath.Join(files, \"index2.html\"))\n                },\n            ),\n        },\n    )\n```", "```\n`--snip--`\n\n    srv := &http.Server{\n        Addr:              addr,\n        Handler:           mux,\n        IdleTimeout:       time.Minute,\n        ReadHeaderTimeout: 30 * time.Second,\n    }\n\n    done := make(chan struct{})\n    go func() {\n        c := make(chan os.Signal, 1)\n        signal.Notify(c, os.Interrupt)\n\n        for {\n         1 if <-c == os.Interrupt {\n             2 if err := srv.Shutdown(context.Background()); err != nil {\n                    log.Printf(\"shutdown: %v\", err)\n                }\n                close(done)\n                return\n            }\n        }\n    }()\n\n    log.Printf(\"Serving files in %q over %s\\n\", files, srv.Addr)\n\n    var err error\n    if cert != \"\" && pkey != \"\" {\n        log.Println(\"TLS enabled\")\n     3 err = srv.ListenAndServeTLS(cert, pkey)\n } else {\n     4 err = srv.ListenAndServe()\n    }\n\n    if err == http.ErrServerClosed {\n        err = nil\n    }\n\n    <-done\n\n    return err\n}\n```"]