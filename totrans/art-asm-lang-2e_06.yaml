- en: Chapter 7. LOW-LEVEL CONTROL STRUCTURES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 低级控制结构
- en: '![LOW-LEVEL CONTROL STRUCTURES](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![低级控制结构](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: This chapter discusses "pure" assembly language control statements. You'll need
    to master these low-level control structures before you can claim to be an assembly
    language programmer. By the time you finish this chapter, you should be able to
    stop using HLA's high-level control statements and synthesize them using low-level
    80x86 machine instructions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论“纯”汇编语言控制语句。在你声称自己是汇编语言程序员之前，你需要掌握这些低级控制结构。完成本章后，你应该能够停止使用HLA的高级控制语句，并使用低级80x86机器指令来合成这些语句。
- en: The last section of this chapter discusses *hybrid* control structures that
    combine the features of HLA's high-level control statements with the 80x86 control
    instructions. These combine the power and efficiency of the low-level control
    statements with the readability of high-level control statements. Advanced assembly
    programmers may want to use these hybrid statements to improve their programs'
    readability without sacrificing efficiency.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后部分讨论了*混合*控制结构，它结合了HLA的高级控制语句和80x86控制指令的特点。这些控制结构将低级控制语句的力量和效率与高级控制语句的可读性结合起来。高级汇编程序员可能希望使用这些混合语句，在不牺牲效率的前提下提高程序的可读性。
- en: 7.1 Low-Level Control Structures
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 低级控制结构
- en: Until now, most of the control structures you've seen and have used in your
    programs are similar to the control structures found in high-level languages like
    Pascal, C++, and Ada. While these control structures make learning assembly language
    easy, they are not true assembly language statements. Instead, the HLA compiler
    translates these control structures into a sequence of "pure" machine instructions
    that achieve the same result as the high-level control structures. This text uses
    the high-level control structures to allow you to learn assembly language without
    having to learn everything all at once. Now, however, it's time to put aside these
    high-level control structures and learn how to write your programs in *real* assembly
    language, using low-level control structures.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，你在程序中看到和使用的大多数控制结构都类似于高级语言（如Pascal、C++和Ada）中的控制结构。虽然这些控制结构使得学习汇编语言变得容易，但它们并不是实际的汇编语言语句。相反，HLA编译器将这些控制结构转换为一系列“纯”机器指令，从而实现与高级控制结构相同的结果。本文通过使用高级控制结构，让你在不需要一次性学习所有内容的情况下学习汇编语言。然而，现在是时候放下这些高级控制结构，学习如何使用低级控制结构编写真正的汇编语言程序了。
- en: 7.2 Statement Labels
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.2 语句标签
- en: 'Assembly language low-level control structures make extensive use of *labels*
    within your source code. A low-level control structure usually transfers control
    between two points in your program. You typically specify the destination of such
    a transfer using a statement label. A statement label consists of a valid (unique)
    HLA identifier and a colon. For example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言的低级控制结构广泛使用*标签*来标识源代码中的位置。低级控制结构通常会在程序的两个点之间转移控制。你通常通过语句标签来指定这样的转移目标。语句标签由一个有效（唯一的）HLA标识符和一个冒号组成。例如：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, as for procedure, variable, and constant identifiers, you should
    attempt to choose descriptive and meaningful names for your labels. The example
    identifier above, `aLabel`, is hardly descriptive or meaningful.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于过程、变量和常量标识符，你应该尽量选择描述性和有意义的名称作为标签。上面示例中的标识符`aLabel`几乎没有描述性或意义。
- en: 'Statement labels have one important attribute that differentiates them from
    most other identifiers in HLA: You don''t have to declare a label before you use
    it. This is important, because low-level control structures must often transfer
    control to some point later in the code; therefore the label may not be defined
    by the time you reference it.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 语句标签有一个重要的特点，使其区别于HLA中大多数其他标识符：你不需要在使用标签之前声明它。这一点很重要，因为低级控制结构通常需要将控制转移到代码中的某个位置；因此，当你引用标签时，它可能尚未被定义。
- en: 'You can do three things with labels: transfer control to a label via a jump
    (`goto`) instruction, call a label via the `call` instruction, and take the address
    of a label. There is very little else you can directly do with a label (of course,
    there is very little else you would want to do with a label, so this is hardly
    a restriction). The program in [Example 7-1](ch07s02.html#displaying_the_address_of_statement_labe
    "Example 7-1. Displaying the address of statement labels in a program") demonstrates
    two ways to take the address of a label in your program and print out the address
    (using the `lea` instruction and using the `&` address-of operator):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对标签执行三种操作：通过跳转（`goto`）指令转移控制权到标签，使用 `call` 指令调用标签，并获取标签的地址。对于标签，你几乎不能做其他操作（当然，你也不会希望对标签做太多其他操作，所以这并不算限制）。[示例
    7-1](ch07s02.html#displaying_the_address_of_statement_labe "示例 7-1. 在程序中显示语句标签的地址")
    演示了在程序中获取标签地址并打印地址的两种方法（使用 `lea` 指令和使用 `&` 地址操作符）：
- en: Example 7-1. Displaying the address of statement labels in a program
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-1. 在程序中显示语句标签的地址
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'HLA also allows you to initialize double-word variables with the addresses
    of statement labels. However, there are some restrictions on labels that appear
    in the initialization portions of variable declarations. The most important restriction
    is that you must define the statement label at the same lexical level as the variable
    declaration. That is, if you reference a statement label in the initializer of
    a variable declaration appearing in the main program, the statement label must
    also be in the main program. Conversely, if you take the address of a statement
    label in a local variable declaration, that symbol must appear in the same procedure
    as the local variable. [Example 7-2](ch07s02.html#initializing_dword_variables_with_the_ad
    "Example 7-2. Initializing dword variables with the address of statement labels")
    demonstrates the use of statement labels in variable initialization:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 还允许你使用语句标签的地址初始化双字变量。然而，变量声明中的初始化部分对标签有一些限制。最重要的限制是，你必须在与变量声明相同的词法级别上定义语句标签。也就是说，如果你在主程序中引用变量声明的初始化器中的语句标签，则该语句标签也必须位于主程序中。相反，如果你在局部变量声明中获取语句标签的地址，则该符号必须出现在与局部变量相同的过程内。[示例
    7-2](ch07s02.html#initializing_dword_variables_with_the_ad "示例 7-2. 使用语句标签的地址初始化
    dword 变量") 演示了语句标签在变量初始化中的使用：
- en: Example 7-2. Initializing dword variables with the address of statement labels
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-2. 使用语句标签的地址初始化 dword 变量
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once in a while, you'll need to refer to a label that is not within the current
    procedure. The need for this is sufficiently rare that this text will not describe
    all the details. See the HLA documentation for more details should you ever need
    to do this.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要引用当前过程外的标签。由于这种需求相对较少，本文不会描述所有细节。如果你需要做这种操作，请参考 HLA 文档了解更多细节。
- en: 7.3 Unconditional Transfer of Control (jmp)
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.3 无条件转移控制（jmp）
- en: 'The `jmp` ( jump) instruction unconditionally transfers control to another
    point in the program. There are three forms of this instruction: a direct jump
    and two indirect jumps. These instructions take the following forms:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`jmp`（跳转）指令无条件地将控制权转移到程序中的另一个位置。该指令有三种形式：直接跳转和两种间接跳转。这些指令的形式如下：'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first instruction is a direct jump above. For direct jumps you normally
    specify the target address using a statement label. The label appears either on
    the same line as an executable machine instruction or by itself on a line preceding
    an executable machine instruction. The direct jump is completely equivalent to
    a `goto` statement in a high-level language.^([[105](#ftn.CHP-7-FN-1)])
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令是一个直接跳转。对于直接跳转，你通常通过语句标签来指定目标地址。该标签要么与可执行机器指令在同一行，要么单独出现在可执行机器指令前的一行。直接跳转完全等同于高级语言中的
    `goto` 语句。^([[105](#ftn.CHP-7-FN-1)])
- en: 'Here''s an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The second form of the `jmp` instruction given earlier—`jmp(` *`reg32`* `);`—is
    a register indirect jump instruction. This instruction transfers control to the
    instruction whose address appears in the specified 32-bit general-purpose register.
    To use this form of the `jmp` instruction, you must load a 32-bit register with
    the address of some machine instruction prior to the execution of the `jmp`. You
    could use this instruction to implement a *state machine* by loading a register
    with the address of some label at various points throughout your program and then
    use a single indirect jump at a common point to transfer control to one of those
    labels. The short sample program in [Example 7-3](ch07s03.html#using_register-indirect_jmp_instructions
    "Example 7-3. Using register-indirect jmp instructions") demonstrates how you
    could use the `jmp` in this manner.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的第二种 `jmp` 指令形式——`jmp(` *`reg32`* `);`——是寄存器间接跳转指令。该指令将控制转移到指定的 32 位通用寄存器中出现的指令地址。要使用这种形式的
    `jmp` 指令，必须在执行 `jmp` 之前将 32 位寄存器加载为某个机器指令的地址。你可以使用此指令通过在程序的不同位置将寄存器加载为某个标签的地址，并在一个公共点使用单一的间接跳转来实现
    *状态机*。[示例 7-3](ch07s03.html#using_register-indirect_jmp_instructions "示例 7-3.
    使用寄存器间接 jmp 指令") 演示了如何以这种方式使用 `jmp` 指令。
- en: Example 7-3. Using register-indirect `jmp` instructions
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-3. 使用寄存器间接 `jmp` 指令
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The third form of the `jmp` instruction given earlier is a memory-indirect `jmp`.
    This form of the `jmp` instruction fetches the double-word value from the memory
    location and jumps to that address. This is similar to the register-indirect `jmp`
    except the address appears in a memory location rather than in a register. [Example 7-4](ch07s03.html#using_memory-indirect_jmp_instructions
    "Example 7-4. Using memory-indirect jmp instructions") demonstrates a rather trivial
    use of this form of the `jmp` instruction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的第三种 `jmp` 指令形式是内存间接 `jmp`。这种形式的 `jmp` 指令从内存位置获取双字值并跳转到该地址。这类似于寄存器间接 `jmp`，只不过地址出现在内存位置，而不是寄存器中。[示例
    7-4](ch07s03.html#using_memory-indirect_jmp_instructions "示例 7-4. 使用内存间接 jmp 指令")
    演示了这种 `jmp` 指令形式的一个相当简单的用法。
- en: Example 7-4. Using memory-indirect `jmp` instructions
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-4. 使用内存间接 `jmp` 指令
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Warning
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Unlike the HLA high-level control structures, the low-level `jmp` instructions
    can cause you a lot of trouble. In particular, if you do not initialize a register
    with the address of a valid instruction and you jump indirectly through that register,
    the results are undefined (though this will usually cause a general protection
    fault). Similarly, if you do not initialize a double-word variable with the address
    of a legal instruction, jumping indirectly through that memory location will probably
    crash your program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HLA 高级控制结构不同，低级的`jmp`指令可能会给你带来很多麻烦。特别是，如果你没有用有效指令的地址初始化一个寄存器，并且通过该寄存器间接跳转，那么结果是未定义的（虽然这通常会导致一般保护故障）。类似地，如果你没有用合法指令的地址初始化一个双字变量，通过该内存位置间接跳转可能会导致程序崩溃。
- en: '* * *'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[105](#CHP-7-FN-1)]) Unlike high-level languages, where your instructors
    usually forbid you to use `goto` statements, you will find that the use of the
    `jmp` instruction in assembly language is essential.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[105](#CHP-7-FN-1)]) 与高级语言不同，在高级语言中，教师通常会禁止使用 `goto` 语句，而你会发现，在汇编语言中使用 `jmp`
    指令是必不可少的。
- en: 7.4 The Conditional Jump Instructions
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4 条件跳转指令
- en: Although the `jmp` instruction provides transfer of control, it is inconvenient
    to use when making decisions such as those you'll need to implement statements
    like `if` and `while`. The 80x86's conditional jump instructions handle this task.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `jmp` 指令提供了控制转移，但在做出决策时使用它并不方便，例如你需要实现 `if` 和 `while` 语句的场景。80x86 的条件跳转指令可以处理这一任务。
- en: The conditional jumps test one or more CPU flags to see if they match some particular
    pattern. If the flag settings match the condition, the conditional jump instruction
    transfers control to the target location. If the match fails, the CPU ignores
    the conditional jump and execution continues with the instruction following the
    conditional jump. Some conditional jump instructions simply test the setting of
    the sign, carry, overflow, and zero flags. For example, after the execution of
    a `shl` instruction, you could test the carry flag to determine if the `shl` shifted
    a 1 out of the H.O. bit of its operand. Likewise, you could test the zero flag
    after a `test` instruction to check if the result was 0\. Most of the time, however,
    you will probably execute a conditional jump after a `cmp` instruction. The `cmp`
    instruction sets the flags so that you can test for less than, greater than, equality,
    and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 条件跳转会测试一个或多个 CPU 标志，查看它们是否匹配某个特定的模式。如果标志设置匹配条件，条件跳转指令会将控制转移到目标位置。如果匹配失败，CPU
    会忽略条件跳转，并继续执行紧接着条件跳转之后的指令。一些条件跳转指令仅仅测试符号、进位、溢出和零标志的设置。例如，在执行 `shl` 指令后，你可以测试进位标志，以确定
    `shl` 是否将一个 1 从操作数的高位移出。同样，执行 `test` 指令后，你可以测试零标志来检查结果是否为 0。然而，大多数时候，你可能会在执行 `cmp`
    指令后执行条件跳转。`cmp` 指令会设置标志，从而让你可以测试小于、大于、相等等情况。
- en: 'The conditional `jmp` instructions take the following form:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 条件 `jmp` 指令的形式如下：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The *`cc`* in `j`*`cc`* indicates that you must substitute some character sequence
    that specifies the type of condition to test. These are the same characters the
    `set`*`cc`* instruction uses. For example, `js` stands for *jump* if the sign
    flag is set. A typical `js` instruction is:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*`cc`* 在 `j`*`cc`* 中表示你必须替换为某个字符序列，指定要测试的条件类型。这些字符与 `set`*`cc`* 指令使用的字符相同。例如，`js`
    表示如果符号标志被设置则 *跳转*。一个典型的 `js` 指令是：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the `js` instruction transfers control to the `ValueIsNegative`
    label if the sign flag is currently set; control falls through to the next instruction
    following the `js` instruction if the sign flag is clear.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果符号标志当前被设置，`js` 指令将控制转移到 `ValueIsNegative` 标签；如果符号标志未设置，控制则跳转到 `js`
    指令之后的下一条指令。
- en: Unlike the unconditional `jmp` instruction, the conditional jump instructions
    do not provide an indirect form. They only allow a branch to a statement label
    in your program.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与无条件的 `jmp` 指令不同，条件跳转指令不提供间接形式。它们只允许跳转到程序中的一个标签。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Intel's documentation defines various synonyms or instruction aliases for many
    conditional jump instructions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的文档为许多条件跳转指令定义了各种同义词或指令别名。
- en: '[Table 7-1](ch07s04.html#jcc_instructions_that_test_flags "Table 7-1. jcc Instructions
    That Test Flags"), [Table 7-2](ch07s04.html#jcc_instructions_for_unsigned_comparison
    "Table 7-2. jcc Instructions for Unsigned Comparisons"), and [Table 7-3](ch07s04.html#jcc_instructions_for_signed_comparisons
    "Table 7-3. jcc Instructions for Signed Comparisons") list all the aliases for
    a particular instruction. These tables also list the opposite branches. You''ll
    soon see the purpose of the opposite branches.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-1](ch07s04.html#jcc_instructions_that_test_flags "表 7-1. jcc 指令，测试标志"),
    [表 7-2](ch07s04.html#jcc_instructions_for_unsigned_comparison "表 7-2. jcc 指令，无符号比较"),
    和 [表 7-3](ch07s04.html#jcc_instructions_for_signed_comparisons "表 7-3. jcc 指令，有符号比较")
    列出了特定指令的所有别名。这些表还列出了相反的跳转。你将很快看到相反跳转的用途。'
- en: Table 7-1. `j`*`cc`* Instructions That Test Flags
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1. `j`*`cc`* 指令，测试标志
- en: '| Instruction | Description | Condition | Aliases | Opposite |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 条件 | 别名 | 相反 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `jc` | Jump if carry | Carry = 1 | `jb`, `jnae` | `jnc` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `jc` | 如果进位则跳转 | 进位 = 1 | `jb`, `jnae` | `jnc` |'
- en: '| `jnc` | Jump if no carry | Carry = 0 | `jnb`, `jae` | `jc` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `jnc` | 如果没有进位则跳转 | 进位 = 0 | `jnb`, `jae` | `jc` |'
- en: '| `jz` | Jump if zero | Zero = 1 | `je` | `jnz` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `jz` | 如果为零则跳转 | 零 = 1 | `je` | `jnz` |'
- en: '| `jnz` | Jump if not zero | Zero = 0 | `jne` | `jz` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `jnz` | 如果不为零则跳转 | 零 = 0 | `jne` | `jz` |'
- en: '| `js` | Jump if sign | Sign = 1 |   | `jns` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `js` | 如果符号则跳转 | 符号 = 1 |   | `jns` |'
- en: '| `jns` | Jump if no sign | Sign = 0 |   | `js` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `jns` | 如果没有符号则跳转 | 符号 = 0 |   | `js` |'
- en: '| `jo` | Jump if overflow | Overflow = 1 |   | `jno` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `jo` | 如果溢出则跳转 | 溢出 = 1 |   | `jno` |'
- en: '| `jno` | Jump if no overflow | Overflow = 0 |   | `jo` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `jno` | 如果没有溢出则跳转 | 溢出 = 0 |   | `jo` |'
- en: '| `jp` | Jump if parity | Parity = 1 | `jpe` | `jnp` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `jp` | 如果奇偶校验则跳转 | 奇偶校验 = 1 | `jpe` | `jnp` |'
- en: '| `jpe` | Jump if parity even | Parity = 1 | `jp` | `jpo` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `jpe` | 如果奇偶校验为偶 | 奇偶校验 = 1 | `jp` | `jpo` |'
- en: '| `jnp` | Jump if no parity | Parity = 0 | `jpo` | `jp` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `jnp` | 如果没有奇偶校验跳转 | 奇偶校验 = 0 | `jpo` | `jp` |'
- en: '| `jpo` | Jump if parity odd | Parity = 0 | `jnp` | `jpe` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `jpo` | 如果奇偶校验为奇数跳转 | 奇偶校验 = 0 | `jnp` | `jpe` |'
- en: Table 7-2. `j`*`cc`* Instructions for Unsigned Comparisons
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '| 表7-2. 用于无符号比较的`j`*`cc`*指令'
- en: '| Instruction | Description | Condition | Aliases | Opposite |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 条件 | 别名 | 相反 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `ja` | Jump if above (`>`) | Carry = 0, Zero = 0 | `jnbe` | `jna` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `ja` | 如果大于跳转 (`>`) | 进位 = 0, 零 = 0 | `jnbe` | `jna` |'
- en: '| `jnbe` | Jump if not below or equal (`not <=`) | Carry = 0, Zero = 0 | `ja`
    | `jbe` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `jnbe` | 如果不小于或等于跳转 (`not <=`) | 进位 = 0, 零 = 0 | `ja` | `jbe` |'
- en: '| `jae` | Jump if above or equal (`>=`) | Carry = 0 | `jnc`, `jnb` | `jnae`
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `jae` | 如果大于或等于跳转 (`>=`) | 进位 = 0 | `jnc`, `jnb` | `jnae` |'
- en: '| `jnb` | Jump if not below (`not <`) | Carry = 0 | `jnc`, `jae` | `jb` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `jnb` | 如果不小于跳转 (`not <`) | 进位 = 0 | `jnc`, `jae` | `jb` |'
- en: '| `jb` | Jump if below (`<`) | Carry = 1 | `jc`, `jnae` | `jnb` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `jb` | 如果小于跳转 (`<`) | 进位 = 1 | `jc`, `jnae` | `jnb` |'
- en: '| `jnae` | Jump if not above or equal (`not >=`) | Carry = 1 | `jc`, `jb` |
    `jae` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `jnae` | 如果不大于或等于跳转 (`not >=`) | 进位 = 1 | `jc`, `jb` | `jae` |'
- en: '| `jbe` | Jump if below or equal (`<=`) | Carry = 1 or Zero = 1 | `jna` | `jnbe`
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `jbe` | 如果小于或等于跳转 (`<=`) | 进位 = 1 或零 = 1 | `jna` | `jnbe` |'
- en: '| `jna` | Jump if not above (`not >`) | Carry = 1 or Zero = 1 | `jbe` | `ja`
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `jna` | 如果不大于跳转 (`not >`) | 进位 = 1 或零 = 1 | `jbe` | `ja` |'
- en: '| `je` | Jump if equal (`=`) | Zero = 1 | `jz` | `jne` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `je` | 如果相等跳转 (`=`) | 零 = 1 | `jz` | `jne` |'
- en: '| `jne` | Jump if not equal (`¦`) | Zero = 0 | `jnz` | `je` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `jne` | 如果不相等跳转 (`¦`) | 零 = 0 | `jnz` | `je` |'
- en: Table 7-3. `j`*`cc`* Instructions for Signed Comparisons
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '| 表7-3. 用于有符号比较的`j`*`cc`*指令'
- en: '| Instruction | Description | Condition | Aliases | Opposite |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 条件 | 别名 | 相反 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `jg` | Jump if greater (`>`) | Sign = Overflow or Zero = 0 | `jnle` | `jng`
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `jg` | 如果大于跳转 (`>`) | 符号 = 溢出或零 = 0 | `jnle` | `jng` |'
- en: '| `jnle` | Jump if not less than or equal (`not <=`) | Sign = Overflow or Zero
    = 0 | `jg` | `jle` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `jnle` | 如果不小于或等于跳转 (`not <=`) | 符号 = 溢出或零 = 0 | `jg` | `jle` |'
- en: '| `jge` | Jump if greater than or equal (`>=`) | Sign = Overflow | `jnl` |
    `jge` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `jge` | 如果大于或等于跳转 (`>=`) | 符号 = 溢出 | `jnl` | `jge` |'
- en: '| `jnl` | Jump if not less than (`not <`) | Sign = Overflow | `jge` | `jl`
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `jnl` | 如果不小于跳转 (`not <`) | 符号 = 溢出 | `jge` | `jl` |'
- en: '| `jl` | Jump if less than (`<`) | Sign <> Overflow | `jnge` | `jnl` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `jl` | 如果小于跳转 (`<`) | 符号 <> 溢出 | `jnge` | `jnl` |'
- en: '| `jnge` | Jump if not greater or equal (`not >=`) | Sign <> Overflow | `jl`
    | `jge` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `jnge` | 如果不大于或等于跳转 (`not >=`) | 符号 <> 溢出 | `jl` | `jge` |'
- en: '| `jle` | Jump if less than or equal (`<=`) | Sign <> Overflow or Zero = 1
    | `jng` | `jnle` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `jle` | 如果小于或等于跳转 (`<=`) | 符号 <> 溢出或零 = 1 | `jng` | `jnle` |'
- en: '| `jng` | Jump if not greater than (`not >`) | Sign <> Overflow or Zero = 1
    | `jle` | `jg` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `jng` | 如果不大于跳转 (`not >`) | 符号 <> 溢出或零 = 1 | `jle` | `jg` |'
- en: '| `je` | Jump if equal (`=`) | Zero = 1 | `jz` | `jne` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `je` | 如果相等跳转 (`=`) | 零 = 1 | `jz` | `jne` |'
- en: '| `jne` | Jump if not equal (`¦`) | Zero = 0 | `jnz` | `je` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `jne` | 如果不相等跳转 (`¦`) | 零 = 0 | `jnz` | `je` |'
- en: 'One brief comment about the Opposite column is in order. In many instances
    you will need to be able to generate the opposite of a specific branch instruction
    (examples appear later in this section). With only two exceptions, a very simple
    rule completely describes how to generate an opposite branch:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '| 关于“相反”列，有必要做一个简短的说明。在许多情况下，你需要能够生成特定分支指令的相反指令（后面会有示例）。除了两个例外外，一个非常简单的规则可以完全描述如何生成相反分支：'
- en: If the second letter of the `jcc` instruction is not an n, insert an `n` after
    the `j`. For example, `je` becomes `jne` and `jl` becomes `jnl`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '| 如果`jcc`指令的第二个字母不是`n`，则在`j`后插入`n`。例如，`je`变为`jne`，`jl`变为`jnl`。'
- en: If the second letter of the `j`*`cc`* instruction is an `n`, then remove that
    `n` from the instruction. For example, `jng` becomes `jg` and `jne` becomes `je`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '| 如果`j`*`cc`*指令的第二个字母是`n`，则从指令中删除该`n`。例如，`jng`变为`jg`，`jne`变为`je`。'
- en: The two exceptions to this rule are `jpe` ( jump if parity is even) and `jpo`
    (jump if parity is odd). These exceptions cause few problems because (1) you'll
    hardly ever need to test the parity flag, and (2) you can use the aliases `jp`
    and `jnp` as synonyms for `jpe` and `jpo`. The "N/No N" rule applies to `jp` and
    `jnp`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '| 这两个例外是`jpe`（如果奇偶校验为偶数跳转）和`jpo`（如果奇偶校验为奇数跳转）。这两个例外几乎不会引起问题，因为（1）你几乎不需要测试奇偶校验标志，且（2）你可以使用别名`jp`和`jnp`作为`jpe`和`jpo`的同义词。“N/No
    N”规则适用于`jp`和`jnp`。'
- en: Though you *know* that `jge` is the opposite of `jl`, get in the habit of using
    `jnl` rather than `jge` as the opposite jump instruction for `jl`. It's too easy
    in an important situation to start thinking "greater is the opposite of less"
    and substitute `jg` instead. You can avoid this confusion by always using the
    "N/No N" rule.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你*知道*`jge`是`jl`的反操作，但养成使用`jnl`而不是`jge`作为`jl`的对立跳转指令的习惯。在关键情况下，容易误认为“更大是小的对立面”，并错误地替换为`jg`。你可以通过始终使用“有/没有
    N”规则来避免这种混淆。
- en: 'The 80x86 conditional jump instructions give you the ability to split program
    flow into one of two paths depending on some condition. Suppose you want to increment
    the AX register if BX is equal to CX. You can accomplish this with the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86条件跳转指令使你能够根据某个条件将程序流分成两条路径。假设你想在BX等于CX时递增AX寄存器。你可以通过以下代码实现这一目标：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The trick is to use the *opposite* branch to skip over the instructions you
    want to execute if the condition is true. Always use the "opposite branch (N/No
    N)" rule given earlier to select the opposite branch.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是使用*对立*分支来跳过你希望在条件为真时执行的指令。始终使用之前给出的“对立分支（有/没有 N）”规则来选择对立分支。
- en: 'You can also use the conditional jump instructions to synthesize loops. For
    example, the following code sequence reads a sequence of characters from the user
    and stores each character in successive elements of an array until the user presses
    the **enter** key (carriage return):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用条件跳转指令来合成循环。例如，以下代码序列从用户那里读取一系列字符，并将每个字符存储在数组的连续元素中，直到用户按下**回车**键（换行符）：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Like the `set`*`cc`* instructions, the conditional jump instructions come in
    two basic categories: those that test specific processor flags (e.g., `jz`, `jc`,
    `jno`) and those that test some condition (less than, greater than, etc.). When
    testing a condition, the conditional jump instructions almost always follow a
    `cmp` instruction. The `cmp` instruction sets the flags so that you can use a
    `ja`, `jae`, `jb`, `jbe`, `je`, or `jne` instruction to test for unsigned less
    than, less than or equal, equal, unequal, greater than, or greater than or equal.
    Simultaneously, the `cmp` instruction sets the flags so that you can also do a
    signed comparison using the `jl`, `jle`, `je`, `jne`, `jg`, and `jge` instructions.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 像`set`*`cc`*指令一样，条件跳转指令分为两大类：一种是测试特定处理器标志的指令（例如`jz`，`jc`，`jno`），另一种是测试某些条件（小于、大于等）。在测试条件时，条件跳转指令几乎总是跟随`cmp`指令。`cmp`指令设置标志，以便你可以使用`ja`，`jae`，`jb`，`jbe`，`je`或`jne`指令来测试无符号小于、小于等于、等于、不等于、大于或大于等于。与此同时，`cmp`指令也设置标志，以便你可以使用`jl`，`jle`，`je`，`jne`，`jg`和`jge`指令进行带符号的比较。
- en: The conditional jump instructions only test the 80x86 flags; they do not affect
    any of them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 条件跳转指令只测试80x86标志；它们不会影响任何标志。
- en: '7.5 "Medium-Level" Control Structures: jt and jf'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.5 "中级" 控制结构：jt 和 jf
- en: 'HLA provides two special conditional jump instructions: `jt` ( jump if true)
    and `jf` ( jump if false). These instructions take the following syntax:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: HLA提供了两条特殊的条件跳转指令：`jt`（如果为真则跳转）和`jf`（如果为假则跳转）。这些指令的语法如下：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The *`boolean_expression`* is the standard HLA boolean expression allowed by
    `if..endif` and other HLA high-level language statements. These instructions evaluate
    the boolean expression and jump to the specified label if the expression evaluates
    true (`jt`) or false (`jf`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*`boolean_expression`* 是标准的HLA布尔表达式，允许在`if..endif`和其他HLA高级语言语句中使用。这些指令计算布尔表达式，如果表达式为真，则跳转到指定标签（`jt`），如果为假，则跳转到指定标签（`jf`）。'
- en: These are not real 80x86 instructions. HLA compiles them into a sequence of
    one or more 80x86 machine instructions that achieve the same result. In general,
    you should not use these two instructions in your main code; they offer few benefits
    over using an `if..endif` statement and they are no more readable than the pure
    assembly language sequences they compile into. HLA provides these "medium-level"
    instructions so that you may create your own high-level control structures using
    macros (see [Chapter 9](ch09.html "Chapter 9. MACROS AND THE HLA COMPILE-TIME
    LANGUAGE") and the HLA reference manual for more details).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是实际的80x86指令。HLA将它们编译成一个或多个80x86机器指令，以实现相同的结果。通常，你不应在主代码中使用这两条指令；它们相较于使用`if..endif`语句没有什么好处，并且它们的可读性不比它们编译成的纯汇编语言序列更强。HLA提供这些“中级”指令，以便你可以使用宏创建自己的高级控制结构（更多详情请参见[第9章](ch09.html
    "第9章. 宏与HLA编译时语言")和HLA参考手册）。
- en: 7.6 Implementing Common Control Structures in Assembly Language
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.6 在汇编语言中实现常见的控制结构
- en: Because a primary goal of this chapter is to teach you how to use the low-level
    machine instructions to implement decisions, loops, and other control constructs,
    it would be wise to show you how to implement these high-level statements using
    pure assembly language. The following sections provide this information.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的主要目标是教你如何使用低级机器指令实现决策、循环和其他控制结构，因此明智之举是向你展示如何使用纯汇编语言实现这些高级语句。以下章节提供了这些信息。
- en: 7.7 Introduction to Decisions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.7 决策介绍
- en: 'In its most basic form, a *decision* is some sort of branch within the code
    that switches between two possible execution paths based on some condition. Normally
    (though not always), conditional instruction sequences are implemented with the
    conditional jump instructions. Conditional instructions correspond to the `if..then..endif`
    statement in HLA:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，*决策* 是代码中的某种分支，根据某些条件在两个可能的执行路径之间切换。通常（尽管并非总是如此），条件指令序列是通过条件跳转指令实现的。条件指令对应于
    HLA 中的 `if..then..endif` 语句：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Assembly language, as usual, offers much more flexibility when dealing with
    conditional statements. Consider the following C/C++ statement:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，汇编语言在处理条件语句时提供了更多的灵活性。考虑以下 C/C++ 语句：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A "brute force" approach to converting this statement into assembly language
    might produce the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将此语句转为汇编语言的“暴力”方法可能会产生以下代码：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, it takes a considerable number of conditional statements just
    to process the expression in the example above. This roughly corresponds to the
    (equivalent) C/C++ statements:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，仅仅处理上面示例中的表达式就需要相当多的条件语句。这大致对应于（等效的）C/C++ 语句：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now compare this with the following "improved" code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其与以下“改进版”代码进行比较：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Two things should be apparent from the code sequences above: First, a single
    conditional statement in C/C++ (or some other HLL) may require several conditional
    jumps in assembly language; second, organization of complex expressions in a conditional
    sequence can affect the efficiency of the code. Therefore, you should exercise
    care when dealing with conditional sequences in assembly language.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码序列中应该能看出两点：首先，在 C/C++（或其他高级语言）中，一个单一的条件语句可能需要在汇编语言中使用多个条件跳转；其次，条件序列中的复杂表达式的组织方式可能会影响代码的效率。因此，在处理汇编语言中的条件序列时，应小心谨慎。
- en: 'Conditional statements may be broken down into three basic categories: `if`
    statements, `switch`/`case` statements, and indirect jumps. The following sections
    describe these program structures, how to use them, and how to write them in assembly
    language.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句可以分为三大类：`if` 语句、`switch`/`case` 语句和间接跳转。以下章节描述了这些程序结构，如何使用它们，以及如何用汇编语言编写它们。
- en: 7.7.1 if..then..else Sequences
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.1 if..then..else 序列
- en: The most common conditional statements are the `if..then..endif` and `if..then..else..endif`
    statements. These two statements take the form shown in [Figure 7-1](ch07s07.html#if..then..else..endif_and_if..then..endi
    "Figure 7-1. if..then..else..endif and if..then..endif statement flow").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的条件语句是 `if..then..endif` 和 `if..then..else..endif` 语句。这两种语句的形式如 [图 7-1](ch07s07.html#if..then..else..endif_and_if..then..endi
    "图 7-1. if..then..else..endif 和 if..then..endif 语句流程") 所示。
- en: '![if..then..else..endif and if..then..endif statement flow](tagoreillycom20100401nostarchimages578033.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![if..then..else..endif 和 if..then..endif 语句流程](tagoreillycom20100401nostarchimages578033.png)'
- en: Figure 7-1. `if..then..else..endif` and `if..then..endif` statement flow
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1. `if..then..else..endif` 和 `if..then..endif` 语句流程
- en: 'The `if..then..endif` statement is just a special case of the `if..then..else..endif`
    statement (with an empty `else` block). Therefore, we''ll consider only the more
    general `if..then..else..endif` form. The basic implementation of an `if..then..else..endif`
    statement in 80x86 assembly language looks something like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`if..then..endif` 语句只是 `if..then..else..endif` 语句的一种特殊情况（其 `else` 块为空）。因此，我们将只考虑更通用的
    `if..then..else..endif` 形式。80x86 汇编语言中 `if..then..else..endif` 语句的基本实现大致如下所示：'
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that jcc represents some conditional jump instruction. For example, to
    convert the C/C++ statement
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，jcc 表示某种条件跳转指令。例如，要转换 C/C++ 语句
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'to assembly language, you could use the following 80x86 code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要转为汇编语言，你可以使用以下 80x86 代码：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For simple expressions like `( a == b )` generating the proper code for an
    `if..then..else..endif` statement is almost trivial. Should the expression become
    more complex, the code complexity increases as well. Consider the following C/C++
    `if` statement presented earlier:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 `( a == b )` 这样的简单表达式，生成一个正确的 `if..then..else..endif` 语句几乎是微不足道的。若表达式变得更加复杂，代码的复杂度也会随之增加。考虑之前提到的
    C/C++ `if` 语句：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When processing complex `if` statements such as this one, you''ll find the
    conversion task easier if you break the `if` statement into a sequence of three
    different `if` statements as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理像这样的复杂 `if` 语句时，如果将 `if` 语句分解成三个不同的 `if` 语句，你会发现转换任务更容易，示例如下：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This conversion comes from the following C/C++ equivalents:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该转换源自以下 C/C++ 等价物：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: is equivalent to
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: and
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: is equivalent to
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In assembly language, the former `if` statement becomes
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，前面的 `if` 语句变成
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, testing a condition can easily become more complex than the
    statements appearing in the `else` and `then` blocks. Although it seems somewhat
    paradoxical that it may take more effort to test a condition than to act on the
    results of that condition, it happens all the time. Therefore, you should be prepared
    to accept this.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，测试一个条件可能比 `else` 和 `then` 块中的语句更加复杂。尽管似乎有些矛盾的是，测试一个条件可能比对条件结果进行操作更加费力，但这确实时常发生。因此，你应该做好接受这一点的准备。
- en: 'Probably the biggest problem with complex conditional statements in assembly
    language is trying to figure out what you''ve done after you''ve written the code.
    A big advantage high-level languages offer over assembly language is that expressions
    are much easier to read and comprehend. The high-level version is (more) self-documenting,
    whereas assembly language tends to hide the true nature of the code. Therefore,
    well-written comments are an essential ingredient to assembly language implementations
    of `if..then..else..endif` statements. An elegant implementation of the example
    above is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，复杂的条件语句最头疼的问题可能是当你写完代码后，试图理解自己做了什么。高级语言相较于汇编语言的一个大优势是，表达式更易于阅读和理解。高级语言的版本（更）具自文档性，而汇编语言则往往掩盖了代码的真正含义。因此，编写良好的注释是汇编语言实现
    `if..then..else..endif` 语句的一个必要组成部分。上述示例的优雅实现如下：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Admittedly, this appears to be going overboard for such a simple example. The
    following would probably suffice:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，对于如此简单的示例来说，这看起来有些过于复杂。以下内容可能就足够了：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: However, as your `if` statements become complex, the density (and quality) of
    your comments become more and more important.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着 `if` 语句变得越来越复杂，注释的密度（和质量）变得越来越重要。
- en: 7.7.2 Translating HLA if Statements into Pure Assembly Language
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.2 将 HLA `if` 语句转换成纯汇编语言
- en: Translating HLA `if` statements into pure assembly language is very easy. The
    boolean expressions that the HLA `if` statement supports were specifically chosen
    to expand into a few simple machine instructions. The following paragraphs discuss
    the conversion of each supported boolean expression into pure machine code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HLA `if` 语句转换成纯汇编语言非常容易。HLA `if` 语句所支持的布尔表达式是特别选择的，以便可以展开成几条简单的机器指令。以下段落讨论了将每个支持的布尔表达式转换为纯机器代码的过程。
- en: if( *flag_specification* ) then *stmts* endif;
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *flag_specification* ) then *stmts* endif;
- en: 'This form is, perhaps, the easiest HLA `if` statement to convert. To execute
    the code immediately following the `then` keyword if a particular flag is set
    (or clear), all you need do is skip over the code if the flag is clear (set).
    This requires only a single conditional jump instruction for implementation, as
    the following examples demonstrate:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式，或许是最容易转换的 HLA `if` 语句。为了在特定标志位被设置（或清除）时立即执行 `then` 关键字后的代码，你只需要在标志位清除（设置）时跳过代码。这仅需要一条条件跳转指令来实现，以下示例展示了这一过程：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: if( *register* ) then *stmts* endif;
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *register* ) then *stmts* endif;
- en: 'This form uses the `test` instruction to check the specified register for 0\.
    If the register contains 0 (false), then the program jumps around the statements
    after the `then` clause with a `jz` instruction. Converting this statement to
    assembly language requires a `test` instruction and a `jz` instruction, as the
    following examples demonstrate:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式使用 `test` 指令来检查指定的寄存器是否为 0。如果寄存器中包含 0（假），那么程序会通过 `jz` 指令跳过 `then` 子句后的语句。将此语句转换为汇编语言需要
    `test` 指令和 `jz` 指令，以下示例展示了这一过程：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: if( *!register* ) then *stmts* endif;
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *!register* ) then *stmts* endif;
- en: This form of the `if` statement uses the `test` instruction to check the specified
    register to see if it is 0\. If the register is not 0 (true), then the program
    jumps around the statements after the `then` clause with a `jnz` instruction.
    Converting this statement to assembly language requires a `test` instruction and
    a `jnz` instruction in a manner identical to the previous examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的`if`语句使用`test`指令检查指定的寄存器是否为0。如果寄存器不为0（即为真），程序则使用`jnz`指令跳过`then`子句后的语句。将此语句转换为汇编语言时，需使用`test`指令和`jnz`指令，方法与前面的示例相同。
- en: if( *boolean_variable* ) then *stmts* endif;
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *boolean_variable* ) then *stmts* endif;
- en: 'This form of the `if` statement compares the boolean variable against 0 (false)
    and branches around the statements if the variable contains false. HLA implements
    this statement by using the `cmp` instruction to compare the boolean variable
    to 0, and then it uses a `jz` (`je`) instruction to jump around the statements
    if the variable is false. The following example demonstrates the conversion:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的`if`语句将布尔变量与0（假）进行比较，如果变量为假，则跳过后面的语句。HLA通过使用`cmp`指令将布尔变量与0进行比较，然后使用`jz`（`je`）指令在变量为假时跳过语句。以下示例展示了转换过程：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: if( !*boolean_variable* ) then *stmts* endif;
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( !*boolean_variable* ) then *stmts* endif;
- en: 'This form of the `if` statement compares the boolean variable against 0 (false)
    and branches around the statements if the variable contains true (the opposite
    condition of the previous example). HLA implements this statement by using the
    `cmp` instruction to compare the boolean variable to 0 and then it uses a `jnz`
    (`jne`) instruction to jump around the statements if the variable contains true.
    The following example demonstrates the conversion:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的`if`语句将布尔变量与0（假）进行比较，如果变量为真（即与前一个示例相反的条件），则跳过后面的语句。HLA通过使用`cmp`指令将布尔变量与0进行比较，然后使用`jnz`（`jne`）指令在变量为真时跳过语句。以下示例展示了转换过程：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: if( *mem_reg relop mem_reg_const* ) then *stmts* endif;
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *mem_reg relop mem_reg_const* ) then *stmts* endif;
- en: HLA translates this form of the `if` statement into a `cmp` instruction and
    a conditional jump that skips over the statements on the opposite condition specified
    by the `relop` operator. [Table 7-4](ch07s07.html#if_statement_conditional_jump_instructio
    "Table 7-4. if Statement Conditional Jump Instructions") lists the correspondence
    between operators and conditional jump instructions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: HLA将这种形式的`if`语句转换为`cmp`指令和一个条件跳转，跳过由`relop`运算符指定的相反条件下的语句。[表7-4](ch07s07.html#if_statement_conditional_jump_instructio
    "表7-4. if语句条件跳转指令")列出了操作符和条件跳转指令之间的对应关系。
- en: Table 7-4. `if` Statement Conditional Jump Instructions
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-4. `if`语句条件跳转指令
- en: '| Relational operation | Conditional jump instruction if both operands are
    unsigned | Conditional jump instruction if either operand is signed |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 关系运算 | 如果两个操作数都是无符号的，条件跳转指令 | 如果任一操作数为有符号的，条件跳转指令 |'
- en: '| --- | --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `=` or `==` | `jne` | `jne` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `=` 或 `==` | `jne` | `jne` |'
- en: '| `<>` or `!=` | `je` | `je` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `<>` 或 `!=` | `je` | `je` |'
- en: '| `<` | `jnb` | `jnl` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `<` | `jnb` | `jnl` |'
- en: '| `<=` | `jnbe` | `jnle` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | `jnbe` | `jnle` |'
- en: '| `>` | `jna` | `jng` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `>` | `jna` | `jng` |'
- en: '| `>=` | `jnae` | `jnge` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | `jnae` | `jnge` |'
- en: 'Here are a few examples of `if` statements translated into pure assembly language
    that use expressions involving relational operators:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是几个使用涉及关系运算符的表达式转换成纯汇编语言的`if`语句示例：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: if( *reg/mem* in *LowConst..HiConst* ) then *stmts* endif;
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *reg/mem* 在 *LowConst..HiConst* 范围内 ) then *stmts* endif;
- en: HLA translates this `if` statement into a pair of `cmp` instructions and a pair
    of conditional jump instructions. It compares the register or memory location
    against the lower-valued constant and jumps if less than (signed) or below (unsigned)
    past the statements after the `then` clause. If the register or memory location's
    value is greater than or equal to *`LowConst`*, the code falls through to the
    second `cmp` and conditional jump pair that compares the register or memory location
    against the higher constant. If the value is greater than (above) this constant,
    a conditional jump instruction skips the statements in the `then` clause.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: HLA将此`if`语句转换为一对`cmp`指令和一对条件跳转指令。它将寄存器或内存位置与较小的常量进行比较，如果小于（有符号）或低于（无符号）该常量，则跳过`then`子句后的语句。如果寄存器或内存位置的值大于或等于*`LowConst`*，则代码执行第二对`cmp`和条件跳转指令，将寄存器或内存位置与较高的常量进行比较。如果值大于（高于）该常量，则条件跳转指令跳过`then`子句中的语句。
- en: 'Here''s an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: if( *reg*/*mem* not in *LowConst..HiConst* ) then *stmts* endif;
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *reg*/*mem* 不在 *LowConst..HiConst* 范围内 ) then *stmts* endif;
- en: 'This form of the HLA `if` statement tests a register or memory location to
    see if its value is outside a specified range. The implementation is very similar
    to the previous code except you branch to the `then` clause if the value is less
    than the *`LowConst`* value or greater than the *`HiConst`* value, and you branch
    over the code in the `then` clause if the value is within the range specified
    by the two constants. The following examples demonstrate how to do this conversion:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的 HLA `if` 语句测试一个寄存器或内存位置，查看其值是否在指定范围之外。该实现与前面的代码非常相似，只是如果值小于 *`LowConst`*
    或大于 *`HiConst`*，则跳转到 `then` 子句；如果值在两个常数指定的范围内，则跳过 `then` 子句中的代码。以下示例演示了如何进行此转换：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 7.7.3 Implementing Complex if Statements Using Complete Boolean Evaluation
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.3 使用完整布尔运算实现复杂的 if 语句
- en: 'Many boolean expressions involve conjunction (`and`) or disjunction (`or`)
    operations. This section describes how to convert boolean expressions into assembly
    language. There are two different ways to convert complex boolean expressions
    involving conjunction and disjunction into assembly language: using complete boolean
    evaluation or using short-circuit boolean evaluation. This section discusses complete
    boolean evaluation. The next section discusses short-circuit boolean evaluation.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 许多布尔表达式涉及合取（`and`）或析取（`or`）操作。本节描述了如何将布尔表达式转换为汇编语言。对于涉及合取和析取的复杂布尔表达式，有两种不同的转换方法：使用完整布尔运算或使用短路布尔运算。本节讨论完整布尔运算，下一节讨论短路布尔运算。
- en: 'Conversion via complete boolean evaluation is almost identical to converting
    arithmetic expressions into assembly language. Indeed, the previous chapter on
    arithmetic covers this conversion process. About the only thing worth noting about
    that process is that you do not need to store the result in some variable; once
    the evaluation of the expression is complete, you check to see if you have a false
    (0) or true (1, or nonzero) result to take whatever action the boolean expression
    dictates. As you can see in the examples in the preceding sections, you can often
    use the fact that the last logical instruction (`and`/`or`) sets the zero flag
    if the result is false and clears the zero flag if the result is true. This lets
    you avoid explicitly testing for the result. Consider the following `if` statement
    and its conversion to assembly language using complete boolean evaluation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完整布尔运算进行转换几乎与将算术表达式转换为汇编语言相同。事实上，前一章关于算术的内容涵盖了这个转换过程。值得注意的唯一一点是，你不需要将结果存储在某个变量中；一旦表达式的计算完成，你只需检查是否得到
    `false`（0）或 `true`（1 或非零）结果，并根据布尔表达式的指示采取相应的操作。正如你在前面章节的示例中看到的，你通常可以利用最后的逻辑指令（`and`
    / `or`）在结果为 `false` 时设置零标志，在结果为 `true` 时清除零标志。这让你避免了显式测试结果。考虑以下 `if` 语句及其使用完整布尔运算转换为汇编语言的过程：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code computes a boolean result in the BL register and then, at the end
    of the computation, tests this value to see if it contains true or false. If the
    result is false, this sequence skips over the code associated with `Stmt1`. The
    important thing to note in this example is that the program will execute each
    and every instruction that computes this boolean result (up to the `je` instruction).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码计算 BL 寄存器中的布尔结果，然后在计算结束时测试这个值，看看它是 `true` 还是 `false`。如果结果为 `false`，则该序列跳过与
    `Stmt1` 相关的代码。这个例子中需要注意的重点是，程序将执行每一条计算布尔结果的指令（直到 `je` 指令）。
- en: 7.7.4 Short-Circuit Boolean Evaluation
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.4 短路布尔运算
- en: If you are willing to expend a little more effort, you can usually convert a
    boolean expression to a much shorter and faster sequence of assembly language
    instructions using *short-circuit boolean evaluation*. Short-circuit boolean evaluation
    attempts to determine whether an expression is true or false by executing only
    some of the instructions that would compute the complete expression. For this
    reason, plus the fact that short-circuit boolean evaluation doesn't require the
    use of any temporary registers, HLA uses short-circuit evaluation when translating
    complex boolean expressions into assembly language.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意多花一点力气，通常可以通过使用*短路布尔求值*将布尔表达式转换成更短且更快速的汇编语言指令序列。短路布尔求值通过执行部分指令来判断表达式是“真”还是“假”，从而避免执行计算完整表达式所需的所有指令。出于这个原因，以及短路布尔求值不需要使用任何临时寄存器的事实，HLA在将复杂布尔表达式翻译成汇编语言时使用了短路求值。
- en: 'Consider the expression `a && b`. Once we determine that `a` is false, there
    is no need to evaluate `b` because there is no way the expression can be true.
    If and `b` represent subexpressions rather than simple variables, the savings
    possible with short-circuit boolean evaluation are apparent. As a concrete example,
    consider the subexpression `((x<y) && (z>t))` from the previous section. Once
    you determine that `x` is not less than `y`, there is no need to check to see
    if `z` is greater than `t` because the expression will be false regardless of
    `z` and `t`''s values. The following code fragment shows how you can implement
    short-circuit boolean evaluation for this expression:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表达式`a && b`。一旦我们确定`a`为假，就不需要再评估`b`，因为无论`b`的值是什么，表达式都不可能为真。如果`a`和`b`是子表达式而非简单变量，短路布尔求值所带来的节省就更为明显。举个具体的例子，考虑上一节中的子表达式`((x<y)
    && (z>t))`。一旦你确定`x`不小于`y`，就不需要再检查`z`是否大于`t`，因为无论`z`和`t`的值如何，整个表达式都会为假。以下代码片段展示了如何对这个表达式实现短路布尔求值：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how the code skips any further testing once it determines that `x` is
    not less than `y`. Of course, if `x` is less than `y`, then the program has to
    test `z` to see if it is greater than `t`; if not, the program skips over the
    `then` clause. Only if the program satisfies both conditions does the code fall
    through to the `then` clause.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一旦代码确定`x`不小于`y`，它会跳过进一步的测试。当然，如果`x`小于`y`，程序就必须测试`z`是否大于`t`；如果不是，程序会跳过`then`语句。只有当程序满足两个条件时，代码才会执行`then`语句。
- en: 'For the logical `or` operation the technique is similar. If the first subexpression
    evaluates to true, then there is no need to test the second operand. Whatever
    the second operand''s value is at that point, the full expression still evaluates
    to true. The following example demonstrates the use of short-circuit evaluation
    with disjunction (`or`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逻辑“或”操作，技巧类似。如果第一个子表达式评估为真，那么就不需要再测试第二个操作数。无论第二个操作数的值是什么，整个表达式仍然为真。以下示例展示了如何使用短路求值与析取（`or`）操作：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Because the conjunction and disjunction operators are commutative, you can
    evaluate the left or right operand first if it is more convenient to do so.^([[106](#ftn.CHP-7-FN-2)])
    As one last example in this section, consider the full boolean expression from
    the previous section:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于连接词和析取词运算符是可交换的，因此如果更方便的话，你可以先计算左边或右边的操作数。^([[106](#ftn.CHP-7-FN-2)]) 作为本节的最后一个例子，考虑上一节中的完整布尔表达式：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice how the code in this example chose to evaluate `a != b` first and the
    remaining subexpression last. This is a common technique assembly language programmers
    use to write better code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个示例中的代码选择先评估`a != b`，然后再评估剩余的子表达式。这是汇编语言程序员常用的技巧，用来编写更高效的代码。
- en: 7.7.5 Short-Circuit vs. Complete Boolean Evaluation
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.5 短路与完整布尔求值
- en: When using complete boolean evaluation, every statement in the sequence for
    that expression will execute; short-circuit boolean evaluation, on the other hand,
    may not require the execution of every statement associated with the boolean expression.
    As you've seen in the previous two sections, code based on short-circuit evaluation
    is usually shorter and faster. So it would seem that short-circuit evaluation
    is the technique of choice when converting complex boolean expressions to assembly
    language.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用完全布尔评估时，该表达式序列中的每个语句都会执行；另一方面，短路布尔评估可能不需要执行与布尔表达式相关的每个语句。正如您在前两节中所看到的，基于短路评估的代码通常更简短且更快。因此，似乎短路评估是将复杂布尔表达式转换为汇编语言时的首选技巧。
- en: 'Sometimes, unfortunately, short-circuit boolean evaluation may not produce
    the correct result. In the presence of *side effects* in an expression, short-circuit
    boolean evaluation will produce a different result than complete boolean evaluation.
    Consider the following C/C++ example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有时短路布尔评估可能不会产生正确的结果。在表达式中存在*副作用*时，短路布尔评估会产生与完全布尔评估不同的结果。考虑以下C/C++示例：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using complete boolean evaluation, you might generate the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全布尔评估，您可能会生成如下代码：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using short-circuit boolean evaluation, you might generate the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短路布尔评估，您可能会生成如下代码：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice a very subtle but important difference between these two conversions:
    If `x` is equal to `y`, then the first version above *still increments z* and
    compares it to 0 before it executes the code associated with `Stmt`; the short-circuit
    version, on the other hand, skips the code that increments `z` if it turns out
    that `x` is equal to `y`. Therefore, the behavior of these two code fragments
    is different if `x` is equal to `y`. Neither implementation is particularly wrong;
    depending on the circumstances you may or may not want the code to increment `z`
    if `x` is equal to `y`. However, it is important that you realize that these two
    schemes produce different results, so you can choose an appropriate implementation
    if the effect of this code on `z` matters to your program.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这两个转换之间一个非常微妙但重要的区别：如果`x`等于`y`，那么上面第一版本*仍然会递增z*并在执行与`Stmt`相关的代码之前将其与0进行比较；另一方面，短路版本如果`x`等于`y`，则跳过递增`z`的代码。因此，如果`x`等于`y`，这两段代码的行为是不同的。没有哪种实现特别错误；根据具体情况，您可能希望或者不希望在`x`等于`y`时递增`z`。然而，重要的是要意识到这两种方案会产生不同的结果，因此，如果`z`的变化对程序有影响，您可以选择合适的实现。
- en: 'Many programs take advantage of short-circuit boolean evaluation and rely on
    the fact that the program may not evaluate certain components of the expression.
    The following C/C++ code fragment demonstrates what is probably the most common
    example that requires short-circuit boolean evaluation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序利用短路布尔评估，并依赖于程序可能不会评估表达式中的某些组件这一事实。以下的C/C++代码片段演示了可能最常见的需要短路布尔评估的例子：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If it turns out that `Ptr` is `NULL`, then the expression is false and there
    is no need to evaluate the remainder of the expression (and, therefore, code that
    uses short-circuit boolean evaluation will not evaluate the remainder of this
    expression). This statement relies on the semantics of short-circuit boolean evaluation
    for correct operation. Were C/C++ to use complete boolean evaluation, and the
    variable `Ptr` contained `NULL`, then the second half of the expression would
    attempt to dereference a `NULL` pointer (which tends to crash most programs).
    Consider the translation of this statement using complete and short-circuit boolean
    evaluation:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果是`Ptr`为`NULL`，那么表达式为假，并且无需计算表达式的其余部分（因此，使用短路布尔评估的代码将不会计算该表达式的其余部分）。这个语句依赖于短路布尔评估的语义才能正确操作。如果C/C++使用完全布尔评估，并且变量`Ptr`包含`NULL`，那么表达式的后半部分将尝试解引用一个`NULL`指针（这通常会导致大多数程序崩溃）。考虑使用完全布尔评估和短路布尔评估翻译此语句：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice in this example that if `Ptr` contains `NULL` (0), then this program
    will attempt to access the data at location 0 in memory via the `mov( [eax], al
    );` instruction. Under most operating systems this will cause a memory access
    fault (general protection fault).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，如果`Ptr`包含`NULL`（0），则程序将通过`mov( [eax], al );`指令尝试访问内存位置0的数据。在大多数操作系统下，这将导致内存访问故障（一般保护故障）。
- en: 'Now consider the short-circuit boolean conversion:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑短路布尔转换：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see in this example, the problem with dereferencing the `NULL` pointer
    doesn't exist. If `Ptr` contains `NULL`, this code skips over the statements that
    attempt to access the memory address `Ptr` contains.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此示例中所见，解引用`NULL`指针的问题不存在。如果`Ptr`包含`NULL`，那么这段代码会跳过尝试访问`Ptr`所包含的内存地址的语句。
- en: 7.7.6 Efficient Implementation of if Statements in Assembly Language
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.6 汇编语言中`if`语句的高效实现
- en: Encoding `if` statements efficiently in assembly language takes a bit more thought
    than simply choosing short-circuit evaluation over complete boolean evaluation.
    To write code that executes as quickly as possible in assembly language, you must
    carefully analyze the situation and generate the code appropriately. The following
    paragraphs provide some suggestions you can apply to your programs to improve
    their performance.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中高效编码`if`语句需要比仅仅选择短路求值而不是完整布尔求值更多的思考。为了在汇编语言中编写执行速度尽可能快的代码，你必须仔细分析情况，并适当地生成代码。以下段落提供了一些建议，你可以将其应用到你的程序中，以提高性能。
- en: 7.7.6.1 Know Your Data!
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6.1 了解你的数据！
- en: 'A mistake programmers often make is the assumption that data is random. In
    reality, data is rarely random, and if you know the types of values that your
    program commonly uses, you can use this knowledge to write better code. To see
    how, consider the following C/C++ statement:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员常犯的一个错误是假设数据是随机的。实际上，数据很少是随机的，如果你知道程序常用的值类型，你可以利用这一知识编写更好的代码。看看如何做，考虑以下C/C++语句：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Because C/C++ uses short-circuit evaluation, this code will test to see if
    `a` is equal to `b`. If so, then it will test to see if `c` is less than `d`.
    If you expect `a` to be equal to `b` most of the time but don''t expect `c` to
    be less than `d` most of the time, this statement will execute slower than it
    should. Consider the following HLA implementation of this code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C/C++使用短路求值，这段代码会首先检查`a`是否等于`b`。如果是，它将检查`c`是否小于`d`。如果你预计`a`大多数时候等于`b`，但不预计`c`大多数时候小于`d`，这条语句的执行速度将比预期的要慢。考虑以下HLA实现的这段代码：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see in this code, if `a` is equal to `b` most of the time and `c`
    is not less than `d` most of the time, you will have to execute all six instructions
    nearly every time in order to determine that the expression is false. Now consider
    the following implementation of the above C/C++ statement that takes advantage
    of this knowledge and the fact that the `&&` operator is commutative:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在这段代码中所见，如果`a`大多数时候等于`b`且`c`大多数时候不小于`d`，你将几乎每次都必须执行所有六条指令，以确定表达式的结果是错误的。现在，考虑一下利用这个知识，并且利用`&&`运算符交换律的事实对上述C/C++语句的实现：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this example the code first checks to see if `c` is less than `d`. If most
    of the time `c` is less than `d`, then this code determines that it has to skip
    to the label `DontIncI` after executing only three instructions in the typical
    case (compared with six instructions in the previous example). This fact is much
    more obvious in assembly language than in a high-level language; this is one of
    the main reasons why assembly programs are often faster than their high-level
    language counterparts: optimizations are more obvious in assembly language than
    in a high-level language. Of course, the key here is to understand the behavior
    of your data so you can make intelligent decisions such as the one above.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，代码首先检查`c`是否小于`d`。如果大多数情况下`c`小于`d`，那么这段代码会确定它只需执行三条指令（与前一个例子中的六条指令相比），然后跳到标签`DontIncI`。在汇编语言中，这一点比在高级语言中更为明显；这也是汇编程序通常比其高级语言对应程序更快的主要原因之一：优化在汇编语言中比在高级语言中更为直观。当然，关键是要理解你的数据行为，这样你才能做出像上面那样的智能决策。
- en: 7.7.6.2 Rearranging Expressions
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6.2 重新排列表达式
- en: 'Even if your data is random (or you can''t determine how the input values will
    affect your decisions), there may still be some benefit to rearranging the terms
    in your expressions. Some calculations take far longer to compute than others.
    For example, the `div` instruction is much slower than a simple `cmp` instruction.
    Therefore, if you have a statement like the following, you may want to rearrange
    the expression so that the `cmp` comes first:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的数据是随机的（或者你无法确定输入值如何影响你的决策），重新排列表达式中的项可能仍然会带来一些好处。一些计算比其他计算花费的时间要长得多。例如，`div`指令比简单的`cmp`指令要慢得多。因此，如果你有如下的语句，你可能希望重新排列表达式，使得`cmp`优先执行：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Converted to assembly code, this `if` statement becomes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为汇编代码后，这个`if`语句变成了：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `imod` instruction is very expensive (often 50–100 times slower than most
    of the other instructions in this example). Unless it is 50–100 times more likely
    that the remainder is 0 rather than `x` is equal to `y`, it would be better to
    do the comparison first and the remainder calculation afterward:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`imod`指令非常昂贵（在这个例子中通常比大多数其他指令慢50到100倍）。除非余数为0的可能性比`x`等于`y`的可能性大50到100倍，否则最好先进行比较，然后再进行余数计算：'
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Of course, in order to rearrange the expression in this manner, the code must
    not assume the use of short-circuit evaluation semantics (because the `&&` and
    `||` operators are not commutative if the code must compute one subexpression
    before another).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了以这种方式重新排列表达式，代码不能假定使用短路求值语义（因为`&&`和`||`运算符在必须先计算一个子表达式然后计算另一个子表达式时不具有交换律）。
- en: 7.7.6.3 Destructuring Your Code
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6.3 重构你的代码
- en: Although there are many good things to be said about structured programming
    techniques, there are some drawbacks to writing structured code. Specifically,
    structured code is sometimes less efficient than unstructured code. Most of the
    time this is tolerable because unstructured code is difficult to read and maintain;
    it is often acceptable to sacrifice some performance in exchange for maintainable
    code. In certain instances, however, you may need all the performance you can
    get. In those rare instances you might choose to compromise the readability of
    your code in order to gain some additional performance.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管结构化编程技术有很多优点，但编写结构化代码也有一些缺点。具体而言，结构化代码有时比非结构化代码效率低。大多数情况下这是可以接受的，因为非结构化代码难以阅读和维护；通常可以牺牲一些性能以换取可维护的代码。然而，在某些情况下，你可能需要尽可能地提升性能。在这些罕见的情况下，你可能会选择为了获得额外的性能而牺牲代码的可读性。
- en: 'One classic way to do this is to use code movement to move code your program
    rarely uses out of the way of code that executes most of the time. For example,
    consider the following pseudo C/C++ statement:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的做法是使用代码移动将程序中很少使用的代码移到大部分时间执行的代码之外。例如，考虑以下伪 C/C++ 语句：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In normal code, one does not expect errors to be frequent. Therefore, you would
    normally expect the `then` section of the above `if` to execute far more often
    than the `else` clause. The code above could translate into the following assembly
    code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的代码中，人们并不期望错误经常发生。因此，你通常会期望上述`if`语句的`then`部分执行的次数远远超过`else`分支。上面的代码可以转换为以下汇编代码：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Notice that if the expression is false, this code falls through to the normal
    statements and then jumps over the error-handling statements. Instructions that
    transfer control from one point in your program to another (for example, `jmp`
    instructions) tend to be slow. It is much faster to execute a sequential set of
    instructions rather than jump all over the place in your program. Unfortunately,
    the code above doesn''t allow this. One way to rectify this problem is to move
    the `else` clause of the code somewhere else in your program. That is, you could
    rewrite the code as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果表达式为假，此代码会继续执行正常的语句，然后跳过错误处理语句。控制从程序的一个点转移到另一个点的指令（例如`jmp`指令）通常速度较慢。执行顺序一致的一组指令要比在程序中到处跳转快得多。不幸的是，上面的代码不允许这样做。解决这个问题的一种方法是将代码的`else`分支移动到程序的其他位置。也就是说，你可以将代码重写为以下形式：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At some other point in your program (typically after a `jmp` instruction) you
    would insert the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的某个其他位置（通常在`jmp`指令之后），你会插入以下代码：
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that the program isn't any shorter. The `jmp` you removed from the original
    sequence winds up at the end of the `else` clause. However, because the `else`
    clause rarely executes, moving the `jmp` instruction from the `then` clause (which
    executes frequently) to the `else` clause is a big performance win because the
    `then` clause executes using only straight-line code. This technique is surprisingly
    effective in many time-critical code segments.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序的长度没有任何变化。你从原序列中移除的`jmp`最终会出现在`else`分支的末尾。然而，由于`else`分支很少执行，将`jmp`指令从频繁执行的`then`分支移到`else`分支中是一个重大的性能优化，因为`then`分支只使用直线代码。这种技术在许多时间关键的代码段中效果惊人。
- en: There is a difference between writing *destructured* code and writing *unstructured*
    code. Unstructured code is written in an unstructured way to begin with. It is
    generally hard to read, difficult to maintain, and often contains defects. Destructured
    code, on the other hand, starts out as structured code, and you make a conscious
    decision to eliminate the structure in order to gain a small performance boost.
    Generally, you've already tested the code in its structured form before destructuring
    it. Therefore, destructured code is often easier to work with than unstructured
    code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 写*非结构化*代码和写*结构化*代码是有区别的。非结构化代码一开始就以非结构化方式编写。它通常难以阅读、难以维护，并且经常包含缺陷。另一方面，非结构化代码从结构化代码开始，您做出有意识的决定来消除结构，以获得小幅度的性能提升。通常，在将其非结构化之前，您已经测试了结构化形式的代码。因此，非结构化代码通常比非结构化代码更易于处理。
- en: 7.7.6.4 Calculation Rather Than Branching
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6.4 计算而非分支
- en: 'On many processors in the 80x86 family, branches ( jumps) are very expensive
    compared to many other instructions. For this reason it is sometimes better to
    execute more instructions in a sequence than fewer instructions that involve branching.
    For example, consider the simple assignment `eax = abs( eax );`. Unfortunately,
    there is no 80x86 instruction that computes the absolute value of an integer.
    The obvious way to handle this is with an instruction sequence like the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多80x86系列处理器中，分支（跳转）与许多其他指令相比非常昂贵。因此，有时在序列中执行更多的指令比执行涉及分支的较少指令更好。例如，考虑简单的赋值语句`eax
    = abs( eax );`。不幸的是，80x86指令集中没有计算整数绝对值的指令。处理这个问题的明显方法是使用以下指令序列：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'However, as you can plainly see in this example, it uses a conditional jump
    to skip over the `neg` instruction (that creates a positive value in EAX if EAX
    was negative). Now consider the following sequence that will also do the job:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如您在此示例中明显看到的，它使用条件跳转来跳过`neg`指令（如果EAX为负则会创建一个正数值）。现在考虑以下也能完成任务的序列：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This code will invert all the bits in EAX and then add 1 to EAX if EAX was negative
    prior to the sequence; that is, it negates the value in EAX. If EAX was 0 or positive,
    then this code does not change the value in EAX.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果EAX在序列之前是负数，则此代码将反转EAX中的所有位，然后向EAX添加1；也就是说，它否定了EAX中的值。如果EAX为0或正数，则此代码不会更改EAX中的值。
- en: Note that this sequence takes four instructions rather than the three the previous
    example requires. However, because there are no transfer-of-control instructions
    in this sequence, it may execute faster on many CPUs in the 80x86 family.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此序列需要四条指令，而不是前面示例中所需的三条指令。但是，由于此序列中没有控制传输指令，因此在80x86系列的许多CPU上可能执行速度更快。
- en: 7.7.7 switch/case Statements
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.7 switch/case语句
- en: 'The HLA `switch` statement takes the following form:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: HLA `switch`语句的形式如下：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When this statement executes, it checks the value of the register against the
    constants *`const1`*`..`*`constn`*. If a match is found, then the corresponding
    statements execute. HLA places a few restrictions on the `switch` statement. First,
    the HLA `switch` statement allows only a 32-bit register as the `switch` expression.
    Second, all the constants in the `case` clauses must be unique. The reason for
    these restrictions will become clear in a moment.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当此语句执行时，它检查寄存器的值是否与常量*`const1`*`..`*`constn`*匹配。如果找到匹配项，则执行相应的语句。HLA对`switch`语句有一些限制。首先，HLA
    `switch`语句只允许32位寄存器作为`switch`表达式。其次，在`case`子句中的所有常量必须是唯一的。这些限制的原因将很快明了。
- en: 'Most introductory programming texts introduce the `switch/case` statement by
    explaining it as a sequence of `if..then..elseif..else..endif` statements. They
    might claim that the following two pieces of HLA code are equivalent:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数入门编程教材通过将`switch/case`语句解释为一系列`if..then..elseif..else..endif`语句来介绍它。他们可能会声称以下两段HLA代码是等效的：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'While semantically these two code segments may be the same, their implementation
    is usually different. Whereas the `if..then..elseif..else..endif` chain does a
    comparison for each conditional statement in the sequence, the `switch` statement
    normally uses an indirect jump to transfer control to any one of several statements
    with a single computation. Consider the two examples presented above; they could
    be written in assembly language with the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从语义上讲，这两段代码可能是相同的，但它们的实现通常是不同的。`if..then..elseif..else..endif` 链会对序列中的每个条件语句进行比较，而
    `switch` 语句通常使用间接跳转，通过一次计算将控制转移到多个语句中的任何一个。考虑上述给出的两个示例；它们可以通过以下代码用汇编语言编写：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The implementation of the `if..then..elseif..else..endif` version is fairly
    obvious and needs little in the way of explanation. The indirect jump version,
    however, is probably quite mysterious to you, so let's consider how this particular
    implementation of the `switch` statement works.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`if..then..elseif..else..endif` 版本的实现非常明显，几乎不需要什么解释。然而，间接跳转版本可能对你来说相当神秘，因此让我们考虑一下这个特定的
    `switch` 语句实现是如何工作的。'
- en: Remember that there are three common forms of the `jmp` instruction. The standard
    unconditional `jmp` instruction, like the `jmp EndCase`; instruction in the previous
    examples, transfers control directly to the statement label specified as the `jmp`
    operand. The second form of the `jmp` instruction—`jmp(` *`reg32`* `);`— transfers
    control to the memory location specified by the address found in a 32-bit register.
    The third form of the `jmp` instruction, the one the previous example uses, transfers
    control to the instruction specified by the contents of a double-word memory location.
    As this example clearly illustrates, that memory location can use any addressing
    mode. You are not limited to the displacement-only addressing mode. Now let's
    consider exactly how this second implementation of the `switch` statement works.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`jmp` 指令有三种常见形式。标准的无条件 `jmp` 指令，如前面的 `jmp EndCase` 指令，会直接将控制转移到 `jmp` 操作数指定的语句标签。第二种
    `jmp` 指令形式是 `jmp(` *`reg32`* `);`，它将控制转移到由 32 位寄存器中找到的地址指定的内存位置。第三种 `jmp` 指令形式是前面示例中使用的，它将控制转移到由双字内存位置内容指定的指令。正如这个示例清楚地展示的那样，那个内存位置可以使用任何寻址方式。你不局限于仅使用位移寻址方式。现在让我们仔细考虑一下
    `switch` 语句第二种实现方式是如何工作的。
- en: To begin with, a `switch` statement requires that you create an array of pointers
    with each element containing the address of a statement label in your code (those
    labels must be attached to the sequence of instructions to execute for each case
    in the `switch` statement). In the example above, the `JmpTbl` array serves this
    purpose. Note that this code initializes `JmpTbl` with the address of the statement
    labels `Stmt0`, `Stmt1`, and `Stmt2`. The program places this array in the `readonly`
    section because the program should never change these values during execution.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`switch` 语句要求你创建一个指针数组，每个元素包含代码中某个语句标签的地址（这些标签必须附加到每个 `switch` 语句中的执行语句序列）。在上面的示例中，`JmpTbl`
    数组就起到了这个作用。请注意，这段代码用语句标签 `Stmt0`、`Stmt1` 和 `Stmt2` 的地址初始化了 `JmpTbl`。程序将这个数组放置在
    `readonly` 区段中，因为程序在执行过程中不应改变这些值。
- en: Warning
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Whenever you initialize an array with a set of addresses of statement labels
    as in this example, the declaration section in which you declare the array (e.g.,
    `readonly` in this case) must be in the same procedure that contains the statement
    labels.^([[107](#ftn.CHP-7-FN-3)])
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你用一组语句标签的地址初始化数组时，就像这个示例中一样，你声明数组的部分（例如此例中的 `readonly`）必须与包含语句标签的同一个过程在一起。^([[107](#ftn.CHP-7-FN-3)])
- en: During the execution of this code sequence, the program loads the EAX register
    with `i`'s value. Then the program uses this value as an index into the `JmpTbl`
    array and transfers control to the 4-byte address found at the specified location.
    For example, if EAX contains 0, the `jmp( JmpTbl[eax*4] );` instruction will fetch
    the double word at address `JmpTbl+0 ( eax*4=0 )`. Because the first double word
    in the table contains the address of `Stmt0`, the `jmp` instruction transfers
    control to the first instruction following the `Stmt0` label. Likewise, if `i`
    (and therefore, EAX) contains 1, then the indirect `jmp` instruction fetches the
    double word at offset 4 from the table and transfers control to the first instruction
    following the `Stmt1` label (because the address of `Stmt1` appears at offset
    4 in the table). Finally, if `i`/EAX contains 2, then this code fragment transfers
    control to the statements following the `Stmt2` label because it appears at offset
    8 in the `JmpTbl` table.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此代码序列时，程序将`i`的值加载到EAX寄存器中。然后程序使用该值作为`JmpTbl`数组的索引，并将控制权转移到指定位置的4字节地址。例如，如果EAX中包含0，`jmp(
    JmpTbl[eax*4] );`指令将获取地址`JmpTbl+0 ( eax*4=0 )`处的双字数据。因为表中的第一个双字包含`Stmt0`的地址，所以`jmp`指令将控制权转移到`Stmt0`标签后的第一条指令。同样，如果`i`（因此EAX）包含1，那么间接`jmp`指令将获取表中偏移量为4的双字，并将控制权转移到`Stmt1`标签后的第一条指令（因为`Stmt1`的地址出现在表的偏移量4处）。最后，如果`i`/EAX包含2，那么这段代码将控制权转移到`JmpTbl`表中偏移量为8处的`Stmt2`标签后的语句。
- en: You should note that as you add more (consecutive) cases, the jump table implementation
    becomes more efficient (in terms of both space and speed) than the `if/elseif`
    form. Except for simple cases, the `switch` statement is almost always faster
    and usually by a large margin. As long as the `case` values are consecutive, the
    `switch` statement version is usually smaller as well.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意，当你添加更多（连续的）`case`时，跳转表实现比`if/elseif`形式更高效（无论在空间还是速度方面）。除非是简单的情况，`switch`语句几乎总是更快，而且通常差距较大。只要`case`值是连续的，`switch`语句版本通常也更小。
- en: What happens if you need to include nonconsecutive `case` labels or you cannot
    be sure that the `switch` value doesn't go out of range? With the HLA `switch`
    statement, such an occurrence will transfer control to the first statement after
    the `endswitch` clause (or to a `default` case, if one is present in the switch).
    However, this doesn't happen in the example above. If variable `i` does not contain
    0, 1, or 2, executing the code above produces undefined results. For example,
    if `i` contains 5 when you execute the code in the previous example, the indirect
    `jmp` instruction will fetch the dword at offset 20 (5 * 4) in `JmpTbl` and transfer
    control to that address. Unfortunately, `JmpTbl` doesn't have six entries; so
    the program will wind up fetching the value of the third double word following
    `JmpTbl` and use that as the target address. This will often crash your program
    or transfer control to an unexpected location.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要包含不连续的`case`标签，或者你不能确保`switch`值不会超出范围，会发生什么情况？对于HLA的`switch`语句，出现这种情况时会将控制转移到`endswitch`语句后的第一条语句（或者转移到`default`语句，如果`switch`中存在`default`）。然而，在上面的例子中并没有发生这种情况。如果变量`i`不包含0、1或2，执行上面的代码将产生未定义的结果。例如，如果在执行上面代码时，`i`的值为5，那么间接`jmp`指令将获取`JmpTbl`中偏移量为20（5
    * 4）处的双字，并将控制权转移到该地址。不幸的是，`JmpTbl`中没有六个条目；因此，程序将最终获取`JmpTbl`后第三个双字的值，并将其作为目标地址。这通常会导致程序崩溃，或者将控制转移到一个意外的位置。
- en: 'The solution is to place a few instructions before the indirect `jmp` to verify
    that the `switch` selection value is within some reasonable range. In the previous
    example, we''d probably want to verify that `i`''s value is in the range 0..2
    before executing the `jmp` instruction. If `i`''s value is outside this range,
    the program should simply jump to the `endcase` label (this corresponds to dropping
    down to the first statement after the `endswitch` clause). The following code
    provides this modification:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在间接`jmp`指令之前放置几条指令，以验证`switch`选择值是否在合理范围内。在之前的例子中，我们可能希望在执行`jmp`指令之前验证`i`的值是否在0..2的范围内。如果`i`的值超出此范围，程序应该直接跳转到`endcase`标签（这对应于跳到`endswitch`语句后的第一条语句）。以下代码实现了这一修改：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Although the example above handles the problem of selection values being outside
    the range 0..2, it still suffers from a couple of severe restrictions:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上面的例子处理了选择值超出0..2范围的问题，但它仍然存在几个严重的限制：
- en: The cases must start with the value 0\. That is, the minimum `case` constant
    has to be 0 in this example.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各个`case`必须从值0开始。也就是说，在这个示例中，最小的`case`常量必须是0。
- en: The case values must be contiguous.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case`值必须是连续的。'
- en: 'Solving the first problem is easy, and you deal with it in two steps. First,
    you must compare the case selection value against a lower and upper bounds before
    determining if the case value is legal. For example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 解决第一个问题很简单，且你可以通过两步来处理。首先，必须将`case`选择值与下限和上限进行比较，以确定该`case`值是否合法。例如：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As you can see, this code adds a pair of extra instructions, `cmp` and `jb`,
    to test the selection value to ensure it is in the range 5..7\. If not, control
    drops down to the `EndCase` label; otherwise control transfers via the indirect
    `jmp` instruction. Unfortunately, as the comments point out, this code is broken.
    Consider what happens if variable `i` contains the value 5: the code will verify
    that 5 is in the range 5..7 and then it will fetch the dword at offset 20 (`5*@size(dword)`)
    and jump to that address. As before, however, this loads 4 bytes outside the bounds
    of the table and does not transfer control to a defined location. One solution
    is to subtract the smallest case selection value from EAX before executing the
    `jmp` instruction, as shown in the following example.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码增加了一对额外的指令`cmp`和`jb`，用于测试选择值是否在5到7的范围内。如果不在范围内，控制会跳转到`EndCase`标签；否则，控制通过间接的`jmp`指令转移。遗憾的是，正如评论所指出的，这段代码存在问题。考虑如果变量`i`包含值5时会发生什么：代码会验证5是否在5到7的范围内，然后它会取偏移量为20的dword（`5*@size(dword)`）并跳转到该地址。然而，和之前一样，这会加载超出表格边界的4个字节，并不会将控制转移到已定义的位置。一种解决方案是在执行`jmp`指令之前，从EAX中减去最小的`case`选择值，如下面的示例所示。
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: By subtracting 5 from the value in EAX, this code forces EAX to take on the
    value 0, 1, or 2 prior to the `jmp` instruction. Therefore, case-selection value
    5 jumps to `Stmt5`, case-selection value 6 transfers control to `Stmt6`, and case-selection
    value 7 jumps to `Stmt7`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从EAX中的值减去5，这段代码强制EAX的值为0、1或2，紧接着是`jmp`指令。因此，`case`选择值为5时跳转到`Stmt5`，`case`选择值为6时跳转到`Stmt6`，`case`选择值为7时跳转到`Stmt7`。
- en: 'There is a sneaky way to improve the code above. You can eliminate the `sub`
    instruction by merging this subtraction into the `jmp` instruction''s address
    expression. Consider the following code that does this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种巧妙的方法可以改进上述代码。你可以通过将这个减法合并到`jmp`指令的地址表达式中，从而消除`sub`指令。考虑下面的代码，它实现了这一点：
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The HLA `switch` statement provides a `default` clause that executes if the
    case-selection value doesn''t match any of the case values. For example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: HLA `switch`语句提供了一个`default`子句，如果`case`选择值与任何`case`值不匹配，则执行该子句。例如：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Implementing the equivalent of the `default` clause in pure assembly language
    is very easy. Just use a different target label in the `jb` and `ja` instructions
    at the beginning of the code. The following example implements an HLA `switch`
    statement similar to the one immediately above:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯汇编语言中实现`default`子句的等效功能非常简单。只需在代码开头的`jb`和`ja`指令中使用不同的目标标签。以下示例实现了一个类似于上面那个的HLA
    `switch`语句：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The second restriction noted earlier, that the case values need to be contiguous,
    is easy to handle by inserting extra entries into the jump table. Consider the
    following HLA `switch` statement:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的第二个限制，即`case`值需要是连续的，可以通过在跳转表中插入额外的条目来轻松处理。考虑以下HLA `switch`语句：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The minimum switch value is 1 and the maximum value is 8\. Therefore, the code
    before the indirect `jmp` instruction needs to compare the value in EBX against
    1 and 8\. If the value is between 1 and 8, it''s still possible that EBX might
    not contain a legal case-selection value. However, because the `jmp` instruction
    indexes into a table of double words using the case-selection table, the table
    must have eight double-word entries. To handle the values between 1 and 8 that
    are not case-selection values, simply put the statement label of the `default`
    clause (or the label specifying the first instruction after the `endswitch` if
    there is no `default` clause) in each of the jump table entries that don''t have
    a corresponding `case` clause. The following code demonstrates this technique:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的`switch`值是1，最大值是8。因此，在间接`jmp`指令之前的代码需要将EBX中的值与1和8进行比较。如果该值在1和8之间，仍然可能EBX不包含一个合法的`case`选择值。然而，因为`jmp`指令使用`case`选择表索引到双字表，所以表必须包含八个双字条目。为了处理介于1和8之间但不是`case`选择值的值，只需将`default`子句的语句标签（或者如果没有`default`子句，则是指定`endswitch`后第一条指令的标签）放入每个没有对应`case`子句的跳转表条目中。以下代码演示了这一技术：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There is a problem with this implementation of the `switch` statement. If the
    `case` values contain nonconsecutive entries that are widely spaced, the jump
    table could become exceedingly large. The following `switch` statement would generate
    an extremely large code file:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`switch`语句的实现存在一个问题。如果`case`值包含不连续的条目且间隔较大，跳转表可能会变得非常大。以下`switch`语句会生成一个极其庞大的代码文件：
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this situation, your program will be much smaller if you implement the `switch`
    statement with a sequence of `if` statements rather than using an indirect jump
    statement. However, keep one thing in mind—the size of the jump table does not
    normally affect the execution speed of the program. If the jump table contains
    two entries or two thousand, the `switch` statement will execute the multiway
    branch in a constant amount of time. The `if` statement implementation requires
    a linearly increasing amount of time for each `case` label appearing in the `case`
    statement.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果你用一系列的`if`语句来实现`switch`语句，而不是使用间接跳转语句，那么你的程序将会更小。然而，要记住一点——跳转表的大小通常不会影响程序的执行速度。如果跳转表包含两个条目或两千个条目，`switch`语句将在恒定的时间内执行多重分支。`if`语句的实现则要求随着每个`case`标签的出现，所需的时间按线性方式增加。
- en: 'Probably the biggest advantage to using assembly language over an HLL like
    Pascal or C/C++ is that you get to choose the actual implementation of statements
    like `switch`. In some instances you can implement a `switch` statement as a sequence
    of `if..then..elseif` statements, or you can implement it as a jump table, or
    you can use a hybrid of the two:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用汇编语言而不是像Pascal或C/C++这样的高级语言最大的优势之一就是你可以选择语句（如`switch`）的实际实现方式。在某些情况下，你可以将`switch`语句实现为一系列的`if..then..elseif`语句，或者实现为一个跳转表，或者两者结合使用：
- en: '[PRE70]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This could become
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能变成
- en: '[PRE71]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Of course, HLA supports the following code high-level control structures:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，HLA支持以下代码高级控制结构：
- en: '[PRE72]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: But this tends to destroy the readability of the program. On the other hand,
    the extra code to test for 100 in the assembly language code doesn't adversely
    affect the readability of the program (perhaps because it's so hard to read already).
    Therefore, most people will add the extra code to make their program more efficient.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 但这往往会破坏程序的可读性。另一方面，汇编语言代码中用于测试100的额外代码不会对程序的可读性产生不利影响（也许是因为它本身就已经很难读了）。因此，大多数人会添加额外的代码，以提高程序的效率。
- en: 'The C/C++ `switch` statement is very similar to the HLA `switch` statement.
    There is only one major semantic difference: The programmer must explicitly place
    a `break` statement in each `case` clause to transfer control to the first statement
    beyond the `switch`. This `break` corresponds to the `jmp` instruction at the
    end of each `case` sequence in the assembly code above. If the corresponding `break`
    is not present, C/C++ transfers control into the code of the following `case`.
    This is equivalent to leaving off the `jmp` at the end of the `case`''s sequence:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++的`switch`语句与HLA的`switch`语句非常相似。唯一的主要语义区别是：程序员必须在每个`case`子句中显式地放置一个`break`语句，将控制转移到`switch`语句之外的第一条语句。这个`break`对应于上述汇编代码中每个`case`序列末尾的`jmp`指令。如果没有相应的`break`，C/C++会将控制转移到下一个`case`的代码中。这相当于在`case`序列末尾省略`jmp`指令：
- en: '[PRE73]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This translates into the following 80x86 code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码转换成了以下 80x86 代码：
- en: '[PRE74]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '* * *'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[106](#CHP-7-FN-2)]) However, be aware of the fact that some expressions
    depend on the leftmost subexpression evaluating one way in order for the rightmost
    subexpression to be valid; for example, a common test in C/C++ is `if( x != NULL
    && x->y )...`
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[106](#CHP-7-FN-2)]) 然而，要注意某些表达式依赖于最左边的子表达式以某种方式求值，以便最右边的子表达式有效；例如，C/C++
    中常见的测试是 `if( x != NULL && x->y )...`
- en: ^([[107](#CHP-7-FN-3)]) If the `switch` statement appears in your main program,
    you must declare the array in the declaration section of your main program.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[107](#CHP-7-FN-3)]) 如果 `switch` 语句出现在你的主程序中，你必须在主程序的声明部分声明数组。
- en: 7.8 State Machines and Indirect Jumps
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.8 状态机和间接跳转
- en: Another control structure commonly found in assembly language programs is the
    *state machine*. A state machine uses a *state variable* to control program flow.
    The FORTRAN programming language provides this capability with the assigned `goto`
    statement. Certain variants of C (for example, GNU's GCC from the Free Software
    Foundation) provide similar features. In assembly language, the indirect jump
    can implement state machines.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在汇编语言程序中常见的控制结构是 *状态机*。状态机使用 *状态变量* 来控制程序流程。FORTRAN 编程语言通过赋值的 `goto` 语句提供了这一功能。某些
    C 语言的变种（例如，GNU 的 GCC 编译器）也提供了类似的功能。在汇编语言中，间接跳转可以实现状态机。
- en: So what is a state machine? In very basic terms, it is a piece of code that
    keeps track of its execution history by entering and leaving certain "states."
    For the purposes of this chapter, we'll just assume that a state machine is a
    piece of code that (somehow) remembers the history of its execution (its *state*)
    and executes sections of code based on that history.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是状态机呢？用最基本的话来说，它是一段通过进入和离开某些“状态”来跟踪其执行历史的代码。对于本章的目的，我们假设状态机是一个能够（以某种方式）记住其执行历史（其
    *状态*）并根据该历史执行代码段的程序。
- en: In a very real sense, all programs are state machines. The CPU registers and
    values in memory constitute the state of that machine. However, we'll use a much
    more constrained view. Indeed, for most purposes only a single variable (or the
    value in the EIP register) will denote the current state.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上讲，所有程序都是状态机。CPU 寄存器和内存中的值构成了该机器的状态。然而，我们将采用更为受限的视角。实际上，在大多数情况下，只有一个变量（或
    EIP 寄存器中的值）会表示当前状态。
- en: 'Now let''s consider a concrete example. Suppose you have a procedure that you
    want to perform one operation the first time you call it, a different operation
    the second time you call it, yet something else the third time you call it, and
    then something new again on the fourth call. After the fourth call it repeats
    these four different operations in order. For example, suppose you want the procedure
    to add EAX and EBX the first time, subtract them on the second call, multiply
    them on the third, and divide them on the fourth. You could implement this procedure
    as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个具体的例子。假设你有一个过程，第一次调用时执行一个操作，第二次调用时执行不同的操作，第三次调用时执行另一个操作，然后在第四次调用时执行一个新的操作。在第四次调用之后，它会按顺序重复这四个不同的操作。例如，假设你希望过程在第一次时将
    EAX 和 EBX 相加，第二次时进行减法，第三次时进行乘法，第四次时进行除法。你可以通过以下方式实现这个过程：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Technically, this procedure is not the state machine. Instead, it is the variable
    `State` and the `cmp`/`jne` instructions that constitute the state machine.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这个过程并不是状态机。实际上，正是变量 `State` 和 `cmp`/`jne` 指令构成了状态机。
- en: There is nothing particularly special about this code. It's little more than
    a `switch` statement implemented via the `if..then..elseif` construct. The only
    thing unique about this procedure is that it remembers how many times it has been
    called^([[108](#ftn.CHP-7-FN-4)]) and behaves differently depending upon the number
    of calls. While this is a *correct* implementation of the desired state machine,
    it is not particularly efficient. The astute reader, of course, would recognize
    that this code could be made a little faster using an actual `switch` statement
    rather than the `if..then..elseif` implementation. However, there is an even better
    solution.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有什么特别之处。它不过是通过 `if..then..elseif` 结构实现的 `switch` 语句。这个过程唯一不同之处在于它记住了它被调用的次数^([[108](#ftn.CHP-7-FN-4)])，并根据调用的次数表现出不同的行为。虽然这是一个*正确的*状态机实现，但它的效率并不高。聪明的读者当然会认识到，使用实际的
    `switch` 语句而非 `if..then..elseif` 实现，可以使这段代码运行得更快。然而，还有一个更好的解决方案。
- en: 'A common implementation of a state machine in assembly language is to use an
    indirect jump. Rather than having a state variable that contains a value like
    0, 1, 2, or 3, we could load the state variable with the *address* of the code
    to execute upon entry into the procedure. By simply jumping to that address, the
    state machine could save the tests needed to select the proper code fragment.
    Consider the following implementation using the indirect jump:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，状态机的一种常见实现方式是使用间接跳转。我们可以将状态变量加载为代码执行入口时的*地址*，而不是让状态变量包含像 0、1、2 或 3 这样的值。通过简单地跳转到该地址，状态机可以省略选择合适代码片段所需的测试。考虑以下使用间接跳转的实现：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `jmp` instruction at the beginning of the `StateMachine` procedure transfers
    control to the location pointed at by the `State` variable. The first time you
    call `StateMachine` it points at the `State0` label. Thereafter, each subsection
    of code sets the `State` variable to point at the appropriate successor code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateMachine`过程开始时的`jmp`指令将控制转移到`State`变量所指向的位置。第一次调用`StateMachine`时，它指向`State0`标签。此后，每个代码子段都将`State`变量设置为指向相应的后续代码。'
- en: '* * *'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[108](#CHP-7-FN-4)]) Actually, it remembers how many times, `modulo 4`, that
    it has been called.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[108](#CHP-7-FN-4)]) 实际上，它记住了被调用的次数，并取模4。
- en: 7.9 Spaghetti Code
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.9 意大利面代码
- en: One major problem with assembly language is that it takes several statements
    to realize a simple idea encapsulated by a single high-level language statement.
    All too often an assembly language programmer will notice that she or he can save
    a few bytes or cycles by jumping into the middle of some program structure. After
    a few such observations (and corresponding modifications) the code contains a
    whole sequence of jumps in and out of portions of the code. If you were to draw
    a line from each jump to its destination, the resulting listing would end up looking
    like someone dumped a bowl of spaghetti on your code, hence the term *spaghetti
    code*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言的一个主要问题是，它需要多个语句才能实现一个高级语言中用单个语句封装的简单思想。汇编语言程序员常常会注意到，通过跳转到程序结构的中间某处，可以节省几个字节或时钟周期。经过几次这样的观察（并做出相应修改），代码中就包含了一系列跳转进出代码的操作。如果你画出每个跳转到其目标位置的线，最终得到的代码列表就像有人把一碗意大利面撒在你的代码上一样，因此这个术语叫做*意大利面代码*。
- en: Spaghetti code suffers from one major drawback—it's difficult (at best) to read
    such a program and figure out what it does. Most programs start out in a "structured"
    form only to become spaghetti code when sacrificed at the altar of efficiency.
    Alas, spaghetti code is rarely efficient. Because it's difficult to figure out
    exactly what's going on, it's very difficult to determine if you can use a better
    algorithm to improve the system. Hence, spaghetti code may wind up less efficient
    than structured code.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码有一个主要的缺点——阅读这样的程序并弄清楚它的功能非常困难（即使勉强能读懂）。大多数程序起初是“结构化”的，但在追求效率的过程中往往变成意大利面代码。遗憾的是，意大利面代码很少高效。由于很难准确弄清楚程序在做什么，因此很难判断是否可以使用更好的算法来改进系统。因此，意大利面代码可能最终比结构化代码更低效。
- en: While it's true that producing some spaghetti code in your programs may improve
    its efficiency, doing so should always be a last resort after you've tried everything
    else and you still haven't achieved what you need. Always start out writing your
    programs with straightforward `if` and `switch` statements. Start combining sections
    of code (via `jmp` instructions) once everything is working and well understood.
    Of course, you should never obliterate the structure of your code unless the gains
    are worth it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在程序中写出一些意大利面代码可能会提高效率，但这应该始终是最后的手段，前提是你已经尝试过所有其他方法，并且仍然没有达到所需的效果。编写程序时，始终从简单的`if`和`switch`语句开始。当一切正常并且已经理解时，再开始通过`jmp`指令组合代码段。当然，除非收益足够大，否则你绝不应该破坏代码的结构。
- en: A famous saying in structured programming circles is, "After `goto`s, pointers
    are the next most dangerous element in a programming language." A similar saying
    is "Pointers are to data structures what `goto`s are to control structures." In
    other words, avoid excessive use of pointers. If pointers and `goto`s are bad,
    then the indirect jump must be the worst construct of all because it involves
    both `goto`s and pointers! Seriously, though, the indirect jump instruction should
    be avoided for casual use. Its use tends to make a program harder to read. After
    all, an indirect jump can (theoretically) transfer control to any point within
    a program. Imagine how hard it would be to follow the flow through a program if
    you have no idea what a pointer contains and you come across an indirect jump
    using that pointer. Therefore, you should always exercise care when using jump
    indirect instructions.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构化编程圈子里有一句名言：“在 `goto` 之后，指针是编程语言中最危险的元素。”另一句类似的名言是：“指针对数据结构的作用，就像 `goto`
    对控制结构的作用。”换句话说，要避免过度使用指针。如果 `goto` 和指针都不好，那么间接跳转肯定是最糟糕的构造，因为它涉及到 `goto` 和指针！不过，说正经的，间接跳转指令应该避免随意使用。它的使用往往会使程序更难以阅读。毕竟，间接跳转（理论上）可以将控制转移到程序中的任何位置。想象一下，如果你不知道指针包含什么，而你遇到了一个使用该指针的间接跳转，那么要跟踪程序的执行流程会有多困难。因此，在使用间接跳转指令时，应该始终小心谨慎。
- en: 7.10 Loops
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.10 循环
- en: Loops represent the final basic control structure (sequences, decisions, and
    loops) that make up a typical program. Like so many other structures in assembly
    language, you'll find yourself using loops in places you've never dreamed of using
    loops. Most high-level languages have implied loop structures hidden away. For
    example, consider the BASIC statement `if A$ = B$ then 100`. This `if` statement
    compares two strings and jumps to statement 100 if they are equal. In assembly
    language, you would need to write a loop to compare each character in `A$` to
    the corresponding character in `B$` and then jump to statement 100 if and only
    if all the characters matched. In BASIC, there is no loop to be seen in the program.
    Assembly language requires a loop to compare the individual characters in the
    string.^([[109](#ftn.CHP-7-FN-5)]) This is but a small example that shows how
    loops seem to pop up everywhere.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是典型程序的最后一种基本控制结构（顺序、决策和循环）。像汇编语言中的许多其他结构一样，你会发现自己在从未想过使用循环的地方使用循环。大多数高级语言都有隐藏的隐式循环结构。例如，考虑
    BASIC 语句 `if A$ = B$ then 100`。此 `if` 语句比较两个字符串，如果它们相等，则跳转到语句 100。在汇编语言中，你需要编写一个循环来比较
    `A$` 中的每个字符与 `B$ 中对应的字符，然后仅当所有字符匹配时，才跳转到语句 100。在 BASIC 中，程序中看不见任何循环。汇编语言要求编写一个循环来比较字符串中的每个字符。^([[109](#ftn.CHP-7-FN-5)])
    这只是一个小例子，展示了循环如何似乎无处不在。
- en: 'Program loops consist of three components: an optional initialization component,
    an optional loop termination test, and the body of the loop. The order in which
    you assemble these components can dramatically affect the loop''s operation. Three
    permutations of these components appear frequently in programs. Because of their
    frequency, these loop structures are given special names in high-level languages:
    `while` loops, `repeat..until` loops (`do..while` in C/C++), and infinite loops
    (e.g., `forever..endfor` in HLA).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 程序循环由三个部分组成：一个可选的初始化部分，一个可选的循环终止测试，以及循环体。你组合这些部分的顺序会显著影响循环的操作。这些部分的三种排列方式在程序中非常常见。由于它们的频繁出现，这些循环结构在高级语言中有了特定的名称：`while`
    循环、`repeat..until` 循环（在 C/C++ 中是 `do..while`），以及无限循环（例如，在 HLA 中是 `forever..endfor`）。
- en: 7.10.1 while Loops
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.1 `while` 循环
- en: 'The most general loop is the `while` loop. In HLA''s high-level syntax it takes
    the following form:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最通用的循环是 `while` 循环。在 HLA 的高级语法中，它采用以下形式：
- en: '[PRE77]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There are two important points to note about the `while` loop. First, the test
    for termination appears at the beginning of the loop. Second, as a direct consequence
    of the position of the termination test, the body of the loop may never execute
    if the boolean expression is always false.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `while` 循环，有两点需要注意。首先，终止测试出现在循环的开始处。其次，由于终止测试的位置，循环体可能永远不会执行，如果布尔表达式始终为假。
- en: 'Consider the following HLA `while` loop:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下 HLA 的`while`循环：
- en: '[PRE78]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `mov( 0, i );` instruction is the initialization code for this loop. `i`
    is a loop-control variable, because it controls the execution of the body of the
    loop. `i < 100` is the loop termination condition. That is, the loop will not
    terminate as long as `i` is less than 100\. The single instruction `inc( i );`
    is the loop body that executes on each loop iteration.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov( 0, i );`指令是该循环的初始化代码。`i`是循环控制变量，因为它控制着循环体的执行。`i < 100`是循环的终止条件。也就是说，只要`i`小于100，循环就不会终止。单个指令`inc(
    i );`是每次循环迭代时执行的循环体。'
- en: 'Note that an HLA `while` loop can be easily synthesized using `if` and `jmp`
    statements. For example, you may replace the previous HLA `while` loop with the
    following HLA code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HLA的`while`循环可以通过`if`和`jmp`语句轻松合成。例如，你可以将之前的HLA `while`循环替换为以下HLA代码：
- en: '[PRE79]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'More generally, you can construct any `while` loop as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，你可以像下面这样构造任何`while`循环：
- en: '[PRE80]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Therefore, you can use the techniques from earlier in this chapter to convert
    if statements to assembly language and add a single `jmp` instruction to produce
    a `while` loop. The example we've been looking at in this section translates to
    the following pure 80x86 assembly code:^([[110](#ftn.CHP-7-FN-6)])
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用本章前面介绍的技术，将`if`语句转换为汇编语言，并添加一个`jmp`指令来生成`while`循环。我们在这一节中看到的例子可以转换为以下纯80x86汇编代码：^([[110](#ftn.CHP-7-FN-6)])
- en: '[PRE81]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 7.10.2 repeat..until Loops
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.2 repeat..until 循环
- en: 'The `repeat..until` (`do..while`) loop tests for the termination condition
    at the end of the loop rather than at the beginning. In HLA high-level syntax,
    the `repeat..until` loop takes the following form:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat..until`（`do..while`）循环在循环的末尾测试终止条件，而不是在开始时。在HLA的高级语法中，`repeat..until`循环采用以下形式：'
- en: '[PRE82]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This sequence executes the initialization code, then executes the loop body,
    and finally tests some condition to see if the loop should repeat. If the boolean
    expression evaluates to false, the loop repeats; otherwise the loop terminates.
    The two things you should note about the `repeat..until` loop are that the termination
    test appears at the end of the loop and, as a direct consequence of this, the
    loop body always executes at least once.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列先执行初始化代码，然后执行循环体，最后测试某个条件来判断循环是否应该重复。如果布尔表达式为假，循环会重复；否则循环终止。你应该注意`repeat..until`循环的两点：一是终止测试出现在循环的末尾，二是由于这一点，循环体总是至少执行一次。
- en: 'Like the `while` loop, the `repeat..until` loop can be synthesized with an
    `if` statement and a `jmp`. You could use the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`循环类似，`repeat..until`循环可以通过`if`语句和`jmp`指令来合成。你可以使用以下方式：
- en: '[PRE83]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Based on the material presented in the previous sections, you can easily synthesize
    `repeat..until` loops in assembly language. The following is a simple example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面章节介绍的内容，你可以轻松地在汇编语言中合成`repeat..until`循环。以下是一个简单的例子：
- en: '[PRE84]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 7.10.3 forever..endfor Loops
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.3 forever..endfor 循环
- en: 'If while loops test for termination at the beginning of the loop and `repeat..until`
    loops check for termination at the end of the loop, the only place left to test
    for termination is in the middle of the loop. The HLA high-level `forever..endfor`
    loop, combined with the `break` and `breakif` statements, provides this capability.
    The `forever..endfor` loop takes the following form:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`while`循环在循环开始时测试终止条件，而`repeat..until`循环在循环结束时检查终止条件，那么唯一可以测试终止的地方就是循环的中间。HLA高级`forever..endfor`循环结合`break`和`breakif`语句，提供了这种能力。`forever..endfor`循环采用以下形式：
- en: '[PRE85]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Note that there is no explicit termination condition. Unless otherwise provided
    for, the `forever..endfor` construct forms an infinite loop. A `breakif` statement
    usually handles loop termination. Consider the following HLA code that employs
    a `forever..endfor` construct:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`forever..endfor`构造没有显式的终止条件。除非另有规定，`forever..endfor`构造会形成一个无限循环。通常使用`breakif`语句来处理循环的终止。考虑以下使用`forever..endfor`构造的HLA代码：
- en: '[PRE86]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Converting a `forever` loop to pure assembly language is easy. All you need
    is a label and a `jmp` instruction. The `breakif` statement in this example is
    really nothing more than an `if` and a `jmp` instruction. The pure assembly language
    version of the code above looks something like the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 将`forever`循环转换为纯汇编语言很简单。你需要的只是一个标签和一个`jmp`指令。这个例子中的`breakif`语句实际上不过是一个`if`语句和一个`jmp`指令。上述代码的纯汇编语言版本看起来大概是这样的：
- en: '[PRE87]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 7.10.4 for Loops
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.4 for 循环
- en: 'The `for` loop is a special form of the `while` loop that repeats the loop
    body a specific number of times. In HLA, the `for` loop takes the following form:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环是 `while` 循环的一种特殊形式，它会重复执行循环体指定次数。在 HLA 中，`for` 循环的形式如下：'
- en: '[PRE88]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is completely equivalent to the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全等效于以下代码：
- en: '[PRE89]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Traditionally, programs use the for loop to process arrays and other objects
    accessed in sequential order. One normally initializes a loop-control variable
    with the initialization statement and then uses the loop-control variable as an
    index into the array (or other data type). For example:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，程序使用 `for` 循环来处理按顺序访问的数组和其他对象。通常，首先通过初始化语句初始化循环控制变量，然后使用该循环控制变量作为数组（或其他数据类型）的索引。例如：
- en: '[PRE90]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To convert this to pure assembly language, begin by translating the `for` loop
    into an equivalent `while` loop:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其转换为纯汇编语言，首先将 `for` 循环转换为等效的 `while` 循环：
- en: '[PRE91]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, using the techniques from the section on `while` loops, translate the
    code into pure assembly language:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `while` 循环部分中的技巧，将代码翻译成纯汇编语言：
- en: '[PRE92]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 7.10.5 The break and continue Statements
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.5 `break` 和 `continue` 语句
- en: The HLA `break` and `continue` statements both translate into a single `jmp`
    instruction. The `break` instruction exits the loop that immediately contains
    the `break` statement; the `continue` statement restarts the loop that immediately
    contains the `continue` statement.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 的 `break` 和 `continue` 语句都被翻译为单个 `jmp` 指令。`break` 指令会退出立即包含 `break` 语句的循环；`continue`
    语句会重新启动立即包含 `continue` 语句的循环。
- en: Converting a `break` statement to pure assembly language is very easy. Just
    emit a `jmp` instruction that transfers control to the first statement following
    the `end`*`xxxx`* (or `until`) clause of the loop to exit. You can do this by
    placing a label after the associated `end`*`xxxx`* clause and jumping to that
    label. The following code fragments demonstrate this technique for the various
    loops.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `break` 语句转换为纯汇编语言非常简单。只需发出一个 `jmp` 指令，将控制权转移到循环的 `end`*`xxxx`*（或 `until`）子句之后的第一条语句，以退出循环。可以通过在关联的
    `end`*`xxxx`* 子句后面放置一个标签并跳转到该标签来实现这一点。以下代码片段展示了这种技术在不同循环中的应用。
- en: '[PRE93]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `continue` statement is slightly more complex than the `break` statement.
    The implementation is still a single `jmp` instruction; however, the target label
    doesn't wind up going in the same spot for each of the different loops. [Figure 7-2](ch07s10.html#continue_destination_for_the_forever_loo
    "Figure 7-2. continue destination for the forever loop"), [Figure 7-3](ch07s10.html#continue_destination_and_the_while_loop
    "Figure 7-3. continue destination and the while loop"), [Figure 7-4](ch07s10.html#continue_destination_and_the_for_loop
    "Figure 7-4. continue destination and the for loop"), and [Figure 7-5](ch07s10.html#continue_destination_and_the_repeat..unt
    "Figure 7-5. continue destination and the repeat..until loop") show where the
    `continue` statement transfers control for each of the HLA loops.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句比 `break` 语句稍微复杂一些。实现仍然是单个 `jmp` 指令；但是，目标标签并不是每个不同的循环都指向相同的位置。[图
    7-2](ch07s10.html#continue_destination_for_the_forever_loo "图 7-2. forever 循环的
    continue 目标"), [图 7-3](ch07s10.html#continue_destination_and_the_while_loop "图
    7-3. continue 目标和 while 循环"), [图 7-4](ch07s10.html#continue_destination_and_the_for_loop
    "图 7-4. continue 目标和 for 循环"), 和 [图 7-5](ch07s10.html#continue_destination_and_the_repeat..unt
    "图 7-5. continue 目标和 repeat..until 循环") 显示了 `continue` 语句在每个 HLA 循环中如何转移控制。'
- en: '![continue destination for the forever loop](tagoreillycom20100401nostarchimages578035.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![forever 循环的 continue 目标](tagoreillycom20100401nostarchimages578035.png)'
- en: Figure 7-2. `continue` destination for the `forever` loop
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2. `continue` 目标用于 `forever` 循环
- en: '![continue destination and the while loop](tagoreillycom20100401nostarchimages578037.png.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![continue 目标和 while 循环](tagoreillycom20100401nostarchimages578037.png.jpg)'
- en: Figure 7-3. `continue` destination and the `while` loop
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3. `continue` 目标和 `while` 循环
- en: '![continue destination and the for loop](tagoreillycom20100401nostarchimages578039.png.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![continue 目标和 for 循环](tagoreillycom20100401nostarchimages578039.png.jpg)'
- en: Figure 7-4. `continue` destination and the `for` loop
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4. `continue` 目标和 `for` 循环
- en: '![continue destination and the repeat..until loop](tagoreillycom20100401nostarchimages578041.png.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![continue 目标和 repeat..until 循环](tagoreillycom20100401nostarchimages578041.png.jpg)'
- en: Figure 7-5. `continue` destination and the `repeat..until` loop
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-5. `continue` 目标和 `repeat..until` 循环
- en: The following code fragments demonstrate how to convert the `continue` statement
    into an appropriate `jmp` instruction for each of these loop types.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何将`continue`语句转换为每种循环类型的适当`jmp`指令。
- en: forever..continue..endfor
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: forever..continue..endfor
- en: '[PRE94]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: while..continue..endwhile
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while..continue..endwhile
- en: '[PRE95]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: for..continue..endfor
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for..continue..endfor
- en: '[PRE96]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: repeat..continue..until
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: repeat..continue..until
- en: '[PRE97]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 7.10.6 Register Usage and Loops
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.6 寄存器使用与循环
- en: 'Given that the 80x86 accesses registers more efficiently than memory locations,
    registers are the ideal spot to place loop-control variables (especially for small
    loops). However, there are some problems associated with using registers within
    a loop. The primary problem with using registers as loop-control variables is
    that registers are a limited resource. The following will not work properly because
    it attempts to reuse a register (CX) that is already in use:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到80x86比内存位置更有效地访问寄存器，寄存器是放置循环控制变量的理想位置（特别是对于小循环）。然而，在循环中使用寄存器会遇到一些问题。使用寄存器作为循环控制变量的主要问题是寄存器是有限资源。以下代码由于尝试重用已经在使用的寄存器（CX）而无法正常工作：
- en: '[PRE98]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The intent here, of course, was to create a set of nested loops, that is, one
    loop inside another. The inner loop (`loop2`) should repeat four times for each
    of the eight executions of the outer loop (`loop1`). Unfortunately, both loops
    use the same register as a loop-control variable. Therefore, this will form an
    infinite loop because CX will contain 0 at the end of the first loop. Because
    CX is always 0 upon encountering the second `dec` instruction, control will always
    transfer to the `loop1` label (because decrementing 0 produces a nonzero result).
    The solution here is to save and restore the CX register or to use a different
    register in place of CX for the outer loop:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是创建一组嵌套的循环，即一个循环嵌套在另一个循环中。内层循环（`loop2`）应在外层循环（`loop1`）执行八次的过程中重复四次。不幸的是，两个循环都使用了相同的寄存器作为循环控制变量。因此，这将形成一个无限循环，因为在第一次循环结束时，CX的值会变为0。由于在遇到第二个`dec`指令时，CX总是为0，控制会一直跳转到`loop1`标签（因为递减0会产生非零结果）。解决方案是保存并恢复CX寄存器，或者在外层循环中使用不同的寄存器替代CX：
- en: '[PRE99]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: or
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE100]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Register corruption is one of the primary sources of bugs in loops in assembly
    language programs, so always keep an eye out for this problem.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器损坏是汇编语言程序中循环出现错误的主要来源之一，因此要时刻注意这个问题。
- en: '* * *'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[109](#CHP-7-FN-5)]) Of course, the HLA Standard Library provides the `str.eq`
    routine that compares the strings for you, effectively hiding the loop even in
    an assembly language program.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[109](#CHP-7-FN-5)]) 当然，HLA标准库提供了`str.eq`例程，用于比较字符串，从而有效地隐藏了循环，即使在汇编语言程序中也是如此。
- en: ^([[110](#CHP-7-FN-6)]) Note that HLA will actually convert most `while` statements
    to different 80x86 code than this section presents. The reason for the difference
    appears in [7.11 Performance Improvements](ch07s11.html "7.11 Performance Improvements"),
    when we explore how to write more efficient loop code.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[110](#CHP-7-FN-6)]) 请注意，HLA实际上会将大多数`while`语句转换为与本节所示不同的80x86代码。差异的原因出现在[7.11
    性能优化](ch07s11.html "7.11 性能优化")中，当我们探索如何编写更高效的循环代码时。
- en: 7.11 Performance Improvements
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.11 性能优化
- en: The 80x86 microprocessors execute sequences of instructions at blinding speed.
    Therefore, you'll rarely encounter a slow program that doesn't contain any loops.
    Because loops are the primary source of performance problems within a program,
    they are the place to look when attempting to speed up your software. While a
    treatise on how to write efficient programs is beyond the scope of this chapter,
    there are some things you should be aware of when designing loops in your programs.
    They're all aimed at removing unnecessary instructions from your loops in order
    to reduce the time it takes to execute a single iteration of the loop.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86微处理器以惊人的速度执行指令序列。因此，你很少会遇到不包含循环的慢程序。因为循环是程序性能问题的主要来源，它们是你在尝试加速软件时需要重点关注的地方。虽然关于如何编写高效程序的论文超出了本章的范围，但在设计程序中的循环时，有一些事情你需要注意。这些都是为了从循环中去除不必要的指令，以减少执行一次循环所需的时间。
- en: 7.11.1 Moving the Termination Condition to the End of a Loop
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11.1 将终止条件移到循环末尾
- en: 'Consider the following flow graphs for the three types of loops presented earlier:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下为前三种类型的循环展示的流程图：
- en: '[PRE101]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'As you can see, the `repeat..until` loop is the simplest of the bunch. This
    is reflected in the assembly language implementation of these loops. Consider
    the following `repeat..until` and `while` loops that are semantically identical:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`repeat..until`循环是其中最简单的一种。这在这些循环的汇编语言实现中得到了体现。考虑以下语义完全相同的`repeat..until`和`while`循环：
- en: '[PRE102]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'As you can see by carefully studying the conversion to pure assembly language,
    testing for the termination condition at the end of the loop allowed us to remove
    a `jmp` instruction from the loop. This can be significant if this loop is nested
    inside other loops. In the preceding example there wasn''t a problem with executing
    the body at least once. Given the definition of the loop, you can easily see that
    the loop will be executed exactly 20 times. This suggests that the conversion
    to a `repeat..until` loop is trivial and always possible. Unfortunately, it''s
    not always quite this easy. Consider the following HLA code:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 正如通过仔细研究转换为纯汇编语言所看到的，在循环末尾测试终止条件使我们能够从循环中移除一个`jmp`指令。如果这个循环嵌套在其他循环中，这可能会很重要。在前面的例子中，执行循环体至少一次没有问题。根据循环的定义，你可以轻松看到该循环将被执行恰好20次。这表明转换为`repeat..until`循环是微不足道的，并且总是可能的。不幸的是，事情并不总是如此简单。考虑以下HLA代码：
- en: '[PRE103]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In this particular example, we haven''t the slightest idea what ESI contains
    upon entry into the loop. Therefore, we cannot assume that the loop body will
    execute at least once. So we must test for loop termination before executing the
    body of the loop. The test can be placed at the end of the loop with the inclusion
    of a single `jmp` instruction:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们根本不知道ESI在进入循环时包含什么内容。因此，我们不能假设循环体至少会执行一次。因此，我们必须在执行循环体之前测试循环是否终止。测试可以放在循环的末尾，并包括一个`jmp`指令：
- en: '[PRE104]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Although the code is as long as the original `while` loop, the `jmp` instruction
    executes only once rather than on each repetition of the loop. Note that this
    slight gain in efficiency is obtained via a slight loss in readability. The second
    code sequence above is closer to spaghetti code than the original implementation.
    Such is often the price of a small performance gain. Therefore, you should carefully
    analyze your code to ensure that the performance boost is worth the loss of clarity.
    More often than not, assembly language programmers sacrifice clarity for dubious
    gains in performance, producing impossible-to-understand programs.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码的长度与原始的`while`循环一样，`jmp`指令只执行一次，而不是每次循环时都执行。请注意，通过这种微小的效率提升，换来了可读性的小损失。上述第二段代码比原始实现更接近“意大利面条代码”。这往往是为了小幅性能提升所付出的代价。因此，你应该仔细分析代码，以确保性能提升是值得的，且不会失去清晰度。通常，汇编语言程序员为了可疑的性能提升而牺牲可读性，编写出难以理解的程序。
- en: Note, by the way, that HLA translates its high-level `while` statement into
    a sequence of instructions that test the loop termination condition at the bottom
    of the loop using exactly the technique this section describes.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，HLA将其高级的`while`语句转换为一系列指令，这些指令使用本节所描述的技术，在循环的底部测试循环终止条件。
- en: 7.11.2 Executing the Loop Backwards
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11.2 反向执行循环
- en: 'Because of the nature of the flags on the 80x86, loops that repeat from some
    number down to (or up to) 0 are more efficient than loops that execute from 0
    to some other value. Compare the following HLA `for` loop and the code it generates:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 由于80x86标志的特点，从某个数字递减到（或递增到）0的循环比从0执行到其他值的循环更高效。比较以下HLA的`for`循环及其生成的代码：
- en: '[PRE105]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now consider another loop that also has eight iterations but runs its loop-control
    variable from 8 down to 1 rather than 1 up to 8:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑另一个循环，它也有八次迭代，但它的循环控制变量是从8递减到1，而不是从1递增到8：
- en: '[PRE106]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note that by running the loop from 8 down to 1 we saved a comparison on each
    repetition of the loop.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过从8递减到1运行循环，我们节省了每次循环时的比较操作。
- en: Unfortunately, you cannot force all loops to run backward. However, with a little
    effort and some coercion you should be able to write many `for` loops so that
    they operate backward. Saving the execution time of the `cmp` instruction on each
    iteration of the loop may result in faster code.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你不能强制所有循环都向后运行。然而，稍加努力并做一些调整，你应该能够编写许多`for`循环，使它们反向运行。在每次循环迭代中节省`cmp`指令的执行时间，可能会导致更快的代码。
- en: 'The example above worked out well because the loop ran from 8 down to 1\. The
    loop terminated when the loop-control variable became 0\. What happens if you
    need to execute the loop when the loop-control variable goes to 0? For example,
    suppose that the loop above needed to range from 7 down to 0\. As long as the
    upper bound is positive, you can substitute the `jns` instruction in place of
    the `jnz` instruction in the earlier code:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例效果很好，因为循环从 8 执行到 1。当循环控制变量变为 0 时，循环终止。如果你需要在循环控制变量变为 0 时执行循环会发生什么呢？例如，假设上面的循环需要从
    7 执行到 0。只要上限是正数，你可以用 `jns` 指令替换之前代码中的 `jnz` 指令：
- en: '[PRE107]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This loop will repeat eight times, with `j` taking on the values 7..0\. When
    it decrements 0 to −1, it sets the sign flag and the loop terminates.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将重复八次，`j` 依次取值 7..0。当它将 0 减少到 -1 时，会设置符号标志，循环终止。
- en: Keep in mind that some values may look positive but are actually negative. If
    the loop-control variable is a byte, then values in the range 128..255 are negative
    in the two's complement system. Therefore, initializing the loop-control variable
    with any 8-bit value in the range 129..255 (or, of course, 0) terminates the loop
    after a single execution. This can get you into trouble if you're not careful.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一些值看起来是正数，但实际上是负数。如果循环控制变量是字节，那么在二进制补码系统中，范围在 128..255 之间的值是负数。因此，初始化循环控制变量为范围
    129..255 之间的任何 8 位值（或者当然是 0）会在一次执行后终止循环。如果不小心，这可能会导致问题。
- en: 7.11.3 Loop-Invariant Computations
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11.3 循环不变计算
- en: 'A *loop-invariant computation* is some calculation that appears within a loop
    that always yields the same result. You needn''t do such computations inside the
    loop. You can compute them outside the loop and reference the value of the computations
    inside the loop. The following HLA code demonstrates an invariant computation:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环不变计算*是指在循环中出现的、始终返回相同结果的计算。你不必在循环内执行这样的计算。你可以在循环外进行计算，然后在循环内引用计算结果。以下 HLA
    代码展示了一个不变计算的示例：'
- en: '[PRE108]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Because `j` never changes throughout the execution of this loop, the subexpression
    `j-2` can be computed outside the loop:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `j` 在整个循环执行过程中都不变，所以子表达式 `j-2` 可以在循环外计算：
- en: '[PRE109]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Although we''ve eliminated a single instruction by computing the subexpression
    `j-2` outside the loop, there is still an invariant component to this calculation.
    Note that this invariant component executes *n* times in the loop; this means
    that we can translate the previous code to the following:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过将子表达式 `j-2` 移出循环外计算，我们消除了一个指令，但该计算仍然有一个不变成分。注意，这个不变成分在循环中执行 *n* 次；这意味着我们可以将之前的代码转换为如下：
- en: '[PRE110]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As you can see, we've shrunk the loop body from four instructions down to one.
    Of course, if you're really interested in improving the efficiency of this particular
    loop, you can compute the result without using a loop at all (there is a formula
    that corresponds to the iterative calculation above). Still, this simple example
    demonstrates elimination of loop-invariant calculations from a loop.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已将循环体从四条指令减少到一条。当然，如果你真的想提高这个特定循环的效率，你可以完全不使用循环来计算结果（有一个与上述迭代计算对应的公式）。不过，这个简单的示例展示了如何从循环中消除循环不变计算。
- en: 7.11.4 Unraveling Loops
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11.4 展开循环
- en: 'For small loops, that is, those whose body is only a few statements, the overhead
    required to process a loop may constitute a significant percentage of the total
    processing time. For example, look at the following Pascal code and its associated
    80x86 assembly language code:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型循环，即那些循环体只有几条语句的情况，处理循环所需的开销可能会占总处理时间的一个显著比例。例如，看看以下 Pascal 代码及其相关的 80x86
    汇编语言代码：
- en: '[PRE111]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Four instructions execute on each repetition of the loop. Only one instruction
    is doing the desired operation (moving a 0 into an element of `A`). The remaining
    three instructions control the loop. Therefore, it takes 16 instructions to do
    the operation logically required by 4.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环重复时会执行四条指令。只有一条指令在执行所需的操作（将 0 移动到 `A` 的一个元素中）。其余的三条指令则控制循环。因此，要执行逻辑上需要 4
    次的操作，总共需要 16 条指令。
- en: 'While there are many improvements we could make to this loop based on the information
    presented thus far, consider carefully exactly what it is that this loop is doing—it''s
    storing four 0s into `A[0]` through `A[3]`. A more efficient approach is to use
    four `mov` instructions to accomplish the same task. For example, if `A` is an
    array of double words, then the following code initializes `A` much faster than
    the code above:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以基于目前提供的信息对这个循环做出许多改进，但请仔细考虑一下这个循环到底在做什么——它正在将四个0存储到`A[0]`到`A[3]`。一个更高效的方法是使用四条`mov`指令来完成相同的任务。例如，如果`A`是一个双字数组，那么下面的代码比上面的代码初始化`A`要快得多：
- en: '[PRE112]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Although this is a simple example, it shows the benefit of *loop unraveling*
    (also known as *loop unrolling*). If this simple loop appeared buried inside a
    set of nested loops, the 4:1 instruction reduction could possibly double the performance
    of that section of your program.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的例子，但它展示了*循环展开*（也称为*循环展开*）的好处。如果这个简单的循环出现在一组嵌套循环中，4:1的指令减少可能会使该部分程序的性能翻倍。
- en: Of course, you cannot unravel all loops. Loops that execute a variable number
    of times are difficult to unravel because there is rarely a way to determine (at
    assembly time) the number of loop iterations. Therefore, unraveling a loop is
    a process best applied to loops that execute a known number of times (and the
    number of times is known at assembly time).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并不是所有的循环都能展开。执行可变次数的循环很难展开，因为很少有方法可以在汇编时确定循环的迭代次数。因此，展开循环是一个最适用于已知迭代次数的循环的过程（并且这个次数在汇编时是已知的）。
- en: Even if you repeat a loop some fixed number of iterations, it may not be a good
    candidate for loop unraveling. Loop unraveling produces impressive performance
    improvements when the number of instructions controlling the loop (and handling
    other overhead operations) represents a significant percentage of the total number
    of instructions in the loop. Had the previous loop contained 36 instructions in
    the body (exclusive of the 4 overhead instructions), then the performance improvement
    would be, at best, only 10 percent (compared with the 300–400 percent it now enjoys).
    Therefore, the costs of unraveling a loop, that is, all the extra code that must
    be inserted into your program, quickly reach a point of diminishing returns as
    the body of the loop grows larger or as the number of iterations increases. Furthermore,
    entering that code into your program can become quite a chore. Therefore, loop
    unraveling is a technique best applied to small loops.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你重复执行一个固定次数的循环，这也未必是循环展开的好选择。当控制循环（以及处理其他开销操作）的指令数量占循环总指令数的显著比例时，循环展开能够显著提升性能。如果前面的循环体包含36条指令（不包括4条开销指令），那么性能提升最多也不过是10%（相比于现在的300–400%提升）。因此，展开一个循环的成本，即必须插入程序中的所有额外代码，随着循环体变大或迭代次数增多，很快就会达到收益递减的临界点。此外，将这些代码插入程序也会变得非常麻烦。因此，循环展开是一个最佳应用于小型循环的技术。
- en: Note that the superscalar 80x86 chips (Pentium and later) have *branch-prediction
    hardware* and use other techniques to improve performance. Loop unrolling on such
    systems may actually *slow down* the code because these processors are optimized
    to execute short loops.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，超标量的80x86处理器（Pentium及之后的版本）具有*分支预测硬件*，并使用其他技术来提高性能。在这些系统上进行循环展开实际上可能*会使代码变慢*，因为这些处理器被优化为执行短小的循环。
- en: 7.11.5 Induction Variables
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11.5 归纳变量
- en: 'Consider the following loop:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下循环：
- en: '[PRE113]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Here the program is initializing each element of an array of character sets
    to the empty set. The straightforward code to achieve this is the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这里程序正在初始化一个字符集数组的每个元素为空集。实现这一目标的直接代码如下：
- en: '[PRE114]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Although unraveling this code will still produce a performance improvement,
    it will take 1,024 instructions to accomplish this task, too many for all but
    the most time-critical applications. However, you can reduce the execution time
    of the body of the loop using *induction variables*. An induction variable is
    one whose value depends entirely on the value of some other variable. In the example
    above, the index into the array `csetVar` tracks the loop-control variable (it''s
    always equal to the value of the loop-control variable times 16). Because `i`
    doesn''t appear anywhere else in the loop, there is no sense in performing the
    computations on `i`. Why not operate directly on the array index value? The following
    code demonstrates this technique:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管解开这段代码仍然会提高性能，但要完成这项任务需要 1,024 条指令，对于除最关键的时间应用外，数量过多。然而，你可以通过使用*归纳变量*来减少循环体的执行时间。归纳变量是指其值完全依赖于其他变量的值。在上面的示例中，数组
    `csetVar` 中的索引跟踪循环控制变量（它始终等于循环控制变量的值乘以 16）。由于 `i` 在循环中没有其他用途，因此在 `i` 上执行计算没有意义。为什么不直接操作数组索引值呢？下面的代码演示了这一技巧：
- en: '[PRE115]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The induction that takes place in this example occurs when the code increments
    the loop-control variable (moved into EBX for efficiency reasons) by 16 on each
    iteration of the loop rather than by 1\. Multiplying the loop-control variable
    by 16 (and also the final loop-termination constant value) allows the code to
    eliminate multiplying the loop-control variable by 16 on each iteration of the
    loop (that is, this allows us to remove the `shl` instruction from the previous
    code). Further, because this code no longer refers to the original loop-control
    variable (`i`), the code can maintain the loop-control variable strictly in the
    EBX register.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中发生的归纳操作是在每次循环迭代时通过将循环控制变量（出于效率原因已移入 EBX）增加 16 来进行，而不是增加 1。通过将循环控制变量乘以 16（以及最终的循环终止常量值），代码可以消除在每次循环迭代时将循环控制变量乘以
    16 的操作（即，这使得我们可以去除先前代码中的 `shl` 指令）。此外，由于这段代码不再引用原始的循环控制变量（`i`），代码可以将循环控制变量严格保持在
    EBX 寄存器中。
- en: 7.12 Hybrid Control Structures in HLA
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.12 HLA 中的混合控制结构
- en: 'The HLA high-level language control structures have a few drawbacks: (1) they''re
    not true assembly language instructions, (2) complex boolean expressions support
    only short-circuit evaluation, and (3) they often introduce inefficient coding
    practices into a language that most people use only when they need to write high-performance
    code. On the other hand, while the 80x86 low-level control structures let you
    write efficient code, the resulting code is very difficult to read and maintain.
    HLA provides a set of hybrid control structures that allow you to use pure assembly
    language statements to evaluate boolean expressions while using the high-level
    control structures to delineate the statements controlled by the boolean expressions.
    The result is code that is much more readable than pure assembly language without
    being a whole lot less efficient.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 高级语言控制结构有一些缺点：（1）它们不是纯粹的汇编语言指令，（2）复杂的布尔表达式仅支持短路求值，（3）它们通常会将低效的编码实践引入到一种大多数人仅在需要编写高性能代码时使用的语言中。另一方面，虽然
    80x86 低级控制结构允许你编写高效的代码，但生成的代码非常难以阅读和维护。HLA 提供了一组混合控制结构，允许你使用纯汇编语言语句来求值布尔表达式，同时使用高级控制结构来划定由布尔表达式控制的语句。结果是，代码比纯汇编语言更具可读性，而效率损失不大。
- en: 'HLA provides hybrid forms of the `if..elseif..else..endif`, `while..endwhile`,
    `repeat..until`, `breakif`, `exitif`, and `continueif` statements (that is, those
    that involve a boolean expression). For example, a hybrid `if` statement takes
    the following form:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了混合形式的`if..elseif..else..endif`、`while..endwhile`、`repeat..until`、`breakif`、`exitif`和`continueif`语句（即涉及布尔表达式的语句）。例如，混合形式的
    `if` 语句如下所示：
- en: '[PRE116]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Note the use of `#{` and `}#` operators to surround a sequence of instructions
    within this statement. This is what differentiates the hybrid control structures
    from the standard high-level language control structures. The remaining hybrid
    control structures take the following forms:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `#{` 和 `}#` 操作符的使用，它们将一系列指令包围在该语句中。这就是混合控制结构与标准高级语言控制结构的区别所在。其余的混合控制结构的形式如下：
- en: '[PRE117]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The statements within the curly braces replace the normal boolean expression
    in an HLA high-level control structure. These particular statements are special
    insofar as HLA defines two pseudo-labels, `true` and `false`, within their context.
    HLA associates the label `true` with the code that would normally execute if a
    boolean expression were present and that expression''s result was true. Similarly,
    HLA associates the label `false` with the code that would execute if a boolean
    expression in one of these statements evaluated false. As a simple example, consider
    the following two (equivalent) `if` statements:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号中的语句替代了HLA高级控制结构中的普通布尔表达式。这些语句之所以特殊，是因为HLA在其上下文中定义了两个伪标签，`true`和`false`。HLA将标签`true`与通常会执行的代码关联起来，该代码会在布尔表达式存在且其结果为真时执行。同样，HLA将标签`false`与在这些语句中布尔表达式评估为假时会执行的代码关联起来。作为一个简单的例子，请考虑以下两个（等效的）`if`语句：
- en: '[PRE118]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `jnb` that transfers control to the `false` label in this latter example
    will skip over the `inc` instruction if EAX is not less than EBX. Note that if
    EAX is less than EBX, then control falls through to the inc instruction. This
    is roughly equivalent to the following pure assembly code:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个后续示例中，`jnb`将控制转移到`false`标签，如果EAX不小于EBX，则会跳过`inc`指令。请注意，如果EAX小于EBX，则控制会继续执行`inc`指令。这大致等价于以下纯汇编代码：
- en: '[PRE119]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: As a slightly more complex example, consider the statement
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个稍微复杂一点的例子，请考虑以下语句：
- en: '[PRE120]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The following hybrid `if` statement accomplishes the above:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 以下混合型`if`语句实现了上述功能：
- en: '[PRE121]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'As one final example of the hybrid `if` statement, consider the following:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 作为混合型`if`语句的最后一个例子，请考虑以下内容：
- en: '[PRE122]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Because these examples are rather trivial, they don't really demonstrate how
    much more readable the code can be when using hybrid statements rather than pure
    assembly code. However, one thing you should notice is that using hybrid statements
    eliminates the need to insert labels throughout your code. This can make your
    programs easier to read and understand.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些例子相当简单，它们并没有真正展示使用混合语句而非纯汇编代码时，代码可读性提升的程度。然而，有一点你应该注意到的是，使用混合语句可以消除在代码中插入标签的需求。这可以使你的程序更易于阅读和理解。
- en: For the `if` statement, the `true` label corresponds to the `then` clause of
    the statement; the `false` label corresponds to the `elseif`, `else`, or `endif`
    clause (whichever follows the `then` clause). For the `while` loop, the `true`
    label corresponds to the body of the loop, whereas the `false` label is attached
    to the first statement following the corresponding `endwhile`. For the `repeat..until`
    statement, the `true` label is attached to the code following the `until` clause,
    whereas the `false` label is attached to the first statement of the body of the
    loop. The `breakif`, `exitif`, and `continueif` statements associate the `false`
    label with the statement immediately following one of these statements; they associate
    the `true` label with the code normally associated with a `break`, `exit`, or
    `continue` statement.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`if`语句，`true`标签对应语句的`then`部分；`false`标签对应`elseif`、`else`或`endif`部分（即紧随`then`部分之后的部分）。对于`while`循环，`true`标签对应循环体，而`false`标签则附加到紧随`endwhile`之后的第一条语句。对于`repeat..until`语句，`true`标签附加到`until`子句之后的代码，而`false`标签附加到循环体的第一条语句。`breakif`、`exitif`和`continueif`语句将`false`标签与这些语句之后的第一条语句关联，将`true`标签与通常与`break`、`exit`或`continue`语句相关联的代码关联。
- en: 7.13 For More Information
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.13 获取更多信息
- en: HLA contains a few additional high-level control structures beyond those this
    chapter describes. Examples include the `try..endtry` block and the `foreach`
    statement. A discussion of these statements does not appear in this chapter because
    these are advanced control structures and their implementation is too complex
    to describe this early in the text. For more information on their implementation,
    see the electronic edition at [http://www.artofasm.com/](http://www.artofasm.com/)
    (or [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)) or the HLA reference
    manual.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: HLA包含了一些本章未描述的其他高级控制结构。例如，`try..endtry`块和`foreach`语句。没有在本章讨论这些语句，因为它们是高级控制结构，它们的实现太复杂，无法在本文的早期阶段进行描述。有关其实现的更多信息，请参阅电子版
    [http://www.artofasm.com/](http://www.artofasm.com/)（或 [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)）或HLA参考手册。
