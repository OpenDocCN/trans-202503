- en: Chapter 7. LOW-LEVEL CONTROL STRUCTURES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 低级控制结构
- en: '![LOW-LEVEL CONTROL STRUCTURES](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![低级控制结构](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: This chapter discusses "pure" assembly language control statements. You'll need
    to master these low-level control structures before you can claim to be an assembly
    language programmer. By the time you finish this chapter, you should be able to
    stop using HLA's high-level control statements and synthesize them using low-level
    80x86 machine instructions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论“纯”汇编语言控制语句。在你声称自己是汇编语言程序员之前，你需要掌握这些低级控制结构。完成本章后，你应该能够停止使用HLA的高级控制语句，并使用低级80x86机器指令来合成这些语句。
- en: The last section of this chapter discusses *hybrid* control structures that
    combine the features of HLA's high-level control statements with the 80x86 control
    instructions. These combine the power and efficiency of the low-level control
    statements with the readability of high-level control statements. Advanced assembly
    programmers may want to use these hybrid statements to improve their programs'
    readability without sacrificing efficiency.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后部分讨论了*混合*控制结构，它结合了HLA的高级控制语句和80x86控制指令的特点。这些控制结构将低级控制语句的力量和效率与高级控制语句的可读性结合起来。高级汇编程序员可能希望使用这些混合语句，在不牺牲效率的前提下提高程序的可读性。
- en: 7.1 Low-Level Control Structures
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 低级控制结构
- en: Until now, most of the control structures you've seen and have used in your
    programs are similar to the control structures found in high-level languages like
    Pascal, C++, and Ada. While these control structures make learning assembly language
    easy, they are not true assembly language statements. Instead, the HLA compiler
    translates these control structures into a sequence of "pure" machine instructions
    that achieve the same result as the high-level control structures. This text uses
    the high-level control structures to allow you to learn assembly language without
    having to learn everything all at once. Now, however, it's time to put aside these
    high-level control structures and learn how to write your programs in *real* assembly
    language, using low-level control structures.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，你在程序中看到和使用的大多数控制结构都类似于高级语言（如Pascal、C++和Ada）中的控制结构。虽然这些控制结构使得学习汇编语言变得容易，但它们并不是实际的汇编语言语句。相反，HLA编译器将这些控制结构转换为一系列“纯”机器指令，从而实现与高级控制结构相同的结果。本文通过使用高级控制结构，让你在不需要一次性学习所有内容的情况下学习汇编语言。然而，现在是时候放下这些高级控制结构，学习如何使用低级控制结构编写真正的汇编语言程序了。
- en: 7.2 Statement Labels
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.2 语句标签
- en: 'Assembly language low-level control structures make extensive use of *labels*
    within your source code. A low-level control structure usually transfers control
    between two points in your program. You typically specify the destination of such
    a transfer using a statement label. A statement label consists of a valid (unique)
    HLA identifier and a colon. For example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言的低级控制结构广泛使用*标签*来标识源代码中的位置。低级控制结构通常会在程序的两个点之间转移控制。你通常通过语句标签来指定这样的转移目标。语句标签由一个有效（唯一的）HLA标识符和一个冒号组成。例如：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, as for procedure, variable, and constant identifiers, you should
    attempt to choose descriptive and meaningful names for your labels. The example
    identifier above, `aLabel`, is hardly descriptive or meaningful.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于过程、变量和常量标识符，你应该尽量选择描述性和有意义的名称作为标签。上面示例中的标识符`aLabel`几乎没有描述性或意义。
- en: 'Statement labels have one important attribute that differentiates them from
    most other identifiers in HLA: You don''t have to declare a label before you use
    it. This is important, because low-level control structures must often transfer
    control to some point later in the code; therefore the label may not be defined
    by the time you reference it.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 语句标签有一个重要的特点，使其区别于HLA中大多数其他标识符：你不需要在使用标签之前声明它。这一点很重要，因为低级控制结构通常需要将控制转移到代码中的某个位置；因此，当你引用标签时，它可能尚未被定义。
- en: 'You can do three things with labels: transfer control to a label via a jump
    (`goto`) instruction, call a label via the `call` instruction, and take the address
    of a label. There is very little else you can directly do with a label (of course,
    there is very little else you would want to do with a label, so this is hardly
    a restriction). The program in [Example 7-1](ch07s02.html#displaying_the_address_of_statement_labe
    "Example 7-1. Displaying the address of statement labels in a program") demonstrates
    two ways to take the address of a label in your program and print out the address
    (using the `lea` instruction and using the `&` address-of operator):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对标签执行三种操作：通过跳转（`goto`）指令转移控制权到标签，使用 `call` 指令调用标签，并获取标签的地址。对于标签，你几乎不能做其他操作（当然，你也不会希望对标签做太多其他操作，所以这并不算限制）。[示例
    7-1](ch07s02.html#displaying_the_address_of_statement_labe "示例 7-1. 在程序中显示语句标签的地址")
    演示了在程序中获取标签地址并打印地址的两种方法（使用 `lea` 指令和使用 `&` 地址操作符）：
- en: Example 7-1. Displaying the address of statement labels in a program
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-1. 在程序中显示语句标签的地址
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'HLA also allows you to initialize double-word variables with the addresses
    of statement labels. However, there are some restrictions on labels that appear
    in the initialization portions of variable declarations. The most important restriction
    is that you must define the statement label at the same lexical level as the variable
    declaration. That is, if you reference a statement label in the initializer of
    a variable declaration appearing in the main program, the statement label must
    also be in the main program. Conversely, if you take the address of a statement
    label in a local variable declaration, that symbol must appear in the same procedure
    as the local variable. [Example 7-2](ch07s02.html#initializing_dword_variables_with_the_ad
    "Example 7-2. Initializing dword variables with the address of statement labels")
    demonstrates the use of statement labels in variable initialization:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 还允许你使用语句标签的地址初始化双字变量。然而，变量声明中的初始化部分对标签有一些限制。最重要的限制是，你必须在与变量声明相同的词法级别上定义语句标签。也就是说，如果你在主程序中引用变量声明的初始化器中的语句标签，则该语句标签也必须位于主程序中。相反，如果你在局部变量声明中获取语句标签的地址，则该符号必须出现在与局部变量相同的过程内。[示例
    7-2](ch07s02.html#initializing_dword_variables_with_the_ad "示例 7-2. 使用语句标签的地址初始化
    dword 变量") 演示了语句标签在变量初始化中的使用：
- en: Example 7-2. Initializing dword variables with the address of statement labels
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-2. 使用语句标签的地址初始化 dword 变量
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once in a while, you'll need to refer to a label that is not within the current
    procedure. The need for this is sufficiently rare that this text will not describe
    all the details. See the HLA documentation for more details should you ever need
    to do this.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要引用当前过程外的标签。由于这种需求相对较少，本文不会描述所有细节。如果你需要做这种操作，请参考 HLA 文档了解更多细节。
- en: 7.3 Unconditional Transfer of Control (jmp)
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.3 无条件转移控制（jmp）
- en: 'The `jmp` ( jump) instruction unconditionally transfers control to another
    point in the program. There are three forms of this instruction: a direct jump
    and two indirect jumps. These instructions take the following forms:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`jmp`（跳转）指令无条件地将控制权转移到程序中的另一个位置。该指令有三种形式：直接跳转和两种间接跳转。这些指令的形式如下：'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first instruction is a direct jump above. For direct jumps you normally
    specify the target address using a statement label. The label appears either on
    the same line as an executable machine instruction or by itself on a line preceding
    an executable machine instruction. The direct jump is completely equivalent to
    a `goto` statement in a high-level language.^([[105](#ftn.CHP-7-FN-1)])
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令是一个直接跳转。对于直接跳转，你通常通过语句标签来指定目标地址。该标签要么与可执行机器指令在同一行，要么单独出现在可执行机器指令前的一行。直接跳转完全等同于高级语言中的
    `goto` 语句。^([[105](#ftn.CHP-7-FN-1)])
- en: 'Here''s an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The second form of the `jmp` instruction given earlier—`jmp(` *`reg32`* `);`—is
    a register indirect jump instruction. This instruction transfers control to the
    instruction whose address appears in the specified 32-bit general-purpose register.
    To use this form of the `jmp` instruction, you must load a 32-bit register with
    the address of some machine instruction prior to the execution of the `jmp`. You
    could use this instruction to implement a *state machine* by loading a register
    with the address of some label at various points throughout your program and then
    use a single indirect jump at a common point to transfer control to one of those
    labels. The short sample program in [Example 7-3](ch07s03.html#using_register-indirect_jmp_instructions
    "Example 7-3. Using register-indirect jmp instructions") demonstrates how you
    could use the `jmp` in this manner.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的第二种 `jmp` 指令形式——`jmp(` *`reg32`* `);`——是寄存器间接跳转指令。该指令将控制转移到指定的 32 位通用寄存器中出现的指令地址。要使用这种形式的
    `jmp` 指令，必须在执行 `jmp` 之前将 32 位寄存器加载为某个机器指令的地址。你可以使用此指令通过在程序的不同位置将寄存器加载为某个标签的地址，并在一个公共点使用单一的间接跳转来实现
    *状态机*。[示例 7-3](ch07s03.html#using_register-indirect_jmp_instructions "示例 7-3.
    使用寄存器间接 jmp 指令") 演示了如何以这种方式使用 `jmp` 指令。
- en: Example 7-3. Using register-indirect `jmp` instructions
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-3. 使用寄存器间接 `jmp` 指令
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The third form of the `jmp` instruction given earlier is a memory-indirect `jmp`.
    This form of the `jmp` instruction fetches the double-word value from the memory
    location and jumps to that address. This is similar to the register-indirect `jmp`
    except the address appears in a memory location rather than in a register. [Example 7-4](ch07s03.html#using_memory-indirect_jmp_instructions
    "Example 7-4. Using memory-indirect jmp instructions") demonstrates a rather trivial
    use of this form of the `jmp` instruction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的第三种 `jmp` 指令形式是内存间接 `jmp`。这种形式的 `jmp` 指令从内存位置获取双字值并跳转到该地址。这类似于寄存器间接 `jmp`，只不过地址出现在内存位置，而不是寄存器中。[示例
    7-4](ch07s03.html#using_memory-indirect_jmp_instructions "示例 7-4. 使用内存间接 jmp 指令")
    演示了这种 `jmp` 指令形式的一个相当简单的用法。
- en: Example 7-4. Using memory-indirect `jmp` instructions
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-4. 使用内存间接 `jmp` 指令
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Warning
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Unlike the HLA high-level control structures, the low-level `jmp` instructions
    can cause you a lot of trouble. In particular, if you do not initialize a register
    with the address of a valid instruction and you jump indirectly through that register,
    the results are undefined (though this will usually cause a general protection
    fault). Similarly, if you do not initialize a double-word variable with the address
    of a legal instruction, jumping indirectly through that memory location will probably
    crash your program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HLA 高级控制结构不同，低级的`jmp`指令可能会给你带来很多麻烦。特别是，如果你没有用有效指令的地址初始化一个寄存器，并且通过该寄存器间接跳转，那么结果是未定义的（虽然这通常会导致一般保护故障）。类似地，如果你没有用合法指令的地址初始化一个双字变量，通过该内存位置间接跳转可能会导致程序崩溃。
- en: '* * *'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[105](#CHP-7-FN-1)]) Unlike high-level languages, where your instructors
    usually forbid you to use `goto` statements, you will find that the use of the
    `jmp` instruction in assembly language is essential.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[105](#CHP-7-FN-1)]) 与高级语言不同，在高级语言中，教师通常会禁止使用 `goto` 语句，而你会发现，在汇编语言中使用 `jmp`
    指令是必不可少的。
- en: 7.4 The Conditional Jump Instructions
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4 条件跳转指令
- en: Although the `jmp` instruction provides transfer of control, it is inconvenient
    to use when making decisions such as those you'll need to implement statements
    like `if` and `while`. The 80x86's conditional jump instructions handle this task.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `jmp` 指令提供了控制转移，但在做出决策时使用它并不方便，例如你需要实现 `if` 和 `while` 语句的场景。80x86 的条件跳转指令可以处理这一任务。
- en: The conditional jumps test one or more CPU flags to see if they match some particular
    pattern. If the flag settings match the condition, the conditional jump instruction
    transfers control to the target location. If the match fails, the CPU ignores
    the conditional jump and execution continues with the instruction following the
    conditional jump. Some conditional jump instructions simply test the setting of
    the sign, carry, overflow, and zero flags. For example, after the execution of
    a `shl` instruction, you could test the carry flag to determine if the `shl` shifted
    a 1 out of the H.O. bit of its operand. Likewise, you could test the zero flag
    after a `test` instruction to check if the result was 0\. Most of the time, however,
    you will probably execute a conditional jump after a `cmp` instruction. The `cmp`
    instruction sets the flags so that you can test for less than, greater than, equality,
    and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 条件跳转会测试一个或多个 CPU 标志，查看它们是否匹配某个特定的模式。如果标志设置匹配条件，条件跳转指令会将控制转移到目标位置。如果匹配失败，CPU
    会忽略条件跳转，并继续执行紧接着条件跳转之后的指令。一些条件跳转指令仅仅测试符号、进位、溢出和零标志的设置。例如，在执行 `shl` 指令后，你可以测试进位标志，以确定
    `shl` 是否将一个 1 从操作数的高位移出。同样，执行 `test` 指令后，你可以测试零标志来检查结果是否为 0。然而，大多数时候，你可能会在执行 `cmp`
    指令后执行条件跳转。`cmp` 指令会设置标志，从而让你可以测试小于、大于、相等等情况。
- en: 'The conditional `jmp` instructions take the following form:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 条件 `jmp` 指令的形式如下：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The *`cc`* in `j`*`cc`* indicates that you must substitute some character sequence
    that specifies the type of condition to test. These are the same characters the
    `set`*`cc`* instruction uses. For example, `js` stands for *jump* if the sign
    flag is set. A typical `js` instruction is:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*`cc`* 在 `j`*`cc`* 中表示你必须替换为某个字符序列，指定要测试的条件类型。这些字符与 `set`*`cc`* 指令使用的字符相同。例如，`js`
    表示如果符号标志被设置则 *跳转*。一个典型的 `js` 指令是：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the `js` instruction transfers control to the `ValueIsNegative`
    label if the sign flag is currently set; control falls through to the next instruction
    following the `js` instruction if the sign flag is clear.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果符号标志当前被设置，`js` 指令将控制转移到 `ValueIsNegative` 标签；如果符号标志未设置，控制则跳转到 `js`
    指令之后的下一条指令。
- en: Unlike the unconditional `jmp` instruction, the conditional jump instructions
    do not provide an indirect form. They only allow a branch to a statement label
    in your program.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与无条件的 `jmp` 指令不同，条件跳转指令不提供间接形式。它们只允许跳转到程序中的一个标签。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Intel's documentation defines various synonyms or instruction aliases for many
    conditional jump instructions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的文档为许多条件跳转指令定义了各种同义词或指令别名。
- en: '[Table 7-1](ch07s04.html#jcc_instructions_that_test_flags "Table 7-1. jcc Instructions
    That Test Flags"), [Table 7-2](ch07s04.html#jcc_instructions_for_unsigned_comparison
    "Table 7-2. jcc Instructions for Unsigned Comparisons"), and [Table 7-3](ch07s04.html#jcc_instructions_for_signed_comparisons
    "Table 7-3. jcc Instructions for Signed Comparisons") list all the aliases for
    a particular instruction. These tables also list the opposite branches. You''ll
    soon see the purpose of the opposite branches.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-1](ch07s04.html#jcc_instructions_that_test_flags "表 7-1. jcc 指令，测试标志"),
    [表 7-2](ch07s04.html#jcc_instructions_for_unsigned_comparison "表 7-2. jcc 指令，无符号比较"),
    和 [表 7-3](ch07s04.html#jcc_instructions_for_signed_comparisons "表 7-3. jcc 指令，有符号比较")
    列出了特定指令的所有别名。这些表还列出了相反的跳转。你将很快看到相反跳转的用途。'
- en: Table 7-1. `j`*`cc`* Instructions That Test Flags
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1. `j`*`cc`* 指令，测试标志
- en: '| Instruction | Description | Condition | Aliases | Opposite |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 条件 | 别名 | 相反 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `jc` | Jump if carry | Carry = 1 | `jb`, `jnae` | `jnc` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `jc` | 如果进位则跳转 | 进位 = 1 | `jb`, `jnae` | `jnc` |'
- en: '| `jnc` | Jump if no carry | Carry = 0 | `jnb`, `jae` | `jc` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `jnc` | 如果没有进位则跳转 | 进位 = 0 | `jnb`, `jae` | `jc` |'
- en: '| `jz` | Jump if zero | Zero = 1 | `je` | `jnz` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `jz` | 如果为零则跳转 | 零 = 1 | `je` | `jnz` |'
- en: '| `jnz` | Jump if not zero | Zero = 0 | `jne` | `jz` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `jnz` | 如果不为零则跳转 | 零 = 0 | `jne` | `jz` |'
- en: '| `js` | Jump if sign | Sign = 1 |   | `jns` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `js` | 如果符号则跳转 | 符号 = 1 |   | `jns` |'
- en: '| `jns` | Jump if no sign | Sign = 0 |   | `js` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `jns` | 如果没有符号则跳转 | 符号 = 0 |   | `js` |'
- en: '| `jo` | Jump if overflow | Overflow = 1 |   | `jno` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `jo` | 如果溢出则跳转 | 溢出 = 1 |   | `jno` |'
- en: '| `jno` | Jump if no overflow | Overflow = 0 |   | `jo` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `jno` | 如果没有溢出则跳转 | 溢出 = 0 |   | `jo` |'
- en: '| `jp` | Jump if parity | Parity = 1 | `jpe` | `jnp` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `jp` | 如果奇偶校验则跳转 | 奇偶校验 = 1 | `jpe` | `jnp` |'
- en: '| `jpe` | Jump if parity even | Parity = 1 | `jp` | `jpo` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `jpe` | 如果奇偶校验为偶 | 奇偶校验 = 1 | `jp` | `jpo` |'
- en: '| `jnp` | Jump if no parity | Parity = 0 | `jpo` | `jp` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `jnp` | 如果没有奇偶校验跳转 | 奇偶校验 = 0 | `jpo` | `jp` |'
- en: '| `jpo` | Jump if parity odd | Parity = 0 | `jnp` | `jpe` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `jpo` | 如果奇偶校验为奇数跳转 | 奇偶校验 = 0 | `jnp` | `jpe` |'
- en: Table 7-2. `j`*`cc`* Instructions for Unsigned Comparisons
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '| 表7-2. 用于无符号比较的`j`*`cc`*指令'
- en: '| Instruction | Description | Condition | Aliases | Opposite |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 条件 | 别名 | 相反 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `ja` | Jump if above (`>`) | Carry = 0, Zero = 0 | `jnbe` | `jna` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `ja` | 如果大于跳转 (`>`) | 进位 = 0, 零 = 0 | `jnbe` | `jna` |'
- en: '| `jnbe` | Jump if not below or equal (`not <=`) | Carry = 0, Zero = 0 | `ja`
    | `jbe` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `jnbe` | 如果不小于或等于跳转 (`not <=`) | 进位 = 0, 零 = 0 | `ja` | `jbe` |'
- en: '| `jae` | Jump if above or equal (`>=`) | Carry = 0 | `jnc`, `jnb` | `jnae`
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `jae` | 如果大于或等于跳转 (`>=`) | 进位 = 0 | `jnc`, `jnb` | `jnae` |'
- en: '| `jnb` | Jump if not below (`not <`) | Carry = 0 | `jnc`, `jae` | `jb` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `jnb` | 如果不小于跳转 (`not <`) | 进位 = 0 | `jnc`, `jae` | `jb` |'
- en: '| `jb` | Jump if below (`<`) | Carry = 1 | `jc`, `jnae` | `jnb` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `jb` | 如果小于跳转 (`<`) | 进位 = 1 | `jc`, `jnae` | `jnb` |'
- en: '| `jnae` | Jump if not above or equal (`not >=`) | Carry = 1 | `jc`, `jb` |
    `jae` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `jnae` | 如果不大于或等于跳转 (`not >=`) | 进位 = 1 | `jc`, `jb` | `jae` |'
- en: '| `jbe` | Jump if below or equal (`<=`) | Carry = 1 or Zero = 1 | `jna` | `jnbe`
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `jbe` | 如果小于或等于跳转 (`<=`) | 进位 = 1 或零 = 1 | `jna` | `jnbe` |'
- en: '| `jna` | Jump if not above (`not >`) | Carry = 1 or Zero = 1 | `jbe` | `ja`
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `jna` | 如果不大于跳转 (`not >`) | 进位 = 1 或零 = 1 | `jbe` | `ja` |'
- en: '| `je` | Jump if equal (`=`) | Zero = 1 | `jz` | `jne` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `je` | 如果相等跳转 (`=`) | 零 = 1 | `jz` | `jne` |'
- en: '| `jne` | Jump if not equal (`¦`) | Zero = 0 | `jnz` | `je` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `jne` | 如果不相等跳转 (`¦`) | 零 = 0 | `jnz` | `je` |'
- en: Table 7-3. `j`*`cc`* Instructions for Signed Comparisons
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '| 表7-3. 用于有符号比较的`j`*`cc`*指令'
- en: '| Instruction | Description | Condition | Aliases | Opposite |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 条件 | 别名 | 相反 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `jg` | Jump if greater (`>`) | Sign = Overflow or Zero = 0 | `jnle` | `jng`
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `jg` | 如果大于跳转 (`>`) | 符号 = 溢出或零 = 0 | `jnle` | `jng` |'
- en: '| `jnle` | Jump if not less than or equal (`not <=`) | Sign = Overflow or Zero
    = 0 | `jg` | `jle` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `jnle` | 如果不小于或等于跳转 (`not <=`) | 符号 = 溢出或零 = 0 | `jg` | `jle` |'
- en: '| `jge` | Jump if greater than or equal (`>=`) | Sign = Overflow | `jnl` |
    `jge` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `jge` | 如果大于或等于跳转 (`>=`) | 符号 = 溢出 | `jnl` | `jge` |'
- en: '| `jnl` | Jump if not less than (`not <`) | Sign = Overflow | `jge` | `jl`
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `jnl` | 如果不小于跳转 (`not <`) | 符号 = 溢出 | `jge` | `jl` |'
- en: '| `jl` | Jump if less than (`<`) | Sign <> Overflow | `jnge` | `jnl` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `jl` | 如果小于跳转 (`<`) | 符号 <> 溢出 | `jnge` | `jnl` |'
- en: '| `jnge` | Jump if not greater or equal (`not >=`) | Sign <> Overflow | `jl`
    | `jge` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `jnge` | 如果不大于或等于跳转 (`not >=`) | 符号 <> 溢出 | `jl` | `jge` |'
- en: '| `jle` | Jump if less than or equal (`<=`) | Sign <> Overflow or Zero = 1
    | `jng` | `jnle` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `jle` | 如果小于或等于跳转 (`<=`) | 符号 <> 溢出或零 = 1 | `jng` | `jnle` |'
- en: '| `jng` | Jump if not greater than (`not >`) | Sign <> Overflow or Zero = 1
    | `jle` | `jg` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `jng` | 如果不大于跳转 (`not >`) | 符号 <> 溢出或零 = 1 | `jle` | `jg` |'
- en: '| `je` | Jump if equal (`=`) | Zero = 1 | `jz` | `jne` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `je` | 如果相等跳转 (`=`) | 零 = 1 | `jz` | `jne` |'
- en: '| `jne` | Jump if not equal (`¦`) | Zero = 0 | `jnz` | `je` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `jne` | 如果不相等跳转 (`¦`) | 零 = 0 | `jnz` | `je` |'
- en: 'One brief comment about the Opposite column is in order. In many instances
    you will need to be able to generate the opposite of a specific branch instruction
    (examples appear later in this section). With only two exceptions, a very simple
    rule completely describes how to generate an opposite branch:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '| 关于“相反”列，有必要做一个简短的说明。在许多情况下，你需要能够生成特定分支指令的相反指令（后面会有示例）。除了两个例外外，一个非常简单的规则可以完全描述如何生成相反分支：'
- en: If the second letter of the `jcc` instruction is not an n, insert an `n` after
    the `j`. For example, `je` becomes `jne` and `jl` becomes `jnl`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '| 如果`jcc`指令的第二个字母不是`n`，则在`j`后插入`n`。例如，`je`变为`jne`，`jl`变为`jnl`。'
- en: If the second letter of the `j`*`cc`* instruction is an `n`, then remove that
    `n` from the instruction. For example, `jng` becomes `jg` and `jne` becomes `je`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '| 如果`j`*`cc`*指令的第二个字母是`n`，则从指令中删除该`n`。例如，`jng`变为`jg`，`jne`变为`je`。'
- en: The two exceptions to this rule are `jpe` ( jump if parity is even) and `jpo`
    (jump if parity is odd). These exceptions cause few problems because (1) you'll
    hardly ever need to test the parity flag, and (2) you can use the aliases `jp`
    and `jnp` as synonyms for `jpe` and `jpo`. The "N/No N" rule applies to `jp` and
    `jnp`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '| 这两个例外是`jpe`（如果奇偶校验为偶数跳转）和`jpo`（如果奇偶校验为奇数跳转）。这两个例外几乎不会引起问题，因为（1）你几乎不需要测试奇偶校验标志，且（2）你可以使用别名`jp`和`jnp`作为`jpe`和`jpo`的同义词。“N/No
    N”规则适用于`jp`和`jnp`。'
- en: Though you *know* that `jge` is the opposite of `jl`, get in the habit of using
    `jnl` rather than `jge` as the opposite jump instruction for `jl`. It's too easy
    in an important situation to start thinking "greater is the opposite of less"
    and substitute `jg` instead. You can avoid this confusion by always using the
    "N/No N" rule.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你*知道*`jge`是`jl`的反操作，但养成使用`jnl`而不是`jge`作为`jl`的对立跳转指令的习惯。在关键情况下，容易误认为“更大是小的对立面”，并错误地替换为`jg`。你可以通过始终使用“有/没有
    N”规则来避免这种混淆。
- en: 'The 80x86 conditional jump instructions give you the ability to split program
    flow into one of two paths depending on some condition. Suppose you want to increment
    the AX register if BX is equal to CX. You can accomplish this with the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86条件跳转指令使你能够根据某个条件将程序流分成两条路径。假设你想在BX等于CX时递增AX寄存器。你可以通过以下代码实现这一目标：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The trick is to use the *opposite* branch to skip over the instructions you
    want to execute if the condition is true. Always use the "opposite branch (N/No
    N)" rule given earlier to select the opposite branch.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是使用*对立*分支来跳过你希望在条件为真时执行的指令。始终使用之前给出的“对立分支（有/没有 N）”规则来选择对立分支。
- en: 'You can also use the conditional jump instructions to synthesize loops. For
    example, the following code sequence reads a sequence of characters from the user
    and stores each character in successive elements of an array until the user presses
    the **enter** key (carriage return):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用条件跳转指令来合成循环。例如，以下代码序列从用户那里读取一系列字符，并将每个字符存储在数组的连续元素中，直到用户按下**回车**键（换行符）：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Like the `set`*`cc`* instructions, the conditional jump instructions come in
    two basic categories: those that test specific processor flags (e.g., `jz`, `jc`,
    `jno`) and those that test some condition (less than, greater than, etc.). When
    testing a condition, the conditional jump instructions almost always follow a
    `cmp` instruction. The `cmp` instruction sets the flags so that you can use a
    `ja`, `jae`, `jb`, `jbe`, `je`, or `jne` instruction to test for unsigned less
    than, less than or equal, equal, unequal, greater than, or greater than or equal.
    Simultaneously, the `cmp` instruction sets the flags so that you can also do a
    signed comparison using the `jl`, `jle`, `je`, `jne`, `jg`, and `jge` instructions.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 像`set`*`cc`*指令一样，条件跳转指令分为两大类：一种是测试特定处理器标志的指令（例如`jz`，`jc`，`jno`），另一种是测试某些条件（小于、大于等）。在测试条件时，条件跳转指令几乎总是跟随`cmp`指令。`cmp`指令设置标志，以便你可以使用`ja`，`jae`，`jb`，`jbe`，`je`或`jne`指令来测试无符号小于、小于等于、等于、不等于、大于或大于等于。与此同时，`cmp`指令也设置标志，以便你可以使用`jl`，`jle`，`je`，`jne`，`jg`和`jge`指令进行带符号的比较。
- en: The conditional jump instructions only test the 80x86 flags; they do not affect
    any of them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 条件跳转指令只测试80x86标志；它们不会影响任何标志。
- en: '7.5 "Medium-Level" Control Structures: jt and jf'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.5 "中级" 控制结构：jt 和 jf
- en: 'HLA provides two special conditional jump instructions: `jt` ( jump if true)
    and `jf` ( jump if false). These instructions take the following syntax:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: HLA提供了两条特殊的条件跳转指令：`jt`（如果为真则跳转）和`jf`（如果为假则跳转）。这些指令的语法如下：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The *`boolean_expression`* is the standard HLA boolean expression allowed by
    `if..endif` and other HLA high-level language statements. These instructions evaluate
    the boolean expression and jump to the specified label if the expression evaluates
    true (`jt`) or false (`jf`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*`boolean_expression`* 是标准的HLA布尔表达式，允许在`if..endif`和其他HLA高级语言语句中使用。这些指令计算布尔表达式，如果表达式为真，则跳转到指定标签（`jt`），如果为假，则跳转到指定标签（`jf`）。'
- en: These are not real 80x86 instructions. HLA compiles them into a sequence of
    one or more 80x86 machine instructions that achieve the same result. In general,
    you should not use these two instructions in your main code; they offer few benefits
    over using an `if..endif` statement and they are no more readable than the pure
    assembly language sequences they compile into. HLA provides these "medium-level"
    instructions so that you may create your own high-level control structures using
    macros (see [Chapter 9](ch09.html "Chapter 9. MACROS AND THE HLA COMPILE-TIME
    LANGUAGE") and the HLA reference manual for more details).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是实际的80x86指令。HLA将它们编译成一个或多个80x86机器指令，以实现相同的结果。通常，你不应在主代码中使用这两条指令；它们相较于使用`if..endif`语句没有什么好处，并且它们的可读性不比它们编译成的纯汇编语言序列更强。HLA提供这些“中级”指令，以便你可以使用宏创建自己的高级控制结构（更多详情请参见[第9章](ch09.html
    "第9章. 宏与HLA编译时语言")和HLA参考手册）。
- en: 7.6 Implementing Common Control Structures in Assembly Language
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.6 在汇编语言中实现常见的控制结构
- en: Because a primary goal of this chapter is to teach you how to use the low-level
    machine instructions to implement decisions, loops, and other control constructs,
    it would be wise to show you how to implement these high-level statements using
    pure assembly language. The following sections provide this information.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的主要目标是教你如何使用低级机器指令实现决策、循环和其他控制结构，因此明智之举是向你展示如何使用纯汇编语言实现这些高级语句。以下章节提供了这些信息。
- en: 7.7 Introduction to Decisions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.7 决策介绍
- en: 'In its most basic form, a *decision* is some sort of branch within the code
    that switches between two possible execution paths based on some condition. Normally
    (though not always), conditional instruction sequences are implemented with the
    conditional jump instructions. Conditional instructions correspond to the `if..then..endif`
    statement in HLA:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，*决策* 是代码中的某种分支，根据某些条件在两个可能的执行路径之间切换。通常（尽管并非总是如此），条件指令序列是通过条件跳转指令实现的。条件指令对应于
    HLA 中的 `if..then..endif` 语句：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Assembly language, as usual, offers much more flexibility when dealing with
    conditional statements. Consider the following C/C++ statement:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，汇编语言在处理条件语句时提供了更多的灵活性。考虑以下 C/C++ 语句：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A "brute force" approach to converting this statement into assembly language
    might produce the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将此语句转为汇编语言的“暴力”方法可能会产生以下代码：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, it takes a considerable number of conditional statements just
    to process the expression in the example above. This roughly corresponds to the
    (equivalent) C/C++ statements:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，仅仅处理上面示例中的表达式就需要相当多的条件语句。这大致对应于（等效的）C/C++ 语句：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now compare this with the following "improved" code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其与以下“改进版”代码进行比较：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Two things should be apparent from the code sequences above: First, a single
    conditional statement in C/C++ (or some other HLL) may require several conditional
    jumps in assembly language; second, organization of complex expressions in a conditional
    sequence can affect the efficiency of the code. Therefore, you should exercise
    care when dealing with conditional sequences in assembly language.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码序列中应该能看出两点：首先，在 C/C++（或其他高级语言）中，一个单一的条件语句可能需要在汇编语言中使用多个条件跳转；其次，条件序列中的复杂表达式的组织方式可能会影响代码的效率。因此，在处理汇编语言中的条件序列时，应小心谨慎。
- en: 'Conditional statements may be broken down into three basic categories: `if`
    statements, `switch`/`case` statements, and indirect jumps. The following sections
    describe these program structures, how to use them, and how to write them in assembly
    language.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句可以分为三大类：`if` 语句、`switch`/`case` 语句和间接跳转。以下章节描述了这些程序结构，如何使用它们，以及如何用汇编语言编写它们。
- en: 7.7.1 if..then..else Sequences
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.1 if..then..else 序列
- en: The most common conditional statements are the `if..then..endif` and `if..then..else..endif`
    statements. These two statements take the form shown in [Figure 7-1](ch07s07.html#if..then..else..endif_and_if..then..endi
    "Figure 7-1. if..then..else..endif and if..then..endif statement flow").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的条件语句是 `if..then..endif` 和 `if..then..else..endif` 语句。这两种语句的形式如 [图 7-1](ch07s07.html#if..then..else..endif_and_if..then..endi
    "图 7-1. if..then..else..endif 和 if..then..endif 语句流程") 所示。
- en: '![if..then..else..endif and if..then..endif statement flow](tagoreillycom20100401nostarchimages578033.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![if..then..else..endif 和 if..then..endif 语句流程](tagoreillycom20100401nostarchimages578033.png)'
- en: Figure 7-1. `if..then..else..endif` and `if..then..endif` statement flow
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1. `if..then..else..endif` 和 `if..then..endif` 语句流程
- en: 'The `if..then..endif` statement is just a special case of the `if..then..else..endif`
    statement (with an empty `else` block). Therefore, we''ll consider only the more
    general `if..then..else..endif` form. The basic implementation of an `if..then..else..endif`
    statement in 80x86 assembly language looks something like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`if..then..endif` 语句只是 `if..then..else..endif` 语句的一种特殊情况（其 `else` 块为空）。因此，我们将只考虑更通用的
    `if..then..else..endif` 形式。80x86 汇编语言中 `if..then..else..endif` 语句的基本实现大致如下所示：'
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that jcc represents some conditional jump instruction. For example, to
    convert the C/C++ statement
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，jcc 表示某种条件跳转指令。例如，要转换 C/C++ 语句
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'to assembly language, you could use the following 80x86 code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要转为汇编语言，你可以使用以下 80x86 代码：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For simple expressions like `( a == b )` generating the proper code for an
    `if..then..else..endif` statement is almost trivial. Should the expression become
    more complex, the code complexity increases as well. Consider the following C/C++
    `if` statement presented earlier:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 `( a == b )` 这样的简单表达式，生成一个正确的 `if..then..else..endif` 语句几乎是微不足道的。若表达式变得更加复杂，代码的复杂度也会随之增加。考虑之前提到的
    C/C++ `if` 语句：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When processing complex `if` statements such as this one, you''ll find the
    conversion task easier if you break the `if` statement into a sequence of three
    different `if` statements as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理像这样的复杂 `if` 语句时，如果将 `if` 语句分解成三个不同的 `if` 语句，你会发现转换任务更容易，示例如下：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This conversion comes from the following C/C++ equivalents:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该转换源自以下 C/C++ 等价物：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: is equivalent to
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: and
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: is equivalent to
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In assembly language, the former `if` statement becomes
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，前面的 `if` 语句变成
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, testing a condition can easily become more complex than the
    statements appearing in the `else` and `then` blocks. Although it seems somewhat
    paradoxical that it may take more effort to test a condition than to act on the
    results of that condition, it happens all the time. Therefore, you should be prepared
    to accept this.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，测试一个条件可能比 `else` 和 `then` 块中的语句更加复杂。尽管似乎有些矛盾的是，测试一个条件可能比对条件结果进行操作更加费力，但这确实时常发生。因此，你应该做好接受这一点的准备。
- en: 'Probably the biggest problem with complex conditional statements in assembly
    language is trying to figure out what you''ve done after you''ve written the code.
    A big advantage high-level languages offer over assembly language is that expressions
    are much easier to read and comprehend. The high-level version is (more) self-documenting,
    whereas assembly language tends to hide the true nature of the code. Therefore,
    well-written comments are an essential ingredient to assembly language implementations
    of `if..then..else..endif` statements. An elegant implementation of the example
    above is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，复杂的条件语句最头疼的问题可能是当你写完代码后，试图理解自己做了什么。高级语言相较于汇编语言的一个大优势是，表达式更易于阅读和理解。高级语言的版本（更）具自文档性，而汇编语言则往往掩盖了代码的真正含义。因此，编写良好的注释是汇编语言实现
    `if..then..else..endif` 语句的一个必要组成部分。上述示例的优雅实现如下：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Admittedly, this appears to be going overboard for such a simple example. The
    following would probably suffice:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，对于如此简单的示例来说，这看起来有些过于复杂。以下内容可能就足够了：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: However, as your `if` statements become complex, the density (and quality) of
    your comments become more and more important.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着 `if` 语句变得越来越复杂，注释的密度（和质量）变得越来越重要。
- en: 7.7.2 Translating HLA if Statements into Pure Assembly Language
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.2 将 HLA `if` 语句转换成纯汇编语言
- en: Translating HLA `if` statements into pure assembly language is very easy. The
    boolean expressions that the HLA `if` statement supports were specifically chosen
    to expand into a few simple machine instructions. The following paragraphs discuss
    the conversion of each supported boolean expression into pure machine code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HLA `if` 语句转换成纯汇编语言非常容易。HLA `if` 语句所支持的布尔表达式是特别选择的，以便可以展开成几条简单的机器指令。以下段落讨论了将每个支持的布尔表达式转换为纯机器代码的过程。
- en: if( *flag_specification* ) then *stmts* endif;
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *flag_specification* ) then *stmts* endif;
- en: 'This form is, perhaps, the easiest HLA `if` statement to convert. To execute
    the code immediately following the `then` keyword if a particular flag is set
    (or clear), all you need do is skip over the code if the flag is clear (set).
    This requires only a single conditional jump instruction for implementation, as
    the following examples demonstrate:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式，或许是最容易转换的 HLA `if` 语句。为了在特定标志位被设置（或清除）时立即执行 `then` 关键字后的代码，你只需要在标志位清除（设置）时跳过代码。这仅需要一条条件跳转指令来实现，以下示例展示了这一过程：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: if( *register* ) then *stmts* endif;
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *register* ) then *stmts* endif;
- en: 'This form uses the `test` instruction to check the specified register for 0\.
    If the register contains 0 (false), then the program jumps around the statements
    after the `then` clause with a `jz` instruction. Converting this statement to
    assembly language requires a `test` instruction and a `jz` instruction, as the
    following examples demonstrate:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式使用 `test` 指令来检查指定的寄存器是否为 0。如果寄存器中包含 0（假），那么程序会通过 `jz` 指令跳过 `then` 子句后的语句。将此语句转换为汇编语言需要
    `test` 指令和 `jz` 指令，以下示例展示了这一过程：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: if( *!register* ) then *stmts* endif;
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *!register* ) then *stmts* endif;
- en: This form of the `if` statement uses the `test` instruction to check the specified
    register to see if it is 0\. If the register is not 0 (true), then the program
    jumps around the statements after the `then` clause with a `jnz` instruction.
    Converting this statement to assembly language requires a `test` instruction and
    a `jnz` instruction in a manner identical to the previous examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的`if`语句使用`test`指令检查指定的寄存器是否为0。如果寄存器不为0（即为真），程序则使用`jnz`指令跳过`then`子句后的语句。将此语句转换为汇编语言时，需使用`test`指令和`jnz`指令，方法与前面的示例相同。
- en: if( *boolean_variable* ) then *stmts* endif;
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *boolean_variable* ) then *stmts* endif;
- en: 'This form of the `if` statement compares the boolean variable against 0 (false)
    and branches around the statements if the variable contains false. HLA implements
    this statement by using the `cmp` instruction to compare the boolean variable
    to 0, and then it uses a `jz` (`je`) instruction to jump around the statements
    if the variable is false. The following example demonstrates the conversion:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的`if`语句将布尔变量与0（假）进行比较，如果变量为假，则跳过后面的语句。HLA通过使用`cmp`指令将布尔变量与0进行比较，然后使用`jz`（`je`）指令在变量为假时跳过语句。以下示例展示了转换过程：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: if( !*boolean_variable* ) then *stmts* endif;
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( !*boolean_variable* ) then *stmts* endif;
- en: 'This form of the `if` statement compares the boolean variable against 0 (false)
    and branches around the statements if the variable contains true (the opposite
    condition of the previous example). HLA implements this statement by using the
    `cmp` instruction to compare the boolean variable to 0 and then it uses a `jnz`
    (`jne`) instruction to jump around the statements if the variable contains true.
    The following example demonstrates the conversion:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的`if`语句将布尔变量与0（假）进行比较，如果变量为真（即与前一个示例相反的条件），则跳过后面的语句。HLA通过使用`cmp`指令将布尔变量与0进行比较，然后使用`jnz`（`jne`）指令在变量为真时跳过语句。以下示例展示了转换过程：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: if( *mem_reg relop mem_reg_const* ) then *stmts* endif;
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *mem_reg relop mem_reg_const* ) then *stmts* endif;
- en: HLA translates this form of the `if` statement into a `cmp` instruction and
    a conditional jump that skips over the statements on the opposite condition specified
    by the `relop` operator. [Table 7-4](ch07s07.html#if_statement_conditional_jump_instructio
    "Table 7-4. if Statement Conditional Jump Instructions") lists the correspondence
    between operators and conditional jump instructions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: HLA将这种形式的`if`语句转换为`cmp`指令和一个条件跳转，跳过由`relop`运算符指定的相反条件下的语句。[表7-4](ch07s07.html#if_statement_conditional_jump_instructio
    "表7-4. if语句条件跳转指令")列出了操作符和条件跳转指令之间的对应关系。
- en: Table 7-4. `if` Statement Conditional Jump Instructions
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-4. `if`语句条件跳转指令
- en: '| Relational operation | Conditional jump instruction if both operands are
    unsigned | Conditional jump instruction if either operand is signed |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 关系运算 | 如果两个操作数都是无符号的，条件跳转指令 | 如果任一操作数为有符号的，条件跳转指令 |'
- en: '| --- | --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `=` or `==` | `jne` | `jne` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `=` 或 `==` | `jne` | `jne` |'
- en: '| `<>` or `!=` | `je` | `je` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `<>` 或 `!=` | `je` | `je` |'
- en: '| `<` | `jnb` | `jnl` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `<` | `jnb` | `jnl` |'
- en: '| `<=` | `jnbe` | `jnle` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | `jnbe` | `jnle` |'
- en: '| `>` | `jna` | `jng` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `>` | `jna` | `jng` |'
- en: '| `>=` | `jnae` | `jnge` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | `jnae` | `jnge` |'
- en: 'Here are a few examples of `if` statements translated into pure assembly language
    that use expressions involving relational operators:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是几个使用涉及关系运算符的表达式转换成纯汇编语言的`if`语句示例：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: if( *reg/mem* in *LowConst..HiConst* ) then *stmts* endif;
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *reg/mem* 在 *LowConst..HiConst* 范围内 ) then *stmts* endif;
- en: HLA translates this `if` statement into a pair of `cmp` instructions and a pair
    of conditional jump instructions. It compares the register or memory location
    against the lower-valued constant and jumps if less than (signed) or below (unsigned)
    past the statements after the `then` clause. If the register or memory location's
    value is greater than or equal to *`LowConst`*, the code falls through to the
    second `cmp` and conditional jump pair that compares the register or memory location
    against the higher constant. If the value is greater than (above) this constant,
    a conditional jump instruction skips the statements in the `then` clause.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: HLA将此`if`语句转换为一对`cmp`指令和一对条件跳转指令。它将寄存器或内存位置与较小的常量进行比较，如果小于（有符号）或低于（无符号）该常量，则跳过`then`子句后的语句。如果寄存器或内存位置的值大于或等于*`LowConst`*，则代码执行第二对`cmp`和条件跳转指令，将寄存器或内存位置与较高的常量进行比较。如果值大于（高于）该常量，则条件跳转指令跳过`then`子句中的语句。
- en: 'Here''s an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: if( *reg*/*mem* not in *LowConst..HiConst* ) then *stmts* endif;
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if( *reg*/*mem* 不在 *LowConst..HiConst* 范围内 ) then *stmts* endif;
- en: 'This form of the HLA `if` statement tests a register or memory location to
    see if its value is outside a specified range. The implementation is very similar
    to the previous code except you branch to the `then` clause if the value is less
    than the *`LowConst`* value or greater than the *`HiConst`* value, and you branch
    over the code in the `then` clause if the value is within the range specified
    by the two constants. The following examples demonstrate how to do this conversion:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的 HLA `if` 语句测试一个寄存器或内存位置，查看其值是否在指定范围之外。该实现与前面的代码非常相似，只是如果值小于 *`LowConst`*
    或大于 *`HiConst`*，则跳转到 `then` 子句；如果值在两个常数指定的范围内，则跳过 `then` 子句中的代码。以下示例演示了如何进行此转换：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 7.7.3 Implementing Complex if Statements Using Complete Boolean Evaluation
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.3 使用完整布尔运算实现复杂的 if 语句
- en: 'Many boolean expressions involve conjunction (`and`) or disjunction (`or`)
    operations. This section describes how to convert boolean expressions into assembly
    language. There are two different ways to convert complex boolean expressions
    involving conjunction and disjunction into assembly language: using complete boolean
    evaluation or using short-circuit boolean evaluation. This section discusses complete
    boolean evaluation. The next section discusses short-circuit boolean evaluation.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 许多布尔表达式涉及合取（`and`）或析取（`or`）操作。本节描述了如何将布尔表达式转换为汇编语言。对于涉及合取和析取的复杂布尔表达式，有两种不同的转换方法：使用完整布尔运算或使用短路布尔运算。本节讨论完整布尔运算，下一节讨论短路布尔运算。
- en: 'Conversion via complete boolean evaluation is almost identical to converting
    arithmetic expressions into assembly language. Indeed, the previous chapter on
    arithmetic covers this conversion process. About the only thing worth noting about
    that process is that you do not need to store the result in some variable; once
    the evaluation of the expression is complete, you check to see if you have a false
    (0) or true (1, or nonzero) result to take whatever action the boolean expression
    dictates. As you can see in the examples in the preceding sections, you can often
    use the fact that the last logical instruction (`and`/`or`) sets the zero flag
    if the result is false and clears the zero flag if the result is true. This lets
    you avoid explicitly testing for the result. Consider the following `if` statement
    and its conversion to assembly language using complete boolean evaluation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完整布尔运算进行转换几乎与将算术表达式转换为汇编语言相同。事实上，前一章关于算术的内容涵盖了这个转换过程。值得注意的唯一一点是，你不需要将结果存储在某个变量中；一旦表达式的计算完成，你只需检查是否得到
    `false`（0）或 `true`（1 或非零）结果，并根据布尔表达式的指示采取相应的操作。正如你在前面章节的示例中看到的，你通常可以利用最后的逻辑指令（`and`
    / `or`）在结果为 `false` 时设置零标志，在结果为 `true` 时清除零标志。这让你避免了显式测试结果。考虑以下 `if` 语句及其使用完整布尔运算转换为汇编语言的过程：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code computes a boolean result in the BL register and then, at the end
    of the computation, tests this value to see if it contains true or false. If the
    result is false, this sequence skips over the code associated with `Stmt1`. The
    important thing to note in this example is that the program will execute each
    and every instruction that computes this boolean result (up to the `je` instruction).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码计算 BL 寄存器中的布尔结果，然后在计算结束时测试这个值，看看它是 `true` 还是 `false`。如果结果为 `false`，则该序列跳过与
    `Stmt1` 相关的代码。这个例子中需要注意的重点是，程序将执行每一条计算布尔结果的指令（直到 `je` 指令）。
- en: 7.7.4 Short-Circuit Boolean Evaluation
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.4 短路布尔运算
- en: If you are willing to expend a little more effort, you can usually convert a
    boolean expression to a much shorter and faster sequence of assembly language
    instructions using *short-circuit boolean evaluation*. Short-circuit boolean evaluation
    attempts to determine whether an expression is true or false by executing only
    some of the instructions that would compute the complete expression. For this
    reason, plus the fact that short-circuit boolean evaluation doesn't require the
    use of any temporary registers, HLA uses short-circuit evaluation when translating
    complex boolean expressions into assembly language.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意多花一点力气，通常可以通过使用*短路布尔求值*将布尔表达式转换成更短且更快速的汇编语言指令序列。短路布尔求值通过执行部分指令来判断表达式是“真”还是“假”，从而避免执行计算完整表达式所需的所有指令。出于这个原因，以及短路布尔求值不需要使用任何临时寄存器的事实，HLA在将复杂布尔表达式翻译成汇编语言时使用了短路求值。
- en: 'Consider the expression `a && b`. Once we determine that `a` is false, there
    is no need to evaluate `b` because there is no way the expression can be true.
    If and `b` represent subexpressions rather than simple variables, the savings
    possible with short-circuit boolean evaluation are apparent. As a concrete example,
    consider the subexpression `((x<y) && (z>t))` from the previous section. Once
    you determine that `x` is not less than `y`, there is no need to check to see
    if `z` is greater than `t` because the expression will be false regardless of
    `z` and `t`''s values. The following code fragment shows how you can implement
    short-circuit boolean evaluation for this expression:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表达式`a && b`。一旦我们确定`a`为假，就不需要再评估`b`，因为无论`b`的值是什么，表达式都不可能为真。如果`a`和`b`是子表达式而非简单变量，短路布尔求值所带来的节省就更为明显。举个具体的例子，考虑上一节中的子表达式`((x<y)
    && (z>t))`。一旦你确定`x`不小于`y`，就不需要再检查`z`是否大于`t`，因为无论`z`和`t`的值如何，整个表达式都会为假。以下代码片段展示了如何对这个表达式实现短路布尔求值：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how the code skips any further testing once it determines that `x` is
    not less than `y`. Of course, if `x` is less than `y`, then the program has to
    test `z` to see if it is greater than `t`; if not, the program skips over the
    `then` clause. Only if the program satisfies both conditions does the code fall
    through to the `then` clause.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一旦代码确定`x`不小于`y`，它会跳过进一步的测试。当然，如果`x`小于`y`，程序就必须测试`z`是否大于`t`；如果不是，程序会跳过`then`语句。只有当程序满足两个条件时，代码才会执行`then`语句。
- en: 'For the logical `or` operation the technique is similar. If the first subexpression
    evaluates to true, then there is no need to test the second operand. Whatever
    the second operand''s value is at that point, the full expression still evaluates
    to true. The following example demonstrates the use of short-circuit evaluation
    with disjunction (`or`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逻辑“或”操作，技巧类似。如果第一个子表达式评估为真，那么就不需要再测试第二个操作数。无论第二个操作数的值是什么，整个表达式仍然为真。以下示例展示了如何使用短路求值与析取（`or`）操作：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Because the conjunction and disjunction operators are commutative, you can
    evaluate the left or right operand first if it is more convenient to do so.^([[106](#ftn.CHP-7-FN-2)])
    As one last example in this section, consider the full boolean expression from
    the previous section:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于连接词和析取词运算符是可交换的，因此如果更方便的话，你可以先计算左边或右边的操作数。^([[106](#ftn.CHP-7-FN-2)]) 作为本节的最后一个例子，考虑上一节中的完整布尔表达式：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice how the code in this example chose to evaluate `a != b` first and the
    remaining subexpression last. This is a common technique assembly language programmers
    use to write better code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个示例中的代码选择先评估`a != b`，然后再评估剩余的子表达式。这是汇编语言程序员常用的技巧，用来编写更高效的代码。
- en: 7.7.5 Short-Circuit vs. Complete Boolean Evaluation
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.5 短路与完整布尔求值
- en: When using complete boolean evaluation, every statement in the sequence for
    that expression will execute; short-circuit boolean evaluation, on the other hand,
    may not require the execution of every statement associated with the boolean expression.
    As you've seen in the previous two sections, code based on short-circuit evaluation
    is usually shorter and faster. So it would seem that short-circuit evaluation
    is the technique of choice when converting complex boolean expressions to assembly
    language.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用完全布尔评估时，该表达式序列中的每个语句都会执行；另一方面，短路布尔评估可能不需要执行与布尔表达式相关的每个语句。正如您在前两节中所看到的，基于短路评估的代码通常更简短且更快。因此，似乎短路评估是将复杂布尔表达式转换为汇编语言时的首选技巧。
- en: 'Sometimes, unfortunately, short-circuit boolean evaluation may not produce
    the correct result. In the presence of *side effects* in an expression, short-circuit
    boolean evaluation will produce a different result than complete boolean evaluation.
    Consider the following C/C++ example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有时短路布尔评估可能不会产生正确的结果。在表达式中存在*副作用*时，短路布尔评估会产生与完全布尔评估不同的结果。考虑以下C/C++示例：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using complete boolean evaluation, you might generate the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全布尔评估，您可能会生成如下代码：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using short-circuit boolean evaluation, you might generate the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短路布尔评估，您可能会生成如下代码：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice a very subtle but important difference between these two conversions:
    If `x` is equal to `y`, then the first version above *still increments z* and
    compares it to 0 before it executes the code associated with `Stmt`; the short-circuit
    version, on the other hand, skips the code that increments `z` if it turns out
    that `x` is equal to `y`. Therefore, the behavior of these two code fragments
    is different if `x` is equal to `y`. Neither implementation is particularly wrong;
    depending on the circumstances you may or may not want the code to increment `z`
    if `x` is equal to `y`. However, it is important that you realize that these two
    schemes produce different results, so you can choose an appropriate implementation
    if the effect of this code on `z` matters to your program.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这两个转换之间一个非常微妙但重要的区别：如果`x`等于`y`，那么上面第一版本*仍然会递增z*并在执行与`Stmt`相关的代码之前将其与0进行比较；另一方面，短路版本如果`x`等于`y`，则跳过递增`z`的代码。因此，如果`x`等于`y`，这两段代码的行为是不同的。没有哪种实现特别错误；根据具体情况，您可能希望或者不希望在`x`等于`y`时递增`z`。然而，重要的是要意识到这两种方案会产生不同的结果，因此，如果`z`的变化对程序有影响，您可以选择合适的实现。
- en: 'Many programs take advantage of short-circuit boolean evaluation and rely on
    the fact that the program may not evaluate certain components of the expression.
    The following C/C++ code fragment demonstrates what is probably the most common
    example that requires short-circuit boolean evaluation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序利用短路布尔评估，并依赖于程序可能不会评估表达式中的某些组件这一事实。以下的C/C++代码片段演示了可能最常见的需要短路布尔评估的例子：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If it turns out that `Ptr` is `NULL`, then the expression is false and there
    is no need to evaluate the remainder of the expression (and, therefore, code that
    uses short-circuit boolean evaluation will not evaluate the remainder of this
    expression). This statement relies on the semantics of short-circuit boolean evaluation
    for correct operation. Were C/C++ to use complete boolean evaluation, and the
    variable `Ptr` contained `NULL`, then the second half of the expression would
    attempt to dereference a `NULL` pointer (which tends to crash most programs).
    Consider the translation of this statement using complete and short-circuit boolean
    evaluation:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果是`Ptr`为`NULL`，那么表达式为假，并且无需计算表达式的其余部分（因此，使用短路布尔评估的代码将不会计算该表达式的其余部分）。这个语句依赖于短路布尔评估的语义才能正确操作。如果C/C++使用完全布尔评估，并且变量`Ptr`包含`NULL`，那么表达式的后半部分将尝试解引用一个`NULL`指针（这通常会导致大多数程序崩溃）。考虑使用完全布尔评估和短路布尔评估翻译此语句：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice in this example that if `Ptr` contains `NULL` (0), then this program
    will attempt to access the data at location 0 in memory via the `mov( [eax], al
    );` instruction. Under most operating systems this will cause a memory access
    fault (general protection fault).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，如果`Ptr`包含`NULL`（0），则程序将通过`mov( [eax], al );`指令尝试访问内存位置0的数据。在大多数操作系统下，这将导致内存访问故障（一般保护故障）。
- en: 'Now consider the short-circuit boolean conversion:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑短路布尔转换：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see in this example, the problem with dereferencing the `NULL` pointer
    doesn't exist. If `Ptr` contains `NULL`, this code skips over the statements that
    attempt to access the memory address `Ptr` contains.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此示例中所见，解引用`NULL`指针的问题不存在。如果`Ptr`包含`NULL`，那么这段代码会跳过尝试访问`Ptr`所包含的内存地址的语句。
- en: 7.7.6 Efficient Implementation of if Statements in Assembly Language
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.6 汇编语言中`if`语句的高效实现
- en: Encoding `if` statements efficiently in assembly language takes a bit more thought
    than simply choosing short-circuit evaluation over complete boolean evaluation.
    To write code that executes as quickly as possible in assembly language, you must
    carefully analyze the situation and generate the code appropriately. The following
    paragraphs provide some suggestions you can apply to your programs to improve
    their performance.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中高效编码`if`语句需要比仅仅选择短路求值而不是完整布尔求值更多的思考。为了在汇编语言中编写执行速度尽可能快的代码，你必须仔细分析情况，并适当地生成代码。以下段落提供了一些建议，你可以将其应用到你的程序中，以提高性能。
- en: 7.7.6.1 Know Your Data!
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6.1 了解你的数据！
- en: 'A mistake programmers often make is the assumption that data is random. In
    reality, data is rarely random, and if you know the types of values that your
    program commonly uses, you can use this knowledge to write better code. To see
    how, consider the following C/C++ statement:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员常犯的一个错误是假设数据是随机的。实际上，数据很少是随机的，如果你知道程序常用的值类型，你可以利用这一知识编写更好的代码。看看如何做，考虑以下C/C++语句：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Because C/C++ uses short-circuit evaluation, this code will test to see if
    `a` is equal to `b`. If so, then it will test to see if `c` is less than `d`.
    If you expect `a` to be equal to `b` most of the time but don''t expect `c` to
    be less than `d` most of the time, this statement will execute slower than it
    should. Consider the following HLA implementation of this code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C/C++使用短路求值，这段代码会首先检查`a`是否等于`b`。如果是，它将检查`c`是否小于`d`。如果你预计`a`大多数时候等于`b`，但不预计`c`大多数时候小于`d`，这条语句的执行速度将比预期的要慢。考虑以下HLA实现的这段代码：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see in this code, if `a` is equal to `b` most of the time and `c`
    is not less than `d` most of the time, you will have to execute all six instructions
    nearly every time in order to determine that the expression is false. Now consider
    the following implementation of the above C/C++ statement that takes advantage
    of this knowledge and the fact that the `&&` operator is commutative:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在这段代码中所见，如果`a`大多数时候等于`b`且`c`大多数时候不小于`d`，你将几乎每次都必须执行所有六条指令，以确定表达式的结果是错误的。现在，考虑一下利用这个知识，并且利用`&&`运算符交换律的事实对上述C/C++语句的实现：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this example the code first checks to see if `c` is less than `d`. If most
    of the time `c` is less than `d`, then this code determines that it has to skip
    to the label `DontIncI` after executing only three instructions in the typical
    case (compared with six instructions in the previous example). This fact is much
    more obvious in assembly language than in a high-level language; this is one of
    the main reasons why assembly programs are often faster than their high-level
    language counterparts: optimizations are more obvious in assembly language than
    in a high-level language. Of course, the key here is to understand the behavior
    of your data so you can make intelligent decisions such as the one above.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，代码首先检查`c`是否小于`d`。如果大多数情况下`c`小于`d`，那么这段代码会确定它只需执行三条指令（与前一个例子中的六条指令相比），然后跳到标签`DontIncI`。在汇编语言中，这一点比在高级语言中更为明显；这也是汇编程序通常比其高级语言对应程序更快的主要原因之一：优化在汇编语言中比在高级语言中更为直观。当然，关键是要理解你的数据行为，这样你才能做出像上面那样的智能决策。
- en: 7.7.6.2 Rearranging Expressions
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6.2 重新排列表达式
- en: 'Even if your data is random (or you can''t determine how the input values will
    affect your decisions), there may still be some benefit to rearranging the terms
    in your expressions. Some calculations take far longer to compute than others.
    For example, the `div` instruction is much slower than a simple `cmp` instruction.
    Therefore, if you have a statement like the following, you may want to rearrange
    the expression so that the `cmp` comes first:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的数据是随机的（或者你无法确定输入值如何影响你的决策），重新排列表达式中的项可能仍然会带来一些好处。一些计算比其他计算花费的时间要长得多。例如，`div`指令比简单的`cmp`指令要慢得多。因此，如果你有如下的语句，你可能希望重新排列表达式，使得`cmp`优先执行：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Converted to assembly code, this `if` statement becomes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为汇编代码后，这个`if`语句变成了：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `imod` instruction is very expensive (often 50–100 times slower than most
    of the other instructions in this example). Unless it is 50–100 times more likely
    that the remainder is 0 rather than `x` is equal to `y`, it would be better to
    do the comparison first and the remainder calculation afterward:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`imod`指令非常昂贵（在这个例子中通常比大多数其他指令慢50到100倍）。除非余数为0的可能性比`x`等于`y`的可能性大50到100倍，否则最好先进行比较，然后再进行余数计算：'
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Of course, in order to rearrange the expression in this manner, the code must
    not assume the use of short-circuit evaluation semantics (because the `&&` and
    `||` operators are not commutative if the code must compute one subexpression
    before another).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了以这种方式重新排列表达式，代码不能假定使用短路求值语义（因为`&&`和`||`运算符在必须先计算一个子表达式然后计算另一个子表达式时不具有交换律）。
- en: 7.7.6.3 Destructuring Your Code
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6.3 重构你的代码
- en: Although there are many good things to be said about structured programming
    techniques, there are some drawbacks to writing structured code. Specifically,
    structured code is sometimes less efficient than unstructured code. Most of the
    time this is tolerable because unstructured code is difficult to read and maintain;
    it is often acceptable to sacrifice some performance in exchange for maintainable
    code. In certain instances, however, you may need all the performance you can
    get. In those rare instances you might choose to compromise the readability of
    your code in order to gain some additional performance.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管结构化编程技术有很多优点，但编写结构化代码也有一些缺点。具体而言，结构化代码有时比非结构化代码效率低。大多数情况下这是可以接受的，因为非结构化代码难以阅读和维护；通常可以牺牲一些性能以换取可维护的代码。然而，在某些情况下，你可能需要尽可能地提升性能。在这些罕见的情况下，你可能会选择为了获得额外的性能而牺牲代码的可读性。
- en: 'One classic way to do this is to use code movement to move code your program
    rarely uses out of the way of code that executes most of the time. For example,
    consider the following pseudo C/C++ statement:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的做法是使用代码移动将程序中很少使用的代码移到大部分时间执行的代码之外。例如，考虑以下伪 C/C++ 语句：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In normal code, one does not expect errors to be frequent. Therefore, you would
    normally expect the `then` section of the above `if` to execute far more often
    than the `else` clause. The code above could translate into the following assembly
    code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的代码中，人们并不期望错误经常发生。因此，你通常会期望上述`if`语句的`then`部分执行的次数远远超过`else`分支。上面的代码可以转换为以下汇编代码：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Notice that if the expression is false, this code falls through to the normal
    statements and then jumps over the error-handling statements. Instructions that
    transfer control from one point in your program to another (for example, `jmp`
    instructions) tend to be slow. It is much faster to execute a sequential set of
    instructions rather than jump all over the place in your program. Unfortunately,
    the code above doesn''t allow this. One way to rectify this problem is to move
    the `else` clause of the code somewhere else in your program. That is, you could
    rewrite the code as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果表达式为假，此代码会继续执行正常的语句，然后跳过错误处理语句。控制从程序的一个点转移到另一个点的指令（例如`jmp`指令）通常速度较慢。执行顺序一致的一组指令要比在程序中到处跳转快得多。不幸的是，上面的代码不允许这样做。解决这个问题的一种方法是将代码的`else`分支移动到程序的其他位置。也就是说，你可以将代码重写为以下形式：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At some other point in your program (typically after a `jmp` instruction) you
    would insert the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的某个其他位置（通常在`jmp`指令之后），你会插入以下代码：
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that the program isn't any shorter. The `jmp` you removed from the original
    sequence winds up at the end of the `else` clause. However, because the `else`
    clause rarely executes, moving the `jmp` instruction from the `then` clause (which
    executes frequently) to the `else` clause is a big performance win because the
    `then` clause executes using only straight-line code. This technique is surprisingly
    effective in many time-critical code segments.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序的长度没有任何变化。你从原序列中移除的`jmp`最终会出现在`else`分支的末尾。然而，由于`else`分支很少执行，将`jmp`指令从频繁执行的`then`分支移到`else`分支中是一个重大的性能优化，因为`then`分支只使用直线代码。这种技术在许多时间关键的代码段中效果惊人。
- en: There is a difference between writing *destructured* code and writing *unstructured*
    code. Unstructured code is written in an unstructured way to begin with. It is
    generally hard to read, difficult to maintain, and often contains defects. Destructured
    code, on the other hand, starts out as structured code, and you make a conscious
    decision to eliminate the structure in order to gain a small performance boost.
    Generally, you've already tested the code in its structured form before destructuring
    it. Therefore, destructured code is often easier to work with than unstructured
    code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 写*非结构化*代码和写*结构化*代码是有区别的。非结构化代码一开始就以非结构化方式编写。它通常难以阅读、难以维护，并且经常包含缺陷。另一方面，非结构化代码从结构化代码开始，您做出有意识的决定来消除结构，以获得小幅度的性能提升。通常，在将其非结构化之前，您已经测试了结构化形式的代码。因此，非结构化代码通常比非结构化代码更易于处理。
- en: 7.7.6.4 Calculation Rather Than Branching
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6.4 计算而非分支
- en: 'On many processors in the 80x86 family, branches ( jumps) are very expensive
    compared to many other instructions. For this reason it is sometimes better to
    execute more instructions in a sequence than fewer instructions that involve branching.
    For example, consider the simple assignment `eax = abs( eax );`. Unfortunately,
    there is no 80x86 instruction that computes the absolute value of an integer.
    The obvious way to handle this is with an instruction sequence like the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多80x86系列处理器中，分支（跳转）与许多其他指令相比非常昂贵。因此，有时在序列中执行更多的指令比执行涉及分支的较少指令更好。例如，考虑简单的赋值语句`eax
    = abs( eax );`。不幸的是，80x86指令集中没有计算整数绝对值的指令。处理这个问题的明显方法是使用以下指令序列：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'However, as you can plainly see in this example, it uses a conditional jump
    to skip over the `neg` instruction (that creates a positive value in EAX if EAX
    was negative). Now consider the following sequence that will also do the job:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如您在此示例中明显看到的，它使用条件跳转来跳过`neg`指令（如果EAX为负则会创建一个正数值）。现在考虑以下也能完成任务的序列：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This code will invert all the bits in EAX and then add 1 to EAX if EAX was negative
    prior to the sequence; that is, it negates the value in EAX. If EAX was 0 or positive,
    then this code does not change the value in EAX.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果EAX在序列之前是负数，则此代码将反转EAX中的所有位，然后向EAX添加1；也就是说，它否定了EAX中的值。如果EAX为0或正数，则此代码不会更改EAX中的值。
- en: Note that this sequence takes four instructions rather than the three the previous
    example requires. However, because there are no transfer-of-control instructions
    in this sequence, it may execute faster on many CPUs in the 80x86 family.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此序列需要四条指令，而不是前面示例中所需的三条指令。但是，由于此序列中没有控制传输指令，因此在80x86系列的许多CPU上可能执行速度更快。
- en: 7.7.7 switch/case Statements
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.7 switch/case语句
- en: 'The HLA `switch` statement takes the following form:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: HLA `switch`语句的形式如下：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When this statement executes, it checks the value of the register against the
    constants *`const1`*`..`*`constn`*. If a match is found, then the corresponding
    statements execute. HLA places a few restrictions on the `switch` statement. First,
    the HLA `switch` statement allows only a 32-bit register as the `switch` expression.
    Second, all the constants in the `case` clauses must be unique. The reason for
    these restrictions will become clear in a moment.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当此语句执行时，它检查寄存器的值是否与常量*`const1`*`..`*`constn`*匹配。如果找到匹配项，则执行相应的语句。HLA对`switch`语句有一些限制。首先，HLA
    `switch`语句只允许32位寄存器作为`switch`表达式。其次，在`case`子句中的所有常量必须是唯一的。这些限制的原因将很快明了。
- en: 'Most introductory programming texts introduce the `switch/case` statement by
    explaining it as a sequence of `if..then..elseif..else..endif` statements. They
    might claim that the following two pieces of HLA code are equivalent:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数入门编程教材通过将`switch/case`语句解释为一系列`if..then..elseif..else..endif`语句来介绍它。他们可能会声称以下两段HLA代码是等效的：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'While semantically these two code segments may be the same, their implementation
    is usually different. Whereas the `if..then..elseif..else..endif` chain does a
    comparison for each conditional statement in the sequence, the `switch` statement
    normally uses an indirect jump to transfer control to any one of several statements
    with a single computation. Consider the two examples presented above; they could
    be written in assembly language with the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The implementation of the `if..then..elseif..else..endif` version is fairly
    obvious and needs little in the way of explanation. The indirect jump version,
    however, is probably quite mysterious to you, so let's consider how this particular
    implementation of the `switch` statement works.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Remember that there are three common forms of the `jmp` instruction. The standard
    unconditional `jmp` instruction, like the `jmp EndCase`; instruction in the previous
    examples, transfers control directly to the statement label specified as the `jmp`
    operand. The second form of the `jmp` instruction—`jmp(` *`reg32`* `);`— transfers
    control to the memory location specified by the address found in a 32-bit register.
    The third form of the `jmp` instruction, the one the previous example uses, transfers
    control to the instruction specified by the contents of a double-word memory location.
    As this example clearly illustrates, that memory location can use any addressing
    mode. You are not limited to the displacement-only addressing mode. Now let's
    consider exactly how this second implementation of the `switch` statement works.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, a `switch` statement requires that you create an array of pointers
    with each element containing the address of a statement label in your code (those
    labels must be attached to the sequence of instructions to execute for each case
    in the `switch` statement). In the example above, the `JmpTbl` array serves this
    purpose. Note that this code initializes `JmpTbl` with the address of the statement
    labels `Stmt0`, `Stmt1`, and `Stmt2`. The program places this array in the `readonly`
    section because the program should never change these values during execution.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you initialize an array with a set of addresses of statement labels
    as in this example, the declaration section in which you declare the array (e.g.,
    `readonly` in this case) must be in the same procedure that contains the statement
    labels.^([[107](#ftn.CHP-7-FN-3)])
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: During the execution of this code sequence, the program loads the EAX register
    with `i`'s value. Then the program uses this value as an index into the `JmpTbl`
    array and transfers control to the 4-byte address found at the specified location.
    For example, if EAX contains 0, the `jmp( JmpTbl[eax*4] );` instruction will fetch
    the double word at address `JmpTbl+0 ( eax*4=0 )`. Because the first double word
    in the table contains the address of `Stmt0`, the `jmp` instruction transfers
    control to the first instruction following the `Stmt0` label. Likewise, if `i`
    (and therefore, EAX) contains 1, then the indirect `jmp` instruction fetches the
    double word at offset 4 from the table and transfers control to the first instruction
    following the `Stmt1` label (because the address of `Stmt1` appears at offset
    4 in the table). Finally, if `i`/EAX contains 2, then this code fragment transfers
    control to the statements following the `Stmt2` label because it appears at offset
    8 in the `JmpTbl` table.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此代码序列时，程序将`i`的值加载到EAX寄存器中。然后程序使用该值作为`JmpTbl`数组的索引，并将控制权转移到指定位置的4字节地址。例如，如果EAX中包含0，`jmp(
    JmpTbl[eax*4] );`指令将获取地址`JmpTbl+0 ( eax*4=0 )`处的双字数据。因为表中的第一个双字包含`Stmt0`的地址，所以`jmp`指令将控制权转移到`Stmt0`标签后的第一条指令。同样，如果`i`（因此EAX）包含1，那么间接`jmp`指令将获取表中偏移量为4的双字，并将控制权转移到`Stmt1`标签后的第一条指令（因为`Stmt1`的地址出现在表的偏移量4处）。最后，如果`i`/EAX包含2，那么这段代码将控制权转移到`JmpTbl`表中偏移量为8处的`Stmt2`标签后的语句。
- en: You should note that as you add more (consecutive) cases, the jump table implementation
    becomes more efficient (in terms of both space and speed) than the `if/elseif`
    form. Except for simple cases, the `switch` statement is almost always faster
    and usually by a large margin. As long as the `case` values are consecutive, the
    `switch` statement version is usually smaller as well.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意，当你添加更多（连续的）`case`时，跳转表实现比`if/elseif`形式更高效（无论在空间还是速度方面）。除非是简单的情况，`switch`语句几乎总是更快，而且通常差距较大。只要`case`值是连续的，`switch`语句版本通常也更小。
- en: What happens if you need to include nonconsecutive `case` labels or you cannot
    be sure that the `switch` value doesn't go out of range? With the HLA `switch`
    statement, such an occurrence will transfer control to the first statement after
    the `endswitch` clause (or to a `default` case, if one is present in the switch).
    However, this doesn't happen in the example above. If variable `i` does not contain
    0, 1, or 2, executing the code above produces undefined results. For example,
    if `i` contains 5 when you execute the code in the previous example, the indirect
    `jmp` instruction will fetch the dword at offset 20 (5 * 4) in `JmpTbl` and transfer
    control to that address. Unfortunately, `JmpTbl` doesn't have six entries; so
    the program will wind up fetching the value of the third double word following
    `JmpTbl` and use that as the target address. This will often crash your program
    or transfer control to an unexpected location.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要包含不连续的`case`标签，或者你不能确保`switch`值不会超出范围，会发生什么情况？对于HLA的`switch`语句，出现这种情况时会将控制转移到`endswitch`语句后的第一条语句（或者转移到`default`语句，如果`switch`中存在`default`）。然而，在上面的例子中并没有发生这种情况。如果变量`i`不包含0、1或2，执行上面的代码将产生未定义的结果。例如，如果在执行上面代码时，`i`的值为5，那么间接`jmp`指令将获取`JmpTbl`中偏移量为20（5
    * 4）处的双字，并将控制权转移到该地址。不幸的是，`JmpTbl`中没有六个条目；因此，程序将最终获取`JmpTbl`后第三个双字的值，并将其作为目标地址。这通常会导致程序崩溃，或者将控制转移到一个意外的位置。
- en: 'The solution is to place a few instructions before the indirect `jmp` to verify
    that the `switch` selection value is within some reasonable range. In the previous
    example, we''d probably want to verify that `i`''s value is in the range 0..2
    before executing the `jmp` instruction. If `i`''s value is outside this range,
    the program should simply jump to the `endcase` label (this corresponds to dropping
    down to the first statement after the `endswitch` clause). The following code
    provides this modification:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在间接`jmp`指令之前放置几条指令，以验证`switch`选择值是否在合理范围内。在之前的例子中，我们可能希望在执行`jmp`指令之前验证`i`的值是否在0..2的范围内。如果`i`的值超出此范围，程序应该直接跳转到`endcase`标签（这对应于跳到`endswitch`语句后的第一条语句）。以下代码实现了这一修改：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Although the example above handles the problem of selection values being outside
    the range 0..2, it still suffers from a couple of severe restrictions:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上面的例子处理了选择值超出0..2范围的问题，但它仍然存在几个严重的限制：
- en: The cases must start with the value 0\. That is, the minimum `case` constant
    has to be 0 in this example.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The case values must be contiguous.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solving the first problem is easy, and you deal with it in two steps. First,
    you must compare the case selection value against a lower and upper bounds before
    determining if the case value is legal. For example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As you can see, this code adds a pair of extra instructions, `cmp` and `jb`,
    to test the selection value to ensure it is in the range 5..7\. If not, control
    drops down to the `EndCase` label; otherwise control transfers via the indirect
    `jmp` instruction. Unfortunately, as the comments point out, this code is broken.
    Consider what happens if variable `i` contains the value 5: the code will verify
    that 5 is in the range 5..7 and then it will fetch the dword at offset 20 (`5*@size(dword)`)
    and jump to that address. As before, however, this loads 4 bytes outside the bounds
    of the table and does not transfer control to a defined location. One solution
    is to subtract the smallest case selection value from EAX before executing the
    `jmp` instruction, as shown in the following example.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: By subtracting 5 from the value in EAX, this code forces EAX to take on the
    value 0, 1, or 2 prior to the `jmp` instruction. Therefore, case-selection value
    5 jumps to `Stmt5`, case-selection value 6 transfers control to `Stmt6`, and case-selection
    value 7 jumps to `Stmt7`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a sneaky way to improve the code above. You can eliminate the `sub`
    instruction by merging this subtraction into the `jmp` instruction''s address
    expression. Consider the following code that does this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The HLA `switch` statement provides a `default` clause that executes if the
    case-selection value doesn''t match any of the case values. For example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Implementing the equivalent of the `default` clause in pure assembly language
    is very easy. Just use a different target label in the `jb` and `ja` instructions
    at the beginning of the code. The following example implements an HLA `switch`
    statement similar to the one immediately above:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The second restriction noted earlier, that the case values need to be contiguous,
    is easy to handle by inserting extra entries into the jump table. Consider the
    following HLA `switch` statement:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The minimum switch value is 1 and the maximum value is 8\. Therefore, the code
    before the indirect `jmp` instruction needs to compare the value in EBX against
    1 and 8\. If the value is between 1 and 8, it''s still possible that EBX might
    not contain a legal case-selection value. However, because the `jmp` instruction
    indexes into a table of double words using the case-selection table, the table
    must have eight double-word entries. To handle the values between 1 and 8 that
    are not case-selection values, simply put the statement label of the `default`
    clause (or the label specifying the first instruction after the `endswitch` if
    there is no `default` clause) in each of the jump table entries that don''t have
    a corresponding `case` clause. The following code demonstrates this technique:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There is a problem with this implementation of the `switch` statement. If the
    `case` values contain nonconsecutive entries that are widely spaced, the jump
    table could become exceedingly large. The following `switch` statement would generate
    an extremely large code file:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this situation, your program will be much smaller if you implement the `switch`
    statement with a sequence of `if` statements rather than using an indirect jump
    statement. However, keep one thing in mind—the size of the jump table does not
    normally affect the execution speed of the program. If the jump table contains
    two entries or two thousand, the `switch` statement will execute the multiway
    branch in a constant amount of time. The `if` statement implementation requires
    a linearly increasing amount of time for each `case` label appearing in the `case`
    statement.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the biggest advantage to using assembly language over an HLL like
    Pascal or C/C++ is that you get to choose the actual implementation of statements
    like `switch`. In some instances you can implement a `switch` statement as a sequence
    of `if..then..elseif` statements, or you can implement it as a jump table, or
    you can use a hybrid of the two:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This could become
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Of course, HLA supports the following code high-level control structures:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: But this tends to destroy the readability of the program. On the other hand,
    the extra code to test for 100 in the assembly language code doesn't adversely
    affect the readability of the program (perhaps because it's so hard to read already).
    Therefore, most people will add the extra code to make their program more efficient.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The C/C++ `switch` statement is very similar to the HLA `switch` statement.
    There is only one major semantic difference: The programmer must explicitly place
    a `break` statement in each `case` clause to transfer control to the first statement
    beyond the `switch`. This `break` corresponds to the `jmp` instruction at the
    end of each `case` sequence in the assembly code above. If the corresponding `break`
    is not present, C/C++ transfers control into the code of the following `case`.
    This is equivalent to leaving off the `jmp` at the end of the `case`''s sequence:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This translates into the following 80x86 code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '* * *'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: ^([[106](#CHP-7-FN-2)]) However, be aware of the fact that some expressions
    depend on the leftmost subexpression evaluating one way in order for the rightmost
    subexpression to be valid; for example, a common test in C/C++ is `if( x != NULL
    && x->y )...`
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: ^([[107](#CHP-7-FN-3)]) If the `switch` statement appears in your main program,
    you must declare the array in the declaration section of your main program.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 7.8 State Machines and Indirect Jumps
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another control structure commonly found in assembly language programs is the
    *state machine*. A state machine uses a *state variable* to control program flow.
    The FORTRAN programming language provides this capability with the assigned `goto`
    statement. Certain variants of C (for example, GNU's GCC from the Free Software
    Foundation) provide similar features. In assembly language, the indirect jump
    can implement state machines.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: So what is a state machine? In very basic terms, it is a piece of code that
    keeps track of its execution history by entering and leaving certain "states."
    For the purposes of this chapter, we'll just assume that a state machine is a
    piece of code that (somehow) remembers the history of its execution (its *state*)
    and executes sections of code based on that history.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: In a very real sense, all programs are state machines. The CPU registers and
    values in memory constitute the state of that machine. However, we'll use a much
    more constrained view. Indeed, for most purposes only a single variable (or the
    value in the EIP register) will denote the current state.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s consider a concrete example. Suppose you have a procedure that you
    want to perform one operation the first time you call it, a different operation
    the second time you call it, yet something else the third time you call it, and
    then something new again on the fourth call. After the fourth call it repeats
    these four different operations in order. For example, suppose you want the procedure
    to add EAX and EBX the first time, subtract them on the second call, multiply
    them on the third, and divide them on the fourth. You could implement this procedure
    as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Technically, this procedure is not the state machine. Instead, it is the variable
    `State` and the `cmp`/`jne` instructions that constitute the state machine.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing particularly special about this code. It's little more than
    a `switch` statement implemented via the `if..then..elseif` construct. The only
    thing unique about this procedure is that it remembers how many times it has been
    called^([[108](#ftn.CHP-7-FN-4)]) and behaves differently depending upon the number
    of calls. While this is a *correct* implementation of the desired state machine,
    it is not particularly efficient. The astute reader, of course, would recognize
    that this code could be made a little faster using an actual `switch` statement
    rather than the `if..then..elseif` implementation. However, there is an even better
    solution.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'A common implementation of a state machine in assembly language is to use an
    indirect jump. Rather than having a state variable that contains a value like
    0, 1, 2, or 3, we could load the state variable with the *address* of the code
    to execute upon entry into the procedure. By simply jumping to that address, the
    state machine could save the tests needed to select the proper code fragment.
    Consider the following implementation using the indirect jump:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `jmp` instruction at the beginning of the `StateMachine` procedure transfers
    control to the location pointed at by the `State` variable. The first time you
    call `StateMachine` it points at the `State0` label. Thereafter, each subsection
    of code sets the `State` variable to point at the appropriate successor code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: ^([[108](#CHP-7-FN-4)]) Actually, it remembers how many times, `modulo 4`, that
    it has been called.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 Spaghetti Code
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One major problem with assembly language is that it takes several statements
    to realize a simple idea encapsulated by a single high-level language statement.
    All too often an assembly language programmer will notice that she or he can save
    a few bytes or cycles by jumping into the middle of some program structure. After
    a few such observations (and corresponding modifications) the code contains a
    whole sequence of jumps in and out of portions of the code. If you were to draw
    a line from each jump to its destination, the resulting listing would end up looking
    like someone dumped a bowl of spaghetti on your code, hence the term *spaghetti
    code*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Spaghetti code suffers from one major drawback—it's difficult (at best) to read
    such a program and figure out what it does. Most programs start out in a "structured"
    form only to become spaghetti code when sacrificed at the altar of efficiency.
    Alas, spaghetti code is rarely efficient. Because it's difficult to figure out
    exactly what's going on, it's very difficult to determine if you can use a better
    algorithm to improve the system. Hence, spaghetti code may wind up less efficient
    than structured code.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: While it's true that producing some spaghetti code in your programs may improve
    its efficiency, doing so should always be a last resort after you've tried everything
    else and you still haven't achieved what you need. Always start out writing your
    programs with straightforward `if` and `switch` statements. Start combining sections
    of code (via `jmp` instructions) once everything is working and well understood.
    Of course, you should never obliterate the structure of your code unless the gains
    are worth it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: A famous saying in structured programming circles is, "After `goto`s, pointers
    are the next most dangerous element in a programming language." A similar saying
    is "Pointers are to data structures what `goto`s are to control structures." In
    other words, avoid excessive use of pointers. If pointers and `goto`s are bad,
    then the indirect jump must be the worst construct of all because it involves
    both `goto`s and pointers! Seriously, though, the indirect jump instruction should
    be avoided for casual use. Its use tends to make a program harder to read. After
    all, an indirect jump can (theoretically) transfer control to any point within
    a program. Imagine how hard it would be to follow the flow through a program if
    you have no idea what a pointer contains and you come across an indirect jump
    using that pointer. Therefore, you should always exercise care when using jump
    indirect instructions.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 7.10 Loops
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops represent the final basic control structure (sequences, decisions, and
    loops) that make up a typical program. Like so many other structures in assembly
    language, you'll find yourself using loops in places you've never dreamed of using
    loops. Most high-level languages have implied loop structures hidden away. For
    example, consider the BASIC statement `if A$ = B$ then 100`. This `if` statement
    compares two strings and jumps to statement 100 if they are equal. In assembly
    language, you would need to write a loop to compare each character in `A$` to
    the corresponding character in `B$` and then jump to statement 100 if and only
    if all the characters matched. In BASIC, there is no loop to be seen in the program.
    Assembly language requires a loop to compare the individual characters in the
    string.^([[109](#ftn.CHP-7-FN-5)]) This is but a small example that shows how
    loops seem to pop up everywhere.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Program loops consist of three components: an optional initialization component,
    an optional loop termination test, and the body of the loop. The order in which
    you assemble these components can dramatically affect the loop''s operation. Three
    permutations of these components appear frequently in programs. Because of their
    frequency, these loop structures are given special names in high-level languages:
    `while` loops, `repeat..until` loops (`do..while` in C/C++), and infinite loops
    (e.g., `forever..endfor` in HLA).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.1 while Loops
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most general loop is the `while` loop. In HLA''s high-level syntax it takes
    the following form:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There are two important points to note about the `while` loop. First, the test
    for termination appears at the beginning of the loop. Second, as a direct consequence
    of the position of the termination test, the body of the loop may never execute
    if the boolean expression is always false.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following HLA `while` loop:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `mov( 0, i );` instruction is the initialization code for this loop. `i`
    is a loop-control variable, because it controls the execution of the body of the
    loop. `i < 100` is the loop termination condition. That is, the loop will not
    terminate as long as `i` is less than 100\. The single instruction `inc( i );`
    is the loop body that executes on each loop iteration.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that an HLA `while` loop can be easily synthesized using `if` and `jmp`
    statements. For example, you may replace the previous HLA `while` loop with the
    following HLA code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'More generally, you can construct any `while` loop as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Therefore, you can use the techniques from earlier in this chapter to convert
    if statements to assembly language and add a single `jmp` instruction to produce
    a `while` loop. The example we've been looking at in this section translates to
    the following pure 80x86 assembly code:^([[110](#ftn.CHP-7-FN-6)])
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 7.10.2 repeat..until Loops
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `repeat..until` (`do..while`) loop tests for the termination condition
    at the end of the loop rather than at the beginning. In HLA high-level syntax,
    the `repeat..until` loop takes the following form:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This sequence executes the initialization code, then executes the loop body,
    and finally tests some condition to see if the loop should repeat. If the boolean
    expression evaluates to false, the loop repeats; otherwise the loop terminates.
    The two things you should note about the `repeat..until` loop are that the termination
    test appears at the end of the loop and, as a direct consequence of this, the
    loop body always executes at least once.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `while` loop, the `repeat..until` loop can be synthesized with an
    `if` statement and a `jmp`. You could use the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Based on the material presented in the previous sections, you can easily synthesize
    `repeat..until` loops in assembly language. The following is a simple example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 7.10.3 forever..endfor Loops
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If while loops test for termination at the beginning of the loop and `repeat..until`
    loops check for termination at the end of the loop, the only place left to test
    for termination is in the middle of the loop. The HLA high-level `forever..endfor`
    loop, combined with the `break` and `breakif` statements, provides this capability.
    The `forever..endfor` loop takes the following form:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Note that there is no explicit termination condition. Unless otherwise provided
    for, the `forever..endfor` construct forms an infinite loop. A `breakif` statement
    usually handles loop termination. Consider the following HLA code that employs
    a `forever..endfor` construct:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Converting a `forever` loop to pure assembly language is easy. All you need
    is a label and a `jmp` instruction. The `breakif` statement in this example is
    really nothing more than an `if` and a `jmp` instruction. The pure assembly language
    version of the code above looks something like the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 7.10.4 for Loops
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` loop is a special form of the `while` loop that repeats the loop
    body a specific number of times. In HLA, the `for` loop takes the following form:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is completely equivalent to the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Traditionally, programs use the for loop to process arrays and other objects
    accessed in sequential order. One normally initializes a loop-control variable
    with the initialization statement and then uses the loop-control variable as an
    index into the array (or other data type). For example:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To convert this to pure assembly language, begin by translating the `for` loop
    into an equivalent `while` loop:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, using the techniques from the section on `while` loops, translate the
    code into pure assembly language:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 7.10.5 The break and continue Statements
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HLA `break` and `continue` statements both translate into a single `jmp`
    instruction. The `break` instruction exits the loop that immediately contains
    the `break` statement; the `continue` statement restarts the loop that immediately
    contains the `continue` statement.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Converting a `break` statement to pure assembly language is very easy. Just
    emit a `jmp` instruction that transfers control to the first statement following
    the `end`*`xxxx`* (or `until`) clause of the loop to exit. You can do this by
    placing a label after the associated `end`*`xxxx`* clause and jumping to that
    label. The following code fragments demonstrate this technique for the various
    loops.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `continue` statement is slightly more complex than the `break` statement.
    The implementation is still a single `jmp` instruction; however, the target label
    doesn't wind up going in the same spot for each of the different loops. [Figure 7-2](ch07s10.html#continue_destination_for_the_forever_loo
    "Figure 7-2. continue destination for the forever loop"), [Figure 7-3](ch07s10.html#continue_destination_and_the_while_loop
    "Figure 7-3. continue destination and the while loop"), [Figure 7-4](ch07s10.html#continue_destination_and_the_for_loop
    "Figure 7-4. continue destination and the for loop"), and [Figure 7-5](ch07s10.html#continue_destination_and_the_repeat..unt
    "Figure 7-5. continue destination and the repeat..until loop") show where the
    `continue` statement transfers control for each of the HLA loops.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![continue destination for the forever loop](tagoreillycom20100401nostarchimages578035.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2. `continue` destination for the `forever` loop
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '![continue destination and the while loop](tagoreillycom20100401nostarchimages578037.png.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3. `continue` destination and the `while` loop
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![continue destination and the for loop](tagoreillycom20100401nostarchimages578039.png.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4. `continue` destination and the `for` loop
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '![continue destination and the repeat..until loop](tagoreillycom20100401nostarchimages578041.png.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5. `continue` destination and the `repeat..until` loop
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The following code fragments demonstrate how to convert the `continue` statement
    into an appropriate `jmp` instruction for each of these loop types.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: forever..continue..endfor
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: while..continue..endwhile
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: for..continue..endfor
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: repeat..continue..until
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 7.10.6 Register Usage and Loops
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given that the 80x86 accesses registers more efficiently than memory locations,
    registers are the ideal spot to place loop-control variables (especially for small
    loops). However, there are some problems associated with using registers within
    a loop. The primary problem with using registers as loop-control variables is
    that registers are a limited resource. The following will not work properly because
    it attempts to reuse a register (CX) that is already in use:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The intent here, of course, was to create a set of nested loops, that is, one
    loop inside another. The inner loop (`loop2`) should repeat four times for each
    of the eight executions of the outer loop (`loop1`). Unfortunately, both loops
    use the same register as a loop-control variable. Therefore, this will form an
    infinite loop because CX will contain 0 at the end of the first loop. Because
    CX is always 0 upon encountering the second `dec` instruction, control will always
    transfer to the `loop1` label (because decrementing 0 produces a nonzero result).
    The solution here is to save and restore the CX register or to use a different
    register in place of CX for the outer loop:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: or
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Register corruption is one of the primary sources of bugs in loops in assembly
    language programs, so always keep an eye out for this problem.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: ^([[109](#CHP-7-FN-5)]) Of course, the HLA Standard Library provides the `str.eq`
    routine that compares the strings for you, effectively hiding the loop even in
    an assembly language program.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: ^([[110](#CHP-7-FN-6)]) Note that HLA will actually convert most `while` statements
    to different 80x86 code than this section presents. The reason for the difference
    appears in [7.11 Performance Improvements](ch07s11.html "7.11 Performance Improvements"),
    when we explore how to write more efficient loop code.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 7.11 Performance Improvements
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 80x86 microprocessors execute sequences of instructions at blinding speed.
    Therefore, you'll rarely encounter a slow program that doesn't contain any loops.
    Because loops are the primary source of performance problems within a program,
    they are the place to look when attempting to speed up your software. While a
    treatise on how to write efficient programs is beyond the scope of this chapter,
    there are some things you should be aware of when designing loops in your programs.
    They're all aimed at removing unnecessary instructions from your loops in order
    to reduce the time it takes to execute a single iteration of the loop.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.1 Moving the Termination Condition to the End of a Loop
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following flow graphs for the three types of loops presented earlier:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'As you can see, the `repeat..until` loop is the simplest of the bunch. This
    is reflected in the assembly language implementation of these loops. Consider
    the following `repeat..until` and `while` loops that are semantically identical:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'As you can see by carefully studying the conversion to pure assembly language,
    testing for the termination condition at the end of the loop allowed us to remove
    a `jmp` instruction from the loop. This can be significant if this loop is nested
    inside other loops. In the preceding example there wasn''t a problem with executing
    the body at least once. Given the definition of the loop, you can easily see that
    the loop will be executed exactly 20 times. This suggests that the conversion
    to a `repeat..until` loop is trivial and always possible. Unfortunately, it''s
    not always quite this easy. Consider the following HLA code:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In this particular example, we haven''t the slightest idea what ESI contains
    upon entry into the loop. Therefore, we cannot assume that the loop body will
    execute at least once. So we must test for loop termination before executing the
    body of the loop. The test can be placed at the end of the loop with the inclusion
    of a single `jmp` instruction:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Although the code is as long as the original `while` loop, the `jmp` instruction
    executes only once rather than on each repetition of the loop. Note that this
    slight gain in efficiency is obtained via a slight loss in readability. The second
    code sequence above is closer to spaghetti code than the original implementation.
    Such is often the price of a small performance gain. Therefore, you should carefully
    analyze your code to ensure that the performance boost is worth the loss of clarity.
    More often than not, assembly language programmers sacrifice clarity for dubious
    gains in performance, producing impossible-to-understand programs.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Note, by the way, that HLA translates its high-level `while` statement into
    a sequence of instructions that test the loop termination condition at the bottom
    of the loop using exactly the technique this section describes.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.2 Executing the Loop Backwards
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because of the nature of the flags on the 80x86, loops that repeat from some
    number down to (or up to) 0 are more efficient than loops that execute from 0
    to some other value. Compare the following HLA `for` loop and the code it generates:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now consider another loop that also has eight iterations but runs its loop-control
    variable from 8 down to 1 rather than 1 up to 8:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note that by running the loop from 8 down to 1 we saved a comparison on each
    repetition of the loop.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, you cannot force all loops to run backward. However, with a little
    effort and some coercion you should be able to write many `for` loops so that
    they operate backward. Saving the execution time of the `cmp` instruction on each
    iteration of the loop may result in faster code.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'The example above worked out well because the loop ran from 8 down to 1\. The
    loop terminated when the loop-control variable became 0\. What happens if you
    need to execute the loop when the loop-control variable goes to 0? For example,
    suppose that the loop above needed to range from 7 down to 0\. As long as the
    upper bound is positive, you can substitute the `jns` instruction in place of
    the `jnz` instruction in the earlier code:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This loop will repeat eight times, with `j` taking on the values 7..0\. When
    it decrements 0 to −1, it sets the sign flag and the loop terminates.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that some values may look positive but are actually negative. If
    the loop-control variable is a byte, then values in the range 128..255 are negative
    in the two's complement system. Therefore, initializing the loop-control variable
    with any 8-bit value in the range 129..255 (or, of course, 0) terminates the loop
    after a single execution. This can get you into trouble if you're not careful.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.3 Loop-Invariant Computations
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *loop-invariant computation* is some calculation that appears within a loop
    that always yields the same result. You needn''t do such computations inside the
    loop. You can compute them outside the loop and reference the value of the computations
    inside the loop. The following HLA code demonstrates an invariant computation:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Because `j` never changes throughout the execution of this loop, the subexpression
    `j-2` can be computed outside the loop:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Although we''ve eliminated a single instruction by computing the subexpression
    `j-2` outside the loop, there is still an invariant component to this calculation.
    Note that this invariant component executes *n* times in the loop; this means
    that we can translate the previous code to the following:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As you can see, we've shrunk the loop body from four instructions down to one.
    Of course, if you're really interested in improving the efficiency of this particular
    loop, you can compute the result without using a loop at all (there is a formula
    that corresponds to the iterative calculation above). Still, this simple example
    demonstrates elimination of loop-invariant calculations from a loop.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.4 Unraveling Loops
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For small loops, that is, those whose body is only a few statements, the overhead
    required to process a loop may constitute a significant percentage of the total
    processing time. For example, look at the following Pascal code and its associated
    80x86 assembly language code:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Four instructions execute on each repetition of the loop. Only one instruction
    is doing the desired operation (moving a 0 into an element of `A`). The remaining
    three instructions control the loop. Therefore, it takes 16 instructions to do
    the operation logically required by 4.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are many improvements we could make to this loop based on the information
    presented thus far, consider carefully exactly what it is that this loop is doing—it''s
    storing four 0s into `A[0]` through `A[3]`. A more efficient approach is to use
    four `mov` instructions to accomplish the same task. For example, if `A` is an
    array of double words, then the following code initializes `A` much faster than
    the code above:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Although this is a simple example, it shows the benefit of *loop unraveling*
    (also known as *loop unrolling*). If this simple loop appeared buried inside a
    set of nested loops, the 4:1 instruction reduction could possibly double the performance
    of that section of your program.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you cannot unravel all loops. Loops that execute a variable number
    of times are difficult to unravel because there is rarely a way to determine (at
    assembly time) the number of loop iterations. Therefore, unraveling a loop is
    a process best applied to loops that execute a known number of times (and the
    number of times is known at assembly time).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Even if you repeat a loop some fixed number of iterations, it may not be a good
    candidate for loop unraveling. Loop unraveling produces impressive performance
    improvements when the number of instructions controlling the loop (and handling
    other overhead operations) represents a significant percentage of the total number
    of instructions in the loop. Had the previous loop contained 36 instructions in
    the body (exclusive of the 4 overhead instructions), then the performance improvement
    would be, at best, only 10 percent (compared with the 300–400 percent it now enjoys).
    Therefore, the costs of unraveling a loop, that is, all the extra code that must
    be inserted into your program, quickly reach a point of diminishing returns as
    the body of the loop grows larger or as the number of iterations increases. Furthermore,
    entering that code into your program can become quite a chore. Therefore, loop
    unraveling is a technique best applied to small loops.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Note that the superscalar 80x86 chips (Pentium and later) have *branch-prediction
    hardware* and use other techniques to improve performance. Loop unrolling on such
    systems may actually *slow down* the code because these processors are optimized
    to execute short loops.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.5 Induction Variables
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following loop:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Here the program is initializing each element of an array of character sets
    to the empty set. The straightforward code to achieve this is the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Although unraveling this code will still produce a performance improvement,
    it will take 1,024 instructions to accomplish this task, too many for all but
    the most time-critical applications. However, you can reduce the execution time
    of the body of the loop using *induction variables*. An induction variable is
    one whose value depends entirely on the value of some other variable. In the example
    above, the index into the array `csetVar` tracks the loop-control variable (it''s
    always equal to the value of the loop-control variable times 16). Because `i`
    doesn''t appear anywhere else in the loop, there is no sense in performing the
    computations on `i`. Why not operate directly on the array index value? The following
    code demonstrates this technique:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The induction that takes place in this example occurs when the code increments
    the loop-control variable (moved into EBX for efficiency reasons) by 16 on each
    iteration of the loop rather than by 1\. Multiplying the loop-control variable
    by 16 (and also the final loop-termination constant value) allows the code to
    eliminate multiplying the loop-control variable by 16 on each iteration of the
    loop (that is, this allows us to remove the `shl` instruction from the previous
    code). Further, because this code no longer refers to the original loop-control
    variable (`i`), the code can maintain the loop-control variable strictly in the
    EBX register.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 7.12 Hybrid Control Structures in HLA
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HLA high-level language control structures have a few drawbacks: (1) they''re
    not true assembly language instructions, (2) complex boolean expressions support
    only short-circuit evaluation, and (3) they often introduce inefficient coding
    practices into a language that most people use only when they need to write high-performance
    code. On the other hand, while the 80x86 low-level control structures let you
    write efficient code, the resulting code is very difficult to read and maintain.
    HLA provides a set of hybrid control structures that allow you to use pure assembly
    language statements to evaluate boolean expressions while using the high-level
    control structures to delineate the statements controlled by the boolean expressions.
    The result is code that is much more readable than pure assembly language without
    being a whole lot less efficient.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA provides hybrid forms of the `if..elseif..else..endif`, `while..endwhile`,
    `repeat..until`, `breakif`, `exitif`, and `continueif` statements (that is, those
    that involve a boolean expression). For example, a hybrid `if` statement takes
    the following form:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Note the use of `#{` and `}#` operators to surround a sequence of instructions
    within this statement. This is what differentiates the hybrid control structures
    from the standard high-level language control structures. The remaining hybrid
    control structures take the following forms:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The statements within the curly braces replace the normal boolean expression
    in an HLA high-level control structure. These particular statements are special
    insofar as HLA defines two pseudo-labels, `true` and `false`, within their context.
    HLA associates the label `true` with the code that would normally execute if a
    boolean expression were present and that expression''s result was true. Similarly,
    HLA associates the label `false` with the code that would execute if a boolean
    expression in one of these statements evaluated false. As a simple example, consider
    the following two (equivalent) `if` statements:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `jnb` that transfers control to the `false` label in this latter example
    will skip over the `inc` instruction if EAX is not less than EBX. Note that if
    EAX is less than EBX, then control falls through to the inc instruction. This
    is roughly equivalent to the following pure assembly code:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: As a slightly more complex example, consider the statement
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The following hybrid `if` statement accomplishes the above:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'As one final example of the hybrid `if` statement, consider the following:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Because these examples are rather trivial, they don't really demonstrate how
    much more readable the code can be when using hybrid statements rather than pure
    assembly code. However, one thing you should notice is that using hybrid statements
    eliminates the need to insert labels throughout your code. This can make your
    programs easier to read and understand.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: For the `if` statement, the `true` label corresponds to the `then` clause of
    the statement; the `false` label corresponds to the `elseif`, `else`, or `endif`
    clause (whichever follows the `then` clause). For the `while` loop, the `true`
    label corresponds to the body of the loop, whereas the `false` label is attached
    to the first statement following the corresponding `endwhile`. For the `repeat..until`
    statement, the `true` label is attached to the code following the `until` clause,
    whereas the `false` label is attached to the first statement of the body of the
    loop. The `breakif`, `exitif`, and `continueif` statements associate the `false`
    label with the statement immediately following one of these statements; they associate
    the `true` label with the code normally associated with a `break`, `exit`, or
    `continue` statement.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 7.13 For More Information
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HLA contains a few additional high-level control structures beyond those this
    chapter describes. Examples include the `try..endtry` block and the `foreach`
    statement. A discussion of these statements does not appear in this chapter because
    these are advanced control structures and their implementation is too complex
    to describe this early in the text. For more information on their implementation,
    see the electronic edition at [http://www.artofasm.com/](http://www.artofasm.com/)
    (or [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)) or the HLA reference
    manual.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
