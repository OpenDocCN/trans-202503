["```\n$ file * | head -4\n100_0399.png:    PNG image data, 1024 x 768, 8-bit/color RGBA, non-interlaced\n8t grade art1.jpeg:  JPEG image data, JFIF standard 1.01\n99icon.gif:          GIF image data, version 89a, 143 x 163\nAngel.jpg:           JPEG image data, JFIF standard 1.01\n```", "```\n   #!/bin/bash\n   # imagesize--Displays image file information and dimensions using the\n   #   identify utility from ImageMagick\n\n   for name\n   do\n➊   identify -format \"%f: %G with %k colors.\\n\" \"$name\"\n   done\n   exit 0\n```", "```\n$ identify -verbose testimage.png\nImage: testimage.png\n  Format: PNG (Portable Network Graphics)\n  Class: DirectClass\n  Geometry: 1172x158+0+0\n  Resolution: 72x72\n  Print size: 16.2778x2.19444\n  Units: Undefined\n\n  --snip--\n\n  Profiles:\n    Profile-icc: 3144 bytes\n      IEC 61966-2.1 Default RGB colour space - sRGB\n  Artifacts:\n    verbose: true\n  Tainted: False\n  Filesize: 80.9KBB\n  Number pixels: 185KB\n  Pixels per second: 18.52MB\n  User time: 0.000u\n  Elapsed time: 0:01.009\n  Version: ImageMagick 6.7.7-10 2016-06-01 Q16 http://www.imagemagick.org\n$\n```", "```\n$ identify testimage.png\ntestimage.png PNG 1172x158 1172x158+0+0 8-bit DirectClass 80.9KB 0.000u\n0:00.000\n```", "```\n$ imagesize * | head -4\n100_0399.png: 1024x768 with 120719 colors.\n8t grade art1.jpeg: 480x554 with 11548 colors.\ndticon.gif: 143x163 with 80 colors.\nAngel.jpg: 532x404 with 80045 colors.\n$\n```", "```\n   #!/bin/bash\n   # watermark--Adds specified text as a watermark on the input image,\n   #   saving the output as image+wm\n\n   wmfile=\"/tmp/watermark.$$.png\"\n   fontsize=\"44\"                          # Should be a starting arg\n\n   trap \"$(which rm) -f $wmfile\" 0 1 15    # No temp file left behind\n\n   if [ $# -ne 2 ] ; then\n     echo \"Usage: $(basename $0) imagefile \\\"watermark text\\\"\" >&2\n     exit 1\n   fi\n\n   if [ ! -r \"$1\" ] ; then\n     echo \"$(basename $0): Can't read input image $1\" >&2\n     exit 1\n   fi\n\n   # To start, get the dimensions of the image.\n\n➊ dimensions=\"$(identify -format \"%G\" \"$1\")\"\n\n   # Let's create the temporary watermark overlay.\n\n➋ convert -size $dimensions xc:none -pointsize $fontsize -gravity south \\\n     -draw \"fill black text 1,1 '$2' text 0,0 '$2' fill white text 2,2 '$2'\" \\\n     $wmfile\n\n   # Now let's composite the overlay and the original file.\n➌ suffix=\"$(echo $1 | rev | cut -d. -f1 | rev)\"\n   prefix=\"$(echo $1 | rev | cut -d. -f2- | rev)\"\n\n   newfilename=\"$prefix+wm.$suffix\"\n➍ composite -dissolve 75% -gravity south $wmfile \"$1\" \"$newfilename\"\n\n   echo \"Created new watermarked image file $newfilename.\"\n\n   exit 0\n```", "```\n$ watermark test.png \"(C) 2016 by Dave Taylor\"\nCreated new watermarked image file test+wm.png.\n```", "```\n$ brew install ghostscript\n```", "```\n   #!/bin/bash\n   # frameit--Makes it easy to add a graphical frame around\n   #   an image file, using ImageMagick\n\n   usage()\n   {\n   cat << EOF\n   Usage: $(basename $0) -b border -c color imagename\n      or  $(basename $0) -f frame  -m color imagename\n\n   In the first case, specify border parameters as size x size or\n   percentage x percentage followed by the color desired for the\n   border (RGB or color name).\n\n   In the second instance, specify the frame size and offset,\n   followed by the matte color.\n\n   EXAMPLE USAGE:\n     $(basename $0) -b 15x15 -c black imagename\n     $(basename $0) -b 10%x10% -c gray imagename\n\n     $(basename $0) -f 10x10+10+0 imagename\n     $(basename $0) -f 6x6+2+2 -m tomato imagename\n   EOF\n   exit 1\n   }\n\n   #### MAIN CODE BLOCK\n\n   # Most of this is parsing starting arguments!\n\n   while getopts \"b:c:f:m:\" opt; do\n     case $opt in\n     b ) border=\"$OPTARG\";                ;;\n     c ) bordercolor=\"$OPTARG\";           ;;\n     f ) frame=\"$OPTARG\";                 ;;\n     m ) mattecolor=\"$OPTARG\";            ;;\n     ? ) usage;                           ;;\n     esac\n   done\n   shift $(($OPTIND - 1))    # Eat all the parsed arguments.\n\n   if [ $# -eq 0 ] ; then    # No images specified?\n     usage\n   fi\n\n   # Did we specify a border and a frame?\n\n   if [ ! -z \"$bordercolor\" -a ! -z \"$mattecolor\" ] ; then\n     echo \"$0: You can't specify a color and matte color simultaneously.\" >&2\n     exit 1\n   fi\n\n   if [ ! -z \"$frame\" -a ! -z \"$border\" ] ; then\n     echo \"$0: You can't specify a border and frame simultaneously.\" >&2\n     exit 1\n   fi\n\n   if [ ! -z \"$border\" ] ; then\n     args=\"-bordercolor $bordercolor -border $border\"\n   else\n     args=\"-mattecolor $mattecolor -frame $frame\"\n   fi\n\n➊ for name\n   do\n     suffix=\"$(echo $name | rev | cut -d. -f1 | rev)\"\n     prefix=\"$(echo $name | rev | cut -d. -f2- | rev)\"\n➋   newname=\"$prefix+f.$suffix\"\n     echo \"Adding a frame to image $name, saving as $newname\"\n➌   convert $name $args $newname\n   done\n\n   exit 0\n```", "```\n$ frameit -f 15%x15%+10+10 -m black abandoned-train.png\nAdding a frame to image abandoned-train.png, saving as abandoned-train+f.png\n```", "```\n$ frameit -f 15%x15%+10+10 alcatraz.png\nAdding a frame to image alcatraz.png, saving as alcatraz+f.png\nconvert: option requires an argument '-mattecolor' @ error/convert.c/\nConvertImageCommand/1936.\n```", "```\n$ mkdir thumbs\n$ mogrify -format gif -path thumbs -thumbnail 100x100 *.jpg\n```", "```\n   #!/bin/bash\n   # thumbnails--Creates thumbnail images for the graphics file specified,\n   #   matching exact dimensions or not-to-exceed dimensions\n\n   convargs=\"➊-unsharp 0x.5 -resize\"\n   count=0; exact=\"\"; fit=\"\"\n\n   usage()\n   {\n     echo \"Usage: $0 (-e|-f) thumbnail-size image [image] [image]\" >&2\n     echo \"-e  resize to exact dimensions, ignoring original proportions\" >&2\n     echo \"-f  fit image into specified dimensions, retaining proportion\" >&2\n echo \"-s  strip EXIF information (make ready for web use)\" >&2\n     echo \"    please use WIDTHxHEIGHT for requested size (e.g., 100x100)\"\n     exit 1\n   }\n\n   #############\n   ## BEGIN MAIN\n\n   if [ $# -eq 0 ] ; then\n     usage\n   fi\n\n   while getopts \"e:f:s\" opt; do\n     case $opt in\n      e ) exact=\"$OPTARG\";                ;;\n      f ) fit=\"$OPTARG\";                  ;;\n      s ) strip=\"➋-strip\";               ;;\n      ? ) usage;                          ;;\n     esac\n   done\n   shift $(($OPTIND - 1))  # Eat all the parsed arguments.\n\n   rwidth=\"$(echo $exact $fit | cut -dx -f1)\"    # Requested width\n   rheight=\"$(echo $exact $fit | cut -dx -f2)\"   # Requested height\n\n   for image\n   do\n     width=\"$(identify -format \"%w\" \"$image\")\"\n     height=\"$(identify -format \"%h\" \"$image\")\"\n\n     # Building thumbnail for image=$image, width=$width, and height=$height\n     if [ $width -le $rwidth -a $height -le $rheight ] ; then\n       echo \"Image $image is already smaller than requested dimensions. Skipped.\"\n     else\n       # Build new filename.\n\n       suffix=\"$(echo $image | rev | cut -d. -f1 | rev)\"\n       prefix=\"$(echo $image | rev | cut -d. -f2- | rev)\"\n       newname=\"$prefix-thumb.$suffix\"\n\n       # Add the \"!\" suffix to ignore proportions as needed.\n\n➌     if [ -z \"$fit\" ] ; then\n         size=\"$exact!\"\n         echo \"Creating ${rwidth}x${rheight} (exact size) thumb for file $image\"\n       else\n         size=\"$fit\"\n         echo \"Creating ${rwidth}x${rheight} (max size) thumb for file $image\"\n       fi\n\n       convert \"$image\" $strip $convargs \"$size\" \"$newname\"\n     fi\n     count=$(( $count + 1 ))\n   done\n\n   if [ $count -eq 0 ] ; then\n     echo \"Warning: no images found to process.\"\n   fi\n\n   exit 0\n```", "```\n$ thumbnails\nUsage: thumbnails (-e|-f) thumbnail-size image [image] [image]\n-e  resize to exact dimensions, ignoring original proportions\n-f  fit image into specified dimensions, retaining proportion\n-s  strip EXIF information (make ready for web use)\n    please use WIDTHxHEIGHT for requested size (e.g., 100x100)\n$ thumbnails -s -e 300x300 hawaii.png\nCreating 300x300 (exact size) thumb for file hawaii.png\n$ thumbnails -f 300x300 hawaii.png\nCreating 300x300 (max size) thumb for file hawaii.png\n$\n```", "```\nexif:GPSLatitude: 40/1, 4/1, 1983/100\nexif:GPSLatitudeRef: N\nexif:GPSLongitude: 105/1, 12/1, 342/100\nexif:GPSLongitudeRef: W\n```", "```\n40 4' 19.83\" N, 105 12' 3.42\" W\n```", "```\n   #!/bin/bash\n   # geoloc--For images that have GPS information, converts that data into\n   #   a string that can be fed to Google Maps or Bing Maps\n\n   tempfile=\"/tmp/geoloc.$$\"\n\n   trap \"$(which rm) -f $tempfile\" 0 1 15\n\n   if [ $# -eq 0 ] ; then\n     echo \"Usage: $(basename $0) image\" >&2\n     exit 1\n   fi\n\n   for filename\n   do\n     identify -format➊ \"%[EXIF:*]\" \"$filename\" | grep GPSL > $tempfile\n\n➋   latdeg=$(head -1 $tempfile | cut -d, -f1 | cut -d= -f2)\n     latdeg=$(scriptbc -p 0 $latdeg)\n     latmin=$(head -1 $tempfile | cut -d, -f2)\n     latmin=$(scriptbc -p 0 $latmin)\n     latsec=$(head -1 $tempfile | cut -d, -f3)\n     latsec=$(scriptbc $latsec)\n     latorientation=$(sed -n '2p' $tempfile | cut -d= -f2)\n\n     longdeg=$(sed -n '3p' $tempfile | cut -d, -f1 | cut -d= -f2)\n     longdeg=$(scriptbc -p 0 $longdeg)\n     longmin=$(sed -n '3p' $tempfile | cut -d, -f2)\n     longmin=$(scriptbc -p 0 $longmin)\n     longsec=$(sed -n '3p' $tempfile | cut -d, -f3)\n     longsec=$(scriptbc $longsec)\n     longorientation=$(sed -n '4p' $tempfile | cut -d= -f2)\n\n➌   echon \"Coords: $latdeg ${latmin}' ${latsec}\\\" $latorientation, \"\n     echo \"$longdeg ${longmin}' ${longsec}\\\" $longorientation\"\n\n   done\n\n   exit 0\n```", "```\n$ geoloc parking-lot-with-geotags.jpg\nCoords: 40 3' 19.73\" N, 103 12' 3.72\" W\n$\n```"]