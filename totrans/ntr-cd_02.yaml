- en: '**1 Vectors**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1 向量**'
- en: '*I’m committing crimes with both direction and magnitude.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*我正在犯下既有方向又有大小的罪行。*'
- en: —Vector, *Despicable Me*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —向量，*卑鄙的我*
- en: '![Image](../images/pg73_Image_58.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg73_Image_58.jpg)'
- en: '**Marshall Islands stick chart on display at the Berkeley Art Museum (photo
    by Jim Heaphy)**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**马绍尔群岛的航海图（由Jim Heaphy拍摄，展出于伯克利艺术博物馆）**'
- en: The stick chart is a navigational tool crafted by the indigenous people of the
    Marshall Islands, located in the central Pacific Ocean. This ancient tool was
    made by carefully tying together the midribs of coconut fronds. Shell markings
    on the chart signify the locations of islands in the region. The layout of the
    fronds and shells serves as a geographical guide, offering an abstract representation
    of vectors that capture the ocean swell patterns and their directional flow.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这张航海图是马绍尔群岛土著人民制作的导航工具，马绍尔群岛位于中太平洋。这种古老的工具是通过精心绑扎椰子叶的中脉制成的。图表上的贝壳标记表示该地区岛屿的位置。叶脉和贝壳的布局作为地理指引，提供了一种抽象的向量表示，捕捉了海洋波动模式及其方向流动。
- en: 'This book is all about looking at the world around us and developing ways to
    simulate it with code. In this first part of the book, I’ll start by looking at
    basic physics: how an apple falls from a tree, how a pendulum swings in the air,
    how Earth revolves around the sun, and so on. Absolutely everything contained
    within the book’s first five chapters requires the use of the most basic building
    block for programming motion, the **vector**. And so that’s where I’ll begin the
    story.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的核心内容是观察我们周围的世界，并开发用代码模拟它的方法。在本书的第一部分，我将从基础物理学开始：例如一个苹果从树上掉下来，一个摆钟在空气中摆动，地球围绕太阳转动，等等。书中的前五章涵盖的所有内容，都需要使用编程运动的最基本构建块——**向量**。因此，我将从这里开始讲解。
- en: The word *vector* can mean a lot of things. It’s the name of a New Wave rock
    band formed in Sacramento, California, in the early 1980s, and the name of a breakfast
    cereal manufactured by Kellogg’s Canada. In the field of epidemiology, a vector
    is an organism that transmits infection from one host to another. In the C++ programming
    language, a vector ( `std::vector` ) is an implementation of a dynamically resizable
    array data structure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “*向量*”这个词可以有很多含义。它是1980年代初在加利福尼亚州萨克拉门托成立的一支新浪潮摇滚乐队的名字，也是加拿大凯洛格公司生产的一种早餐谷物的名字。在流行病学领域，向量是指传递感染的有机体。在C++编程语言中，向量（`std::vector`）是动态可调整大小的数组数据结构的实现。
- en: While all these definitions are worth exploring, they’re not the focus here.
    Instead, this chapter dives into the **Euclidean vector** (named for the Greek
    mathematician Euclid), also known as the **geometric vector**. When you see the
    term *vector* in this book, you can assume it refers to a Euclidean vector, defined
    as an entity that has both magnitude and direction.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有这些定义都值得探讨，但它们并不是本章的重点。相反，本章深入探讨了**欧几里得向量**（以希腊数学家欧几里得命名），也被称为**几何向量**。当你在本书中看到“*向量*”这个词时，你可以假设它指的是欧几里得向量，即具有大小和方向的实体。
- en: A vector is typically drawn as an arrow, as in [Figure 1.1](ch01.xhtml#ch1fig1).
    The vector’s direction is indicated by where the arrow is pointing, and its magnitude
    by the length of the arrow.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 向量通常绘制为箭头，如[图1.1](ch01.xhtml#ch1fig1)所示。箭头的指向表示向量的方向，箭头的长度则表示向量的大小。
- en: The vector in [Figure 1.1](ch01.xhtml#ch1fig1) is drawn as an arrow from point
    A to point B. It serves as an instruction for how to travel from A to B.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.1](ch01.xhtml#ch1fig1)中的向量被绘制为从A点指向B点的箭头。它表示从A到B的旅行方向。'
- en: '![Image](../images/pg74_Image_59.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg74_Image_59.jpg)'
- en: 'Figure 1.1: A vector represented as an arrow drawn from point A to point B'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：一个作为箭头从A点指向B点的向量
- en: '**The Point of Vectors**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**向量的意义**'
- en: Before diving into more details about vectors, I’d like to create a p5.js example
    that demonstrates why you should care about vectors in the first place. If you’ve
    watched any beginner p5.js tutorials, read any introductory p5.js textbooks, or
    taken an introduction to creative coding course (and hopefully you’ve done one
    of these things to help prepare you for this book!), you probably, at one point
    or another, learned how to write a bouncing ball sketch.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解向量的更多细节之前，我想创建一个p5.js的示例，演示为什么你应该首先关心向量。如果你曾看过任何初学者p5.js教程，阅读过任何介绍性的p5.js教材，或参加过创意编码入门课程（希望你在准备这本书时做过其中一项！），你可能在某个时刻学过如何编写一个弹跳球的草图。
- en: '![Image](../images/pg75_Image_60.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg75_Image_60.jpg)'
- en: 'In this example, there’s a flat, 2D world—a blank canvas—with a circular shape
    (a “ball”) traveling around. This ball has properties like position and speed
    that are represented in the code as variables:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有一个平面二维世界——一块空白画布——其中一个圆形物体（“球”）在四处移动。这个球有位置、速度等属性，这些属性在代码中以变量的形式表示：
- en: '| **Property** | **Variable Names** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **变量名** |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Position | `x` and `y` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | `x` 和 `y` |'
- en: '| Speed | `xspeed` and `yspeed` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | `xspeed` 和 `yspeed` |'
- en: 'In a more sophisticated sketch, you might have many more variables representing
    other properties of the ball and its environment:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更复杂的草图中，你可能会有更多的变量来表示球和它的环境的其他属性：
- en: '| **Property** | **Variable Names** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **变量名** |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Acceleration | `xacceleration` and `yacceleration` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 加速度 | `xacceleration` 和 `yacceleration` |'
- en: '| Target position | `xtarget` and `ytarget` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 目标位置 | `xtarget` 和 `ytarget` |'
- en: '| Wind | `xwind` and `ywind` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 风速 | `xwind` 和 `ywind` |'
- en: '| Friction | `xfriction` and `yfriction` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 摩擦力 | `xfriction` 和 `yfriction` |'
- en: 'You might notice that for every concept in this world (wind, position, acceleration,
    and the like), there are two variables. And this is only a 2D world. In a three-dimensional
    (3D) world, you’d need three variables for each property: `x`, `y`, and `z` for
    position; `xspeed`, `yspeed`, and `zspeed` for speed; and so on. Wouldn’t it be
    nice to simplify the code to use fewer variables? Instead of starting the program
    with something like this'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在这个世界中的每个概念（风速、位置、加速度等）都有两个变量。这只是一个二维世界。在三维（3D）世界中，每个属性都需要三个变量：位置用 `x`、`y`
    和 `z` 表示；速度用 `xspeed`、`yspeed` 和 `zspeed` 表示；依此类推。是不是很想简化代码，减少使用变量的数量？而不是像这样开始程序
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'you’d be able to start it with something like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够像这样开始它：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Thinking of the ball’s properties as vectors instead of a loose collection of
    separate values will allow you to do just that.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将球的属性视为向量，而不是将它们作为一组分离的值，将帮助你做到这一点。
- en: Taking this first step toward using vectors won’t let you do anything new or
    magically turn a p5.js sketch into a full-on physics simulation. However, using
    vectors will help organize your code and provide a set of methods for common mathematical
    operations you’ll need over and over and over again while programming motion.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 迈出使用向量的第一步，并不会让你做出什么新奇的事物，也不会将 p5.js 草图 magically 转换为完整的物理仿真。然而，使用向量将帮助你组织代码，并为你在编程运动时需要反复使用的常见数学操作提供一套方法。
- en: As an introduction to vectors, I’m going to stick to two dimensions for quite
    some time (at least the first several chapters). All these examples can be fairly
    easily extended to three dimensions (and the class I’ll use, `p5.Vector`, allows
    for three dimensions). However, for the purposes of learning the fundamentals,
    the added complexity of the third dimension would be a distraction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为向量的介绍，我将长期坚持使用二维（至少前几章）。所有这些例子都可以相对容易地扩展到三维（并且我将使用的类 `p5.Vector` 支持三维）。然而，为了学习基础，第三维度带来的额外复杂性会分散注意力。
- en: '**Vectors in p5.js**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**p5.js 中的向量**'
- en: Think of a vector as the difference between two points, or as instructions for
    walking from one point to another. For example, [Figure 1.2](ch01.xhtml#ch1fig2)
    shows some vectors and possible interpretations of them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将向量视为两点之间的差异，或者将其视为从一个点走到另一个点的指令。例如，[图 1.2](ch01.xhtml#ch1fig2)展示了一些向量及其可能的解释。
- en: '![Image](../images/pg77_Image_61.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg77_Image_61.jpg)'
- en: 'Figure 1.2: Three example vectors drawn as arrows, with accompanying instructions
    for walking in north, south, east, or west directions'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：三条示例向量以箭头的形式绘制，附带的指令指示向北、南、东或西方向行走。
- en: 'These vectors could be thought of in the following way:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些向量可以按以下方式理解：
- en: '| **Vector** | **Instructions** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **向量** | **说明** |'
- en: '| --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| (–15, 3) | Walk 15 steps west; turn and walk 3 steps north. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| (–15, 3) | 向西走 15 步；转身并向北走 3 步。 |'
- en: '| (3, 4) | Walk 3 steps east; turn and walk 4 steps north. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| (3, 4) | 向东走 3 步；转身并向北走 4 步。 |'
- en: '| (2, –1) | Walk 2 steps east; turn and walk 1 step south. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| (2, –1) | 向东走 2 步；转身并向南走 1 步。 |'
- en: You’ve probably already thought this way when programming motion. For every
    frame of animation (a single cycle through a p5.js `draw()` loop), you instruct
    each object to reposition itself to a new spot a certain number of pixels away
    horizontally and a certain number of pixels away vertically. This instruction
    is essentially a vector, as in [Figure 1.3](ch01.xhtml#ch1fig3); it has both magnitude
    (how far away did you travel?) and direction (which way did you go?).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在编程运动时考虑过这种方式。对于每一帧动画（即每次通过 p5.js 的`draw()`循环），你会指示每个对象将自己重新定位到一个新的位置，水平和垂直方向分别移动一定的像素数。这个指令本质上就是一个向量，如[图
    1.3](ch01.xhtml#ch1fig3)所示；它有大小（你移动了多远？）和方向（你朝哪个方向移动？）。
- en: '![Image](../images/pg78_Image_62.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg78_Image_62.jpg)'
- en: 'Figure 1.3: A vector showing the number of horizontal and vertical steps to
    go from a position to a new position'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：一个向量，表示从一个位置到新位置的水平和垂直步数
- en: 'The vector sets the object’s **velocity**, defined as the rate of change of
    the object’s position with respect to time. In other words, the velocity vector
    determines the object’s new position for every frame of the animation, according
    to this basic algorithm for motion: *the new position is equal to the result of
    applying the velocity to the current position*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 向量设置了对象的**速度**，定义为对象位置随时间变化的速率。换句话说，速度向量决定了对象在每一帧动画中的新位置，根据这个基本的运动算法：*新位置等于将速度应用到当前的位置的结果*。
- en: If velocity is a vector (the difference between two points), what about position?
    Is it a vector too? Technically, you could argue that position is not a vector,
    since it’s not describing how to move from one point to another; it’s describing
    a single point in space. Nevertheless, another way to describe a position is as
    the path taken from the origin—point (0, 0)—to the current point. When you think
    of position in this way, it becomes a vector, just like velocity, as in [Figure
    1.4](ch01.xhtml#ch1fig4).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果速度是一个向量（表示两个点之间的差异），那么位置呢？位置也是向量吗？从技术上讲，你可以辩称位置不是向量，因为它并不描述从一个点到另一个点的移动；它描述的是空间中的一个单一位置。然而，另一种描述位置的方式是将其视为从原点（0,
    0）到当前点所经过的路径。当你以这种方式考虑位置时，它就变成了一个向量，就像速度一样，正如[图 1.4](ch01.xhtml#ch1fig4)所示。
- en: '![Image](../images/pg78_Image_63.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg78_Image_63.jpg)'
- en: 'Figure 1.4: A computer graphics window with (0, 0) in the top left, showing
    a position vector and a velocity vector'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：一个计算机图形窗口，左上角是（0，0），显示了位置向量和速度向量
- en: In [Figure 1.4](ch01.xhtml#ch1fig4), the vectors are placed on a computer graphics
    canvas. Unlike in [Figure 1.2](ch01.xhtml#ch1fig2), the origin point (0, 0) isn’t
    at the center; it’s at the top-left corner. And instead of north, south, east,
    and west, there are positive and negative directions along the x- and y-axes (with
    y pointing down in the positive direction).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1.4](ch01.xhtml#ch1fig4)中，向量被放置在计算机图形画布上。不同于[图 1.2](ch01.xhtml#ch1fig2)，原点（0,
    0）不在中心，而是在左上角。而且，不再是北、南、东、西方向，而是沿着x轴和y轴有正负方向（y轴的正方向指向下方）。
- en: 'Let’s examine the underlying data for both position and velocity. In the bouncing
    ball example, I originally had the following variables:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看位置和速度的底层数据。在弹跳球的例子中，我最初有以下变量：
- en: '| **Property** | **Variable Names** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **变量名** |'
- en: '| --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Position | `x`, `y` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | `x`，`y` |'
- en: '| Velocity | `xspeed`, `yspeed` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | `xspeed`，`yspeed` |'
- en: 'Now I’ll treat position and velocity as vectors instead, each represented by
    an object with `x` and `y` attributes. If I were to write a `Vector` class myself,
    I’d start with something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将位置和速度视为向量，每个向量由具有`x`和`y`属性的对象表示。如果我自己编写一个`Vector`类，我会从类似这样的代码开始：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that this class is designed to store the same data as before—two floating-point
    numbers per vector, an `x` value and a `y` value. At its core, a `Vector` object
    is just a convenient way to store two values (or three, as you’ll see in 3D examples)
    under one name.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个类设计用于存储与之前相同的数据——每个向量有两个浮动小数值，一个是`x`值，一个是`y`值。从根本上讲，`Vector`对象只是一个方便的方式，通过一个名称存储两个值（或在3D示例中存储三个值）。
- en: As it happens, p5.js already has a built-in `p5.Vector` class, so I don’t need
    to write one myself. And so this
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好，p5.js已经有一个内建的`p5.Vector`类，因此我不需要自己编写。于是，这
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'becomes this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 变成这样：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the `position` and `velocity` vector objects aren’t created as you
    might expect, by invoking a constructor function. Instead of writing `new p5.Vector(x,
    y)`, I’ve called `createVector(x, y)`. The `createVector()` function is included
    in p5.js as a helper function to take care of details behind the scenes upon creation
    of the vector. Except in special circumstances, you should always create `p5.Vector`
    objects with `createVector()`. I should note that p5.js functions such as `createVector()`
    can’t be executed outside of `setup()` or `draw()`, since the library won’t yet
    be loaded. I’ll demonstrate how to address this in [Example 1.2](ch01.xhtml#ch1ex2).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`position` 和 `velocity` 向量对象并没有像你可能预期的那样，通过调用构造函数来创建。与其写 `new p5.Vector(x,
    y)`，我使用了 `createVector(x, y)`。`createVector()` 函数作为 p5.js 中的辅助函数，在创建向量时处理幕后细节。除特殊情况外，你应该始终通过
    `createVector()` 来创建 `p5.Vector` 对象。我需要指出，像 `createVector()` 这样的 p5.js 函数不能在 `setup()`
    或 `draw()` 之外执行，因为库还未加载。我将在[示例 1.2](ch01.xhtml#ch1ex2)中演示如何处理这个问题。
- en: 'Now that I have two vector objects ( `position` and `velocity` ), I’m ready
    to implement the vector-based algorithm for motion: **position = position + velocity**.
    In [Example 1.1](ch01.xhtml#ch1ex1), without vectors, the code reads as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了两个向量对象（`position` 和 `velocity`），我准备实现基于向量的运动算法：**position = position +
    velocity**。在[示例 1.1](ch01.xhtml#ch1ex1)中，没有使用向量时，代码如下：
- en: '![Image](../images/pg80_Image_64.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg80_Image_64.jpg)'
- en: 'In an ideal world, I would be able to rewrite this as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，我将能够像这样重新编写：
- en: '![Image](../images/pg80_Image_65.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg80_Image_65.jpg)'
- en: In JavaScript, however, the addition operator `+` is reserved for primitive
    values (integers, floats, and the like). JavaScript doesn’t know how to add two
    `p5.Vector` objects together any more than it knows how to add two `p5.Font` objects
    or `p5.Image` objects. Fortunately, the `p5.Vector` class includes methods for
    common mathematical operations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 JavaScript 中，加法运算符 `+` 是为原始值（整数、浮点数等）保留的。JavaScript 不知道如何将两个 `p5.Vector`
    对象相加，就像它不知道如何将两个 `p5.Font` 对象或 `p5.Image` 对象相加一样。幸运的是，`p5.Vector` 类包含了用于常见数学运算的方法。
- en: '**Vector Addition**'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**向量加法**'
- en: 'Before I continue working with the `p5.Vector` class and the `add()` method,
    let’s examine vector addition by using the notation found in math and physics
    textbooks. Vectors are typically written either in boldface type or with an arrow
    on top. For the purposes of this book, to distinguish a **vector** (with magnitude
    and direction) from a **scalar** (a single value, such as an integer or a floating-point
    number), I’ll use the arrow notation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续使用 `p5.Vector` 类和 `add()` 方法之前，让我们先用数学和物理课本中常见的符号来研究向量加法。向量通常以粗体字或上面加箭头的形式书写。为了本书的目的，为了区分**向量**（具有大小和方向）和**标量**（单一值，例如整数或浮动小数），我将使用箭头符号表示：
- en: 'Vector: ![Image](../images/pg80_Image_66.jpg)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量：![Image](../images/pg80_Image_66.jpg)
- en: 'Scalar: *x*'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量：*x*
- en: Let’s say I have the two vectors shown in [Figure 1.5](ch01.xhtml#ch1fig5).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有[图 1.5](ch01.xhtml#ch1fig5)中显示的两个向量。
- en: '![Image](../images/pg81_Image_67.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg81_Image_67.jpg)'
- en: 'Figure 1.5: Two vectors ![Image](../images/pg81_Image_70.jpg) and ![Image](../images/pg81_Image_71.jpg)
    depicted as triangles'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：两个向量 ![Image](../images/pg81_Image_70.jpg) 和 ![Image](../images/pg81_Image_71.jpg)
    以三角形形式表示
- en: Each vector has two **components**, an *x* and a *y*. To add the two vectors
    together, add both x-components and y-components to create a new vector, as in
    [Figure 1.6](ch01.xhtml#ch1fig6).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个向量有两个**分量**，*x* 和 *y*。为了将两个向量相加，将 x 分量和 y 分量分别相加，得到一个新的向量，如[图 1.6](ch01.xhtml#ch1fig6)所示。
- en: '![Image](../images/pg81_Image_68.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg81_Image_68.jpg)'
- en: 'Figure 1.6: Adding vectors by combining the x- and y-components'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：通过组合 x 和 y 分量来加法向量
- en: 'In other words, ![Image](../images/pg81_Image_69.jpg) can be written as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说， ![Image](../images/pg81_Image_69.jpg) 可以写成如下形式：
- en: '*w[x]* = *u[x]* + *v[x]*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*w[x]* = *u[x]* + *v[x]*'
- en: '*w[y]* = *u[y]* + *v[y]*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*w[y]* = *u[y]* + *v[y]*'
- en: 'Then, replacing ![Image](../images/pg81_Image_72.jpg) and ![Image](../images/pg81_Image_73.jpg)
    with their values from [Figure 1.6](ch01.xhtml#ch1fig6), you get this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 ![Image](../images/pg81_Image_72.jpg) 和 ![Image](../images/pg81_Image_73.jpg)
    替换为来自[图 1.6](ch01.xhtml#ch1fig6)的值，你将得到：
- en: '*w[x]* = 5 + 3 = 8'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*w[x]* = 5 + 3 = 8'
- en: '*w[y]* = 2 + 4 = 6'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*w[y]* = 2 + 4 = 6'
- en: 'Finally, write the result as a vector:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将结果写成一个向量：
- en: '![Image](../images/pg81_Image_74.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg81_Image_74.jpg)'
- en: '![Image](../images/zoom.jpg) **Addition Properties with Vectors**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **向量加法性质**'
- en: Addition with vectors follows the same algebraic rules as with real numbers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 向量加法遵循与实数相同的代数规则。
- en: 'The commutative rule: ![Image](../images/pg82_Image_75.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可交换性规则：![Image](../images/pg82_Image_75.jpg)
- en: 'The associative rule: ![Image](../images/pg82_Image_76.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 结合性规则：![Image](../images/pg82_Image_76.jpg)
- en: 'Fancy terminology and symbols aside, these rules boil down to quite a simple
    concept: the result is the same no matter the order in which the vectors are added.
    Replace the vectors with regular numbers (scalars), and these rules are easy to
    see:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 抛开复杂的术语和符号，这些规则归结为一个非常简单的概念：无论向量加法的顺序如何，结果是相同的。将向量替换为常规的数字（标量），这些规则就很容易理解：
- en: 'Commutative: 3 + 2 = 2 + 3'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可交换性：3 + 2 = 2 + 3
- en: 'Associative: (3 + 2) + 1 = 3 + (2 + 1)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结合性：(3 + 2) + 1 = 3 + (2 + 1)
- en: 'Now that I’ve covered the theory behind adding two vectors together, I can
    turn to adding vector objects in p5.js. Imagine again that I’m creating my own
    `Vector` class. I could give it a function called `add()` that takes another `Vector`
    object as its argument:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经讲解了将两个向量相加的理论，我可以开始讲解如何在p5.js中添加向量对象。再假设一次，我正在创建我自己的`Vector`类。我可以为它定义一个名为`add()`的函数，接收另一个`Vector`对象作为参数：
- en: '![Image](../images/pg82_Image_77.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg82_Image_77.jpg)'
- en: 'The function looks up the x- and y-components of the two vectors and adds them
    separately. This is exactly how the built-in `p5.Vector` class’s `add()` method
    is written too. Knowing how it works, I can now return to the bouncing ball example
    with its **position + velocity** algorithm and implement vector addition:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数查找两个向量的x和y分量，并分别相加。这正是内建的`p5.Vector`类的`add()`方法的写法。了解了它的工作原理后，我现在可以回到反弹球的例子，使用**位置
    + 速度**算法并实现向量加法：
- en: '![Image](../images/pg82_Image_78.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg82_Image_78.jpg)'
- en: Now you have what you need to rewrite the bouncing ball example with vectors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经具备了重写反弹球示例并使用向量的必要条件。
- en: '![Image](../images/pg83_Image_79.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg83_Image_79.jpg)'
- en: At this stage, you might feel somewhat disappointed. After all, these changes
    may appear to have made the code more complicated than the original version. While
    this is a perfectly reasonable and valid critique, it’s important to understand
    that the power of programming with vectors hasn’t been fully realized just yet.
    Looking at a bouncing ball and only implementing vector addition is just the first
    step. As I move forward into a more complex world of multiple objects and multiple
    *forces* (which I’ll introduce in [Chapter 2](ch02.xhtml#ch02)) acting on those
    objects, the benefits of vectors will become more apparent.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能会感到有些失望。毕竟，这些变化看起来让代码变得比原来更复杂了。虽然这是一个完全合理且有效的批评，但理解向量编程的强大功能尚未完全展现是非常重要的。仅仅实现一个反弹球并进行向量加法只是第一步。当我进入一个更复杂的世界，多个物体和多个*力*（我将在[第二章](ch02.xhtml#ch02)中介绍）作用于这些物体时，向量的优势会变得更加明显。
- en: I should, however, note an important aspect of the transition to programming
    with vectors. Even though I’m using `p5.Vector` objects to encapsulate two values—the
    `x` and `y` of the ball’s position or the `x` and `y` of the ball’s velocity—under
    a single variable name, I’ll still often need to refer to the x-and y-components
    of each vector individually.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我需要注意到，过渡到使用向量编程时的一个重要方面。即使我使用`p5.Vector`对象来封装两个值——球的位置的`x`和`y`，或球的速度的`x`和`y`——在一个单一的变量名下，我仍然常常需要单独引用每个向量的x和y分量。
- en: 'The `circle()` function doesn’t allow for a `p5.Vector` object as an argument.
    A circle can be drawn with only two scalar values, an x-coordinate and a y-coordinate.
    And so I must dig into the `p5.Vector` object and pull out the x- and y-components
    by using object-oriented dot syntax:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`circle()`函数不允许将`p5.Vector`对象作为参数传递。一个圆只能用两个标量值，x坐标和y坐标来绘制。因此，我必须深入到`p5.Vector`对象中，通过面向对象的点语法提取出x和y分量：'
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The same issue arises when testing whether the circle has reached the edge
    of the window. In this case, I need to access the individual components of both
    vectors, `position` and `velocity`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试圆形是否已经到达窗口边缘时，也会出现相同的问题。在这种情况下，我需要访问`position`和`velocity`两个向量的各个分量：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It may not always be obvious when to directly access an object’s properties
    versus when to reference the object as a whole or use one of its methods. The
    goal of this chapter (and most of this book) is to help you distinguish between
    these scenarios by providing a variety of examples and use cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时直接访问对象的属性与将对象作为整体引用或使用其方法之间的区别并不总是显而易见。本章（以及本书的大部分内容）的目标是通过提供各种示例和使用案例，帮助你区分这些场景。
- en: '![Image](../images/pencil.jpg) **Exercise 1.1**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 1.1**'
- en: Take one of the walker examples from [Chapter 0](ch00.xhtml#ch00) and convert
    it to use vectors.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第 0 章](ch00.xhtml#ch00)中取一个行走者示例，并将其转换为使用向量。
- en: '![Image](../images/pencil.jpg) **Exercise 1.2**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 1.2**'
- en: Find something else you’ve previously made in p5.js using separate `x` and `y`
    variables, and use vectors instead.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 找一个你之前在 p5.js 中使用单独的 `x` 和 `y` 变量制作的东西，并用向量代替它。
- en: '![Image](../images/pencil.jpg) **Exercise 1.3**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 1.3**'
- en: Extend [Example 1.2](ch01.xhtml#ch1ex2) into 3D. Can you get a sphere to bounce
    around a box?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将[示例 1.2](ch01.xhtml#ch1ex2)扩展为 3D。你能让一个球体在盒子中反弹吗？
- en: '**More Vector Math**'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更多向量数学**'
- en: Addition was really just the first step. Many mathematical operations are commonly
    used with vectors. Here’s a comprehensive table of the operations available as
    methods in the `p5.Vector` class. Remember, these are not stand-alone functions,
    but rather methods associated with the `p5.Vector` class. When you see the word
    *this* in the following table, it refers to the specific vector the method is
    operating on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 加法实际上只是第一步。许多数学运算通常与向量一起使用。以下是 `p5.Vector` 类中可用的操作的完整表格。请记住，这些不是独立的函数，而是与 `p5.Vector`
    类关联的方法。当你看到以下表格中的 *this* 时，它指的是该方法正在操作的特定向量。
- en: '| **Method** | **Task** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **任务** |'
- en: '| --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| add()       | Adds a vector to this vector |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| add()       | 将一个向量加到此向量上 |'
- en: '| sub()       | Subtracts a vector from this vector |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| sub()       | 从此向量中减去另一个向量 |'
- en: '| mult()      | Scales this vector with multiplication |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| mult()       | 通过乘法缩放此向量 |'
- en: '| div()       | Scales this vector with division |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| div()       | 通过除法缩放此向量 |'
- en: '| mag()       | Returns the magnitude of this vector |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| mag()       | 返回此向量的大小 |'
- en: '| setMag()     | Sets the magnitude of this vector |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| setMag()     | 设置此向量的大小 |'
- en: '| normalize()    | Normalizes this vector to a unit length of 1 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| normalize()   | 将此向量归一化为单位长度 1 |'
- en: '| limit()      | Limits the magnitude of this vector |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| limit()     | 限制此向量的大小 |'
- en: '| heading()     | Returns the 2D heading of this vector expressed as an angle
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| heading()    | 返回此向量的 2D 方向角度 |'
- en: '| rotate()     | Rotates this 2D vector by an angle |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| rotate()     | 按角度旋转此 2D 向量 |'
- en: '| lerp()      | Linear interpolates to another vector |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| lerp()       | 线性插值到另一个向量 |'
- en: '| dist()      | Returns the Euclidean distance between two vectors (considered
    as points) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| dist()      | 返回两个向量（视为点）之间的欧几里得距离 |'
- en: '| angleBetween()  | Finds the angle between two vectors |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| angleBetween() | 计算两个向量之间的角度 |'
- en: '| dot()       | Returns the dot product of two vectors |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| dot()       | 返回两个向量的点积 |'
- en: '| cross()      | Returns the cross product of two vectors (relevant only in
    three dimensions) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| cross()     | 返回两个向量的叉积（仅在三维中相关） |'
- en: '| random2D()    | Returns a random 2D vector |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| random2D()    | 返回一个随机的 2D 向量 |'
- en: '| random3D()    | Returns a random 3D vector |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| random3D()    | 返回一个随机的 3D 向量 |'
- en: I’ll go through a few of the key methods now. As the examples get more sophisticated
    in later chapters, I’ll continue to reveal more details.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将介绍一些关键方法。随着例子的逐步复杂化，在后面的章节中，我会继续揭示更多的细节。
- en: '**Vector Subtraction**'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向量减法**'
- en: 'Having already covered addition, I’ll now turn to subtraction. This one’s not
    so bad; just take the plus sign and replace it with a minus! Before tackling subtraction
    itself, however, consider what it means for a vector ![Image](../images/pg80_Image_66.jpg)
    to become – ![Image](../images/pg80_Image_66.jpg). The negative version of the
    scalar 3 is –3\. A negative vector is similar: the polarity of each of the vector’s
    components is inverted. So if ![Image](../images/pg80_Image_66.jpg) has the components
    (*x*, *y*), then – ![Image](../images/pg80_Image_66.jpg) is (–*x*, –*y*). Visually,
    this results in an arrow of the same length as the original vector pointing in
    the opposite direction, as depicted in [Figure 1.7](ch01.xhtml#ch1fig7).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在已经讲解了加法之后，我现在来讲解减法。其实不难；只需将加号替换为减号即可！不过，在处理减法之前，先考虑一下向量![Image](../images/pg80_Image_66.jpg)变成–![Image](../images/pg80_Image_66.jpg)的意义。标量3的负数是–3，而负向量也是类似的：每个向量分量的极性都会被反转。所以，如果![Image](../images/pg80_Image_66.jpg)有分量（*x*,
    *y*），那么–![Image](../images/pg80_Image_66.jpg)就是(–*x*, –*y*)。从视觉上来看，这会生成一个长度与原始向量相同的箭头，指向相反的方向，如[图1.7](ch01.xhtml#ch1fig7)所示。
- en: '![Image](../images/pg86_Image_80.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg86_Image_80.jpg)'
- en: 'Figure 1.7: The relationship between ![Image](../images/pg81_Image_70.jpg)
    and –![Image](../images/pg81_Image_71.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：![Image](../images/pg81_Image_70.jpg)与–![Image](../images/pg81_Image_71.jpg)之间的关系
- en: 'Subtraction, then, is the same as addition, only with the second vector in
    the equation treated as a negative version of itself:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，减法和加法是相同的，只不过方程中的第二个向量被视为其负数版本：
- en: '![Image](../images/pg86_Image_81.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg86_Image_81.jpg)'
- en: Just as vectors are added by placing them “tip to tail”—that is, aligning the
    tip (or endpoint) of one vector with the tail (or start point) of the next—vectors
    are subtracted by reversing the direction of the second vector and placing it
    at the end of the first, as in [Figure 1.8](ch01.xhtml#ch1fig8).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就像向量相加时，将它们“头尾相接”——也就是将一个向量的头部（或终点）与下一个向量的尾部（或起点）对齐——向量相减时，第二个向量的方向会反转，并将它放置在第一个向量的末尾，如[图1.8](ch01.xhtml#ch1fig8)所示。
- en: '![Image](../images/pg86_Image_82.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg86_Image_82.jpg)'
- en: 'Figure 1.8: Vector subtraction places one vector at the end of another, but
    pointing in the opposite direction.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：向量减法将一个向量放置在另一个向量的末端，但方向相反。
- en: 'To actually solve the subtraction, take the difference of the vectors’ components.
    That is, ![Image](../images/pg86_Image_83.jpg) can be written as shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际解决减法问题，计算向量分量的差值。即，![Image](../images/pg86_Image_83.jpg)可以写成如下所示：
- en: '*w[x]* = *u[x]* – *v[x]*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*w[x]* = *u[x]* – *v[x]*'
- en: '*w[y]* = *u[y]* – *v[y]*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*w[y]* = *u[y]* – *v[y]*'
- en: 'Inside `p5.Vector`, the code reads as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`p5.Vector`中，代码如下所示：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following example demonstrates vector subtraction by taking the difference
    between two points (which are treated as vectors): the mouse position and the
    center of the window.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例通过计算两个点之间的差来演示向量减法（这两个点被视为向量）：鼠标位置和窗口的中心。
- en: '![Image](../images/pg87_Image_90.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg87_Image_90.jpg)'
- en: Note the use of `translate()` to visualize the resulting vector as a line from
    the center `(width / 2, height / 2)` to the mouse. Vector subtraction is its own
    kind of translation, moving the “origin” of a position vector. Here, by subtracting
    the center vector from the mouse vector, I’m effectively moving the starting point
    of the resulting vector to the center of the canvas. Therefore, I also need to
    move the origin by using `translate()`. Without this, the line would be drawn
    from the top-left corner, and the visual connection wouldn’t be as clear.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`translate()`来将结果向量可视化为从中心 `(width / 2, height / 2)` 到鼠标的线。向量减法是一种特殊的平移操作，它移动位置向量的“原点”。在这里，通过将中心向量从鼠标向量中减去，我实际上是在将结果向量的起点移动到画布的中心。因此，我还需要通过使用`translate()`来移动原点。如果没有这个操作，线条将从左上角绘制，视觉上的连接就不那么清晰了。
- en: '**Vector Multiplication and Division**'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向量乘法与除法**'
- en: Moving on to multiplication, you have to think a bit differently. Multiplying
    a vector typically refers to the process of **scaling** a vector. If I want to
    scale a vector to twice its size or one-third of its size, while leaving its direction
    the same, I would say, “Multiply the vector by 2” or “Multiply the vector by 1/3.”
    Unlike with addition and subtraction, I’m multiplying the vector by a scalar (a
    single number), not by another vector. [Figure 1.9](ch01.xhtml#ch1fig9) illustrates
    how to scale a vector by a factor of 3.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 进入乘法部分，你需要从不同的角度思考。乘法向量通常指的是**缩放**向量的过程。如果我想将一个向量缩放为其大小的两倍或三分之一，同时保持其方向不变，我会说：“将向量乘以
    2”或“将向量乘以 1/3。”与加法和减法不同，我是在将向量乘以一个标量（一个数），而不是另一个向量。[图 1.9](ch01.xhtml#ch1fig9)
    说明了如何通过 3 的倍数缩放一个向量。
- en: '![Image](../images/pg88_Image_91.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg88_Image_91.jpg)'
- en: 'Figure 1.9: Scaling a vector with multiplication'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：通过乘法缩放一个向量
- en: 'To scale a vector, multiply each component (*x* and *y*) by a scalar. That
    is, ![Image](../images/pg88_Image_92.jpg) can be written as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩放一个向量，可以将每个分量（*x* 和 *y*）乘以一个标量。也就是说，![Image](../images/pg88_Image_92.jpg)
    可以写成如下形式：
- en: '*w[x]* = *u[x]* × *n*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*w[x]* = *u[x]* × *n*'
- en: '*w[y]* = *u[y]* × *n*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*w[y]* = *u[y]* × *n*'
- en: 'As an example, say ![Image](../images/pg88_Image_94.jpg) and *n* = 3\. You
    can calculate ![Image](../images/pg88_Image_95.jpg) as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，假设 ![Image](../images/pg88_Image_94.jpg) 和 *n* = 3。你可以按照以下方式计算 ![Image](../images/pg88_Image_95.jpg)：
- en: '*w[x]* = −3 × 3'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*w[x]* = −3 × 3'
- en: '*w[y]* = 7 × 3'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*w[y]* = 7 × 3'
- en: '![Image](../images/pg88_Image_95a.jpg) = (− 9, 21)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg88_Image_95a.jpg) = (− 9, 21)'
- en: 'This is exactly how the `mult()` function inside the `p5.Vector` class works:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 `p5.Vector` 类中的 `mult()` 函数的工作原理：
- en: '![Image](../images/pg88_Image_93.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg88_Image_93.jpg)'
- en: 'Implementing multiplication in code is as simple as the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中实现乘法非常简单，代码如下：
- en: '![Image](../images/pg89_Image_96.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg89_Image_96.jpg)'
- en: '[Example 1.4](ch01.xhtml#ch1ex4) illustrates vector multiplication by drawing
    a line between the mouse and the center of the canvas, as in the previous example,
    and then scaling that line by 0.5.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1.4](ch01.xhtml#ch1ex4) 通过在鼠标和画布中心之间画一条线来说明向量乘法，正如前一个示例所示，然后将该线缩放为 0.5。'
- en: '![Image](../images/pg89_Image_97.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg89_Image_97.jpg)'
- en: The resulting vector is half its original size. Rather than multiplying the
    vector by 0.5, I could achieve the same effect by dividing the vector by 2, as
    in [Figure 1.10](ch01.xhtml#ch1fig10).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的向量是原始大小的一半。与其将向量乘以 0.5，我也可以通过将向量除以 2 来达到相同的效果，就像在[图 1.10](ch01.xhtml#ch1fig10)中所示。
- en: '![Image](../images/pg90_Image_98.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg90_Image_98.jpg)'
- en: 'Figure 1.10: Scaling a vector with division'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10：通过除法缩放一个向量
- en: 'Vector division, then, works just like vector multiplication—just replace the
    multiplication sign ( `*` ) with the division sign ( `/` ). Here’s how the `p5.Vector`
    class implements the `div()` function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 向量除法的运作方式和向量乘法一样——只需将乘法符号（`*`）替换为除法符号（`/`）。以下是 `p5.Vector` 类如何实现 `div()` 函数：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And here’s how to use the `div()` function in a sketch:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在草图中使用 `div()` 函数：
- en: '![Image](../images/pg90_Image_99.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg90_Image_99.jpg)'
- en: This takes the vector `u` and divides it by 2.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向量 `u` 除以 2。
- en: '![Image](../images/zoom.jpg) **More Number Properties with Vectors**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **更多与向量相关的数值属性**'
- en: As with addition, basic algebraic rules of multiplication apply to vectors.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与加法一样，乘法的基本代数规则也适用于向量。
- en: 'The associative rule: ![Image](../images/pg90_Image_100.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 结合律：![Image](../images/pg90_Image_100.jpg)
- en: 'The distributive rule with two scalars, one vector: ![Image](../images/pg90_Image_101.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 两个标量和一个向量的分配律：![Image](../images/pg90_Image_101.jpg)
- en: 'The distributive rule with two vectors, one scalar: ![Image](../images/pg90_Image_102.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量和一个标量的分配律：![Image](../images/pg90_Image_102.jpg)
- en: '**Vector Magnitude**'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**向量大小**'
- en: Multiplication and division, as just described, alter the length of a vector
    without affecting its direction. Perhaps you’re wondering, “Okay, so how do I
    know what the length of a vector is? I know the vector’s components (*x* and *y*),
    but how long (in pixels) is the actual arrow?” Understanding how to calculate
    the length of a vector, also known as its **magnitude**, is incredibly useful
    and important.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，乘法和除法可以改变向量的长度，而不影响其方向。你可能会想：“好吧，那我怎么知道一个向量的长度是多少呢？我知道这个向量的分量（*x* 和 *y*），但是这个实际的箭头有多长（单位：像素）？”理解如何计算向量的长度，也就是它的**大小**，是非常有用且重要的。
- en: '![Image](../images/pg91_Image_103.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg91_Image_103.jpg)'
- en: 'Figure 1.11: The length, or magnitude, of a vector ![Image](../images/pg81_Image_71.jpg)
    is often written as ![Image](../images/pg91_Image_107.jpg).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11：向量的长度或大小！[Image](../images/pg81_Image_71.jpg)通常表示为![Image](../images/pg91_Image_107.jpg)。
- en: Notice in [Figure 1.11](ch01.xhtml#ch1fig11) that the vector, drawn as an arrow
    and two components (*x* and *y*), creates a right triangle. The sides are the
    components, and the hypotenuse is the arrow. We’re lucky to have this right triangle,
    because once upon a time, a Greek mathematician named Pythagoras discovered a
    lovely formula that describes the relationship between the sides and hypotenuse
    of a right triangle. This formula, the **Pythagorean theorem**, is *a*² + *b*²
    = *c*² (see [Figure 1.12](ch01.xhtml#ch1fig12)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在[图 1.11](ch01.xhtml#ch1fig11)中，向量以箭头和两个分量（*x* 和 *y*）表示，形成了一个直角三角形。三角形的边是分量，而斜边是箭头。我们很幸运有这个直角三角形，因为曾经有位名叫毕达哥拉斯的希腊数学家发现了一个优美的公式，描述了直角三角形的边和斜边之间的关系。这个公式就是**勾股定理**，即*a*²
    + *b*² = *c*²（见[图 1.12](ch01.xhtml#ch1fig12)）。
- en: '![Image](../images/pg91_Image_104.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg91_Image_104.jpg)'
- en: 'Figure 1.12: The Pythagorean theorem calculates the length of a vector by using
    its components.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12：勾股定理通过使用向量的分量来计算向量的长度。
- en: 'Armed with this formula, we can now compute the magnitude of ![Image](../images/pg80_Image_66.jpg)
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个公式，我们现在可以计算![Image](../images/pg80_Image_66.jpg)的大小，如下所示：
- en: '![Image](../images/pg91_Image_105.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg91_Image_105.jpg)'
- en: 'In the `p5.Vector` class, the `mag()` function is defined using the same formula:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`p5.Vector`类中，`mag()`函数使用相同的公式定义：
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The sketch in the next example calculates the magnitude of the vector between
    the mouse and the center of the canvas, and visualizes it as a rectangle drawn
    across the top of the window.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例中的草图计算了鼠标和画布中心之间的向量大小，并将其可视化为一条穿过窗口顶部的矩形。
- en: '![Image](../images/pg92_Image_109.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg92_Image_109.jpg)'
- en: Notice that the magnitude (length) of a vector is always positive, even if the
    vector’s components are negative.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，向量的大小（长度）始终为正，即使向量的分量是负数。
- en: '**Normalizing Vectors**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**归一化向量**'
- en: Calculating the magnitude of a vector is only the beginning. It opens the door
    to many possibilities, the first of which is **normalization** ([Figure 1.13](ch01.xhtml#ch1fig13)).
    This is the process of making something standard or, well . . . normal. In the
    case of vectors, the convention is that a standard vector has a length of 1\.
    To normalize a vector, therefore, is to take a vector of any length and change
    its length to 1, without changing its direction. That normalized vector is then
    called a **unit vector**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 计算向量的大小只是开始。它打开了许多可能性的大门，其中第一个是**归一化**（[图 1.13](ch01.xhtml#ch1fig13)）。这是将某物标准化或称为“正常化”的过程。对于向量来说，约定是标准向量的长度为1。因此，归一化一个向量就是将任何长度的向量改为长度为1，而不改变其方向。归一化后的向量被称为**单位向量**。
- en: '![Image](../images/pg93_Image_110.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg93_Image_110.jpg)'
- en: 'Figure 1.13: When a vector is normalized, it points in the same direction but
    has been resized to a unit length of 1.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13：当一个向量被归一化时，它仍然指向相同的方向，但其长度已经调整为单位长度1。
- en: A unit vector describes a vector’s direction without regard to its length. You’ll
    see this come in especially handy once you start to work with forces in [Chapter
    2](ch02.xhtml#ch02).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 单位向量描述了向量的方向，而不考虑其长度。一旦你开始处理[第2章](ch02.xhtml#ch02)中的力时，你会发现它特别有用。
- en: 'For any given vector ![Image](../images/pg81_Image_72.jpg), its unit vector
    (written as *û*) is calculated as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的向量![Image](../images/pg81_Image_72.jpg)，其单位向量（写作*û*）的计算方式如下：
- en: '![Image](../images/pg93_Image_111.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg93_Image_111.jpg)'
- en: In other words, to normalize a vector, divide each component by the vector’s
    magnitude. To see why this works, consider a vector (4, 3), which has a magnitude
    of 5 (see [Figure 1.14](ch01.xhtml#ch1fig14)). Once normalized, the vector will
    have a magnitude of 1\. Thinking of the vector as a right triangle, normalization
    shrinks the hypotenuse by dividing by 5 (since 5/5 = 1). In that process, each
    side shrinks as well, also by a factor of 5\. The side lengths go from 4 and 3
    to 4/5 and 3/5, respectively.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，要归一化一个向量，将每个分量除以向量的大小。为了理解为什么这样做有效，考虑一个向量（4, 3），其大小为5（见[图 1.14](ch01.xhtml#ch1fig14)）。一旦归一化，向量的大小将为1。将向量视为直角三角形，归一化的过程通过除以5来缩小斜边（因为5/5
    = 1）。在这个过程中，每一边也按5的比例缩小。边长从4和3分别变为4/5和3/5。
- en: '![Image](../images/pg93_Image_112.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg93_Image_112.jpg)'
- en: 'Figure 1.14: To normalize a vector, its components are divided by its magnitude.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14：为了标准化一个向量，其分量将被其大小除以。
- en: 'In the `p5.Vector` class, the normalization method is written as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`p5.Vector`类中，标准化方法写作如下：
- en: '[PRE10]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, there’s one small issue. What if the magnitude of the vector is 0?
    You can’t divide by 0! Some quick error checking, shown next, fixes that right
    up.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里有一个小问题。如果向量的大小是0怎么办？你不能除以0！一些快速的错误检查（如下所示）可以解决这个问题。
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This sketch uses normalization to give the vector between the mouse and the
    center of the canvas a fixed length, regardless of the actual magnitude of the
    original vector.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用标准化来使鼠标和画布中心之间的向量长度固定，不管原始向量的实际大小如何。
- en: '![Image](../images/pg94_Image_114.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg94_Image_114.jpg)'
- en: Notice that I’ve multiplied the `mouse` vector by 50 after normalizing it to
    1\. Normalization is often the first step in creating a vector of a specific length,
    even if the desired length is something other than 1\. You’ll see more of this
    later in the chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在将`mouse`向量标准化为1后，我将其乘以了50。标准化通常是创建具有特定长度的向量的第一步，即使目标长度不是1。你将在本章稍后看到更多相关内容。
- en: All this vector math stuff sounds like something you should know about, but
    why? How will it help you write code? Patience. It’ll take some time before the
    awesomeness of using `p5.Vector` fully comes to light. This is a fairly common
    occurrence when learning a new data structure. For example, when you first learn
    about arrays, it might seem like more work to use an array than to have several
    variables stand for multiple things. That plan quickly breaks down when you need
    100, 1,000, or 10,000 things, however.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些向量数学的内容听起来像是你应该了解的东西，但为什么呢？它如何帮助你编写代码？耐心点，使用`p5.Vector`的强大功能将在一段时间后完全显现出来。这在学习新数据结构时是很常见的现象。例如，当你第一次学习数组时，可能会觉得使用数组比用几个变量表示多个东西要麻烦。但当你需要处理100、1000或10000个元素时，这种做法就会迅速崩溃。
- en: The same can be true for vectors. What might seem like more work now will pay
    off later, and quite nicely. And you don’t have to wait too long, as your reward
    will come in the next chapter. For now, however, I’ll focus on *how* vectors work,
    and on how working with them provides a different way to think about motion.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的情况也一样。现在看起来像是更多的工作，稍后会得到回报，而且回报会非常不错。而且你不必等太久，因为你的奖励将在下一章到来。不过现在，我将专注于*向量是如何工作的*，以及如何通过使用它们提供一种不同的思维方式来处理运动。
- en: '**Motion with Vectors**'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用向量进行运动**'
- en: 'What does it mean to program motion by using vectors? You got a taste of it
    in [Example 1.2](ch01.xhtml#ch1ex2), the bouncing ball. The circle onscreen has
    a position (its location at any given moment) as well as a velocity (instructions
    for how it should move from one moment to the next). Velocity is added to position:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用向量编程运动是什么意思？你在[示例 1.2](ch01.xhtml#ch1ex2)中体验过了，那个是弹跳球。屏幕上的圆圈有一个位置（它在任何给定时刻的位置），以及一个速度（指示它如何从一个时刻移动到下一个时刻）。速度被加到位置上：
- en: '[PRE12]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then the object is drawn at the new position:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，物体会绘制在新的位置：
- en: '[PRE13]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Together, these steps are Motion 101:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤合起来构成了运动基础101：
- en: Add the velocity to the position.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将速度添加到位置。
- en: Draw the object at the position.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该位置绘制物体。
- en: In the bouncing ball example, all this code happened within `setup()` and `draw()`.
    What I want to do now is move toward encapsulating all the logic for an object’s
    motion inside a **class**. This way, I can create a foundation for programming
    moving objects that I can easily reuse again and again. (See “The Random Walker
    Class” on [page 3](ch00.xhtml#ch00lev1sec11) for a brief review of OOP basics.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹跳球的示例中，所有这些代码都在`setup()`和`draw()`中完成。现在我想做的是将一个物体的运动逻辑封装到一个**类**中。这样，我就可以为编程运动物体创建一个基础，便于我反复使用。（有关面向对象编程的简要回顾，请参见[第3页](ch00.xhtml#ch00lev1sec11)的《随机行走类》一节。）
- en: 'To start, I’m going to create a generic `Mover` class that will describe a
    shape moving around the canvas. For that, I must consider the following two questions:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将创建一个通用的`Mover`类，用于描述一个形状在画布上的移动。为此，我必须考虑以下两个问题：
- en: What data does a mover have?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个移动器包含哪些数据？
- en: What functionality does a mover have?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个移动器具备什么功能？
- en: 'The Motion 101 algorithm answers both of these questions. First, a `Mover`
    object has two pieces of data, `position` and `velocity`, which are both `p5.Vector`
    objects. These are initialized in the object’s constructor. In this case, I’ll
    arbitrarily decide to initialize the `Mover` object by giving it a random position
    and velocity. Note the use of `this` with all variables that are part of the `Mover`
    object:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 《运动101》算法回答了这两个问题。首先，一个`Mover`对象有两部分数据，`position`和`velocity`，它们都是`p5.Vector`对象。这些数据在对象的构造函数中初始化。在这种情况下，我随意决定通过给`Mover`对象一个随机的位置和速度来初始化它。注意所有属于`Mover`对象的变量都使用了`this`关键字：
- en: '![Image](../images/pg96_Image_115a.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg96_Image_115a.jpg)'
- en: 'The functionality follows suit. The `Mover` object needs to move (by applying
    its velocity to its position) and needs to be visible. I’ll implement these needs
    as functions named `update()` and `show()`. I’ll put all the motion logic code
    in `update()` and draw the object in `show()`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 功能也跟着变化。`Mover`对象需要移动（通过将速度应用到位置）并且需要可见。我将把这些需求实现为名为`update()`和`show()`的函数。我会把所有运动逻辑的代码放在`update()`中，并在`show()`中绘制对象：
- en: '![Image](../images/pg96_Image_115.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg96_Image_115.jpg)'
- en: 'The `Mover` class also needs a function that determines what the object should
    do when it reaches the edge of the canvas. For now, I’ll do something simple and
    have it wrap around the edges:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mover`类还需要一个函数，用来决定当对象到达画布边缘时应该做什么。目前，我做了一件简单的事情，让它在边缘处绕回来：'
- en: '![Image](../images/pg96_Image_116.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg96_Image_116.jpg)'
- en: 'Now the `Mover` class is finished, but the class itself isn’t an object; it’s
    a template for creating an instance of an object. To actually create a `Mover`
    object, I first need to declare a variable to hold it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Mover`类已经完成，但该类本身不是一个对象；它是用来创建对象实例的模板。要实际创建一个`Mover`对象，我首先需要声明一个变量来存储它：
- en: '[PRE14]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, inside the `setup()` function, I create the object by invoking the class
    name along with the `new` keyword. This triggers the class’s constructor to make
    an instance of the object:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`setup()`函数中，我通过调用类名和`new`关键字来创建对象。这会触发类的构造函数，从而创建该对象的实例：
- en: '[PRE15]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now all that remains is to call the appropriate methods in `draw()`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是在`draw()`中调用适当的方法：
- en: '[PRE16]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here’s the entire example for reference.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的示例，供参考。
- en: '![Image](../images/pg97_Image_118.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg97_Image_118.jpg)'
- en: If OOP is at all new to you, one aspect here may seem a bit strange. I spent
    the beginning of this chapter discussing the `p5.Vector` class, and this class
    is the template for making the `position` object and the `velocity` object. So
    what are those objects doing inside yet another object, the `Mover` object?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果面向对象编程（OOP）对你来说是全新的，这里有一点可能看起来有些奇怪。我在本章开头讨论了`p5.Vector`类，而这个类是用来创建`position`对象和`velocity`对象的模板。那么，这些对象为什么会出现在另一个对象——`Mover`对象里呢？
- en: In fact, this is just about the most normal thing ever. An object is something
    that holds data (and functionality). That data can be numbers, or it can be other
    objects (arrays too)! You’ll see this over and over again in this book. In [Chapter
    4](ch04.xhtml#ch04), for example, I’ll write a class to describe a system of particles.
    That `ParticleSystem` object will include a list of `Particle` objects . . . and
    each `Particle` object will have as its data several `p5.Vector` objects!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这几乎是最正常不过的事了。一个对象就是用来存储数据（和功能）的。这些数据可以是数字，也可以是其他对象（包括数组）！你会在本书中反复看到这一点。例如，在[第4章](ch04.xhtml#ch04)中，我将编写一个类来描述一个粒子系统。那个`ParticleSystem`对象将包含一个`Particle`对象的列表……而每个`Particle`对象的数据将包含几个`p5.Vector`对象！
- en: You may have also noticed in the `Mover` class that I’m setting the initial
    position and velocity directly within the constructor, without using any arguments.
    While this approach keeps the code simple for now, I’ll explore the benefits of
    adding arguments to the constructor in [Chapter 2](ch02.xhtml#ch02).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到，在`Mover`类中，我直接在构造函数内设置了初始位置和速度，而没有使用任何参数。虽然这种做法目前保持了代码的简洁，但我将在[第2章](ch02.xhtml#ch02)中探讨在构造函数中添加参数的好处。
- en: 'At this point, you hopefully feel comfortable with two concepts: (1) what a
    vector is and (2) how to use vectors inside an object to keep track of its position
    and movement. This is an excellent first step and deserves a mild round of applause.
    Before standing ovations are in order, however, you need to make one more, somewhat
    bigger step forward. After all, watching the Motion 101 example is fairly boring.
    The circle never speeds up, never slows down, and never turns. For more sophisticated
    motion—the kind of motion that appears in the world around us—one more vector
    needs to be added to the class: `acceleration`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，希望你已经熟悉了两个概念：（1）什么是向量，以及（2）如何在对象内使用向量来跟踪其位置和运动。这是一个很好的第一步，值得小小鼓掌。然而，在真正的热烈掌声到来之前，你还需要再迈出一步，这一步有些大。毕竟，观看“运动
    101”示例相当无聊。圆形从未加速，从未减速，也从未转动。为了实现更复杂的运动——那种在我们周围的世界中出现的运动——需要向类中添加一个额外的向量：`加速度`。
- en: '**Acceleration**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加速度**'
- en: '**Acceleration** is the rate of change of velocity. Think about that definition
    for a moment. Is it a new concept? Not really. Earlier I defined velocity as the
    rate of change of position, so in essence I’m developing a trickle-down effect.
    Acceleration affects velocity, which in turn affects position. (To provide some
    brief foreshadowing, this point will become even more crucial in the next chapter,
    when I show how forces like friction affect acceleration, which affects velocity,
    which affects position.) In code, this trickle-down effect reads like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**加速度**是速度变化的速率。稍微思考一下这个定义。这是一个全新的概念吗？不完全是。之前我将速度定义为位置变化的速率，因此，本质上，我正在开发一个渐变效应。加速度影响速度，而速度反过来影响位置。（为了稍作铺垫，这一点将在下一章变得更加关键，当我展示摩擦力等力量如何影响加速度，从而影响速度，再影响位置时。）在代码中，这个渐变效应是这样的：'
- en: '[PRE17]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As an exercise, from this point forward, I’m going to make a rule for myself:
    I’ll try to write every example in the rest of this book without ever touching
    the values of velocity and position (except to initialize them). In other words,
    the goal for programming motion is to come up with an algorithm for calculating
    acceleration and then let the trickle-down effect work its magic. (In truth, there
    will be a multitude of reasons to break this rule, and break it I shall. Nevertheless,
    it’s a useful constraint to begin with to illustrate the principles behind the
    motion algorithm with acceleration.)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个练习，从现在开始，我给自己定个规则：我会尽量在本书余下的示例中，避免直接接触速度和位置的值（除了初始化它们）。换句话说，编程运动的目标是提出一个计算加速度的算法，然后让它的渐变效应发挥作用。（事实上，会有许多理由打破这个规则，而我也会打破它。尽管如此，作为一个起点，这个限制还是很有用的，它有助于通过加速度的运动算法原理进行说明。）
- en: 'The next step, then, is to come up with a way to calculate acceleration. Here
    are a few possible algorithms:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是想出一种计算加速度的方法。以下是几种可能的算法：
- en: A constant acceleration
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恒定加速度
- en: A random acceleration
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机加速度
- en: An acceleration toward the mouse
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 朝向鼠标的加速度
- en: I’ll use the rest of this chapter to show you how to implement these algorithms.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我将用本章的剩余部分来向你展示如何实现这些算法。
- en: '**Algorithm 1: Constant Acceleration**'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算法 1：恒定加速度**'
- en: 'Acceleration Algorithm 1, a constant acceleration, isn’t particularly interesting,
    but it’s the simplest and thus an excellent starting point to incorporate acceleration
    into the code. The first step is to add another variable to the `Mover` class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度算法 1，恒定加速度，虽然并不特别有趣，但它是最简单的，因此是将加速度引入代码的绝佳起点。第一步是向`Mover`类添加另一个变量：
- en: '![Image](../images/pg100_Image_120.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg100_Image_120.jpg)'
- en: 'Next, incorporate acceleration into the `update()` function:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将加速度整合到`update()`函数中：
- en: '![Image](../images/pg100_Image_121.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg100_Image_121.jpg)'
- en: 'I’m almost finished. The only missing piece is to get that mover moving! In
    the constructor, the initial velocity is set to 0, rather than a random vector
    as previously done. Therefore, when the sketch starts, the object is at rest.
    To get it moving instead of changing the velocity directly, I’ll update it through
    the object’s acceleration. According to Algorithm 1, the acceleration should be
    constant, so I’ll choose a value now:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我快完成了。唯一缺少的部分就是让那个移动器动起来！在构造函数中，初始速度被设置为 0，而不是之前做的随机向量。因此，当草图开始时，物体是静止的。为了让它动起来，而不是直接改变速度，我将通过物体的加速度来更新它。根据算法
    1，加速度应该是恒定的，因此我现在选择一个值：
- en: '[PRE18]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This means that for every frame of the animation, the object’s velocity should
    increase by –0.001 pixels in the x-direction and 0.01 pixels in the y-direction.
    Maybe you’re thinking, “Gosh, those values seem awfully small!” Indeed, they are
    quite tiny, but that’s by design. Acceleration values accumulate over time in
    the velocity, about 30 times per second, depending on the sketch’s frame rate.
    To keep the magnitude of the velocity vector from growing too quickly and spiraling
    out of control, the acceleration values should remain quite small.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着动画的每一帧，物体的速度在 x 方向应该增加 -0.001 像素，在 y 方向增加 0.01 像素。也许你会想，“天哪，这些值看起来太小了！”确实，它们非常微小，但这是有意设计的。加速度值随着时间在速度中累积，每秒约
    30 次，这取决于草图的帧速率。为了防止速度矢量的大小增长过快并失控，加速度值应保持相当小。
- en: 'I can also help keep the velocity within a reasonable range by incorporating
    the `p5.Vector` function `limit()`, which puts a cap on the magnitude of a vector:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `p5.Vector` 函数 `limit()`，我还可以帮助保持速度在合理范围内，它限制了向量的大小：
- en: '![Image](../images/pg101_Image_122.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg101_Image_122.jpg)'
- en: 'This translates to the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这转化为以下内容：
- en: '*What is the magnitude of velocity? If it’s less than 10, no worries; just
    leave it as is. If it’s more than 10, however, reduce it to 10!*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*速度的大小是多少？如果小于 10，没问题；保持原样。如果大于 10，则将其减小到 10！*'
- en: '![Image](../images/pencil.jpg) **Exercise 1.4**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 1.4**'
- en: 'Write the `limit()` function for the `p5.Vector` class:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `p5.Vector` 类编写 `limit()` 函数：
- en: '[PRE19]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s take a look at the changes to the `Mover` class, complete with `acceleration`
    and `limit()`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `Mover` 类的更改，包括 `acceleration` 和 `limit()`。
- en: '![Image](../images/pg101_Image_123.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg101_Image_123.jpg)'
- en: The net result is that the object falls down and to the left, gradually moving
    faster and faster until it reaches the maximum velocity.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是物体向下和向左移动，逐渐加速，直到达到最大速度。
- en: '![Image](../images/pencil.jpg) **Exercise 1.5**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 1.5**'
- en: Create a simulation of an object (think about a vehicle) that accelerates when
    you press the up arrow and brakes when you press the down arrow.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个物体的模拟（想象一辆车），按向上箭头加速，按向下箭头刹车。
- en: '**Algorithm 2: Random Acceleration**'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算法 2：随机加速**'
- en: 'Now on to Acceleration Algorithm 2, a random acceleration. In this case, instead
    of initializing `acceleration` in the object’s constructor, I want to randomly
    set its value inside the `update()` method. This way, the object will get a different
    acceleration vector for every frame of the animation:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入加速度算法 2，随机加速。在这种情况下，我不想在对象的构造函数中初始化 `acceleration`，而是希望在 `update()` 方法内随机设置其值。这样，每帧动画对象将获得一个不同的加速度向量：
- en: '![Image](../images/pg102_Image_125.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg102_Image_125.jpg)'
- en: 'The `random2D()` method produces a normalized vector, meaning it has a random
    direction, but its magnitude is always 1\. To make things interesting, I can try
    scaling the random vector by a constant value:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`random2D()` 方法生成一个归一化向量，意味着它具有随机的方向，但其大小始终为 1。为了增加趣味性，我可以尝试将随机向量按照一个常数值进行缩放：'
- en: '![Image](../images/pg103_Image_126.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg103_Image_126.jpg)'
- en: Or, for even greater variety, I can scale the acceleration to a random value.
    In [Example 1.9](ch01.xhtml#ch1ex9), the `acceleration` vector has both a random
    direction and a random magnitude from 0 to 2.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了更大的变化，我可以将加速度缩放到一个随机值。在 [示例 1.9](ch01.xhtml#ch1ex9) 中，`acceleration` 向量既具有随机方向又具有
    0 到 2 的随机大小。
- en: '![Image](../images/pg103_Image_127.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg103_Image_127.jpg)'
- en: It’s crucial to understand that acceleration doesn’t merely refer to *speeding
    up* or *slowing down.* Rather, as this example has shown, it refers to *any change*
    in velocity—magnitude or direction. Acceleration is used to steer an object, and
    you’ll see this again and again in future chapters as I begin to code objects
    that make decisions about how to move.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 很重要的一点是要理解，加速度不仅仅指*加速*或*减速*。正如这个例子所显示的，它指的是速度的*任何变化*——大小或方向。加速度用于控制物体的运动，你将在未来的章节中再次看到这一点，当我开始编写能够决定如何移动的对象时。
- en: 'You might also notice that this example is another kind of random walker. A
    key distinction between what I’m doing here and the previous chapter’s examples,
    however, lies in *what* is being randomized. With the traditional random walker,
    I was directly manipulating the velocity, meaning each step was completely independent
    of the last. In [Example 1.9](ch01.xhtml#ch1ex9), the acceleration (the rate of
    change of velocity) is being randomized, not the velocity itself. This makes the
    object’s motion dependent on its previous state: the velocity changes incrementally
    according to the random acceleration. The resulting movement of the object has
    a kind of continuity and fluidity that the original random walker lacked. The
    difference may seem subtle, but it fundamentally changes the way the object moves
    about the canvas.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，这个例子是另一种类型的随机游走。然而，和上一章的例子不同，关键在于 *随机化的内容*。在传统的随机游走中，我是直接操作速度，也就是说每一步都与上一部完全独立。而在
    [例子 1.9](ch01.xhtml#ch1ex9) 中，是加速度（速度的变化率）在随机化，而不是速度本身。这使得物体的运动依赖于其之前的状态：速度根据随机加速度逐步变化。由此产生的物体运动具有连续性和流畅性，而原始的随机游走缺乏这种特性。这个差异可能看起来很微妙，但它从根本上改变了物体在画布上的运动方式。
- en: '![Image](../images/pencil.jpg) **Exercise 1.6**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 1.6**'
- en: Referring back to [Exercise 0.6](ch00.xhtml#ch0exe6), implement an acceleration
    calculated with Perlin noise.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [练习 0.6](ch00.xhtml#ch0exe6)，实现一个基于 Perlin 噪声计算的加速度。
- en: '**Static vs. Nonstatic Methods**'
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**静态方法与非静态方法**'
- en: You might have noticed something a bit odd and unfamiliar in the previous example.
    The `random2D()` method used to create a random unit vector was called on the
    class name, as in `p5.Vector.random2D()`, rather than on the current instance
    of the class, as in `this.random2D()`. This is because `random2D()` is a **static
    method**, meaning it’s associated with the class as a whole rather than the individual
    objects (that is, the instances of that class).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到在上一个例子中有些奇怪而陌生的地方。用于创建随机单位向量的 `random2D()` 方法是通过类名调用的，像这样 `p5.Vector.random2D()`，而不是通过类的当前实例调用，像这样
    `this.random2D()`。这是因为 `random2D()` 是一个 **静态方法**，意味着它是与整个类相关的，而不是与个别对象（即该类的实例）相关的。
- en: Static methods are rarely needed when you’re writing your own classes (like
    `Walker` or `Mover`), so you may not have encountered them before. They sometimes
    form an important part of prewritten classes like `p5.Vector`, however. In fact,
    Acceleration Algorithm 3 (accelerate toward the mouse) requires further use of
    this concept, so let’s take a step back and consider the difference between static
    and nonstatic methods.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写自己的类（如 `Walker` 或 `Mover`）时，通常不需要静态方法，所以你可能没有接触过它们。然而，在一些预写的类中，如 `p5.Vector`，静态方法有时是非常重要的一部分。事实上，加速算法
    3（朝向鼠标加速）需要进一步使用这个概念，所以让我们退一步，考虑一下静态方法和非静态方法之间的区别。
- en: 'Setting aside vectors for a second, take a look at the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时抛开向量，看看以下代码：
- en: '[PRE20]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is probably what you’re used to, yes? I give `x` a value of 0, add `y`
    to it, and now `x` is equal to 5\. I could write similar code for adding two vectors:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你习惯的方式，对吗？我给 `x` 赋值为 0，将 `y` 加到它上面，现在 `x` 等于 5。我可以写类似的代码来添加两个向量：
- en: '[PRE21]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The vector `v` has the value of (0, 0), I add the vector `u` to it, and now
    `v` is equal to (4, 5). Makes sense, right?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 `v` 的值为 (0, 0)，我将向量 `u` 加到它上面，现在 `v` 的值变为 (4, 5)。有道理，对吧？
- en: 'Now consider this example:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看这个例子：
- en: '[PRE22]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I give `x` a value of 0, add `y` to it, and store the result in a new variable
    `z`. The value of `x` doesn’t change here (neither does `y`)! This may seem like
    a trivial point, and one that’s quite intuitive when it comes to mathematical
    operations with simple numbers. However, it’s not so obvious with mathematical
    operations using `p5.Vector` objects. Let’s try to rewrite the example with vectors,
    based on what I’ve covered of the `p5.Vector` class so far:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我给 `x` 赋值为 0，将 `y` 加到它上面，并将结果存储到一个新变量 `z` 中。这里 `x` 的值没有改变（`y` 也没有改变）！这看起来可能是一个微不足道的点，对于简单数字的数学运算来说，它非常直观。然而，当我们使用
    `p5.Vector` 对象进行数学运算时，这就不那么显而易见了。让我们尝试基于我到目前为止介绍的 `p5.Vector` 类，重写这个例子：
- en: '![Image](../images/pg105_Image_128.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg105_Image_128.jpg)'
- en: 'This might seem like a good guess, but it’s just not the way the `p5.Vector`
    class works. If you look at the definition of `add()`, you can see why:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能是一个不错的猜测，但这不是 `p5.Vector` 类的工作方式。如果你查看 `add()` 方法的定义，你就能明白原因：
- en: '[PRE23]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code has two problems. First, the `add()` method doesn’t return a new `p5.Vector`
    object, and second, `add()` changes the value of the vector upon which it’s called.
    To add two vector objects together and return the result as a new vector, I must
    use the static version of the `add()` method by calling it on the class name,
    rather than calling the nonstatic version on a specific object instance.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两个问题。首先，`add()` 方法不会返回一个新的 `p5.Vector` 对象；其次，`add()` 会改变它调用时所在向量的值。为了将两个向量对象相加并返回结果作为一个新的向量，我必须使用
    `add()` 方法的静态版本，调用时是类名而非特定对象实例的非静态版本。
- en: 'Here’s how I might write the static version of `add()` if I were declaring
    the class myself:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我自己声明这个类，下面是如何编写 `add()` 的静态版本：
- en: '![Image](../images/pg105_Image_129.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg105_Image_129.jpg)'
- en: The key difference here is that the method returns a new vector ( `v3` ) created
    using the sum of the components of `v1` and `v2`. As a result, the method doesn’t
    make changes to either original vector.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键区别是，方法返回一个新的向量（`v3`），它是通过 `v1` 和 `v2` 的分量之和创建的。因此，方法不会对任何原始向量做出修改。
- en: 'When calling a static method, instead of referencing an object instance, you
    reference the name of the class. Here’s the right way to implement the vector
    addition example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 调用静态方法时，你不是引用对象实例，而是引用类的名称。下面是实现向量加法示例的正确方式：
- en: '[PRE24]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `p5.Vector` class has static versions of `add()`, `sub()`, `mult()`, and
    `div()`. These static methods allow you to perform generic mathematical operations
    on vectors without changing the value of one of the input vectors in the process.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`p5.Vector` 类有 `add()`、`sub()`、`mult()` 和 `div()` 的静态版本。这些静态方法允许你对向量执行通用的数学运算，而不会在过程中改变任何输入向量的值。'
- en: '![Image](../images/pencil.jpg) **Exercise 1.7**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 1.7**'
- en: 'Translate the following pseudocode to code, using static or nonstatic functions
    where appropriate:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下伪代码转化为代码，根据需要使用静态或非静态函数：
- en: The vector `v` equals (1, 5).
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量 `v` 等于 (1, 5)。
- en: The vector `u` equals `v` multiplied by 2.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量 `u` 等于 `v` 乘以 2。
- en: The vector `w` equals `v` minus `u`.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量 `w` 等于 `v` 减去 `u`。
- en: Divide the vector `w` by 3.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将向量 `w` 除以 3。
- en: '[PRE25]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Algorithm 3: Interactive Motion**'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算法 3：交互式运动**'
- en: 'To finish out this chapter, let’s try something a bit more complex and a great
    deal more useful. I’ll dynamically calculate an object’s acceleration according
    to the rule stated in Acceleration Algorithm 3: the object accelerates toward
    the mouse.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章内容，让我们尝试一些更复杂、也更有用的内容。我将根据加速度算法 3 中所述的规则动态计算一个对象的加速度：对象朝向鼠标加速。
- en: 'Anytime you want to calculate a vector based on a rule or formula, you need
    to compute two attributes: magnitude and direction. I’ll start with direction.
    I know the acceleration vector should point from the object’s position toward
    the mouse position ([Figure 1.15](ch01.xhtml#ch1fig15)). Let’s say the object
    is located at the position vector (*x*, *y*), and the mouse is at (*mouseX*, *mouseY*).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要根据规则或公式计算一个向量时，你需要计算两个属性：大小和方向。我将从方向开始。我知道加速度向量应该从对象的位置指向鼠标位置（[图 1.15](ch01.xhtml#ch1fig15)）。假设对象位于位置向量
    (*x*, *y*)，而鼠标位于 (*mouseX*, *mouseY*)。
- en: '![Image](../images/pg106_Image_130.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg106_Image_130.jpg)'
- en: 'Figure 1.15: A vector from an object to the mouse position'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15：从对象到鼠标位置的向量
- en: 'In [Figure 1.16](ch01.xhtml#ch1fig16), you see that the acceleration vector
    (*dx*, *dy*) can be calculated by subtracting the object’s position from the mouse’s
    position:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1.16](ch01.xhtml#ch1fig16)中，你可以看到加速度向量（*dx*，*dy*）可以通过从对象位置中减去鼠标位置来计算：
- en: '*dx = mouseX - x*'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dx = mouseX - x*'
- en: '*dy = mouseY - y*'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dy = mouseY - y*'
- en: '![Image](../images/pg107_Image_131.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg107_Image_131.jpg)'
- en: 'Figure 1.16: Calculating an initial acceleration vector by taking the difference
    of the mouse and position vectors'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16：通过取鼠标和位置向量的差来计算初始加速度向量
- en: 'Let’s implement that by using `p5.Vector` syntax. Assuming the code will live
    inside the `Mover` class and thus have access to the object’s `position`, I can
    write this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 `p5.Vector` 语法来实现这个。假设代码位于 `Mover` 类内，因此可以访问对象的 `position`，我可以这样写：
- en: '![Image](../images/pg107_Image_132.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg107_Image_132.jpg)'
- en: I’ve used the static version of `sub()` to create a new vector `direction` that
    points from the mover’s position to the mouse. If the object were to actually
    accelerate using that vector, however, it would appear instantaneously at the
    mouse position, since the magnitude of `direction` is equal to the distance between
    the object and the mouse. This wouldn’t make for a smooth animation, of course.
    The next step, therefore, is to decide how quickly the object should accelerate
    toward the mouse by changing the vector’s magnitude.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了`sub()`的静态版本来创建一个新的向量`direction`，它指向从物体的位置到鼠标的位置。然而，如果物体实际使用该向量加速，它会瞬间出现在鼠标位置，因为`direction`的大小等于物体与鼠标之间的距离。当然，这样做并不会产生平滑的动画。因此，下一步是决定物体应该以多快的速度向鼠标加速，通过改变向量的大小。
- en: 'To set the magnitude (whatever it may be) of the acceleration vector, I must
    first ______ the vector. That’s right, you said it: *normalize*! If I can shrink
    the vector to its unit vector (of length 1), I can easily scale it to any other
    value, because 1 multiplied by anything equals anything:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置加速度向量的大小（无论它是多少），我必须先______该向量。没错，你说对了：*归一化*！如果我能将向量缩小到单位向量（长度为1），我就可以轻松地将它缩放到任何其他值，因为1乘以任何东西都等于任何东西：
- en: '![Image](../images/pg107_Image_133.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg107_Image_133.jpg)'
- en: 'To summarize, follow these steps to make the object accelerate toward the mouse:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，按照以下步骤让物体向鼠标加速：
- en: Calculate a vector that points from the object to the target position (mouse).
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一个指向物体到目标位置（鼠标）的向量。
- en: Normalize that vector (reducing its length to 1).
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归一化该向量（将其长度缩小到1）。
- en: Scale that vector to an appropriate value (by multiplying it by a value).
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将那个向量缩放到适当的值（通过将其乘以某个值）。
- en: Assign that vector to acceleration.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该向量分配给加速度。
- en: 'I have a confession to make. Normalization and then scaling is such a common
    vector operation that `p5.Vector` includes a function that does both, setting
    the magnitude of a vector to a given value with a single function call. That function
    is `setMag()`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我得承认，归一化然后缩放是如此常见的向量操作，以至于`p5.Vector`包含了一个可以同时完成这两个操作的函数，用一个函数调用即可将向量的大小设置为给定值。那个函数就是`setMag()`：
- en: '[PRE26]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this next example, to emphasize the math, I’m going to write the code using
    `normalize()` and `mult()`, but this is likely the last time I’ll do that. You’ll
    find `setMag()` in examples going forward.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，为了强调数学部分，我将使用`normalize()`和`mult()`来编写代码，但这可能是我最后一次这样做了。你会在之后的示例中看到`setMag()`。
- en: '![Image](../images/pg108_Image_134.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg108_Image_134.jpg)'
- en: You may be wondering why the circle doesn’t stop when it reaches the target.
    It’s important to note that the moving object has no knowledge about trying to
    stop at a destination; it knows only the destination’s position. The object tries
    to accelerate there at a fixed rate, regardless of how far away it is. This means
    it will inevitably overshoot the target and have to turn around, again accelerating
    toward the destination, overshooting it again, and so forth. Stay tuned; in later
    chapters, I’ll show you how to program an object to **arrive** at a target (slow
    down on approach).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么圆圈在到达目标时不会停止。需要注意的是，运动物体并不了解试图停在目的地这一点；它只知道目的地的位置。物体会以固定速率向该位置加速，无论距离有多远。这意味着它不可避免地会超越目标，然后必须转过头来，再次加速朝向目的地，再次超越目标，如此反复。敬请期待；在后续章节中，我会向你展示如何编程让物体**到达**目标（在接近时减速）。
- en: '![Image](../images/pencil.jpg) **Exercise 1.8**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 1.8**'
- en: '[Example 1.10](ch01.xhtml#ch1ex10) is remarkably close to the concept of gravitational
    attraction, with the object being attracted to the mouse position. In the example,
    however, the attraction magnitude is constant, whereas with a real-life gravitational
    force, the magnitude is inversely proportional to distance: the closer the object
    is to the attraction point, the faster it accelerates. I’ll cover gravitational
    attraction in more detail in the next chapter, but for now, try implementing your
    own version of [Example 1.10](ch01.xhtml#ch1ex10) with a variable magnitude of
    acceleration, stronger when it’s either closer or farther away.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1.10](ch01.xhtml#ch1ex10)非常接近引力吸引的概念，物体被吸引到鼠标位置。然而，在这个示例中，吸引的强度是恒定的，而在现实中的引力中，强度与距离成反比：物体越接近吸引点，它加速的速度越快。我将在下一章详细讲解引力吸引的内容，但现在，请尝试实现你自己的版本，[示例
    1.10](ch01.xhtml#ch1ex10)，并使用可变的加速度强度，物体离得越近或越远，吸引力越强。'
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bird.jpg) **生态系统项目**'
- en: Incorporate vectors to further develop and refine the motion of the elements
    within your ecosystem. Explore how motion can be directed by solely manipulating
    an object’s acceleration vector.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 将向量引入，以进一步发展和精炼你生态系统中元素的运动。探索如何通过单纯操控物体的加速度向量来引导运动。
- en: How might you calculate acceleration to emulate certain behaviors—the erratic
    buzzing of a nervous fly, the gentle hops of a bunny, or the slithering of a snake?
    What role does acceleration play in nature? Consider the way a bird accelerates
    when taking off or how a fish suddenly changes direction when swimming. Again,
    how much of a creature’s personality can be shaped by its behavior alone? What
    is added (or taken away) by incorporating more visual design elements beyond simple
    shapes?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何计算加速度来模拟某些行为——一只紧张的苍蝇不规则的嗡嗡声、一只兔子轻盈的跳跃，或者一条蛇的滑行？加速度在自然界中扮演着什么角色？考虑一下鸟类起飞时如何加速，或者鱼类游泳时如何突然改变方向。再次思考，生物的个性能有多少是通过其行为塑造的？通过引入更多视觉设计元素，除了简单的形状外，还能添加（或去除）什么？
- en: '![Image](../images/pg109_Image_135.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg109_Image_135.jpg)'
