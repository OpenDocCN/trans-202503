- en: '**1 Vectors**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*I’m committing crimes with both direction and magnitude.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Vector, *Despicable Me*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg73_Image_58.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Marshall Islands stick chart on display at the Berkeley Art Museum (photo
    by Jim Heaphy)**'
  prefs: []
  type: TYPE_NORMAL
- en: The stick chart is a navigational tool crafted by the indigenous people of the
    Marshall Islands, located in the central Pacific Ocean. This ancient tool was
    made by carefully tying together the midribs of coconut fronds. Shell markings
    on the chart signify the locations of islands in the region. The layout of the
    fronds and shells serves as a geographical guide, offering an abstract representation
    of vectors that capture the ocean swell patterns and their directional flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book is all about looking at the world around us and developing ways to
    simulate it with code. In this first part of the book, I’ll start by looking at
    basic physics: how an apple falls from a tree, how a pendulum swings in the air,
    how Earth revolves around the sun, and so on. Absolutely everything contained
    within the book’s first five chapters requires the use of the most basic building
    block for programming motion, the **vector**. And so that’s where I’ll begin the
    story.'
  prefs: []
  type: TYPE_NORMAL
- en: The word *vector* can mean a lot of things. It’s the name of a New Wave rock
    band formed in Sacramento, California, in the early 1980s, and the name of a breakfast
    cereal manufactured by Kellogg’s Canada. In the field of epidemiology, a vector
    is an organism that transmits infection from one host to another. In the C++ programming
    language, a vector ( `std::vector` ) is an implementation of a dynamically resizable
    array data structure.
  prefs: []
  type: TYPE_NORMAL
- en: While all these definitions are worth exploring, they’re not the focus here.
    Instead, this chapter dives into the **Euclidean vector** (named for the Greek
    mathematician Euclid), also known as the **geometric vector**. When you see the
    term *vector* in this book, you can assume it refers to a Euclidean vector, defined
    as an entity that has both magnitude and direction.
  prefs: []
  type: TYPE_NORMAL
- en: A vector is typically drawn as an arrow, as in [Figure 1.1](ch01.xhtml#ch1fig1).
    The vector’s direction is indicated by where the arrow is pointing, and its magnitude
    by the length of the arrow.
  prefs: []
  type: TYPE_NORMAL
- en: The vector in [Figure 1.1](ch01.xhtml#ch1fig1) is drawn as an arrow from point
    A to point B. It serves as an instruction for how to travel from A to B.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg74_Image_59.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: A vector represented as an arrow drawn from point A to point B'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Point of Vectors**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before diving into more details about vectors, I’d like to create a p5.js example
    that demonstrates why you should care about vectors in the first place. If you’ve
    watched any beginner p5.js tutorials, read any introductory p5.js textbooks, or
    taken an introduction to creative coding course (and hopefully you’ve done one
    of these things to help prepare you for this book!), you probably, at one point
    or another, learned how to write a bouncing ball sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg75_Image_60.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, there’s a flat, 2D world—a blank canvas—with a circular shape
    (a “ball”) traveling around. This ball has properties like position and speed
    that are represented in the code as variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Variable Names** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Position | `x` and `y` |'
  prefs: []
  type: TYPE_TB
- en: '| Speed | `xspeed` and `yspeed` |'
  prefs: []
  type: TYPE_TB
- en: 'In a more sophisticated sketch, you might have many more variables representing
    other properties of the ball and its environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Variable Names** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration | `xacceleration` and `yacceleration` |'
  prefs: []
  type: TYPE_TB
- en: '| Target position | `xtarget` and `ytarget` |'
  prefs: []
  type: TYPE_TB
- en: '| Wind | `xwind` and `ywind` |'
  prefs: []
  type: TYPE_TB
- en: '| Friction | `xfriction` and `yfriction` |'
  prefs: []
  type: TYPE_TB
- en: 'You might notice that for every concept in this world (wind, position, acceleration,
    and the like), there are two variables. And this is only a 2D world. In a three-dimensional
    (3D) world, you’d need three variables for each property: `x`, `y`, and `z` for
    position; `xspeed`, `yspeed`, and `zspeed` for speed; and so on. Wouldn’t it be
    nice to simplify the code to use fewer variables? Instead of starting the program
    with something like this'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'you’d be able to start it with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Thinking of the ball’s properties as vectors instead of a loose collection of
    separate values will allow you to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Taking this first step toward using vectors won’t let you do anything new or
    magically turn a p5.js sketch into a full-on physics simulation. However, using
    vectors will help organize your code and provide a set of methods for common mathematical
    operations you’ll need over and over and over again while programming motion.
  prefs: []
  type: TYPE_NORMAL
- en: As an introduction to vectors, I’m going to stick to two dimensions for quite
    some time (at least the first several chapters). All these examples can be fairly
    easily extended to three dimensions (and the class I’ll use, `p5.Vector`, allows
    for three dimensions). However, for the purposes of learning the fundamentals,
    the added complexity of the third dimension would be a distraction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vectors in p5.js**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Think of a vector as the difference between two points, or as instructions for
    walking from one point to another. For example, [Figure 1.2](ch01.xhtml#ch1fig2)
    shows some vectors and possible interpretations of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg77_Image_61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Three example vectors drawn as arrows, with accompanying instructions
    for walking in north, south, east, or west directions'
  prefs: []
  type: TYPE_NORMAL
- en: 'These vectors could be thought of in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Vector** | **Instructions** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (–15, 3) | Walk 15 steps west; turn and walk 3 steps north. |'
  prefs: []
  type: TYPE_TB
- en: '| (3, 4) | Walk 3 steps east; turn and walk 4 steps north. |'
  prefs: []
  type: TYPE_TB
- en: '| (2, –1) | Walk 2 steps east; turn and walk 1 step south. |'
  prefs: []
  type: TYPE_TB
- en: You’ve probably already thought this way when programming motion. For every
    frame of animation (a single cycle through a p5.js `draw()` loop), you instruct
    each object to reposition itself to a new spot a certain number of pixels away
    horizontally and a certain number of pixels away vertically. This instruction
    is essentially a vector, as in [Figure 1.3](ch01.xhtml#ch1fig3); it has both magnitude
    (how far away did you travel?) and direction (which way did you go?).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg78_Image_62.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: A vector showing the number of horizontal and vertical steps to
    go from a position to a new position'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vector sets the object’s **velocity**, defined as the rate of change of
    the object’s position with respect to time. In other words, the velocity vector
    determines the object’s new position for every frame of the animation, according
    to this basic algorithm for motion: *the new position is equal to the result of
    applying the velocity to the current position*.'
  prefs: []
  type: TYPE_NORMAL
- en: If velocity is a vector (the difference between two points), what about position?
    Is it a vector too? Technically, you could argue that position is not a vector,
    since it’s not describing how to move from one point to another; it’s describing
    a single point in space. Nevertheless, another way to describe a position is as
    the path taken from the origin—point (0, 0)—to the current point. When you think
    of position in this way, it becomes a vector, just like velocity, as in [Figure
    1.4](ch01.xhtml#ch1fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg78_Image_63.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: A computer graphics window with (0, 0) in the top left, showing
    a position vector and a velocity vector'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 1.4](ch01.xhtml#ch1fig4), the vectors are placed on a computer graphics
    canvas. Unlike in [Figure 1.2](ch01.xhtml#ch1fig2), the origin point (0, 0) isn’t
    at the center; it’s at the top-left corner. And instead of north, south, east,
    and west, there are positive and negative directions along the x- and y-axes (with
    y pointing down in the positive direction).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the underlying data for both position and velocity. In the bouncing
    ball example, I originally had the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Variable Names** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Position | `x`, `y` |'
  prefs: []
  type: TYPE_TB
- en: '| Velocity | `xspeed`, `yspeed` |'
  prefs: []
  type: TYPE_TB
- en: 'Now I’ll treat position and velocity as vectors instead, each represented by
    an object with `x` and `y` attributes. If I were to write a `Vector` class myself,
    I’d start with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this class is designed to store the same data as before—two floating-point
    numbers per vector, an `x` value and a `y` value. At its core, a `Vector` object
    is just a convenient way to store two values (or three, as you’ll see in 3D examples)
    under one name.
  prefs: []
  type: TYPE_NORMAL
- en: As it happens, p5.js already has a built-in `p5.Vector` class, so I don’t need
    to write one myself. And so this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `position` and `velocity` vector objects aren’t created as you
    might expect, by invoking a constructor function. Instead of writing `new p5.Vector(x,
    y)`, I’ve called `createVector(x, y)`. The `createVector()` function is included
    in p5.js as a helper function to take care of details behind the scenes upon creation
    of the vector. Except in special circumstances, you should always create `p5.Vector`
    objects with `createVector()`. I should note that p5.js functions such as `createVector()`
    can’t be executed outside of `setup()` or `draw()`, since the library won’t yet
    be loaded. I’ll demonstrate how to address this in [Example 1.2](ch01.xhtml#ch1ex2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that I have two vector objects ( `position` and `velocity` ), I’m ready
    to implement the vector-based algorithm for motion: **position = position + velocity**.
    In [Example 1.1](ch01.xhtml#ch1ex1), without vectors, the code reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg80_Image_64.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In an ideal world, I would be able to rewrite this as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg80_Image_65.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In JavaScript, however, the addition operator `+` is reserved for primitive
    values (integers, floats, and the like). JavaScript doesn’t know how to add two
    `p5.Vector` objects together any more than it knows how to add two `p5.Font` objects
    or `p5.Image` objects. Fortunately, the `p5.Vector` class includes methods for
    common mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector Addition**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before I continue working with the `p5.Vector` class and the `add()` method,
    let’s examine vector addition by using the notation found in math and physics
    textbooks. Vectors are typically written either in boldface type or with an arrow
    on top. For the purposes of this book, to distinguish a **vector** (with magnitude
    and direction) from a **scalar** (a single value, such as an integer or a floating-point
    number), I’ll use the arrow notation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vector: ![Image](../images/pg80_Image_66.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scalar: *x*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s say I have the two vectors shown in [Figure 1.5](ch01.xhtml#ch1fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg81_Image_67.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Two vectors ![Image](../images/pg81_Image_70.jpg) and ![Image](../images/pg81_Image_71.jpg)
    depicted as triangles'
  prefs: []
  type: TYPE_NORMAL
- en: Each vector has two **components**, an *x* and a *y*. To add the two vectors
    together, add both x-components and y-components to create a new vector, as in
    [Figure 1.6](ch01.xhtml#ch1fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg81_Image_68.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Adding vectors by combining the x- and y-components'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, ![Image](../images/pg81_Image_69.jpg) can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*w[x]* = *u[x]* + *v[x]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*w[y]* = *u[y]* + *v[y]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, replacing ![Image](../images/pg81_Image_72.jpg) and ![Image](../images/pg81_Image_73.jpg)
    with their values from [Figure 1.6](ch01.xhtml#ch1fig6), you get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*w[x]* = 5 + 3 = 8'
  prefs: []
  type: TYPE_NORMAL
- en: '*w[y]* = 2 + 4 = 6'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, write the result as a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg81_Image_74.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image](../images/zoom.jpg) **Addition Properties with Vectors**'
  prefs: []
  type: TYPE_NORMAL
- en: Addition with vectors follows the same algebraic rules as with real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commutative rule: ![Image](../images/pg82_Image_75.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The associative rule: ![Image](../images/pg82_Image_76.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fancy terminology and symbols aside, these rules boil down to quite a simple
    concept: the result is the same no matter the order in which the vectors are added.
    Replace the vectors with regular numbers (scalars), and these rules are easy to
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Commutative: 3 + 2 = 2 + 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Associative: (3 + 2) + 1 = 3 + (2 + 1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that I’ve covered the theory behind adding two vectors together, I can
    turn to adding vector objects in p5.js. Imagine again that I’m creating my own
    `Vector` class. I could give it a function called `add()` that takes another `Vector`
    object as its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg82_Image_77.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The function looks up the x- and y-components of the two vectors and adds them
    separately. This is exactly how the built-in `p5.Vector` class’s `add()` method
    is written too. Knowing how it works, I can now return to the bouncing ball example
    with its **position + velocity** algorithm and implement vector addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg82_Image_78.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you have what you need to rewrite the bouncing ball example with vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg83_Image_79.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this stage, you might feel somewhat disappointed. After all, these changes
    may appear to have made the code more complicated than the original version. While
    this is a perfectly reasonable and valid critique, it’s important to understand
    that the power of programming with vectors hasn’t been fully realized just yet.
    Looking at a bouncing ball and only implementing vector addition is just the first
    step. As I move forward into a more complex world of multiple objects and multiple
    *forces* (which I’ll introduce in [Chapter 2](ch02.xhtml#ch02)) acting on those
    objects, the benefits of vectors will become more apparent.
  prefs: []
  type: TYPE_NORMAL
- en: I should, however, note an important aspect of the transition to programming
    with vectors. Even though I’m using `p5.Vector` objects to encapsulate two values—the
    `x` and `y` of the ball’s position or the `x` and `y` of the ball’s velocity—under
    a single variable name, I’ll still often need to refer to the x-and y-components
    of each vector individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `circle()` function doesn’t allow for a `p5.Vector` object as an argument.
    A circle can be drawn with only two scalar values, an x-coordinate and a y-coordinate.
    And so I must dig into the `p5.Vector` object and pull out the x- and y-components
    by using object-oriented dot syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The same issue arises when testing whether the circle has reached the edge
    of the window. In this case, I need to access the individual components of both
    vectors, `position` and `velocity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It may not always be obvious when to directly access an object’s properties
    versus when to reference the object as a whole or use one of its methods. The
    goal of this chapter (and most of this book) is to help you distinguish between
    these scenarios by providing a variety of examples and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 1.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Take one of the walker examples from [Chapter 0](ch00.xhtml#ch00) and convert
    it to use vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 1.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Find something else you’ve previously made in p5.js using separate `x` and `y`
    variables, and use vectors instead.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 1.3**'
  prefs: []
  type: TYPE_NORMAL
- en: Extend [Example 1.2](ch01.xhtml#ch1ex2) into 3D. Can you get a sphere to bounce
    around a box?
  prefs: []
  type: TYPE_NORMAL
- en: '**More Vector Math**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Addition was really just the first step. Many mathematical operations are commonly
    used with vectors. Here’s a comprehensive table of the operations available as
    methods in the `p5.Vector` class. Remember, these are not stand-alone functions,
    but rather methods associated with the `p5.Vector` class. When you see the word
    *this* in the following table, it refers to the specific vector the method is
    operating on.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Task** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| add()       | Adds a vector to this vector |'
  prefs: []
  type: TYPE_TB
- en: '| sub()       | Subtracts a vector from this vector |'
  prefs: []
  type: TYPE_TB
- en: '| mult()      | Scales this vector with multiplication |'
  prefs: []
  type: TYPE_TB
- en: '| div()       | Scales this vector with division |'
  prefs: []
  type: TYPE_TB
- en: '| mag()       | Returns the magnitude of this vector |'
  prefs: []
  type: TYPE_TB
- en: '| setMag()     | Sets the magnitude of this vector |'
  prefs: []
  type: TYPE_TB
- en: '| normalize()    | Normalizes this vector to a unit length of 1 |'
  prefs: []
  type: TYPE_TB
- en: '| limit()      | Limits the magnitude of this vector |'
  prefs: []
  type: TYPE_TB
- en: '| heading()     | Returns the 2D heading of this vector expressed as an angle
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate()     | Rotates this 2D vector by an angle |'
  prefs: []
  type: TYPE_TB
- en: '| lerp()      | Linear interpolates to another vector |'
  prefs: []
  type: TYPE_TB
- en: '| dist()      | Returns the Euclidean distance between two vectors (considered
    as points) |'
  prefs: []
  type: TYPE_TB
- en: '| angleBetween()  | Finds the angle between two vectors |'
  prefs: []
  type: TYPE_TB
- en: '| dot()       | Returns the dot product of two vectors |'
  prefs: []
  type: TYPE_TB
- en: '| cross()      | Returns the cross product of two vectors (relevant only in
    three dimensions) |'
  prefs: []
  type: TYPE_TB
- en: '| random2D()    | Returns a random 2D vector |'
  prefs: []
  type: TYPE_TB
- en: '| random3D()    | Returns a random 3D vector |'
  prefs: []
  type: TYPE_TB
- en: I’ll go through a few of the key methods now. As the examples get more sophisticated
    in later chapters, I’ll continue to reveal more details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector Subtraction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Having already covered addition, I’ll now turn to subtraction. This one’s not
    so bad; just take the plus sign and replace it with a minus! Before tackling subtraction
    itself, however, consider what it means for a vector ![Image](../images/pg80_Image_66.jpg)
    to become – ![Image](../images/pg80_Image_66.jpg). The negative version of the
    scalar 3 is –3\. A negative vector is similar: the polarity of each of the vector’s
    components is inverted. So if ![Image](../images/pg80_Image_66.jpg) has the components
    (*x*, *y*), then – ![Image](../images/pg80_Image_66.jpg) is (–*x*, –*y*). Visually,
    this results in an arrow of the same length as the original vector pointing in
    the opposite direction, as depicted in [Figure 1.7](ch01.xhtml#ch1fig7).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg86_Image_80.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: The relationship between ![Image](../images/pg81_Image_70.jpg)
    and –![Image](../images/pg81_Image_71.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtraction, then, is the same as addition, only with the second vector in
    the equation treated as a negative version of itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg86_Image_81.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just as vectors are added by placing them “tip to tail”—that is, aligning the
    tip (or endpoint) of one vector with the tail (or start point) of the next—vectors
    are subtracted by reversing the direction of the second vector and placing it
    at the end of the first, as in [Figure 1.8](ch01.xhtml#ch1fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg86_Image_82.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Vector subtraction places one vector at the end of another, but
    pointing in the opposite direction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually solve the subtraction, take the difference of the vectors’ components.
    That is, ![Image](../images/pg86_Image_83.jpg) can be written as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*w[x]* = *u[x]* – *v[x]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*w[y]* = *u[y]* – *v[y]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `p5.Vector`, the code reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates vector subtraction by taking the difference
    between two points (which are treated as vectors): the mouse position and the
    center of the window.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg87_Image_90.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the use of `translate()` to visualize the resulting vector as a line from
    the center `(width / 2, height / 2)` to the mouse. Vector subtraction is its own
    kind of translation, moving the “origin” of a position vector. Here, by subtracting
    the center vector from the mouse vector, I’m effectively moving the starting point
    of the resulting vector to the center of the canvas. Therefore, I also need to
    move the origin by using `translate()`. Without this, the line would be drawn
    from the top-left corner, and the visual connection wouldn’t be as clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector Multiplication and Division**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Moving on to multiplication, you have to think a bit differently. Multiplying
    a vector typically refers to the process of **scaling** a vector. If I want to
    scale a vector to twice its size or one-third of its size, while leaving its direction
    the same, I would say, “Multiply the vector by 2” or “Multiply the vector by 1/3.”
    Unlike with addition and subtraction, I’m multiplying the vector by a scalar (a
    single number), not by another vector. [Figure 1.9](ch01.xhtml#ch1fig9) illustrates
    how to scale a vector by a factor of 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg88_Image_91.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Scaling a vector with multiplication'
  prefs: []
  type: TYPE_NORMAL
- en: 'To scale a vector, multiply each component (*x* and *y*) by a scalar. That
    is, ![Image](../images/pg88_Image_92.jpg) can be written as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*w[x]* = *u[x]* × *n*'
  prefs: []
  type: TYPE_NORMAL
- en: '*w[y]* = *u[y]* × *n*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, say ![Image](../images/pg88_Image_94.jpg) and *n* = 3\. You
    can calculate ![Image](../images/pg88_Image_95.jpg) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*w[x]* = −3 × 3'
  prefs: []
  type: TYPE_NORMAL
- en: '*w[y]* = 7 × 3'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg88_Image_95a.jpg) = (− 9, 21)'
  prefs: []
  type: TYPE_IMG
- en: 'This is exactly how the `mult()` function inside the `p5.Vector` class works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg88_Image_93.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Implementing multiplication in code is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg89_Image_96.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Example 1.4](ch01.xhtml#ch1ex4) illustrates vector multiplication by drawing
    a line between the mouse and the center of the canvas, as in the previous example,
    and then scaling that line by 0.5.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg89_Image_97.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The resulting vector is half its original size. Rather than multiplying the
    vector by 0.5, I could achieve the same effect by dividing the vector by 2, as
    in [Figure 1.10](ch01.xhtml#ch1fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg90_Image_98.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: Scaling a vector with division'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vector division, then, works just like vector multiplication—just replace the
    multiplication sign ( `*` ) with the division sign ( `/` ). Here’s how the `p5.Vector`
    class implements the `div()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s how to use the `div()` function in a sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg90_Image_99.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This takes the vector `u` and divides it by 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/zoom.jpg) **More Number Properties with Vectors**'
  prefs: []
  type: TYPE_NORMAL
- en: As with addition, basic algebraic rules of multiplication apply to vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The associative rule: ![Image](../images/pg90_Image_100.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The distributive rule with two scalars, one vector: ![Image](../images/pg90_Image_101.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The distributive rule with two vectors, one scalar: ![Image](../images/pg90_Image_102.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector Magnitude**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiplication and division, as just described, alter the length of a vector
    without affecting its direction. Perhaps you’re wondering, “Okay, so how do I
    know what the length of a vector is? I know the vector’s components (*x* and *y*),
    but how long (in pixels) is the actual arrow?” Understanding how to calculate
    the length of a vector, also known as its **magnitude**, is incredibly useful
    and important.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg91_Image_103.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: The length, or magnitude, of a vector ![Image](../images/pg81_Image_71.jpg)
    is often written as ![Image](../images/pg91_Image_107.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: Notice in [Figure 1.11](ch01.xhtml#ch1fig11) that the vector, drawn as an arrow
    and two components (*x* and *y*), creates a right triangle. The sides are the
    components, and the hypotenuse is the arrow. We’re lucky to have this right triangle,
    because once upon a time, a Greek mathematician named Pythagoras discovered a
    lovely formula that describes the relationship between the sides and hypotenuse
    of a right triangle. This formula, the **Pythagorean theorem**, is *a*² + *b*²
    = *c*² (see [Figure 1.12](ch01.xhtml#ch1fig12)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg91_Image_104.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: The Pythagorean theorem calculates the length of a vector by using
    its components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with this formula, we can now compute the magnitude of ![Image](../images/pg80_Image_66.jpg)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg91_Image_105.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `p5.Vector` class, the `mag()` function is defined using the same formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The sketch in the next example calculates the magnitude of the vector between
    the mouse and the center of the canvas, and visualizes it as a rectangle drawn
    across the top of the window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg92_Image_109.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the magnitude (length) of a vector is always positive, even if the
    vector’s components are negative.
  prefs: []
  type: TYPE_NORMAL
- en: '**Normalizing Vectors**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calculating the magnitude of a vector is only the beginning. It opens the door
    to many possibilities, the first of which is **normalization** ([Figure 1.13](ch01.xhtml#ch1fig13)).
    This is the process of making something standard or, well . . . normal. In the
    case of vectors, the convention is that a standard vector has a length of 1\.
    To normalize a vector, therefore, is to take a vector of any length and change
    its length to 1, without changing its direction. That normalized vector is then
    called a **unit vector**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg93_Image_110.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: When a vector is normalized, it points in the same direction but
    has been resized to a unit length of 1.'
  prefs: []
  type: TYPE_NORMAL
- en: A unit vector describes a vector’s direction without regard to its length. You’ll
    see this come in especially handy once you start to work with forces in [Chapter
    2](ch02.xhtml#ch02).
  prefs: []
  type: TYPE_NORMAL
- en: 'For any given vector ![Image](../images/pg81_Image_72.jpg), its unit vector
    (written as *û*) is calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg93_Image_111.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In other words, to normalize a vector, divide each component by the vector’s
    magnitude. To see why this works, consider a vector (4, 3), which has a magnitude
    of 5 (see [Figure 1.14](ch01.xhtml#ch1fig14)). Once normalized, the vector will
    have a magnitude of 1\. Thinking of the vector as a right triangle, normalization
    shrinks the hypotenuse by dividing by 5 (since 5/5 = 1). In that process, each
    side shrinks as well, also by a factor of 5\. The side lengths go from 4 and 3
    to 4/5 and 3/5, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg93_Image_112.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: To normalize a vector, its components are divided by its magnitude.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `p5.Vector` class, the normalization method is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there’s one small issue. What if the magnitude of the vector is 0?
    You can’t divide by 0! Some quick error checking, shown next, fixes that right
    up.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This sketch uses normalization to give the vector between the mouse and the
    center of the canvas a fixed length, regardless of the actual magnitude of the
    original vector.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg94_Image_114.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that I’ve multiplied the `mouse` vector by 50 after normalizing it to
    1\. Normalization is often the first step in creating a vector of a specific length,
    even if the desired length is something other than 1\. You’ll see more of this
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All this vector math stuff sounds like something you should know about, but
    why? How will it help you write code? Patience. It’ll take some time before the
    awesomeness of using `p5.Vector` fully comes to light. This is a fairly common
    occurrence when learning a new data structure. For example, when you first learn
    about arrays, it might seem like more work to use an array than to have several
    variables stand for multiple things. That plan quickly breaks down when you need
    100, 1,000, or 10,000 things, however.
  prefs: []
  type: TYPE_NORMAL
- en: The same can be true for vectors. What might seem like more work now will pay
    off later, and quite nicely. And you don’t have to wait too long, as your reward
    will come in the next chapter. For now, however, I’ll focus on *how* vectors work,
    and on how working with them provides a different way to think about motion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Motion with Vectors**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What does it mean to program motion by using vectors? You got a taste of it
    in [Example 1.2](ch01.xhtml#ch1ex2), the bouncing ball. The circle onscreen has
    a position (its location at any given moment) as well as a velocity (instructions
    for how it should move from one moment to the next). Velocity is added to position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the object is drawn at the new position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Together, these steps are Motion 101:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the velocity to the position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the object at the position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the bouncing ball example, all this code happened within `setup()` and `draw()`.
    What I want to do now is move toward encapsulating all the logic for an object’s
    motion inside a **class**. This way, I can create a foundation for programming
    moving objects that I can easily reuse again and again. (See “The Random Walker
    Class” on [page 3](ch00.xhtml#ch00lev1sec11) for a brief review of OOP basics.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, I’m going to create a generic `Mover` class that will describe a
    shape moving around the canvas. For that, I must consider the following two questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What data does a mover have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What functionality does a mover have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Motion 101 algorithm answers both of these questions. First, a `Mover`
    object has two pieces of data, `position` and `velocity`, which are both `p5.Vector`
    objects. These are initialized in the object’s constructor. In this case, I’ll
    arbitrarily decide to initialize the `Mover` object by giving it a random position
    and velocity. Note the use of `this` with all variables that are part of the `Mover`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg96_Image_115a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The functionality follows suit. The `Mover` object needs to move (by applying
    its velocity to its position) and needs to be visible. I’ll implement these needs
    as functions named `update()` and `show()`. I’ll put all the motion logic code
    in `update()` and draw the object in `show()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg96_Image_115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Mover` class also needs a function that determines what the object should
    do when it reaches the edge of the canvas. For now, I’ll do something simple and
    have it wrap around the edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg96_Image_116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the `Mover` class is finished, but the class itself isn’t an object; it’s
    a template for creating an instance of an object. To actually create a `Mover`
    object, I first need to declare a variable to hold it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the `setup()` function, I create the object by invoking the class
    name along with the `new` keyword. This triggers the class’s constructor to make
    an instance of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all that remains is to call the appropriate methods in `draw()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the entire example for reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg97_Image_118.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If OOP is at all new to you, one aspect here may seem a bit strange. I spent
    the beginning of this chapter discussing the `p5.Vector` class, and this class
    is the template for making the `position` object and the `velocity` object. So
    what are those objects doing inside yet another object, the `Mover` object?
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this is just about the most normal thing ever. An object is something
    that holds data (and functionality). That data can be numbers, or it can be other
    objects (arrays too)! You’ll see this over and over again in this book. In [Chapter
    4](ch04.xhtml#ch04), for example, I’ll write a class to describe a system of particles.
    That `ParticleSystem` object will include a list of `Particle` objects . . . and
    each `Particle` object will have as its data several `p5.Vector` objects!
  prefs: []
  type: TYPE_NORMAL
- en: You may have also noticed in the `Mover` class that I’m setting the initial
    position and velocity directly within the constructor, without using any arguments.
    While this approach keeps the code simple for now, I’ll explore the benefits of
    adding arguments to the constructor in [Chapter 2](ch02.xhtml#ch02).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you hopefully feel comfortable with two concepts: (1) what a
    vector is and (2) how to use vectors inside an object to keep track of its position
    and movement. This is an excellent first step and deserves a mild round of applause.
    Before standing ovations are in order, however, you need to make one more, somewhat
    bigger step forward. After all, watching the Motion 101 example is fairly boring.
    The circle never speeds up, never slows down, and never turns. For more sophisticated
    motion—the kind of motion that appears in the world around us—one more vector
    needs to be added to the class: `acceleration`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Acceleration**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Acceleration** is the rate of change of velocity. Think about that definition
    for a moment. Is it a new concept? Not really. Earlier I defined velocity as the
    rate of change of position, so in essence I’m developing a trickle-down effect.
    Acceleration affects velocity, which in turn affects position. (To provide some
    brief foreshadowing, this point will become even more crucial in the next chapter,
    when I show how forces like friction affect acceleration, which affects velocity,
    which affects position.) In code, this trickle-down effect reads like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As an exercise, from this point forward, I’m going to make a rule for myself:
    I’ll try to write every example in the rest of this book without ever touching
    the values of velocity and position (except to initialize them). In other words,
    the goal for programming motion is to come up with an algorithm for calculating
    acceleration and then let the trickle-down effect work its magic. (In truth, there
    will be a multitude of reasons to break this rule, and break it I shall. Nevertheless,
    it’s a useful constraint to begin with to illustrate the principles behind the
    motion algorithm with acceleration.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step, then, is to come up with a way to calculate acceleration. Here
    are a few possible algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: A constant acceleration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A random acceleration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An acceleration toward the mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll use the rest of this chapter to show you how to implement these algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm 1: Constant Acceleration**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Acceleration Algorithm 1, a constant acceleration, isn’t particularly interesting,
    but it’s the simplest and thus an excellent starting point to incorporate acceleration
    into the code. The first step is to add another variable to the `Mover` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg100_Image_120.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, incorporate acceleration into the `update()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg100_Image_121.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I’m almost finished. The only missing piece is to get that mover moving! In
    the constructor, the initial velocity is set to 0, rather than a random vector
    as previously done. Therefore, when the sketch starts, the object is at rest.
    To get it moving instead of changing the velocity directly, I’ll update it through
    the object’s acceleration. According to Algorithm 1, the acceleration should be
    constant, so I’ll choose a value now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This means that for every frame of the animation, the object’s velocity should
    increase by –0.001 pixels in the x-direction and 0.01 pixels in the y-direction.
    Maybe you’re thinking, “Gosh, those values seem awfully small!” Indeed, they are
    quite tiny, but that’s by design. Acceleration values accumulate over time in
    the velocity, about 30 times per second, depending on the sketch’s frame rate.
    To keep the magnitude of the velocity vector from growing too quickly and spiraling
    out of control, the acceleration values should remain quite small.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can also help keep the velocity within a reasonable range by incorporating
    the `p5.Vector` function `limit()`, which puts a cap on the magnitude of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_122.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is the magnitude of velocity? If it’s less than 10, no worries; just
    leave it as is. If it’s more than 10, however, reduce it to 10!*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 1.4**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the `limit()` function for the `p5.Vector` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at the changes to the `Mover` class, complete with `acceleration`
    and `limit()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_123.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The net result is that the object falls down and to the left, gradually moving
    faster and faster until it reaches the maximum velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 1.5**'
  prefs: []
  type: TYPE_NORMAL
- en: Create a simulation of an object (think about a vehicle) that accelerates when
    you press the up arrow and brakes when you press the down arrow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm 2: Random Acceleration**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now on to Acceleration Algorithm 2, a random acceleration. In this case, instead
    of initializing `acceleration` in the object’s constructor, I want to randomly
    set its value inside the `update()` method. This way, the object will get a different
    acceleration vector for every frame of the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg102_Image_125.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `random2D()` method produces a normalized vector, meaning it has a random
    direction, but its magnitude is always 1\. To make things interesting, I can try
    scaling the random vector by a constant value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg103_Image_126.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Or, for even greater variety, I can scale the acceleration to a random value.
    In [Example 1.9](ch01.xhtml#ch1ex9), the `acceleration` vector has both a random
    direction and a random magnitude from 0 to 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg103_Image_127.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s crucial to understand that acceleration doesn’t merely refer to *speeding
    up* or *slowing down.* Rather, as this example has shown, it refers to *any change*
    in velocity—magnitude or direction. Acceleration is used to steer an object, and
    you’ll see this again and again in future chapters as I begin to code objects
    that make decisions about how to move.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also notice that this example is another kind of random walker. A
    key distinction between what I’m doing here and the previous chapter’s examples,
    however, lies in *what* is being randomized. With the traditional random walker,
    I was directly manipulating the velocity, meaning each step was completely independent
    of the last. In [Example 1.9](ch01.xhtml#ch1ex9), the acceleration (the rate of
    change of velocity) is being randomized, not the velocity itself. This makes the
    object’s motion dependent on its previous state: the velocity changes incrementally
    according to the random acceleration. The resulting movement of the object has
    a kind of continuity and fluidity that the original random walker lacked. The
    difference may seem subtle, but it fundamentally changes the way the object moves
    about the canvas.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 1.6**'
  prefs: []
  type: TYPE_NORMAL
- en: Referring back to [Exercise 0.6](ch00.xhtml#ch0exe6), implement an acceleration
    calculated with Perlin noise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Static vs. Nonstatic Methods**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might have noticed something a bit odd and unfamiliar in the previous example.
    The `random2D()` method used to create a random unit vector was called on the
    class name, as in `p5.Vector.random2D()`, rather than on the current instance
    of the class, as in `this.random2D()`. This is because `random2D()` is a **static
    method**, meaning it’s associated with the class as a whole rather than the individual
    objects (that is, the instances of that class).
  prefs: []
  type: TYPE_NORMAL
- en: Static methods are rarely needed when you’re writing your own classes (like
    `Walker` or `Mover`), so you may not have encountered them before. They sometimes
    form an important part of prewritten classes like `p5.Vector`, however. In fact,
    Acceleration Algorithm 3 (accelerate toward the mouse) requires further use of
    this concept, so let’s take a step back and consider the difference between static
    and nonstatic methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting aside vectors for a second, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is probably what you’re used to, yes? I give `x` a value of 0, add `y`
    to it, and now `x` is equal to 5\. I could write similar code for adding two vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The vector `v` has the value of (0, 0), I add the vector `u` to it, and now
    `v` is equal to (4, 5). Makes sense, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'I give `x` a value of 0, add `y` to it, and store the result in a new variable
    `z`. The value of `x` doesn’t change here (neither does `y`)! This may seem like
    a trivial point, and one that’s quite intuitive when it comes to mathematical
    operations with simple numbers. However, it’s not so obvious with mathematical
    operations using `p5.Vector` objects. Let’s try to rewrite the example with vectors,
    based on what I’ve covered of the `p5.Vector` class so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_128.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This might seem like a good guess, but it’s just not the way the `p5.Vector`
    class works. If you look at the definition of `add()`, you can see why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code has two problems. First, the `add()` method doesn’t return a new `p5.Vector`
    object, and second, `add()` changes the value of the vector upon which it’s called.
    To add two vector objects together and return the result as a new vector, I must
    use the static version of the `add()` method by calling it on the class name,
    rather than calling the nonstatic version on a specific object instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how I might write the static version of `add()` if I were declaring
    the class myself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_129.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The key difference here is that the method returns a new vector ( `v3` ) created
    using the sum of the components of `v1` and `v2`. As a result, the method doesn’t
    make changes to either original vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling a static method, instead of referencing an object instance, you
    reference the name of the class. Here’s the right way to implement the vector
    addition example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `p5.Vector` class has static versions of `add()`, `sub()`, `mult()`, and
    `div()`. These static methods allow you to perform generic mathematical operations
    on vectors without changing the value of one of the input vectors in the process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 1.7**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Translate the following pseudocode to code, using static or nonstatic functions
    where appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: The vector `v` equals (1, 5).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vector `u` equals `v` multiplied by 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vector `w` equals `v` minus `u`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Divide the vector `w` by 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Algorithm 3: Interactive Motion**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To finish out this chapter, let’s try something a bit more complex and a great
    deal more useful. I’ll dynamically calculate an object’s acceleration according
    to the rule stated in Acceleration Algorithm 3: the object accelerates toward
    the mouse.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anytime you want to calculate a vector based on a rule or formula, you need
    to compute two attributes: magnitude and direction. I’ll start with direction.
    I know the acceleration vector should point from the object’s position toward
    the mouse position ([Figure 1.15](ch01.xhtml#ch1fig15)). Let’s say the object
    is located at the position vector (*x*, *y*), and the mouse is at (*mouseX*, *mouseY*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_130.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.15: A vector from an object to the mouse position'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 1.16](ch01.xhtml#ch1fig16), you see that the acceleration vector
    (*dx*, *dy*) can be calculated by subtracting the object’s position from the mouse’s
    position:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dx = mouseX - x*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*dy = mouseY - y*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg107_Image_131.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.16: Calculating an initial acceleration vector by taking the difference
    of the mouse and position vectors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement that by using `p5.Vector` syntax. Assuming the code will live
    inside the `Mover` class and thus have access to the object’s `position`, I can
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg107_Image_132.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I’ve used the static version of `sub()` to create a new vector `direction` that
    points from the mover’s position to the mouse. If the object were to actually
    accelerate using that vector, however, it would appear instantaneously at the
    mouse position, since the magnitude of `direction` is equal to the distance between
    the object and the mouse. This wouldn’t make for a smooth animation, of course.
    The next step, therefore, is to decide how quickly the object should accelerate
    toward the mouse by changing the vector’s magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the magnitude (whatever it may be) of the acceleration vector, I must
    first ______ the vector. That’s right, you said it: *normalize*! If I can shrink
    the vector to its unit vector (of length 1), I can easily scale it to any other
    value, because 1 multiplied by anything equals anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg107_Image_133.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To summarize, follow these steps to make the object accelerate toward the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate a vector that points from the object to the target position (mouse).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normalize that vector (reducing its length to 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale that vector to an appropriate value (by multiplying it by a value).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign that vector to acceleration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I have a confession to make. Normalization and then scaling is such a common
    vector operation that `p5.Vector` includes a function that does both, setting
    the magnitude of a vector to a given value with a single function call. That function
    is `setMag()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this next example, to emphasize the math, I’m going to write the code using
    `normalize()` and `mult()`, but this is likely the last time I’ll do that. You’ll
    find `setMag()` in examples going forward.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg108_Image_134.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You may be wondering why the circle doesn’t stop when it reaches the target.
    It’s important to note that the moving object has no knowledge about trying to
    stop at a destination; it knows only the destination’s position. The object tries
    to accelerate there at a fixed rate, regardless of how far away it is. This means
    it will inevitably overshoot the target and have to turn around, again accelerating
    toward the destination, overshooting it again, and so forth. Stay tuned; in later
    chapters, I’ll show you how to program an object to **arrive** at a target (slow
    down on approach).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 1.8**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1.10](ch01.xhtml#ch1ex10) is remarkably close to the concept of gravitational
    attraction, with the object being attracted to the mouse position. In the example,
    however, the attraction magnitude is constant, whereas with a real-life gravitational
    force, the magnitude is inversely proportional to distance: the closer the object
    is to the attraction point, the faster it accelerates. I’ll cover gravitational
    attraction in more detail in the next chapter, but for now, try implementing your
    own version of [Example 1.10](ch01.xhtml#ch1ex10) with a variable magnitude of
    acceleration, stronger when it’s either closer or farther away.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  prefs: []
  type: TYPE_NORMAL
- en: Incorporate vectors to further develop and refine the motion of the elements
    within your ecosystem. Explore how motion can be directed by solely manipulating
    an object’s acceleration vector.
  prefs: []
  type: TYPE_NORMAL
- en: How might you calculate acceleration to emulate certain behaviors—the erratic
    buzzing of a nervous fly, the gentle hops of a bunny, or the slithering of a snake?
    What role does acceleration play in nature? Consider the way a bird accelerates
    when taking off or how a fish suddenly changes direction when swimming. Again,
    how much of a creature’s personality can be shaped by its behavior alone? What
    is added (or taken away) by incorporating more visual design elements beyond simple
    shapes?
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg109_Image_135.jpg)'
  prefs: []
  type: TYPE_IMG
