<html><head></head><body><div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="157" id="Page_157"/>10</span><br/>&#13;
<span class="ChapterTitle">Inspecting and Modifying Data</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img src="Images/chapterart.png" alt="" width="200" height="200"/>&#13;
</figure>&#13;
<p class="ChapterIntro">If I were to propose a toast to a newly minted class of data analysts, I’d raise my glass and say, “May your data arrive perfectly structured and free of errors!” In reality, you’ll sometimes receive data in such a sorry state that it’s hard to analyze without modifying it. This is called <em>dirty data</em>, a general label for data with errors, missing values, or poor organization that makes standard queries ineffective. In this chapter, you’ll use SQL to clean a set of dirty data and perform other useful maintenance tasks to make data workable.</p>&#13;
<p>Dirty data can have multiple origins. Converting data from one file type to another or giving a column the wrong data type can cause information to be lost. People also can be careless when inputting or editing data, leaving behind typos and spelling inconsistencies. Whatever the cause may be, dirty data is the bane of the data analyst.</p>&#13;
<p><span epub:type="pagebreak" title="158" id="Page_158"/>You’ll learn how to examine data to assess its quality and how to modify data and tables to make analysis easier. But the techniques you’ll learn will be useful for more than just cleaning data. The ability to make changes to data and tables gives you options for updating or adding new information to your database as it becomes available, elevating your database from a static collection to a living record.</p>&#13;
<p>Let’s begin by importing our data.</p>&#13;
<h2 id="h1-501065c10-0001">Importing Data on Meat, Poultry, and Egg Producers</h2>&#13;
<p class="BodyFirst">For this example, we’ll use a directory of US meat, poultry, and egg producers. The Food Safety and Inspection Service (FSIS), an agency within the US Department of Agriculture, compiles and updates this database regularly. The FSIS is responsible for inspecting animals and food at more than 6,000 meat processing plants, slaughterhouses, farms, and the like. If inspectors find a problem, such as bacterial contamination or mislabeled food, the agency can issue a recall. Anyone interested in agriculture business, food supply chain, or outbreaks of foodborne illnesses will find the directory useful. Read more about the agency on its site at <a href="https://www.fsis.usda.gov/" class="LinkURL">https://www.fsis.usda.gov/</a>.</p>&#13;
<p>The data we’ll use comes from <a href="https://www.data.gov/" class="LinkURL">https://www.data.gov/</a>, a website run by the US federal government that catalogs thousands of datasets from various federal agencies (<a href="https://catalog.data.gov/dataset/fsis-meat-poultry-and-egg-inspection-directory-by-establishment-name/" class="LinkURL">https://catalog.data.gov/dataset/fsis-meat-poultry-and-egg-inspection-directory-by-establishment-name/</a>). I’ve converted the Excel file posted on the site to CSV format, and you’ll find a link to the file <em>MPI_Directory_by_Establishment_Name.csv</em> along with other resources for this book at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Because FSIS updates the data regularly, you will see different results than those shown in this chapter if you download directly from <a href="https://www.data.gov/" class="LinkURL">https://www.data.gov/</a>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>To import the file into PostgreSQL, use the code in <a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a> to create a table called <code>meat_poultry_egg_establishments</code> and use <code>COPY</code> to add the CSV file to the table. As in previous examples, use pgAdmin to connect to your <code>analysis</code> database, and then open the Query Tool to run the code. Remember to change the path in the <code>COPY</code> statement to reflect the location of your CSV file.</p>&#13;
<pre><code>CREATE TABLE meat_poultry_egg_establishments (&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> establishment_number text CONSTRAINT est_number_key PRIMARY KEY,&#13;
    company text,&#13;
    street text,&#13;
    city text,&#13;
    st text,&#13;
    zip text,&#13;
    phone text,&#13;
    grant_date date,&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> activities text,&#13;
    dbas text&#13;
);&#13;
&#13;
<span epub:type="pagebreak" title="159" id="Page_159"/><span class="CodeAnnotationHang" aria-label="annotation3">3</span> COPY meat_poultry_egg_establishments&#13;
FROM '<var>C:\YourDirectory\</var>MPI_Directory_by_Establishment_Name.csv'&#13;
WITH (FORMAT CSV, HEADER);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> CREATE INDEX company_idx ON meat_poultry_egg_establishments (company);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-1">Listing 10-1</a>: Importing the FSIS Meat, Poultry, and Egg Inspection Directory</p>&#13;
<p>The table has 10 columns. We add a natural primary key constraint to the <code>establishment_number</code> column <span class="CodeAnnotation" aria-label="annotation1">1</span>, which will hold unique values that identify each establishment. Most of the remaining columns relate to the company’s name and location. You’ll use the <code>activities</code> column <span class="CodeAnnotation" aria-label="annotation2">2</span>, which describes activities at the company, in the “Try It Yourself” exercise at the end of this chapter. We set most columns to <code>text</code>. In PostgreSQL, <code>text</code> is a varying length data type that affords us up to 1GB of data (see <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>). The column <code>dbas</code> contains strings of more than 1,000 characters in its rows, so we’re prepared to handle that. We import the CSV file <span class="CodeAnnotation" aria-label="annotation3">3</span> and then create an index on the <code>company</code> column <span class="CodeAnnotation" aria-label="annotation4">4</span> to speed up searches for particular companies.</p>&#13;
<p>For practice, let’s use the <code>count()</code> aggregate function introduced in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> to check how many rows are in the <code>meat_poultry_egg_establishments</code> table:</p>&#13;
<pre><code>SELECT count(*) FROM meat_poultry_egg_establishments;</code></pre>&#13;
<p>The result should show 6,287 rows. Now let’s find out what the data contains and determine whether we can glean useful information from it as is, or if we need to modify it in some way.</p>&#13;
<h2 id="h1-501065c10-0002">Interviewing the Dataset</h2>&#13;
<p class="BodyFirst">Interviewing data is my favorite part of analysis. We interview a dataset to discover its details—what it holds, what questions it can answer, and how suitable it is for our purposes—the same way a job interview reveals whether a candidate has the skills required.</p>&#13;
<p>The aggregate queries from <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> are a useful interviewing tool because they often expose the limitations of a dataset or raise questions you may want to ask before drawing conclusions and assuming the validity of your findings.</p>&#13;
<p>For example, the <code>meat_poultry_egg_establishments</code> table’s rows describe food producers. At first glance, we might assume that each company in each row operates at a distinct address. But it’s never safe to assume in data analysis, so let’s check using the code in <a href="#listing10-2" id="listinganchor10-2">Listing 10-2</a>.</p>&#13;
<pre><code>SELECT company,&#13;
       street,&#13;
       city,&#13;
       st,&#13;
       count(*) AS address_count&#13;
FROM meat_poultry_egg_establishments&#13;
<span epub:type="pagebreak" title="160" id="Page_160"/>GROUP BY company, street, city, st&#13;
HAVING count(*) &gt; 1&#13;
ORDER BY company, street, city, st;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-2">Listing 10-2</a>: Finding multiple companies at the same address</p>&#13;
<p>Here, we group companies by unique combinations of the <code>company</code>, <code>street</code>, <code>city</code>, and <code>st</code> columns. Then we use <code>count(*)</code>, which returns the number of rows for each combination of those columns and gives it the alias <code>address_count</code>. Using the <code>HAVING</code> clause introduced in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, we filter the results to show only cases where more than one row has the same combination of values. This should return all duplicate addresses for a company.</p>&#13;
<p>The query returns 23 rows, which means there are close to two dozen cases where the same company is listed multiple times at the same address:</p>&#13;
<pre><code>company                    street                     city          st    address_count&#13;
-----------------------    -----------------------    ----------    --    -------------&#13;
Acre Station Meat Farm     17076 Hwy 32 N             Pinetown      NC                2&#13;
Beltex Corporation         3801 North Grove Street    Fort Worth    TX                2&#13;
Cloverleaf Cold Storage    111 Imperial Drive         Sanford       NC                2&#13;
<var>--snip--</var></code></pre>&#13;
<p>This is not necessarily a problem. There may be valid reasons for a company to appear multiple times at the same address. For example, two types of processing plants could exist with the same name. On the other hand, we may have found data entry errors. Either way, it’s a wise practice to eliminate concerns about the validity of a dataset before relying on it, and this result should prompt us to investigate individual cases before we draw conclusions. However, this dataset has other issues that we need to look at before we can get meaningful information from it. Let’s work through a few examples.</p>&#13;
<h3 id="h2-501065c10-0001">Checking for Missing Values</h3>&#13;
<p class="BodyFirst">Next, we’ll check whether we have values from all states and whether any rows are missing a state code by asking a basic question: How many meat, poultry, and egg processing companies are there in each state? We’ll use the aggregate function <code>count()</code> along with <code>GROUP BY</code> to determine this, as shown in <a href="#listing10-3" id="listinganchor10-3">Listing 10-3</a>.</p>&#13;
<pre><code>SELECT st,&#13;
       count(*) AS st_count&#13;
FROM meat_poultry_egg_establishments&#13;
GROUP BY st&#13;
ORDER BY st;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-3">Listing 10-3</a>: Grouping and counting states</p>&#13;
<p>The query is a simple count that tallies the number of times each state postal code (<code>st</code>) appears in the table. Your result should include 57 rows, grouped by the state postal code in the column <code>st</code>. Why more than the 50 US states? Because the data includes Puerto Rico and other unincorporated <span epub:type="pagebreak" title="161" id="Page_161"/>US territories, such as Guam and American Samoa. Alaska (<code>AK</code>) is at the top of the results with a count of <code>17</code> establishments:</p>&#13;
<pre><code>st    st_count&#13;
--    --------&#13;
AK          17&#13;
AL          93&#13;
AR          87&#13;
AS           1&#13;
<var>--snip--</var>&#13;
WA         139&#13;
WI         184&#13;
WV          23&#13;
WY           1&#13;
             3</code></pre>&#13;
<p>However, the row at the bottom of the list has a <code>NULL</code> value in the <code>st</code> column and a <code>3</code> in <code>st_count</code>. That means three rows have a <code>NULL</code> in <code>st</code>. To see the details of those facilities, let’s query those rows.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Depending on the database implementation, <code>NULL</code> values will appear either first or last in a sorted column. In PostgreSQL, they appear last by default. The ANSI SQL standard doesn’t specify one or the other, but it lets you add <code>NULLS FIRST</code> or <code>NULLS LAST</code> to an <code>ORDER BY</code> clause to specify a preference. For example, to make <code>NULL</code> values appear first in the preceding query, the clause would read <code>ORDER BY st NULLS FIRST</code>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>In <a href="#listing10-4" id="listinganchor10-4">Listing 10-4</a>, we add a <code>WHERE</code> clause with the <code>st</code> column and the <code>IS NULL</code> keywords to find which rows are missing a state code.</p>&#13;
<pre><code>SELECT establishment_number,&#13;
       company,&#13;
       city,&#13;
       st,&#13;
       zip&#13;
FROM meat_poultry_egg_establishments&#13;
WHERE st IS NULL;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-4">Listing 10-4</a>: Using <code>IS NULL</code> to find missing values in the <code>st</code> column</p>&#13;
<p>This query returns three rows that don’t have a value in the <code>st</code> column:</p>&#13;
<pre><code>est_number           company                            city      st    zip&#13;
-----------------    -------------------------------    ------    --    -----&#13;
V18677A              Atlas Inspection, Inc.             Blaine          55449&#13;
M45319+P45319        Hall-Namie Packing Company, Inc                    36671&#13;
M263A+P263A+V263A    Jones Dairy Farm                                   53538</code></pre>&#13;
<p>That’s a problem, because any counts that include the <code>st</code> column will be incorrect, such as the number of establishments per state. When you spot an error such as this, it’s worth making a quick visual check of the original file you downloaded. Unless you’re working with files in the gigabyte range, you can usually open a CSV file in one of the text editors I noted in <span class="xref" itemid="xref_target_Chapter 1"><span epub:type="pagebreak" title="162" id="Page_162"/>Chapter 1</span> and search for the row. If you’re working with larger files, you might be able to examine the source data using utilities such as <code>grep</code> (on Linux and macOS) or <code>findstr</code> (on Windows). In this case, a visual check of the file from <a href="https://www.data.gov/" class="LinkURL">https://www.data.gov/</a> confirms that, indeed, there was no state listed in those rows in the file, so the error is organic to the data, not one introduced during import.</p>&#13;
<p>In our interview of the data so far, we’ve discovered that we’ll need to add missing values to the <code>st</code> column to clean up this table. Let’s look at what other issues exist in our dataset and make a list of cleanup tasks.</p>&#13;
<h3 id="h2-501065c10-0002">Checking for Inconsistent Data Values</h3>&#13;
<p class="BodyFirst">Inconsistent data is another factor that can hamper our analysis. We can check for inconsistently entered data within a column by using <code>GROUP BY</code> with <code>count()</code>. When you scan the unduplicated values in the results, you might be able to spot variations in the spelling of names or other attributes.</p>&#13;
<p>For example, many of the 6,200 companies in our table are multiple locations owned by just a few multinational food corporations, such as Cargill or Tyson Foods. To find out how many locations each company owns, we count the values in the <code>company</code> column. Let’s see what happens when we do, using the query in <a href="#listing10-5" id="listinganchor10-5">Listing 10-5</a>.</p>&#13;
<pre><code>SELECT company,&#13;
       count(*) AS company_count&#13;
FROM meat_poultry_egg_establishments&#13;
GROUP BY company&#13;
ORDER BY company ASC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-5">Listing 10-5</a>: Using <code>GROUP BY</code> and <code>count()</code> to find inconsistent company names</p>&#13;
<p>Scrolling through the results reveals a number of cases in which a company’s name is spelled in several different ways. For example, notice the entries for the Armour-Eckrich brand:</p>&#13;
<pre><code>company                        company_count&#13;
---------------------------    -------------&#13;
<var>--snip--</var>&#13;
Armour - Eckrich Meats, LLC                1&#13;
Armour-Eckrich Meats LLC                   3&#13;
Armour-Eckrich Meats, Inc.                 1&#13;
Armour-Eckrich Meats, LLC                  2&#13;
<var>--snip--</var></code></pre>&#13;
<p>At least four different spellings are shown for seven establishments that are likely owned by the same company. If we later perform any aggregation by company, it would help to standardize the names so all the items counted or summed are grouped properly. Let’s add that to our list of items to fix.</p>&#13;
<h3 id="h2-501065c10-0003">Checking for Malformed Values Using length()</h3>&#13;
<p class="BodyFirst">It’s a good idea to check for unexpected values in a column that should be consistently formatted. For example, each entry in the <code>zip</code> column in the <code/><span epub:type="pagebreak" title="163" id="Page_163"/>meat_poultry_egg_establishments table should be formatted in the style of US ZIP codes with five digits. However, that’s not what is in our dataset.</p>&#13;
<p>Solely for the purpose of this example, I replicated a common error I’ve committed before. When I converted the original Excel file to a CSV file, I stored the ZIP code in the default “General” number format instead of as a text value, and any ZIP code that begins with a zero lost its leading zero because an integer can’t start with a zero. As a result, 07502 appears in the table as <code>7502</code>. You can make this error in a variety of ways, including by copying and pasting data into Excel columns set to “General.” After being burned a few times, I learned to take extra caution with numbers that should be formatted as text.</p>&#13;
<p>My deliberate error appears when we run the code in <a href="#listing10-6" id="listinganchor10-6">Listing 10-6</a>. The example introduces <code>length()</code>, a <em>string function</em> that counts the number of characters in a string. We combine <code>length()</code> with <code>count()</code> and <code>GROUP BY</code> to determine how many rows have five characters in the <code>zip</code> field and how many have a value other than five. To make it easy to scan the results, we use <code>length()</code> in the <code>ORDER BY</code> clause.</p>&#13;
<pre><code>SELECT length(zip),&#13;
       count(*) AS length_count&#13;
FROM meat_poultry_egg_establishments&#13;
GROUP BY length(zip)&#13;
ORDER BY length(zip) ASC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-6">Listing 10-6</a>: Using <code>length()</code> and <code>count()</code> to test the <code>zip</code> column</p>&#13;
<p>The results confirm the formatting error. As you can see, <code>496</code> of the ZIP codes are four characters long, and <code>86</code> are three characters long, which likely means these numbers originally had two leading zeros that my conversion erroneously eliminated:</p>&#13;
<pre><code>length    length_count&#13;
------    ------------&#13;
     3              86&#13;
     4             496&#13;
     5            5705</code></pre>&#13;
<p>Using the <code>WHERE</code> clause, we can see which states these shortened ZIP codes correspond to, as shown in <a href="#listing10-7" id="listinganchor10-7">Listing 10-7</a>.</p>&#13;
<pre><code>SELECT st,&#13;
       count(*) AS st_count&#13;
FROM meat_poultry_egg_establishments&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> WHERE length(zip) &lt; 5&#13;
GROUP BY st&#13;
ORDER BY st ASC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-7">Listing 10-7</a>: Filtering with <code>length()</code> to find short <code>zip</code> values</p>&#13;
<p>We use the <code>length()</code> function inside the <code>WHERE</code> clause <span class="CodeAnnotation" aria-label="annotation1">1</span> to return a count of rows where the ZIP code is less than five characters for each state code. <span epub:type="pagebreak" title="164" id="Page_164"/>The result is what we would expect. The states are largely in the Northeast region of the United States where ZIP codes often start with a zero:</p>&#13;
<pre><code>st    st_count&#13;
--    --------&#13;
CT          55&#13;
MA         101&#13;
ME          24&#13;
NH          18&#13;
NJ         244&#13;
PR          84&#13;
RI          27&#13;
VI           2&#13;
VT          27</code></pre>&#13;
<p>Obviously, we don’t want this error to persist, so we’ll add it to our list of items to correct. So far, we need to correct the following issues in our dataset:</p>&#13;
<ul>&#13;
<li>Missing values for three rows in the <code>st</code> column</li>&#13;
<li>Inconsistent spelling of at least one company’s name</li>&#13;
<li>Inaccurate ZIP codes due to file conversion</li>&#13;
</ul>&#13;
<p>Next, we’ll look at how to use SQL to fix these issues by modifying your data.</p>&#13;
<h2 id="h1-501065c10-0003">Modifying Tables, Columns, and Data</h2>&#13;
<p class="BodyFirst">Almost nothing in a database, from tables to columns and the data types and values they contain, is set in concrete after it’s created. As your needs change, you can use SQL to add columns to a table, change data types on existing columns, and edit values. Given the issues we discovered in the <code>meat_poultry_egg_establishments</code> table, being able to modify our database will come in handy.</p>&#13;
<p>We’ll use two SQL commands. The first, <code>ALTER TABLE</code>, is part of the ANSI SQL standard and provides options to <code>ADD COLUMN</code>, <code>ALTER COLUMN</code>, and <code>DROP COLUMN</code>, among others.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p> 	Typically, PostgreSQL and other databases include implementation-specific extensions to <code>ALTER</code> <code>TABLE</code> that provide an array of options for managing database objects (see <a href="https://www.postgresql.org/docs/current/sql-altertable.html" class="LinkURL">https://www.postgresql.org/docs/current/sql-altertable.html</a>). For our exercises, we’ll stick with the core options.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>The second command, <code>UPDATE</code>, also included in the SQL standard, allows you to change values in a table’s columns. You can supply criteria using <code>WHERE</code> to choose which rows to update.</p>&#13;
<p>Let’s explore the basic syntax and options for both commands and then use them to fix the issues in our dataset.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="165" id="Page_165"/>When to Toss Your Data</h2>&#13;
<p class="BoxBodyFirst">If your interview of the data reveals too many missing values or values that defy common sense—such as numbers ranging in the billions when you expected thousands—it’s time to reevaluate your use of it. The data may not be reliable enough to serve as the foundation of your analysis.</p>&#13;
<p>If you suspect as much, the first step is to revisit the original data file. Make sure you imported it correctly and that values in all the source columns are located in the same columns in the table. You might need to open the original spreadsheet or CSV file and do a visual comparison. The second step is to call the agency or company that produced the data to confirm what you see and seek an explanation. You might also ask for advice from others who have used the same data.</p>&#13;
<p>More than once I’ve had to toss a dataset after determining that it was poorly assembled or simply incomplete. Sometimes, the amount of work required to make a dataset usable undermines its usefulness. These situations require you to make a tough judgment call. But it’s better to start over or find an alternative than to use bad data that can lead to faulty conclusions.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h3 id="h2-501065c10-0004">Modifying Tables with ALTER TABLE</h3>&#13;
<p class="BodyFirst">We can use the <code>ALTER TABLE</code> statement to modify the structure of tables. The following examples show standard ANSI SQL syntax for common operations, starting with the code for adding a column to a table: </p>&#13;
<pre><code>ALTER TABLE <var>table</var> ADD COLUMN <var>column</var> <var>data_type</var>;</code></pre>&#13;
<p>We can remove a column with the following syntax: </p>&#13;
<pre><code>ALTER TABLE <var>table</var> DROP COLUMN <var>column</var>;</code></pre>&#13;
<p>To change the data type of a column, we would use this code: </p>&#13;
<pre><code>ALTER TABLE <var>table</var> ALTER COLUMN <var>column</var> SET DATA TYPE <var>data_type</var>;</code></pre>&#13;
<p>We add a <code>NOT NULL</code> constraint to a column like so: </p>&#13;
<pre><code>ALTER TABLE <var>table</var> ALTER COLUMN <var>column</var> SET NOT NULL;</code></pre>&#13;
<p>Note that in PostgreSQL and some other systems, adding a constraint to the table causes all rows to be checked to see whether they comply with the constraint. If the table has millions of rows, this could take a while.</p>&#13;
<p>Removing the <code>NOT NULL</code> constraint looks like this: </p>&#13;
<pre><code>ALTER TABLE <var>table</var> ALTER COLUMN <var>column</var> DROP NOT NULL;</code></pre>&#13;
<p><span epub:type="pagebreak" title="166" id="Page_166"/>When you execute <code>ALTER TABLE</code> with the placeholders filled in, you should see a message that reads <code>ALTER TABLE</code> in the pgAdmin output screen. If an operation violates a constraint or if you attempt to change a column’s data type and the existing values in the column won’t conform to the new data type, PostgreSQL returns an error. But PostgreSQL won’t give you any warning about deleting data when you drop a column, so use extra caution before dropping a column.</p>&#13;
<h3 id="h2-501065c10-0005">Modifying Values with UPDATE</h3>&#13;
<p class="BodyFirst">The <code>UPDATE</code> statement, part of the ANSI SQL standard, modifies the data in a column that meets a condition. It can be applied to all rows or a subset of rows. Its basic syntax for updating the data in every row in a column follows this form:</p>&#13;
<pre><code>UPDATE <var>table</var>&#13;
SET <var>column</var> = <var>value</var>;</code></pre>&#13;
<p>We first pass <code>UPDATE</code> the name of the table. Then to <code>SET</code> we pass the column we want to update. The new <var>value</var> to place in the column can be a string, number, the name of another column, or even a query or expression that generates a value. The new value must be compatible with the column data type.</p>&#13;
<p>We can update values in multiple columns by adding additional columns and source values and separating each with a comma:</p>&#13;
<pre><code>UPDATE <var>table</var>&#13;
SET <var>column_a</var> = <var>value</var>,&#13;
<var>    column_b</var> = <var>value</var>;</code></pre>&#13;
<p>To restrict the update to particular rows, we add a <code>WHERE</code> clause with some criteria that must be met before the update can happen, such as rows where values equal a date or match a string:</p>&#13;
<pre><code>UPDATE <var>table</var>&#13;
SET <var>column</var> = <var>value</var>&#13;
WHERE <var>criteria</var>;</code></pre>&#13;
<p>We can also update one table with values from another table. Standard ANSI SQL requires that we use a <em>subquery</em>, a query inside a query, to specify which values and rows to update:</p>&#13;
<pre><code>UPDATE <var>table</var>&#13;
SET <var>column</var> = (SELECT <var>column</var>&#13;
              FROM <var>table_b</var>&#13;
              WHERE <var>table.column</var> = <var>table_b.column</var>)&#13;
WHERE EXISTS (SELECT <var>column</var>&#13;
              FROM <var>table_b</var>&#13;
              WHERE <var>table.column</var> = <var>table_b.column</var>);</code></pre>&#13;
<p><span epub:type="pagebreak" title="167" id="Page_167"/>The value portion of <code>SET</code>, inside the parentheses, is a subquery. A <code>SELECT</code> statement inside parentheses generates the values for the update by joining columns in both tables on matching row values. Similarly, the <code>WHERE EXISTS</code> clause uses a <code>SELECT</code> statement to ensure that we only update rows where both tables have matching values. If we didn’t use <code>WHERE EXISTS</code>, we might inadvertently set some values to <code>NULL</code> without planning to. (If this syntax looks somewhat complicated, that’s okay. I’ll cover subqueries in detail in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>.)</p>&#13;
<p>Some database managers offer additional syntax for updating across tables. PostgreSQL supports the ANSI standard but also a simpler syntax using a <code>FROM</code> clause:</p>&#13;
<pre><code>UPDATE <var>table</var>&#13;
SET <var>column</var> = <var>table_b.column</var>&#13;
FROM <var>table_b</var>&#13;
WHERE <var>table.column = table_b.column</var>;</code></pre>&#13;
<p>When you execute an <code>UPDATE</code> statement, you’ll get a message stating <code>UPDATE</code> along with the number of rows affected.</p>&#13;
<h3 id="h2-501065c10-0006">Viewing Modified Data with RETURNING</h3>&#13;
<p class="BodyFirst">If you add an optional <code>RETURNING</code> clause to <code>UPDATE</code>, you can view the values that were modified without having to run a second, separate query. The syntax of the clause uses the <code>RETURNING</code> keyword followed by a list of columns or a wildcard in the same manner that we name columns following <code>SELECT</code>. Here’s an example:</p>&#13;
<pre><code>UPDATE <var>table</var>&#13;
SET <var>column_a</var> = <var>value</var>&#13;
RETURNING <var>column_a</var>, <var>column_b</var>, <var>column_c</var>;</code></pre>&#13;
<p>Instead of just noting the number of rows modified, <code>RETURNING</code> directs the database to show the columns you specify for the rows modified. This is a PostgreSQL-specific implementation that you also can use with <code>INSERT</code> and <code>DELETE FROM</code>. We’ll try it with some of our examples.</p>&#13;
<h3 id="h2-501065c10-0007">Creating Backup Tables</h3>&#13;
<p class="BodyFirst">Before modifying a table, it’s a good idea to make a copy for reference and backup in case you accidentally destroy some data. <a href="#listing10-8" id="listinganchor10-8">Listing 10-8</a> shows how to use a variation of the familiar <code>CREATE TABLE</code> statement to make a new table from the table we want to duplicate.</p>&#13;
<pre><code>CREATE TABLE meat_poultry_egg_establishments_backup AS&#13;
SELECT * FROM meat_poultry_egg_establishments;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-8">Listing 10-8</a>: Backing up a table</p>&#13;
<p><span epub:type="pagebreak" title="168" id="Page_168"/>The result should be a pristine copy of your table with the new specified name. You can confirm this by counting the number of records in both tables at once:</p>&#13;
<pre><code>SELECT&#13;
    (SELECT count(*) FROM meat_poultry_egg_establishments) AS original,&#13;
    (SELECT count(*) FROM meat_poultry_egg_establishments_backup) AS backup;</code></pre>&#13;
<p>The results should return the same count from both tables, like this:</p>&#13;
<pre><code>original    backup&#13;
--------    ------&#13;
    6287      6287</code></pre>&#13;
<p>If the counts match, you can be sure your backup table is an exact copy of the structure and contents of the original table. As an added measure and for easy reference, we’ll use <code>ALTER TABLE</code> to make copies of column data within the table we’re updating.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Indexes are not copied when creating a table backup using the <code>CREATE TABLE</code> statement. If you decide to run queries on the backup, be sure to create a separate index on that table.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h3 id="h2-501065c10-0008">Restoring Missing Column Values</h3>&#13;
<p class="BodyFirst">The query in <a href="#listing10-4">Listing 10-4</a> earlier revealed that three rows in the <code>meat_poultry_egg_establishments</code> table don’t have a value in the <code>st</code> column:</p>&#13;
<pre><code>est_number           company                            city      st    zip&#13;
-----------------    -------------------------------    ------    --    -----&#13;
V18677A              Atlas Inspection, Inc.             Blaine          55449&#13;
M45319+P45319        Hall-Namie Packing Company, Inc                    36671&#13;
M263A+P263A+V263A    Jones Dairy Farm                                   53538</code></pre>&#13;
<p>To get a complete count of establishments in each state, we need to fill those missing values using an <code>UPDATE</code> statement.</p>&#13;
<h4 id="h3-501065c10-0001">Creating a Column Copy</h4>&#13;
<p class="BodyFirst">Even though we’ve backed up this table, let’s take extra caution and make a copy of the <code>st</code> column within the table so we still have the original data if we make some dire error somewhere. Let’s create the copy and fill it with the existing <code>st</code> column values as in <a href="#listing10-9" id="listinganchor10-9">Listing 10-9</a>.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> ALTER TABLE meat_poultry_egg_establishments ADD COLUMN st_copy text;&#13;
&#13;
UPDATE meat_poultry_egg_establishments&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> SET st_copy = st;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-9">Listing 10-9</a>: Creating and filling the <code>st_copy</code> column with <code>ALTER TABLE</code> and <code>UPDATE</code></p>&#13;
<p><span epub:type="pagebreak" title="169" id="Page_169"/>The <code>ALTER TABLE</code> statement <span class="CodeAnnotation" aria-label="annotation1">1</span> adds a column called <code>st_copy</code> using the same <code>text</code> data type as the original <code>st</code> column. Next, the <code>SET</code> clause <span class="CodeAnnotation" aria-label="annotation2">2</span> in <code>UPDATE</code> fills our new <code>st_copy</code> column with the values in column <code>st</code>. Because we don’t specify any criteria using <code>WHERE</code>, values in every row are updated, and PostgreSQL returns the message <code>UPDATE 6287</code>. Again, it’s worth noting that on a very large table, this operation could take some time and also substantially increase the table’s size. Making a column copy in addition to a table backup isn’t entirely necessary, but if you’re the patient, cautious type, it can be worthwhile.</p>&#13;
<p>We can confirm the values were copied properly with a simple <code>SELECT</code> query on both columns, as in <a href="#listing10-10" id="listinganchor10-10">Listing 10-10</a>.</p>&#13;
<pre><code>SELECT st,&#13;
       st_copy&#13;
FROM meat_poultry_egg_establishments&#13;
WHERE st IS DISTINCT FROM st_copy&#13;
ORDER BY st;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-10">Listing 10-10</a>: Checking values in the <code>st</code> and <code>st_copy</code> columns</p>&#13;
<p>To check for differences between values in the columns, we use <code>IS DISTINCT FROM</code> in the <code>WHERE</code> clause. You’ve used <code>DISTINCT</code> before to find unique values in a column (<span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>); in this context, <code>IS DISTINCT FROM</code> tests whether values in <code>st</code> and <code>st_copy</code> are different. This keeps us from having to scan every row ourselves. Running this query will return zero rows, meaning the values match throughout the table.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Because <code>IS DISTINCT FROM</code> treats <code>NULL</code> as a known value, comparisons between values always will evaluate to <code>true</code> or <code>false</code>. That’s different than the <code>&lt;&gt;</code> operator, in which a comparison that includes a <code>NULL</code> will return <code>NULL</code>. Run <code>SELECT 'a' &lt;&gt; NULL;</code> to see this behavior.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>Now, with our original data safely stored, we can update the three rows with missing state codes. This is now our in-table backup, so if something goes drastically wrong while we’re updating the original column, we can easily copy the original data back in. I’ll show you how after we apply the first updates.</p>&#13;
<h4 id="h3-501065c10-0002">Updating Rows Where Values Are Missing</h4>&#13;
<p class="BodyFirst">To update those rows’ missing values, we first find the values we need with a quick online search: Atlas Inspection is located in Minnesota; Hall-Namie Packing is in Alabama; and Jones Dairy is in Wisconsin. We add those states to the appropriate rows in <a href="#listing10-11" id="listinganchor10-11">Listing 10-11</a>.</p>&#13;
<pre><code>UPDATE meat_poultry_egg_establishments&#13;
SET st = 'MN'&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> WHERE establishment_number = 'V18677A';&#13;
&#13;
UPDATE meat_poultry_egg_establishments&#13;
SET st = 'AL'&#13;
WHERE establishment_number = 'M45319+P45319';&#13;
&#13;
<span epub:type="pagebreak" title="170" id="Page_170"/>UPDATE meat_poultry_egg_establishments&#13;
SET st = 'WI'&#13;
WHERE establishment_number = 'M263A+P263A+V263A'&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> RETURNING establishment_number, company, city, st, zip;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-11">Listing 10-11</a>: Updating the <code>st</code> column for three establishments</p>&#13;
<p>Because we want each <code>UPDATE</code> statement to affect a single row, we include a <code>WHERE</code> clause <span class="CodeAnnotation" aria-label="annotation1">1</span> for each that identifies the company’s unique <code>establishment_number</code>, which is the table’s primary key. When we run the first two queries, PostgreSQL responds with the message <code>UPDATE 1</code>, showing that only one row was updated for each query. When we run the third, the <code>RETURNING</code> clause <span class="CodeAnnotation" aria-label="annotation2">2</span> directs the database to show several columns from the row that was updated:</p>&#13;
<pre><code>establishment_number   company           city      st    zip&#13;
--------------------   ----------------  --------  --    -----&#13;
M263A+P263A+V263A      Jones Dairy Farm            WI    53538</code></pre>&#13;
<p>If we rerun the code in <a href="#listing10-4">Listing 10-4</a> to find rows where <code>st</code> is <code>NULL</code>, the query should return nothing. Success! Our count of establishments by state is now complete.</p>&#13;
<h4 id="h3-501065c10-0003">Restoring Original Values</h4>&#13;
<p class="BodyFirst">What happens if we botch an update by providing the wrong values or updating the wrong rows? We’ll just copy the data back from either the full table backup or the column backup. <a href="#listing10-12" id="listinganchor10-12">Listing 10-12</a> shows the two options.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> UPDATE meat_poultry_egg_establishments&#13;
SET st = st_copy;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> UPDATE meat_poultry_egg_establishments original&#13;
SET st = backup.st&#13;
FROM meat_poultry_egg_establishments_backup backup&#13;
WHERE original.establishment_number = backup.establishment_number;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-12">Listing 10-12</a>: Restoring original <code>st</code> column values</p>&#13;
<p>To restore the values from the backup column in <code>meat_poultry_egg_establishments</code>, run an <code>UPDATE</code> query <span class="CodeAnnotation" aria-label="annotation1">1</span> that sets <code>st</code> to the values in <code>st_copy</code>. Both columns should again have the identical original values. Alternatively, you can create an <code>UPDATE</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> that sets <code>st</code> to values in the <code>st</code> column from the <code>meat_poultry_egg_establishments_backup</code> table you made in <a href="#listing10-8">Listing 10-8</a>. This will obviate the fixes you made to add missing state values, so if you want to try this query, you’ll need to redo the fixes using <a href="#listing10-11">Listing 10-11</a>.</p>&#13;
<h3 id="h2-501065c10-0009">Updating Values for Consistency</h3>&#13;
<p class="BodyFirst">In <a href="#listing10-5">Listing 10-5</a>, we discovered several cases where a single company’s name was entered inconsistently. These inconsistencies will hinder us if we want to aggregate data by company name, so we’ll fix them.</p>&#13;
<p><span epub:type="pagebreak" title="171" id="Page_171"/>Here are the spelling variations of Armour-Eckrich Meats in <a href="#listing10-5">Listing 10-5</a>:</p>&#13;
<pre><code><var>--snip--</var>&#13;
Armour - Eckrich Meats, LLC&#13;
Armour-Eckrich Meats LLC&#13;
Armour-Eckrich Meats, Inc.&#13;
Armour-Eckrich Meats, LLC&#13;
<var>--snip--</var></code></pre>&#13;
<p>We can standardize the spelling using an <code>UPDATE</code> statement. To protect our data, we’ll create a new column for the standardized spellings, copy the names in <code>company</code> into the new column, and work in the new column. <a href="#listing10-13" id="listinganchor10-13">Listing 10-13</a> has the code for both actions.</p>&#13;
<pre><code>ALTER TABLE meat_poultry_egg_establishments ADD COLUMN company_standard text;&#13;
&#13;
UPDATE meat_poultry_egg_establishments&#13;
SET company_standard = company;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-13">Listing 10-13</a>: Creating and filling the <code>company_standard</code> column</p>&#13;
<p>Now, let’s say we want any name in <code>company</code> that starts with the string <code>Armour</code> to appear in <code>company_standard</code> as <code>Armour-Eckrich Meats</code>. (This assumes we’ve checked all Armour entries and want to standardize them.) With <a href="#listing10-14" id="listinganchor10-14">Listing 10-14</a>, we can update all the rows matching the string <code>Armour</code> using <code>WHERE</code>.</p>&#13;
<pre><code>UPDATE meat_poultry_egg_establishments&#13;
SET company_standard = 'Armour-Eckrich Meats'&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> WHERE company LIKE 'Armour%'&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> RETURNING company, company_standard;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-14">Listing 10-14</a>: Using an <code>UPDATE</code> statement to modify column values that match a string</p>&#13;
<p>The important piece of this query is the <code>WHERE</code> clause that uses the <code>LIKE</code> keyword <span class="CodeAnnotation" aria-label="annotation1">1</span> for case-sensitive pattern matching introduced in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. Including the wildcard syntax <code>%</code> at the end of the string <code>Armour</code> updates all rows that start with those characters regardless of what comes after them. The clause lets us target all the varied spellings used for the company’s name. The <code>RETURNING</code> clause <span class="CodeAnnotation" aria-label="annotation2">2</span> causes the statement to provide the results of the updated <code>company_standard</code> column next to the original <code>company</code> column:</p>&#13;
<pre><code>company                        company_standard&#13;
---------------------------    --------------------&#13;
Armour-Eckrich Meats LLC       Armour-Eckrich Meats&#13;
Armour - Eckrich Meats, LLC    Armour-Eckrich Meats&#13;
Armour-Eckrich Meats LLC       Armour-Eckrich Meats&#13;
Armour-Eckrich Meats LLC       Armour-Eckrich Meats&#13;
Armour-Eckrich Meats, Inc.     Armour-Eckrich Meats&#13;
Armour-Eckrich Meats, LLC      Armour-Eckrich Meats&#13;
Armour-Eckrich Meats, LLC      Armour-Eckrich Meats</code></pre>&#13;
<p><span epub:type="pagebreak" title="172" id="Page_172"/>The values for Armour-Eckrich in <code>company_standard</code> are now standardized with consistent spelling. To standardize other company names in the table, we would create an <code>UPDATE</code> statement for each case. We would also keep the original <code>company</code> column for reference.</p>&#13;
<h3 id="h2-501065c10-0010">Repairing ZIP Codes Using Concatenation</h3>&#13;
<p class="BodyFirst">Our final fix repairs values in the <code>zip</code> column that lost leading zeros. Zip codes in Puerto Rico and the US Virgin Islands begin with two zeros, so we need to restore two leading zeros to the values in <code>zip</code>. For the other states, located mostly in New England, we’ll restore a single leading zero.</p>&#13;
<p>We’ll use <code>UPDATE</code> in conjunction with the double-pipe <em>string concatenation operator </em>(<code>||</code>). Concatenation combines two string values into one (it will also combine a string and a number into a string). For example, inserting <code>||</code> between the strings <code>abc</code> and <code>xyz</code> results in <code>abcxyz</code>. The double-pipe operator is a SQL standard for concatenation supported by PostgreSQL. You can use it in many contexts, such as <code>UPDATE</code> queries and <code>SELECT</code>, to provide custom output from existing as well as new data.</p>&#13;
<p>First, <a href="#listing10-15" id="listinganchor10-15">Listing 10-15</a> makes a backup copy of the <code>zip</code> column as we did earlier.</p>&#13;
<pre><code>ALTER TABLE meat_poultry_egg_establishments ADD COLUMN zip_copy text;&#13;
&#13;
UPDATE meat_poultry_egg_establishments&#13;
SET zip_copy = zip;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-15">Listing 10-15</a>: Creating and filling the <code>zip_copy </code>column</p>&#13;
<p>Next, we use the code in <a href="#listing10-16" id="listinganchor10-16">Listing 10-16</a> to perform the first update.</p>&#13;
<pre><code>UPDATE meat_poultry_egg_establishments&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> SET zip = '00' || zip&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> WHERE st IN('PR','VI') AND length(zip) = 3;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-16">Listing 10-16</a>: Modifying codes in the <code>zip</code> column missing two leading zeros</p>&#13;
<p>We use <code>SET</code> to set the value in the <code>zip</code> column <span class="CodeAnnotation" aria-label="annotation1">1</span> to the result of the concatenation of <code>00</code> and the existing value. We limit the <code>UPDATE</code> to only those rows where the <code>st</code> column has the state codes <code>PR</code> and <code>VI</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> using the <code>IN</code> comparison operator from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> and add a test for rows where the length of <code>zip</code> is <code>3</code>. This entire statement will then only update the <code>zip</code> values for Puerto Rico and the Virgin Islands. Run the query; PostgreSQL should return the message <code>UPDATE 86</code>, which is the number of rows we expect to change based on our earlier count in <a href="#listing10-6">Listing 10-6</a>.</p>&#13;
<p>Let’s repair the remaining ZIP codes using a similar query in <a href="#listing10-17" id="listinganchor10-17">Listing 10-17</a>.</p>&#13;
<pre><code>UPDATE meat_poultry_egg_establishments&#13;
SET zip = '0' || zip&#13;
WHERE st IN('CT','MA','ME','NH','NJ','RI','VT') AND length(zip) = 4;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-17">Listing 10-17</a>: Modifying codes in the <code>zip</code> column missing one leading zero</p>&#13;
<p><span epub:type="pagebreak" title="173" id="Page_173"/>PostgreSQL should return the message <code>UPDATE 496</code>. Now, let’s check our progress. Earlier in <a href="#listing10-6">Listing 10-6</a>, when we aggregated rows in the <code>zip</code> column by length, we found <code>86</code> rows with three characters and <code>496</code> with four.</p>&#13;
<p>Using the same query now returns a more desirable result: all the rows have a five-digit ZIP code.</p>&#13;
<pre><code>length    count&#13;
------    -----&#13;
     5     6287</code></pre>&#13;
<p>I’ll discuss additional string functions in <span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span> when we consider advanced techniques for working with text.</p>&#13;
<h3 id="h2-501065c10-0011">Updating Values Across Tables</h3>&#13;
<p class="BodyFirst">In “Modifying Values with UPDATE” earlier in the chapter, I showed the standard ANSI SQL and PostgreSQL-specific syntax for updating values in one table based on values in another. This syntax is particularly valuable in a relational database where primary keys and foreign keys establish table relationships. In those cases, we may need information in one table to update values in another table.</p>&#13;
<p>Let’s say we’re setting an inspection deadline for each of the companies in our table. We want to do this by US regions, such as Northeast, Pacific, and so on, but those regional designations don’t exist in our table. However, they <em>do</em> exist in the file <em>state_regions.csv</em>, included with the book’s resources, that contains matching <code>st</code> state codes. Once we load that file into a table, we can use that data in an <code>UPDATE</code> statement. Let’s begin with the New England region to see how this works.</p>&#13;
<p>Enter the code in <a href="#listing10-18" id="listinganchor10-18">Listing 10-18</a>, which contains the SQL statements to create a <code>state_regions</code> table and fill the table with data:</p>&#13;
<pre><code>CREATE TABLE state_regions (&#13;
    st text CONSTRAINT st_key PRIMARY KEY,&#13;
    region text NOT NULL&#13;
);&#13;
&#13;
COPY state_regions&#13;
FROM '<var>C:\YourDirectory\</var>state_regions.csv'&#13;
WITH (FORMAT CSV, HEADER);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-18">Listing 10-18</a>: Creating and filling a <code>state_regions</code> table</p>&#13;
<p>We’ll create two columns in a <code>state_regions</code> table: one containing the two-character state code <code>st</code> and the other containing the <code>region</code> name. We set the primary key constraint to the <code>st</code> column, which holds a unique <code>st_key</code> value to identify each state. In the data you’re importing, each state is present and assigned to a census region, and territories outside the United States are labeled as outlying areas. We’ll update the table one region at a time.</p>&#13;
<p>Next, let’s return to the <code>meat_poultry_egg_establishments</code> table, add a column for inspection dates, and then fill in that column with the New England states. <a href="#listing10-19" id="listinganchor10-19">Listing 10-19</a> shows the code.</p>&#13;
<pre><code><span epub:type="pagebreak" title="174" id="Page_174"/>ALTER TABLE meat_poultry_egg_establishments&#13;
    ADD COLUMN inspection_deadline timestamp with time zone;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> UPDATE meat_poultry_egg_establishments establishments&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> SET inspection_deadline = '2022-12-01 00:00 EST'&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> WHERE EXISTS (SELECT state_regions.region&#13;
              FROM state_regions&#13;
              WHERE establishments.st = state_regions.st&#13;
                    AND state_regions.region = 'New England');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-19">Listing 10-19</a>: Adding and updating an <code>inspection_deadline</code> column</p>&#13;
<p>The <code>ALTER TABLE</code> statement creates the <code>inspection_deadline</code> column in the <code>meat_poultry_egg_establishments</code> table. In the <code>UPDATE</code> statement, we give the table an alias of <code>establishments</code> to make the code easier to read <span class="CodeAnnotation" aria-label="annotation1">1</span> (and do so omitting the optional <code>AS</code> keyword). Next, <code>SET</code> assigns a timestamp value of <code>2022-12-01 00:00 EST</code> to the new <code>inspection_deadline</code> column <span class="CodeAnnotation" aria-label="annotation2">2</span>. Finally, <code>WHERE EXISTS</code> includes a subquery that connects the <code>meat_poultry_egg_establishments</code> table to the <code>state_regions</code> table we created in <a href="#listing10-18">Listing 10-18</a> and specifies which rows to update <span class="CodeAnnotation" aria-label="annotation3">3</span>. The subquery (in parentheses, beginning with <code>SELECT</code>) looks for rows in the <code>state_regions</code> table where the <code>region</code> column matches the string <code>New England</code>. At the same time, it joins the <code>meat_poultry_egg_establishments</code> table with the <code>state_regions</code> table using the <code>st</code> column from both tables. In effect, the query is telling the database to find all the <code>st</code> codes that correspond to the New England region and use those codes to filter the update.</p>&#13;
<p>When you run the code, you should receive a message of <code>UPDATE 252</code>, which is the number of companies in New England states. You can use the code in <a href="#listing10-20" id="listinganchor10-20">Listing 10-20</a> to see the effect of the change.</p>&#13;
<pre><code>SELECT st, inspection_deadline&#13;
FROM meat_poultry_egg_establishments&#13;
GROUP BY st, inspection_deadline&#13;
ORDER BY st;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-20">Listing 10-20</a>: Viewing updated <code>inspection_date</code> values</p>&#13;
<p>The results should show the updated inspection deadlines for all New England companies. The top of the output shows Connecticut has received a deadline timestamp, for example, but states outside New England remain <code>NULL</code> because we haven’t updated them yet:</p>&#13;
<pre><code>st    inspection_deadline&#13;
--    ---------------------&#13;
<var>--snip--</var>&#13;
CA&#13;
CO&#13;
CT    2022-12-01 00:00:00-05&#13;
DC&#13;
<var>--snip--</var></code></pre>&#13;
<p><span epub:type="pagebreak" title="175" id="Page_175"/>To fill in deadlines for additional regions, substitute a different region for <code>New England</code> in <a href="#listing10-19">Listing 10-19</a> and rerun the query.</p>&#13;
<h2 id="h1-501065c10-0004">Deleting Unneeded Data</h2>&#13;
<p class="BodyFirst">The most irrevocable way to modify data is to remove it entirely. SQL includes options to remove rows and columns along with options to delete an entire table or database. We want to perform these operations with caution, removing only data or tables we don’t need. Without a backup, your data is gone for good.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	It’s easy to exclude unwanted data in queries using a <code>WHERE</code> clause, so decide whether you truly need to delete the data or can just filter it out. Cases where deleting may be the best solution include data with errors, data imported incorrectly, or almost no disk space.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>In this section, we’ll use a variety of SQL statements to delete data. If you didn’t back up the <code>meat_poultry_egg_establishments</code> table using <a href="#listing10-8">Listing 10-8</a>, now is a good time to do so.</p>&#13;
<p>Writing and executing these statements is fairly simple, but doing so comes with a caveat. If deleting rows, a column, or a table would cause a violation of a constraint, such as the foreign key constraint covered in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, you need to deal with that constraint first. That might involve removing the constraint, deleting data in another table, or deleting another table. Each case is unique and will require a different way to work around the constraint.</p>&#13;
<h3 id="h2-501065c10-0012">Deleting Rows from a Table</h3>&#13;
<p class="BodyFirst">To remove rows from a table, we can use either <code>DELETE FROM</code> or <code>TRUNCATE</code>, which are both part of the ANSI SQL standard. Each offers options that are useful depending on your goals.</p>&#13;
<p>Using <code>DELETE FROM</code>, we can remove all rows from a table, or we can add a <code>WHERE</code> clause to delete only the portion that matches an expression we supply. To delete all rows from a table, use the following syntax:</p>&#13;
<pre><code>DELETE FROM <var>table_name</var>;</code></pre>&#13;
<p>To remove only selected rows, add a <code>WHERE</code> clause along with the matching value or pattern to specify which ones you want to delete:</p>&#13;
<pre><code>DELETE FROM <var>table_name</var> WHERE <var>expression</var>;</code></pre>&#13;
<p>For example, to exclude US territories from our processors table, we can remove the companies in those locations using the code in <a href="#listing10-21" id="listinganchor10-21">Listing 10-21</a>.</p>&#13;
<pre><code>DELETE FROM meat_poultry_egg_establishments&#13;
WHERE st IN('AS','GU','MP','PR','VI');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-21">Listing 10-21</a>: Deleting rows matching an expression</p>&#13;
<p><span epub:type="pagebreak" title="176" id="Page_176"/>Run the code; PostgreSQL should return the message <code>DELETE 105</code>. This means the 105 rows where the <code>st</code> column held any of the codes designating a territory that you supplied via the <code>IN</code> keyword have been removed from the table.</p>&#13;
<p>With large tables, using <code>DELETE FROM</code> to remove all rows can be inefficient because it scans the entire table as part of the process. In that case, you can use <code>TRUNCATE</code>, which skips the scan. To empty the table using <code>TRUNCATE</code>, use the following syntax:</p>&#13;
<pre><code>TRUNCATE <var>table_name</var>;</code></pre>&#13;
<p>A handy feature of <code>TRUNCATE</code> is the ability to reset an <code>IDENTITY</code> sequence, such as one you may have created to serve as a surrogate primary key, as part of the operation. To do that, add the <code>RESTART IDENTITY</code> keywords to the statement:</p>&#13;
<pre><code>TRUNCATE <var>table_name</var> RESTART IDENTITY;</code></pre>&#13;
<p>We’ll skip truncating any tables for now as we need the data for the rest of the chapter.</p>&#13;
<h3 id="h2-501065c10-0013">Deleting a Column from a Table</h3>&#13;
<p class="BodyFirst">Earlier we created a backup <code>zip</code> column called <code>zip_copy</code>. Now that we’ve finished working on fixing the issues in <code>zip</code>, we no longer need <code>zip_copy</code>. We can remove the backup column, including all the data within the column, from the table using the <code>DROP</code> keyword in the <code>ALTER TABLE</code> statement.</p>&#13;
<p>The syntax for removing a column is similar to other <code>ALTER TABLE</code> statements: </p>&#13;
<pre><code>ALTER TABLE <var>table_name</var> DROP COLUMN <var>column_name</var>;</code></pre>&#13;
<p>The code in <a href="#listing10-22" id="listinganchor10-22">Listing 10-22</a> removes the <code>zip_copy</code> column:</p>&#13;
<pre><code>ALTER TABLE meat_poultry_egg_establishments DROP COLUMN zip_copy;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-22">Listing 10-22</a>: Removing a column from a table using <code>DROP</code></p>&#13;
<p>PostgreSQL returns the message <code>ALTER TABLE</code>, and the <code>zip_copy</code> column should be deleted. The database doesn’t actually rewrite the table to remove the column; it just marks the column as deleted in its internal catalog and no longer shows it or adds data to it when new rows are added.</p>&#13;
<h3 id="h2-501065c10-0014">Deleting a Table from a Database</h3>&#13;
<p class="BodyFirst">The <code>DROP TABLE</code> statement is a standard ANSI SQL feature that deletes a table from the database. This statement might come in handy if, for example, you have a collection of backups, or <em>working tables</em>, that have outlived their usefulness. It’s also useful when you need to change the structure of a table <span epub:type="pagebreak" title="177" id="Page_177"/>significantly; in that case, rather than using too many <code>ALTER TABLE</code> statements, you can just remove the table and create a fresh one by running a new <code>CREATE TABLE</code> statement and re-importing the data.</p>&#13;
<p>The syntax for the <code>DROP TABLE</code> command is simple:</p>&#13;
<pre><code>DROP TABLE <var>table_name</var>;</code></pre>&#13;
<p>For example, <a href="#listing10-23" id="listinganchor10-23">Listing 10-23</a> deletes the backup version of the <code>meat_poultry_egg_establishments</code> table.</p>&#13;
<pre><code>DROP TABLE meat_poultry_egg_establishments_backup;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-23">Listing 10-23</a>: Removing a table from a database using <code>DROP</code></p>&#13;
<p>Run the query; PostgreSQL should respond with the message <code>DROP TABLE</code> to indicate the table has been removed.</p>&#13;
<h2 id="h1-501065c10-0005">Using Transactions to Save or Revert Changes</h2>&#13;
<p class="BodyFirst">So far, our alterations in this chapter have been final. That is, after you run a <code>DELETE</code> or <code>UPDATE</code> query (or any other query that alters your data or database structure), the only way to undo the change is to restore from a backup. However, there is a way to check your changes before finalizing them and cancel the change if it’s not what you intended. You do this by enclosing the SQL statement within a <em>transaction</em>, which includes keywords that allow you to commit your changes if they are successful or roll them back if not. You define a transaction using the following keywords at the beginning and end of the query:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>START TRANSACTION</code></span></span>  Signals the start of the transaction block. In PostgreSQL, you can also use the non-ANSI SQL <code>BEGIN</code> keyword.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>COMMIT</code></span></span>  Signals the end of the block and saves all changes.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>ROLLBACK</code></span></span>  Signals the end of the block and reverts all changes.</li>&#13;
</ol>&#13;
<p>You can include multiple statements between <code>BEGIN</code> and <code>COMMIT</code> to define a sequence of operations that perform one unit of work in a database. An example is when you buy concert tickets, which might involve two steps: charging your credit card and reserving your seats so someone else can’t buy them. A database programmer would want either both steps in the transaction to happen (say, when your card charge goes through) or neither to happen (if you cancel at checkout). Defining both steps as one transaction—also called a <em>transaction block</em>—keeps them as a unit; if one step is canceled or throws an error, the other gets canceled too. You can learn more details about transactions and PostgreSQL at <a href="https://www.postgresql.org/docs/current/tutorial-transactions.html" class="LinkURL">https://www.postgresql.org/docs/current/tutorial-transactions.html</a>.</p>&#13;
<p>We can use a transaction block to review changes a query makes and then decide whether to keep or discard them. In our table, let’s say we’re cleaning dirty data related to the company AGRO Merchants Oakland LLC. <span epub:type="pagebreak" title="178" id="Page_178"/>The table has three rows listing the company, but one row has an extra comma in the name:</p>&#13;
<pre><code>Company&#13;
---------------------------&#13;
AGRO Merchants Oakland LLC&#13;
AGRO Merchants Oakland LLC&#13;
AGRO Merchants Oakland, LLC</code></pre>&#13;
<p>We want the name to be consistent, so we’ll remove the comma from the third row using an <code>UPDATE</code> query, as we did earlier. But this time we’ll check the result of our update before we make it final (and we’ll purposely make a mistake we want to discard). <a href="#listing10-24" id="listinganchor10-24">Listing 10-24</a> shows how to do this using a transaction block.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> START TRANSACTION;&#13;
&#13;
UPDATE meat_poultry_egg_establishments&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> SET company = 'AGRO Merchantss Oakland LLC'&#13;
WHERE company = 'AGRO Merchants Oakland, LLC';&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> SELECT company&#13;
FROM meat_poultry_egg_establishments&#13;
WHERE company LIKE 'AGRO%'&#13;
ORDER BY company;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> ROLLBACK;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-24">Listing 10-24</a>: Demonstrating a transaction block</p>&#13;
<p>Beginning with <code>START TRANSACTION;</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, we’ll run each statement separately. The database responds with the message <code>START TRANSACTION</code>, letting you know that any succeeding changes you make to data will not be made permanent unless you issue a <code>COMMIT</code> command. Next, we run the <code>UPDATE</code> statement, which changes the company name in the row where it has an extra comma. I intentionally added an extra <code>s</code> in the name used in the <code>SET</code> clause <span class="CodeAnnotation" aria-label="annotation2">2</span> to introduce a mistake.</p>&#13;
<p>When we view the names of companies starting with the letters <code>AGRO</code> using the <code>SELECT</code> statement <span class="CodeAnnotation" aria-label="annotation3">3</span>, we see that, oops, one company name is misspelled now.</p>&#13;
<pre><code>Company&#13;
---------------------------&#13;
AGRO Merchants Oakland LLC&#13;
AGRO Merchants Oakland LLC&#13;
AGRO Merchantss Oakland LLC</code></pre>&#13;
<p>Instead of rerunning the <code>UPDATE</code> statement to fix the typo, we can simply discard the change by running the <code>ROLLBACK;</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> command. When we rerun the <code>SELECT</code> statement to view the company names, we’re back to where we started:</p>&#13;
<pre><code><span epub:type="pagebreak" title="179" id="Page_179"/>Company&#13;
---------------------------&#13;
AGRO Merchants Oakland LLC&#13;
AGRO Merchants Oakland LLC&#13;
AGRO Merchants Oakland, LLC</code></pre>&#13;
<p>From here, you correct your <code>UPDATE</code> statement by removing the extra <code>s</code> and rerun it, beginning with the <code>START TRANSACTION</code> statement again. If you’re happy with the changes, run <code>COMMIT;</code> to make them permanent.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	When you start a transaction in PostgreSQL, any changes you make to the data aren’t visible to other database users until you execute <code>COMMIT</code>. Other databases may behave differently depending on their settings.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>Transaction blocks are often used for more complex situations rather than checking simple changes. Here you’ve used them to test whether a query behaves as desired, saving you time and headaches. Next, let’s look at another way to save time when updating lots of data.</p>&#13;
<h2 id="h1-501065c10-0006">Improving Performance When Updating Large Tables</h2>&#13;
<p class="BodyFirst">With PostgreSQL, adding a column to a table and filling it with values can quickly inflate the table’s size because the database creates a new version of the existing row each time a value is updated, but it doesn’t delete the old row version. That essentially doubles the table’s size. (You’ll learn how to clean up these old rows when I discuss database maintenance in “Recovering Unused Space with VACUUM” in <span class="xref" itemid="xref_target_Chapter 19">Chapter 19</span>.) For small datasets, the increase is negligible, but for tables with hundreds of thousands or millions of rows, the time required to update rows and the resulting extra disk usage can be substantial.</p>&#13;
<p>Instead of adding a column and filling it with values, we can save disk space by copying the entire table and adding a populated column during the operation. Then, we rename the tables so the copy replaces the original, and the original becomes a backup. Thus, we have a fresh table without the added old rows.</p>&#13;
<p><a href="#listing10-25" id="listinganchor10-25">Listing 10-25</a> shows how to copy <code>meat_poultry_egg_establishments</code> into a new table while adding a populated column. To do this, if you didn’t already drop the <code>meat_poultry_egg_establishments_backup</code> table as shown in <a href="#listing10-23">Listing 10-23</a>, go ahead and drop it. Then run the <code>CREATE TABLE</code> statement.</p>&#13;
<pre><code>CREATE TABLE meat_poultry_egg_establishments_backup AS&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> SELECT *,&#13;
      <span class="CodeAnnotationCode" aria-label="annotation2">2</span> '2023-02-14 00:00 EST'::timestamp with time zone AS reviewed_date&#13;
FROM meat_poultry_egg_establishments;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-25">Listing 10-25</a>: Backing up a table while adding and filling a new column</p>&#13;
<p><span epub:type="pagebreak" title="180" id="Page_180"/>The query is a modified version of the backup script in <a href="#listing10-8">Listing 10-8</a>. Here, in addition to selecting all the columns using the asterisk wildcard <span class="CodeAnnotation" aria-label="annotation1">1</span>, we also add a column called <code>reviewed_date</code> by providing a value cast as a <code>timestamp</code> data type <span class="CodeAnnotation" aria-label="annotation2">2</span> and the <code>AS</code> keyword. That syntax adds and fills <code>reviewed_date</code>, which we might use to track the last time we checked the status of each plant.</p>&#13;
<p>Then we use <a href="#listing10-26" id="listinganchor10-26">Listing 10-26</a> to swap the table names.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> ALTER TABLE meat_poultry_egg_establishments&#13;
    RENAME TO meat_poultry_egg_establishments_temp;&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> ALTER TABLE meat_poultry_egg_establishments_backup&#13;
    RENAME TO meat_poultry_egg_establishments;&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> ALTER TABLE meat_poultry_egg_establishments_temp&#13;
    RENAME TO meat_poultry_egg_establishments_backup;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-26">Listing 10-26</a>: Swapping table names using <code>ALTER TABLE</code></p>&#13;
<p>Here we use <code>ALTER TABLE</code> with a <code>RENAME TO</code> clause to change a table name. The first statement changes the original table name to one that ends with <code>_temp</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. The second statement renames the copy we made with <a href="#listing10-24">Listing 10-24</a> to the original name of the table <span class="CodeAnnotation" aria-label="annotation2">2</span>. Finally, we rename the table that ends with <code>_temp</code> to the ending <code>_backup</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. The original table is now called <code>meat_poultry_egg_establishments_backup</code>, and the copy with the added column is called <code>meat_poultry_egg_establishments</code>. This process avoids updating rows and thus inflating the table.</p>&#13;
<h2 id="h1-501065c10-0007">Wrapping Up</h2>&#13;
<p class="BodyFirst">Gleaning useful information from data sometimes requires modifying the data to remove inconsistencies, fix errors, and make it more suitable for supporting an accurate analysis. In this chapter you learned some useful tools to help you assess dirty data and clean it up. In a perfect world, all datasets would arrive with everything clean and complete. But such a perfect world doesn’t exist, so the ability to alter, update, and delete data is indispensable.</p>&#13;
<p>Let me restate the important tasks of working safely. Be sure to back up your tables before you start making changes. Make copies of your columns, too, for an extra level of protection. When I discuss database maintenance for PostgreSQL later in the book, you’ll learn how to back up entire databases. These few steps of precaution will save you a world of pain.</p>&#13;
<p>In the next chapter, we’ll return to math to explore some of SQL’s advanced statistical functions and techniques for analysis.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="181" id="Page_181"/>try it yourself</h2>&#13;
<p class="BoxBodyFirst">In this exercise, you’ll turn the <code>meat_poultry_egg_establishments</code> table into useful information. You need to answer two questions: how many of the plants in the table process meat, and how many process poultry?</p>&#13;
<p>The answers to these two questions lie in the <code>activities</code> column. Unfortunately, the column contains an assortment of text with inconsistent input. Here’s an example of the kind of text you’ll find in the <code>activities</code> column:</p>&#13;
<pre><code>Poultry Processing, Poultry Slaughter&#13;
Meat Processing, Poultry Processing&#13;
Poultry Processing, Poultry Slaughter</code></pre>&#13;
<p>The mishmash of text makes it impossible to perform a typical count that would allow you to group processing plants by activity. However, you can make some modifications to fix this data. Your tasks are as follows:</p>&#13;
<ol>&#13;
<li value="1">Create two new columns called <code>meat_processing</code> and <code>poultry_processing</code> in your table. Each can be of the type <code>boolean</code>.</li>&#13;
<li value="2">Using <code>UPDATE</code>, set <code>meat_processing = TRUE</code> on any row in which the <code>activities</code> column contains the text <em>Meat Processing</em>. Do the same update on the <code>poultry_processing</code> column, but this time look for the text <em>Poultry Processing</em> in <code>activities</code>.</li>&#13;
<li value="3">Use the data from the new, updated columns to count how many plants perform each type of activity. For a bonus challenge, count how many plants perform both activities.</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div></body></html>