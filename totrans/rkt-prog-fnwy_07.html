<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_179"/><span class="big">7</span><br/>SEARCHING FOR ANSWERS</h2>&#13;
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">For all the problems we have encountered so far, there was a direct method to compute the solution. But this is not always the case. For many problems, we have to search for the solution using some type of algorithm, such as when solving a Sudoku puzzle or the <em>n</em>-queens problem. In these cases, the process involves trying a series of steps until either we find the solution or we have to back up to a previous step to try an alternative route. In this chapter we’ll explore a number of algorithms that allow us to efficiently select a path that leads to a solution. Such an approach is known as a <em>heuristic</em>. In general, a heuristic isn’t guaranteed to find a solution, but the algorithms we explore here (thankfully) are.</p>&#13;
<h3 class="h3" id="ch00lev1sec_41"><span epub:type="pagebreak" id="page_180"/>Graph Theory</h3>&#13;
<p class="noindent">It’s often the case that a problem we’re trying to solve can be modeled with a <em>graph</em>. Intuitively, a graph is just a set of points (or nodes) and connecting lines, as illustrated in <a href="ch07.xhtml#ch7fig1">Figure 7-1</a>. Each node represents some state of the problem-solving process, and the lines extending from one node to other nodes represent possible alternative steps. We’ll first give some basic graph definitions as background before delving into the actual problem-solving algorithms.</p>&#13;
<h4 class="h4" id="ch00lev2sec_55"><strong><em>The Basics</em></strong></h4>&#13;
<p class="noindent">Formally, a graph is a finite set <em>V</em> of <em>vertices</em> (or nodes) and a set <em>E</em> of <em>edges</em> joining different pairs of distinct vertices (see <a href="ch07.xhtml#ch7fig1">Figure 7-1</a>).</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig01.jpg"/></div>&#13;
<p class="figcap" id="ch7fig1"><em>Figure 7-1: Graph</em></p>&#13;
<p class="indent">In <a href="ch07.xhtml#ch7fig1">Figure 7-1</a> above, <em>V</em> = {<em>a, b, c, d, e</em>} are the vertices and <em>E</em> = {(<em>a</em>, <em>b</em>), (<em>a</em>, <em>c</em>), (<em>b</em>, <em>c</em>), (<em>c</em>, <em>d</em>), (<em>b</em>, <em>e</em>), (<em>e</em>, <em>d</em>)} are the edges.</p>&#13;
<p class="indent">A sequence of graph vertices (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, …, <em>v</em><sub><em>n</em></sub>), such that there’s an edge connecting <em>v</em><sub><em>i</em></sub> and <em>v</em><sub><em>i</em>+1</sub>, is called a <em>walk</em>. If all the vertices are distinct, a walk is called a <em>path</em>. A walk where all the vertices are distinct except that <em>v</em><sub>1</sub> = <em>v</em><sub><em>n</em></sub> is called a <em>cycle</em> or <em>circuit</em>. In <a href="ch07.xhtml#ch7fig1">Figure 7-1</a>, the sequence (<em>a</em>, <em>b</em>, <em>c</em>, <em>b</em>) is a walk, the sequence (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>) is a path, and the sequence (<em>a</em>, <em>b</em>, <em>c</em>, <em>a</em>) is a cycle.</p>&#13;
<p class="indent">A graph with a path from each vertex to every other vertex is said to be <em>connected</em>. A connected graph without any cycles is called a <em>tree</em>. In a tree, any path is assumed to flow from upper nodes to lower nodes. Such a structure (where there are no cycles and there is only one way to get from one node to another) is known as a <em>directed acyclic graph (DAG)</em>. It’s possible to convert the graph above to a tree by removing some of its edges, as shown in <a href="ch07.xhtml#ch7fig2">Figure 7-2</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_181"/><img alt="Image" src="../images/07fig02.jpg"/></div>&#13;
<p class="figcap" id="ch7fig2"><em>Figure 7-2: Tree</em></p>&#13;
<p class="indent">If nodes <em>x</em> and <em>y</em> are connected in such a way that it’s possible to go from <em>x</em> to <em>y</em>, then <em>y</em> is said to be a <em>child node</em> of <em>x</em>. Nodes without child nodes (such as <em>a</em>, <em>c</em>, and <em>d</em>) are known as <em>terminal</em> (or <em>leaf</em>) nodes. Problems that have solutions modeled by a tree structure lend themselves to simpler search strategies since a tree doesn’t have circuits. Searching a graph with circuits requires keeping track of nodes already visited so that the same nodes aren’t re-explored.</p>&#13;
<p class="indent">It’s possible to label each edge of the graph with a numerical value called a <em>weight</em>, as shown in <a href="ch07.xhtml#ch7fig3">Figure 7-3</a>. This type of graph is called a <em>weighted graph</em>.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig03.jpg"/></div>&#13;
<p class="figcap" id="ch7fig3"><em>Figure 7-3: Weighted graph</em></p>&#13;
<p class="indent">If <em>e</em> is an edge, the weight of the edge is designated by <em>w</em>(<em>e</em>). Weights can be used to represent any number of measurements such as time, cost, or distance, which may affect the choice of edge when searching a graph.</p>&#13;
<p class="indent">A number of interesting questions arise when exploring the properties of graphs. One such question is this: “Given any two nodes, what’s the shortest path between them?” Another is the famous traveling salesman problem: “Given a list of cities and the distances between them, what’s the shortest possible route that visits each city exactly once and returns to the original city?” This last question, where each node is visited exactly once and returns to the original node, involves what is called a <em>Hamiltonian circuit</em>.</p>&#13;
<h4 class="h4" id="ch00lev2sec_56"><span epub:type="pagebreak" id="page_182"/><strong><em>Graph Search</em></strong></h4>&#13;
<p class="noindent">There are two broad categories of strategies for searching graphs: <em>breadth-first search (BFS)</em> and <em>depth-first search (DFS)</em>. To illustrate these concepts, we’ll use the tree in <a href="ch07.xhtml#ch7fig2">Figure 7-2</a>.</p>&#13;
<h5 class="h5" id="ch00lev3sec_49"><strong>Breadth-First Search</strong></h5>&#13;
<p class="noindent">Breadth-first search involves searching a graph by fully exploring each level (or depth) before moving on to the next level. In the tree diagram (shown in <a href="ch07.xhtml#ch7fig2">Figure 7-2</a>), the <em>e</em> (root) node is on the first level, nodes <em>b</em> and <em>d</em> are on the next level, and nodes <em>a</em> and <em>c</em> are on the third level. This typically involves using a queue to stage the nodes to be examined. The process begins by pushing the root node onto the queue, as shown in <a href="ch07.xhtml#ch7fig4">Figure 7-4</a>:</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig04.jpg"/></div>&#13;
<p class="figcap" id="ch7fig4"><em>Figure 7-4: A queue containing the root node</em></p>&#13;
<p class="indent">We then pop the first node in the queue (<em>e</em>) and test it to see if it’s a goal node; if not, we push its child nodes onto the queue, as shown in <a href="ch07.xhtml#ch7fig5">Figure 7-5</a>:</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig05.jpg"/></div>&#13;
<p class="figcap" id="ch7fig5"><em>Figure 7-5: The queue after node <span class="normal">e</span> was explored</em></p>&#13;
<p class="indent">Again we pop the first node in the queue (this time <em>b</em>) and test it to see if it’s a goal node; if not, we push its child nodes onto the queue, as shown in <a href="ch07.xhtml#ch7fig6">Figure 7-6</a>:</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig06.jpg"/></div>&#13;
<p class="figcap" id="ch7fig6"><em>Figure 7-6: The queue after node <span class="normal">b</span> was explored</em></p>&#13;
<p class="indent">We continue in this fashion until a goal node has been found, or the queue is empty, in which case there’s no solution.</p>&#13;
<h5 class="h5" id="ch00lev3sec_50"><strong>Depth-First Search</strong></h5>&#13;
<p class="noindent">Depth-first search works by continuing to walk down a branch of the tree until a goal node is found or a terminal node is reached. For example, starting at the root node of the tree, nodes <em>e</em>, <em>b</em>, and <em>a</em> would be examined in order. If none of those node are goal nodes, we back up to node <em>b</em> and examine its next child node, <em>c</em>. If <em>c</em> is also not a goal node, we back all the way up to <em>e</em> and examine its next child node, <em>d</em>. The <em>n</em>-queens problem in the next section provides a simple example of using depth-first search.</p>&#13;
<h3 class="h3" id="ch00lev1sec_42"><span epub:type="pagebreak" id="page_183"/>The <em>N</em>-Queens Problem</h3>&#13;
<p class="noindent">The <em>n</em>-queens problem is a classic problem often used to illustrate depth-first search. The problem goes like this: position <em>n</em> queens on an <em>n</em>-by-<em>n</em> chess-board such that no queen is attacked by any other queen. In case you aren’t familiar with chess, a queen can attack any square on the same row, column, or diagonal that the queen lies on, as illustrated in <a href="ch07.xhtml#ch7fig7">Figure 7-7</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig07.jpg"/></div>&#13;
<p class="figcap" id="ch7fig7"><em>Figure 7-7: A queen’s possible moves</em></p>&#13;
<p class="indent">The smallest value of <em>n</em> for which a solution exists is 4. The two possible solutions are shown in <a href="ch07.xhtml#ch7fig8">Figure 7-8</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig08.jpg"/></div>&#13;
<p class="figcap" id="ch7fig8"><em>Figure 7-8: Solutions to the 4-queens problem</em></p>&#13;
<p class="indent">One reason for the popularity of this problem is that the search graph is a tree, meaning that with a depth-first search, there’s no possibility that a state previously seen will be reached again (that is, once a queen is placed, it’s not possible to get to a state with fewer queens in subsequent steps). This avoids the annoying need to keep track of previous states to ensure they aren’t explored again.</p>&#13;
<p class="indent">A simple approach to this problem is to go column by column, testing each square in a column and continuing until a solution has been reached <span epub:type="pagebreak" id="page_184"/>(backtracking as required). For example, if we begin with <a href="ch07.xhtml#ch7fig9">Figure 7-9</a>, we can’t place a queen at b1 or b2, because it would be attacked by the queen at a1.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig09.jpg"/></div>&#13;
<p class="figcap" id="ch7fig9"><em>Figure 7-9: First queen at a1</em></p>&#13;
<p class="indent">The next available square that’s not attacked is b3, resulting in <a href="ch07.xhtml#ch7fig10">Figure 7-10</a>:</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig10.jpg"/></div>&#13;
<p class="figcap" id="ch7fig10"><em>Figure 7-10: Second queen at b3</em></p>&#13;
<p class="indent">But now when we get to column c, we’re stuck since every square in that column is attacked by one of the other queens. So we backtrack and move the queen in column b to b4 in <a href="ch07.xhtml#ch7fig11">Figure 7-11</a>:</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig11.jpg"/></div>&#13;
<p class="figcap" id="ch7fig11"><em>Figure 7-11: Second queen at b4</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_185"/>So now we can place a queen on c2 in <a href="ch07.xhtml#ch7fig12">Figure 7-12</a>:</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig12.jpg"/></div>&#13;
<p class="figcap" id="ch7fig12"><em>Figure 7-12: Third queen at c2</em></p>&#13;
<p class="indent">Alas, now there’s no spot for a queen on column d. So we backtrack all the way to column a and start over in <a href="ch07.xhtml#ch7fig13">Figure 7-13</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig13.jpg"/></div>&#13;
<p class="figcap" id="ch7fig13"><em>Figure 7-13: Backtrack to first queen at a2</em></p>&#13;
<p class="indent">The process continues in this manner until a solution is found.</p>&#13;
<h4 class="h4" id="ch00lev2sec_57"><strong><em>A Racket Solution</em></strong></h4>&#13;
<p class="noindent">We define the chessboard as an <em>n</em>-by-<em>n</em> array constructed from a mutable vector with <em>n</em> elements, each of which is also an <em>n</em>-element vector, where each element is either a 1 or a 0 (0 means the square is unoccupied; 1 means the square has a queen):</p>&#13;
<pre>(define (make-chessboard n)&#13;
  (let loop ([v n] [l '()])&#13;
    (if (zero? v)&#13;
        (list-&gt;vector l)&#13;
        (loop (sub1 v) (cons (make-vector n 0) l)))))</pre>&#13;
<p class="indent">To allow accessing elements of the chessboard <span class="literal">cb</span> by a row (<span class="literal">r</span>) and column (<span class="literal">c</span>) number, we define the following accessor forms, where <span class="literal">v</span> is the value being set or retrieved.</p>&#13;
<pre><span epub:type="pagebreak" id="page_186"/>(define (cb-set! cb r c v)&#13;
  (vector-set! (vector-ref cb c) r v))&#13;
&#13;
(define (cb-ref cb r c)&#13;
  (vector-ref (vector-ref cb c) r))</pre>&#13;
<p class="indent">Since we’re using a mutable data structure for the chessboard, we’ll need a mechanism to copy the board whenever a solution is found, to preserve the state of the board.</p>&#13;
<pre>(define (cb-copy cb)&#13;
  (for/vector ([v cb]) (vector-copy v)))</pre>&#13;
<p class="indent">We’ll of course need to be able to see the solutions, so we provide a print procedure:</p>&#13;
<pre>(define (cb-print cb)&#13;
  (let ([n (vector-length cb)])&#13;
    (for* ([r n]&#13;
           [c n])&#13;
      (when (zero? c) (newline))&#13;
      (let ([v (cb-ref cb r c)])&#13;
        (if (zero? v)&#13;
            (display " .")&#13;
            (display " Q")&#13;
            ))))&#13;
  (newline))</pre>&#13;
<p class="indent">The actual code to solve the problem, <span class="literal">dfs</span>, is a straightforward depth-first search. As solutions are found, they’re compiled into a list called <span class="literal">sols</span>, which is the return value of the function. In the code below, recall that in the <span class="literal">let loop</span> form, we’re employing a named <span class="literal">let</span> (which we described in <a href="ch03.xhtml">Chapter 3</a>) where we’re defining a function (<span class="literal">loop</span>) that we’ll call recursively.</p>&#13;
<pre>(define (dfs n)&#13;
  (let ([sols '()]&#13;
        [cb (make-chessboard n)])&#13;
    (let loop([r 0][c 0])&#13;
      (when (&lt; c n)&#13;
     <span class="ent">➊</span> (let ([valid (not (attacked cb r c))])&#13;
          (when valid&#13;
         <span class="ent">➋</span> (cb-set! cb r c 1)&#13;
         <span class="ent">➌</span> (if (= c (sub1 n))&#13;
              (let ([copy (cb-copy cb)])&#13;
             <span class="ent">➍</span> (set! sols (cons copy sols)))&#13;
           <span class="ent">➎</span> (loop 0 (add1 c)))&#13;
         <span class="ent">➏</span> (cb-set! cb r c 0))&#13;
       <span class="ent">➐</span> (when (&lt; (add1 r) n) (loop (add1 r) c)))))&#13;
 <span class="ent">➑</span> sols))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_187"/>The code first tests each position to see whether the current cell is being attacked by any of the queens that have already been placed on the board <span class="ent">➊</span> (the code for <span class="literal">attacked</span> will be described shortly); if not, then that cell is marked as <span class="literal">valid</span>, and a queen (the number 1) is placed on that square <span class="ent">➋</span>. Next we test whether the current square is in the final column of the board <span class="ent">➌</span>; if it is, we’ve found a solution, so a copy of the board is placed in <span class="literal">sols</span> <span class="ent">➍</span>. If we’re not on the last column, we then nest down to the next level (that is, the next column) <span class="ent">➎</span>. Finally, the valid square is cleared <span class="ent">➏</span> so that additional rows in the column can be tested <span class="ent">➐</span>. Once all the solutions have been found, they’re returned <span class="ent">➑</span>.</p>&#13;
<p class="indent">Where the DFS backtracking occurs in this process is a bit subtle. Suppose we’re at a position that is under attack by the previously placed queens, so <span class="literal">valid</span> <span class="ent">➊</span> is false and execution falls through <span class="ent">➐</span>. Now suppose we’re also on the last row. In that case, the test fails <span class="ent">➐</span>, so no further looping occurs and the recursive call returns. Either there are no following statements, in which case the entire loops exits, or there there additional statements to execute after returning from the recursive call. This can only occur where the current position is cleared and we’re at a previous location <span class="ent">➏</span>. This is the backtrack point. Execution then resumes at the last <span class="literal">when</span> statement <span class="ent">➐</span>.</p>&#13;
<p class="indent">The following function tests whether a square is under attack by any of the previously placed queens. It only checks the columns prior to the current column since the other columns of the chessboard haven’t yet been populated.</p>&#13;
<pre>(define (attacked cb r c)&#13;
  (let ([n (vector-length cb)])&#13;
    (let loop ([ac (sub1 c)])&#13;
      (if (&lt; ac 0) #f&#13;
          (let ([r1 (+ r (- c ac))]&#13;
                [r2 (+ r (- ac c))])&#13;
            (if (or (= 1 (cb-ref cb r ac))&#13;
                    (and (&lt; r1 n) (= 1 (cb-ref cb r1 ac)))&#13;
                    (and (&gt;= r2 0) (= 1 (cb-ref cb r2 ac))))&#13;
                #t&#13;
                (loop (sub1 ac))))))))</pre>&#13;
<p class="indent">To output the solutions, we define a simple routine to iterate through and print each solution returned by <span class="literal">dfs</span>.</p>&#13;
<pre>(define (solve n)&#13;
  (for ([cb (dfs n)]) (cb-print cb)))</pre>&#13;
<p class="indent">Here are a couple of test runs.</p>&#13;
<pre>&gt; <span class="codestrong1">(solve 4)</span>&#13;
&#13;
 . Q . .&#13;
 . . . Q&#13;
 Q . . .&#13;
 . . Q .&#13;
 <span epub:type="pagebreak" id="page_188"/>. . Q .&#13;
 Q . . .&#13;
 . . . Q&#13;
 . Q . .&#13;
 &#13;
&gt; <span class="codestrong1">(solve 5)</span>&#13;
&#13;
 . . Q . .   . . . Q .  . . . . Q   . Q . . .   . . . . Q&#13;
 . . . . Q   . Q . . .  . Q . . .   . . . . Q   . . Q . .&#13;
 . Q . . .   . . . . Q  . . . Q .   . . Q . .   Q . . . .&#13;
 . . . Q .   . . Q . .  Q . . . .   Q . . . .   . . . Q .&#13;
 Q . . . .   Q . . . .  . . Q . .   . . . Q .   . Q . . .&#13;
&#13;
 . Q . . .   . . . Q .   . . Q . .   Q . . . .  Q . . . .&#13;
 . . . Q .   Q . . . .   Q . . . .   . . Q . .  . . . Q .&#13;
 Q . . . .   . . Q . .   . . . Q .   . . . . Q  . Q . . .&#13;
 . . Q . .   . . . . Q   . Q . . .   . Q . . .  . . . . Q&#13;
 . . . . Q   . Q . . .   . . . . Q   . . . Q .  . . Q . .&#13;
&#13;
&gt; <span class="codestrong1">(solve 8)</span>&#13;
&#13;
 . . Q . . . . .&#13;
 . . . . . Q . .&#13;
 . . . Q . . . .&#13;
 . Q . . . . . .&#13;
 . . . . . . . Q&#13;
 . . . . Q . . .&#13;
 . . . . . . Q .&#13;
 Q . . . . . . .&#13;
        &#13;
<span class="codeitalic1">&lt;intermediate solutions omitted&gt;</span>&#13;
        &#13;
 Q . . . . . . .&#13;
 . . . . . . Q .&#13;
 . . . . Q . . .&#13;
 . . . . . . . Q&#13;
 . Q . . . . . .&#13;
 . . . Q . . . .&#13;
 . . . . . Q . .&#13;
 . . Q . . . . .</pre>&#13;
<h3 class="h3" id="ch00lev1sec_43"><span epub:type="pagebreak" id="page_189"/>Dijkstra’s Shortest Path Algorithm</h3>&#13;
<p class="noindent">Given a graph with a node designated as the start node, Edsger Dijkstra’s algorithm finds the shortest path to any other node. The algorithm works by first assigning all the nodes (except the start node, which has distance zero) an infinite distance. As the algorithm progresses, the node distances are refined until their true distance can be determined.</p>&#13;
<p class="indent">We’ll use the weighted graph introduced in <a href="ch07.xhtml#ch7fig3">Figure 7-3</a> earlier to illustrate Dijkstra’s algorithm (where <em>S</em> is the starting node). The algorithm we describe will employ something called a priority queue. A <em>priority queue</em> is similar to a regular queue, but in a priority queue, each item has an associated value, called its priority, that controls its order in the queue. Instead of following a first-in, first-out sequence, items with a higher priority are ordered ahead of other items. Since we’re interested in finding the shortest path, shorter distances will be given a higher priority than longer ones.</p>&#13;
<p class="indent">The following diagram in <a href="ch07.xhtml#ch7fig14">Figure 7-14</a> illustrates the starting conditions of the algorithm.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig14.jpg"/></div>&#13;
<p class="figcap" id="ch7fig14"><em>Figure 7-14: Starting conditions for finding the shortest paths from <span class="normal">S</span></em></p>&#13;
<p class="indent">Node distances from the start node are given just outside the node circle. Nodes that haven’t been visited are assigned a tentative distance value of infinity (except for the start node, which has a value of zero). The queue shows the nodes with distance values indicated by exponents.</p>&#13;
<p class="indent">The first step is to pop the first node in the queue (which will always have a known distance) and color it with a light background as shown here in <a href="ch07.xhtml#ch7fig15">Figure 7-15</a>. Set this node as the current node, <em>u</em> (in this case <em>u</em> = <em>S</em> with a distance value of zero).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_190"/><img alt="Image" src="../images/07fig15.jpg"/></div>&#13;
<p class="figcap" id="ch7fig15"><em>Figure 7-15: Step 1 of Dijkstra’s algorithm</em></p>&#13;
<p class="indent">The neighbors of <em>u</em> are given in a darker color. We then perform the following tentative distance calculation, <em>t</em>, for each neighbor (designated <em>v</em>) of <em>u</em> that’s still in the queue, where <em>d</em>(<em>u</em>) is the known distance from the start node to <em>u</em>, and <em>l</em>(<em>u</em>, <em>v</em>) is the distance value of the edge from <em>u</em> to <em>v</em>:</p>&#13;
<div class="image1"><img alt="Image" src="../images/07eqa01.jpg"/></div>&#13;
<p class="indent">If <em>t</em> is less than the prior distance value (initially <em>∞</em>), the queue is updated with the new node distance.</p>&#13;
<p class="indent">With the queue updated, we repeat the process, this time popping <em>c</em> off the queue, making it the current node (in other words, <em>u</em> = <em>c</em>), and updating the queue and neighbor distances as before. The state of the graph is then as follows in <a href="ch07.xhtml#ch7fig16">Figure 7-16</a>:</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig16.jpg"/></div>&#13;
<p class="figcap" id="ch7fig16"><em>Figure 7-16: Step 2 of Dijkstra’s algorithm</em></p>&#13;
<p class="indent">We show the path from <em>S</em> to <em>c</em> in a thicker gray line to indicate a known shortest path in <a href="ch07.xhtml#ch7fig16">Figure 7-16</a>. The sequence of diagrams in <a href="ch07.xhtml#ch7fig17">Figure 7-17</a> illustrates the remainder of the process. Notice that in <a href="ch07.xhtml#ch7fig17">Figure 7-17</a>a the original distance of node <em>a</em> has been updated from 12 to 9 based on the path now being from <em>S</em> through <em>b</em> to <em>a</em>. The thick lines in 7-17d, the final graph, form a tree structure reflecting all the shortest paths originating from node <em>S</em> to the remaining nodes.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_191"/><img alt="Image" src="../images/07fig17.jpg"/></div>&#13;
<p class="figcap" id="ch7fig17"><em>Figure 7-17: The rest of Dijkstra’s algorithm</em></p>&#13;
<p class="indent">We’re usually interested in how efficiently an algorithm performs. This is generally specified by a <em>complexity</em> value. There are a number of ways this can be done, but a popular formulation is called <em>Big O notation</em> (the O stands for “order of"). This notation aims to give a gross approximation of how efficiently an algorithm performs (in terms of running time or memory usage) based on the size of its inputs. Dijkstra’s algorithm has a running time complexity of <em>O</em>(<em>N</em><sup>2</sup>), where <em>N</em> is the number of nodes in the graph. This means the running time increases as the square of the number of inputs. In other words, if we double the number of nodes, the algorithm will take about four times as long to run. This is taken to be an upper-bound or worst-case scenario, and depending on the nature of the graph, the runtime could be less.</p>&#13;
<h4 class="h4" id="ch00lev2sec_58"><strong><em>The Priority Queue</em></strong></h4>&#13;
<p class="noindent">As we’ve seen in the analysis above, a priority queue plays a key role in Dijkstra’s algorithm. Priority queues can be implemented in a number of ways, but one popular approach is to use something called a binary heap. A <em>binary heap</em> is a binary tree structure (meaning each node has a maximum of two <span epub:type="pagebreak" id="page_192"/>children) where each node’s value is greater than or equal to its child nodes. This type of heap is called a <em>max-heap</em>. It’s also possible for each parent node to be less than or equal to its child nodes. This type of heap is called a <em>min-heap</em>. An example of such a heap is shown in <a href="ch07.xhtml#ch7fig18">Figure 7-18</a>. The top or root node is always the first to be removed since it’s considered to have the highest priority. After nodes are added to or removed from the heap, the remaining nodes are rearranged to maintain the proper priority order. While it’s not terribly difficult to build a binary heap object, Racket already has one available in the <em>data/heap</em> library.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig18.jpg"/></div>&#13;
<p class="figcap" id="ch7fig18"><em>Figure 7-18: Min-heap</em></p>&#13;
<p class="indent">Our heap entries won’t be just numbers: we’ll need to track the node and its current distance value (which determines its priority). So each heap entry will consist of a pair where the first element is the node and the second element is the current distance. When a Racket heap is constructed, it must be supplied with a function that will do the proper comparison when given two node entries. We accomplish this with the following code. The <span class="literal">comp</span> function only compares the second element of each pair since that’s what determines the priority.</p>&#13;
<pre>#lang racket&#13;
(require data/heap)&#13;
&#13;
(define (comp n1 n2)&#13;
  (let ([d1 (cdr n1)]&#13;
        [d2 (cdr n2)])&#13;
    (&lt;= d1 d2)))&#13;
&#13;
(define queue (make-heap comp))</pre>&#13;
<p class="indent">To save a bit of typing, we create a few simple helper functions.</p>&#13;
<pre>(define (enqueue n) (heap-add! queue n))&#13;
&#13;
(define (dequeue)&#13;
  (let ([n (heap-min queue)])&#13;
    (heap-remove-min! queue)&#13;
    n))&#13;
&#13;
<span epub:type="pagebreak" id="page_193"/>(define (update-priority s p)&#13;
  (let ([q (for/first ([x (in-heap queue)] #:when (equal? s (car x))) x)])&#13;
    (heap-remove! queue q)&#13;
    (enqueue (cons s p))))&#13;
&#13;
(define (peek-queue) (heap-min queue))&#13;
&#13;
(define (queue-&gt;list) (for/list ([n (in-heap queue)]) n))&#13;
 &#13;
(define (in-queue? s)&#13;
  (for/or ([x (in-heap queue)]) (equal? (car x) s)))</pre>&#13;
<p class="indent">The <span class="literal">update-priority</span> procedure takes a symbol and a new priority to update the queue. It does this by removing (dequeuing) the old value and adding (enqueuing) a new value. The <span class="literal">heap-remove!</span> function performs very efficiently, but it needs the exact value (pair with symbol and priority) to work. Unfortunately, without knowing the priority, we have to resort to a linear search through the entire queue to find the symbol via the <span class="literal">in-heap</span> sequence. This can be optimized by storing (in another data structure like a hash table) the symbol and current priority. We leave it to the reader to perform this added step if desired.</p>&#13;
<p class="indent">Here are some examples of the priority queue in action.</p>&#13;
<pre>&gt; <span class="codestrong1">(enqueue '(a . 12))</span>&#13;
&gt; <span class="codestrong1">(enqueue '(b . 8))</span>&#13;
&gt; <span class="codestrong1">(enqueue '(c . 6))</span>&#13;
&gt; <span class="codestrong1">(queue-&gt;list)</span>&#13;
'((c . 6) (b . 8) (a . 12))&#13;
&#13;
&gt; <span class="codestrong1">(in-queue? 'b)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(in-queue? 'x)</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(update-priority 'a 9)</span>&#13;
&gt; <span class="codestrong1">(queue-&gt;list)</span>&#13;
'((c . 6) (b . 8) (a . 9))&#13;
&#13;
&gt; <span class="codestrong1">(dequeue)</span>&#13;
'(c . 6)&#13;
&#13;
&gt; <span class="codestrong1">(queue-&gt;list)</span>&#13;
'((b . 8) (a . 9))&#13;
&#13;
&gt; <span class="codestrong1">(peek-queue)</span>&#13;
'(b . 8)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_194"/>Regardless of the order the values were added to the queue, they’re stored and removed in priority order.</p>&#13;
<h4 class="h4" id="ch00lev2sec_59"><strong><em>The Implementation</em></strong></h4>&#13;
<p class="noindent">We define our graph as a list of edges. Each edge in the list consists of the end nodes along with the distance between nodes.</p>&#13;
<pre>(define edge-list&#13;
  '((S a 12)&#13;
    (S b 8)&#13;
    (S c 6)&#13;
    (a b 1)&#13;
    (b c 9)&#13;
    (a e 8)&#13;
    (e d 5)&#13;
    (b d 10)&#13;
    (c d 13)))</pre>&#13;
<p class="indent">As we progress through the algorithm, we want to to keep track of the current parent of each node so that when the algorithm completes, we’ll be able to reproduce the shortest path to each node. A hash table will be used to maintain this information. The key is a node name and the value is the name of the parent node.</p>&#13;
<pre>(define parent (make-hash))</pre>&#13;
<p class="indent">We need to take care in our coding to be mindful of the fact that our graph is bi-directional, and an edge defined by (<em>a</em>, <em>b</em>) is equivalent to one defined by (<em>b</em>, <em>a</em>). We’ll account for this by supplementing the original edge list with a list consisting of the nodes reversed. We’ll also use a hash table (<span class="literal">lengths</span>) to maintain the lengths of each edge and an additional hash table (<span class="literal">dist</span>) to record the shortest distance to each node as it’s discovered. To pull all this together, we define <span class="literal">init-graph</span>, which takes an edge list and returns the original list appended with the swapped node list. It will also be used to initialize the priority queue and the various hash tables.</p>&#13;
<pre>(define lengths (make-hash))&#13;
(define dist (make-hash))&#13;
&#13;
(define (init-graph start-node edges)&#13;
  (let* ([INFINITY 9999]&#13;
         [swapped (map (λ (e) (list (second e) (first e) (third e))) edges)] &#13;
         [all-edges (append edges swapped)]&#13;
         [nodes (list-&gt;set (map (λ (e) (first e)) all-edges))])&#13;
    <span epub:type="pagebreak" id="page_195"/>(hash-clear! lengths)&#13;
    (for ([e all-edges]) (hash-set! lengths (cons (first e) (second e)) (third e)))&#13;
    (set! queue (make-heap comp))&#13;
    (hash-clear! parent)&#13;
    (hash-clear! dist)&#13;
    (for ([n nodes])&#13;
      (hash-set! parent n null)&#13;
      (hash-set! dist n INFINITY)&#13;
      (if (equal? n start-node)&#13;
          (enqueue (cons start-node 0))&#13;
          (enqueue (cons n INFINITY))))&#13;
    (hash-set! dist start-node 0)&#13;
    all-edges))</pre>&#13;
<p class="indent">Here’s the code, <span class="literal">dijkstra</span>, that actually computes the shortest paths for each node.</p>&#13;
<pre>(define (dijkstra start-node edges)&#13;
  (let ([graph (init-graph start-node edges)])&#13;
 <span class="ent">➊</span> (define (neighbors n)&#13;
      (filter&#13;
       (λ (e) (and (equal? n (first e)) (in-queue? (second e))))&#13;
       graph))&#13;
 <span class="ent">➋</span> (let loop ()&#13;
      (let* ([u (car (dequeue))])&#13;
        (for ([n (neighbors u)])&#13;
       <span class="ent">➌</span> (let* ([v (second n)]&#13;
              <span class="ent">➍</span> [t (+ (hash-ref dist u) (hash-ref lengths (cons u v)))])&#13;
    <span class="ent">➎</span> (when (&lt; t (hash-ref dist v))&#13;
           <span class="ent">➏</span> (hash-set! dist v t)&#13;
           <span class="ent">➐</span> (hash-set! parent v u)&#13;
           <span class="ent">➑</span> (update-priority v t)))))&#13;
   <span class="ent">➒</span> (when (&gt; (heap-count queue) 0) (loop)))))</pre>&#13;
<p class="indent">The <span class="literal">dijkstra</span> code takes the starting node symbol and edge list as arguments. It then defines <span class="literal">graph</span>, which is the original list of edges appended with a list of the edges with the nodes swapped. As mentioned, the <span class="literal">init-graph</span> procedure also initializes all the other data structures required for the algorithm to work. A local <span class="literal">neighbors</span> function is defined <span class="ent">➊</span> that takes a node and returns the list of nodes that are adjacent to the node and still in the queue. The main loop starts <span class="ent">➋</span> and the first step is to pop the first node in the queue and assign its symbol to <span class="literal">u</span>. Next, each of its neighbors (<span class="literal">v</span>) is processed <span class="ent">➌</span>. For each neighbor, we compute <em>t</em> = <em>d</em>(<em>u</em>) + <em>l</em>(<em>u</em>, <em>v</em>) <span class="ent">➍</span> (recall that <em>d</em>(<em>u</em>) is the most current distance estimate from the start symbol to <em>u</em>, and <em>l</em>(<em>u</em>, <em>v</em>) is the length of the edge from <em>u</em> to <em>v</em>). We then test whether <em>t</em> &lt; <em>d</em>(<em>v</em>) <span class="ent">➎</span>, and if it passes the test, we do the following:</p>&#13;
<ol>&#13;
<li class="noindent">Assign <em>d</em>(<em>v</em>) = <em>t</em>  <span class="ent">➏</span>.</li>&#13;
<li class="noindent">Assign <em>u</em>  as the parent of <em>v</em>  <span class="ent">➐</span>.</li>&#13;
<li class="noindent">Update the queue with <em>t</em>  as the new priority of <em>v</em>  <span class="ent">➑</span>.</li>&#13;
</ol>&#13;
<p class="indent">Finally, we test whether any values remain on the heap, and if so, repeat the process <span class="ent">➒</span>. Once the algorithm completes, <span class="literal">parent</span> will contain the parent of <span epub:type="pagebreak" id="page_196"/>each node. All that remains is to chase the chain of parents to the start symbol to determine the shortest path to the node. This is done by the following <span class="literal">get-path</span> function:</p>&#13;
<pre>(define (get-path n)&#13;
  (define (loop n)&#13;
    (if (equal? null n)&#13;
        null&#13;
        (let ([p (hash-ref parent n)])&#13;
          (cons n (loop p)))))&#13;
  (reverse (loop n)))</pre>&#13;
<p class="indent">The <span class="literal">show-paths</span> procedure will print out paths for all the nodes.</p>&#13;
<pre>(define (show-paths)&#13;
  (for ([n (hash-keys parent)])&#13;
    (printf "  ~a: ~a\n" n (get-path n))))</pre>&#13;
<p class="indent">For convenience we define <span class="literal">solve</span>, which takes a starting symbol and edge list, calls <span class="literal">dijkstra</span> to compute the shortest paths, and prints out the shortest path to each node.</p>&#13;
<pre>(define (solve start-node edges)&#13;
  (dijkstra start-node edges)&#13;
  (displayln "Shortest path listing:")&#13;
  (show-paths))</pre>&#13;
<p class="indent">Given our original graph where we defined the edges in <span class="literal">edge-list</span> above, and starting symbol <span class="literal">S</span>, we generate the solutions as follows:</p>&#13;
<pre>&gt; <span class="codestrong1">(solve 'S edge-list)</span>&#13;
Shortest path listing:&#13;
  S: (S)&#13;
  e: (S b a e)&#13;
  a: (S b a)&#13;
  d: (S b d)&#13;
  c: (S c)&#13;
  b: (S b)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_197"/>Let’s try this slightly more ambitious example in <a href="ch07.xhtml#ch7fig19">Figure 7-19</a> (see [<strong>4</strong>]).</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig19.jpg"/></div>&#13;
<p class="figcap" id="ch7fig19"><em>Figure 7-19: Another graph to test Dijkstra’s algorithm on</em></p>&#13;
<p class="indent">The edge list for this graph is . . .</p>&#13;
<pre>&gt; <span class="codestrong1">(define edges '((v a 4) (v b 15) (v c 6) (a b 12) (b c 9) (b d 8) (a f 10) (&#13;
     c v 6) (c g 13) (g h 6) (h w 3) (a d 3) (d e 5) (b e 2) (e w 16) (b g 4)&#13;
     (g e 8) (e h 16) (e f 3) (f w 14)))</span></pre>&#13;
<p class="indent">So, solving for the shortest path, we have . . .</p>&#13;
<pre>&gt; <span class="codestrong1">(solve 'v edges)</span>&#13;
Shortest path listing:&#13;
  d: (v a d)&#13;
  w: (v a d e b g h w)&#13;
  f: (v a f)&#13;
  c: (v c)&#13;
  v: (v)&#13;
  a: (v a)&#13;
  e: (v a d e)&#13;
  g: (v a d e b g)&#13;
  h: (v a d e b g h)&#13;
  b: (v a d e b)</pre>&#13;
<p class="indent">We’ve highlighted the tree of shortest paths in the resulting graph (see <a href="ch07.xhtml#ch7fig20">Figure 7-20</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_198"/><img alt="Image" src="../images/07fig20.jpg"/></div>&#13;
<p class="figcap" id="ch7fig20"><em>Figure 7-20: Shortest paths found</em></p>&#13;
<p class="indent">Now that we’ve thoroughly examined Dijkstra’s shortest-path algorithm, we’ll next take a look at the A* algorithm via Sam Loyd’s (in)famous 14–15 puzzle.</p>&#13;
<h3 class="h3" id="ch00lev1sec_44">The 15 Puzzle</h3>&#13;
<p class="noindent">The 15 puzzle consists of 15 sequentially numbered sliding tiles in a square frame that are randomly scrambled, with the goal of getting them back into their proper numerical sequence. In the late 1800’s Sam Loyd created a bit of buzz over this puzzle by offering a $1,000 prize for anyone who could demonstrate a way to start with a puzzle with all the tiles in order, except with the 14 and 15 tiles reversed (as shown in <a href="ch07.xhtml#ch7fig21">Figure 7-21</a>, Loyd called this arrangement the “14-15 Puzzle”), and get them back in their proper order (without removing the tiles from the case, of course). As we’ll see shortly, this is mathematically impossible, so Loyd knew his money was safe.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig21.jpg"/></div>&#13;
<p class="figcap" id="ch7fig21"><em>Figure 7-21: Sam Loyd’s 14–15 puzzle illustration</em></p>&#13;
<h5 class="h5" id="ch00lev3sec_51"><strong>Why Swapping Just Two Tiles Is Impossible</strong></h5>&#13;
<p class="noindent">To get an idea of why Loyd’s money was safe (that is, why it’s not possible to exchange two and only two tiles), consider the puzzle in its solved state as shown in <a href="ch07.xhtml#ch7fig22">Figure 7-22</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_199"/><img alt="Image" src="../images/07fig22.jpg"/></div>&#13;
<p class="figcap" id="ch7fig22"><em>Figure 7-22: Solved 15 puzzle</em></p>&#13;
<p class="indent">Any sequence of moves that would reverse the 14 and 15 tiles would produce the arrangement in Loyd’s puzzle. Simply reproducing this sequence would get the tiles back in order. We’ll see that this is impossible. Now consider the arrangement in <a href="ch07.xhtml#ch7fig23">Figure 7-23</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig23.jpg"/></div>&#13;
<p class="figcap" id="ch7fig23"><em>Figure 7-23: 15 puzzle with inversions</em></p>&#13;
<p class="indent">If we arrange these tiles linearly, we have 2, 3, 1, 4, 5, 6, . . . In particular, the values of tile-2 and tile-3 are larger than tile-1, which follows them. Each such situation, where the value of a tile is larger than one that follows it, is called an <em>inversion</em> (two inversions in this case).</p>&#13;
<p class="indent">Related to the idea of inversion is that of <em>transposition</em>. A transposition is simply the exchange of two values in a sequence. A given arrangement can be arrived at by any number of transpositions. For example, one way to get to the sequence 2, 3, 1, 4, 5, 6, . . . would be as follows.</p>&#13;
<ol>&#13;
<li class="noindent">Starting arrangement: 1, 2, 3, 4, 5, 6, . . .</li>&#13;
<li class="noindent">Transpose 1 and 3: 3, 2, 1, 4, 5, 6, . . .</li>&#13;
<li class="noindent">Transpose 2 and 3: 2, 3, 1, 4, 5, 6, . . .</li>&#13;
</ol>&#13;
<p class="indent">The key idea is that an arrangement consisting of an even number of inversions will always be generated by an even number of transpositions, and an arrangement with an odd number of inversions will always be generated by an odd number of transpositions. For reference purposes, the empty slot will be treated as a tile and designated with the number 16. Any single movement by tile-16 is a transposition. If tile-16 leaves from the lower right corner and arrives at a particular spot using an odd number of transpositions, it will require an odd number of transpositions to get back to the starting location, or a net even number of transpositions. This leaves the puzzle with an even number of inversions.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_200"/>The arrangement Sam Loyd proposes is impossible to solve since it involves a single odd inversion. It’s also true, but trickier to prove, that any puzzle with an even number of inversions is solvable.</p>&#13;
<p class="indent">Having resolved this historical issue with Sam Loyd’s puzzle, we now turn our attention to finding solutions for puzzles that are in fact solvable. In this regard we’ll now explore the A* search algorithm (we mostly abbreviate this to simply the “A* algorithm” hereafter).</p>&#13;
<h4 class="h4" id="ch00lev2sec_60"><strong><em>The A* Search Algorithm</em></strong></h4>&#13;
<p class="noindent">We’ll of course assume that the computer is presented with a solvable puzzle (that is, it has an even number of inversions). The computer should provide a solution that’s as efficient as possible—that is, a solution that requires the smallest number of moves to get to the goal state. One method that generally provides good results is called the <em>A* search</em> algorithm. An advantage of the A* algorithm over a simple breadth-first or depth-first search is that it uses a <em>heuristic</em><sup><a href="footnote.xhtml#ch07foot_1" id="ch07foot1">1</a></sup> to reduce the search space. It does this by computing an <em>estimated</em> cost of taking any given branch in the search tree. It iteratively improves this estimate until it determines the best solution or it determines no solution can be found. Estimates are stored in a priority queue where the least cost state is at the head of the list.</p>&#13;
<p class="indent">We’ll begin our analysis by looking at a smaller variant of the 15 puzzle, called the 8 puzzle. The 8 puzzle in its solved state is shown in <a href="ch07.xhtml#ch7fig24">Figure 7-24</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_201"/><img alt="Image" src="../images/07fig24.jpg"/></div>&#13;
<p class="figcap" id="ch7fig24"><em>Figure 7-24: Solved 8 puzzle</em></p>&#13;
<p class="indent">The search tree of the 8 puzzle can be modeled as shown in <a href="ch07.xhtml#ch7fig25">Figure 7-25</a>, where each node of the tree is a state of the puzzle, and the child nodes are the possible states that can arise from a valid move.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig25.jpg"/></div>&#13;
<p class="figcap" id="ch7fig25"><em>Figure 7-25: Partial 8 puzzle game tree</em></p>&#13;
<p class="indent">At each iteration of the A* algorithm, it computes an estimate of the cost (that is, the number of moves) to get to the goal state. Formally, it attempts to minimize the following estimated cost function, where <em>n</em> is the node under consideration, <em>g</em>(<em>n</em>) is the cost of the path from the start node to <em>n</em>, and <em>h</em>(<em>n</em>) is a heuristic that estimates the cost of the cheapest path from <em>n</em> to the goal:</p>&#13;
<p class="center"><em>f(n)</em> = <em>g(n)</em> + <em>h(n)</em></p>&#13;
<p class="indent">Designing a good heuristic function is something of an art. To get the best performance from the A* algorithm, an important characteristic of the heuristic is that it satisfies the following condition for every edge in the graph, where <em>h</em><sup>*</sup>(<em>n</em>) is the actual (but unknown) cost to reach the goal state:</p>&#13;
<div class="image1"><img alt="Image" src="../images/07eqa02.jpg"/></div>&#13;
<p class="noindent">If a heuristic meets this condition, it’s said to be <em>admissible</em>, and the A* algorithm is guaranteed to find the optimal solution.</p>&#13;
<p class="indent">One possible heuristic for the 8 puzzle uses something called the <em>Manhattan distance</em> (as opposed to the familiar straight-line distance). For example, to get the tile-2 in <a href="ch07.xhtml#ch7fig25">Figure 7-25</a> to its home location (the cell it would occupy in the solved state), the tile would have to move up two squares and one square to the left for a total of three moves—this is the Manhattan distance. The heuristic value for a puzzle state would be the sum of the Manhattan distances for each tile. <a href="ch07.xhtml#ch7tab1">Table 7-1</a> shows the computation of this value for the root node of <a href="ch07.xhtml#ch7fig25">Figure 7-25</a>.</p>&#13;
<p class="tabcap" id="ch7tab1"><strong>Table 7-1</strong>: Computing Manhattan Distance</p>&#13;
<table class="table1">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong><span epub:type="pagebreak" id="page_202"/>Tile</strong></p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Rows</strong></p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Cols.</strong></p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Total</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">4</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">5</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">6</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">7</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">8</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-h1" colspan="3" style="vertical-align: top;"><p class="tabac">Distance:</p></td>&#13;
<td class="table-h1" style="vertical-align: top;"><p class="taba">15</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The Manhattan distance will always be less than or equal to the actual number of moves, so it satisfies the admissibility condition.</p>&#13;
<p class="indent">A slightly weaker heuristic is the <em>Hamming distance</em>, which is just the number of misplaced tiles. The Hamming distance for the puzzle shown in <a href="ch07.xhtml#ch7fig25">Figure 7-25</a> is eight: none of the tiles are in their home location.</p>&#13;
<p class="indent">In <a href="ch07.xhtml#ch7fig26">Figure 7-26</a> we’ve annotated each node with three values. The first value is the depth of the game tree (this value is incremented by one for each level and constitutes the value of <em>g</em>(<em>n</em>) in the cost formula), the second value is the heuristic value, <em>h</em>(<em>n</em>), for the node (the Manhattan distance in this case), and the third value is the sum of the two giving the overall cost score for the node.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_203"/><img alt="Image" src="../images/07fig26.jpg"/></div>&#13;
<p class="figcap" id="ch7fig26"><em>Figure 7-26: 8 puzzle with node costs</em></p>&#13;
<p class="indent">The A* algorithm uses a priority queue called <em>open</em>. This queue orders the puzzle states that have been examined but whose child nodes have not been expanded, according to the estimated cost to reach the goal. The algorithm also relies on a dictionary, called <em>closed</em>, that uses the puzzle state as a key and maintains the most recent cost value for the node. <a href="ch07.xhtml#ch7fig27">Figure 7-27</a> reflects the current state of the analysis, where the first node in the open queue is the root node of <a href="ch07.xhtml#ch7fig26">Figure 7-26</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig27.jpg"/></div>&#13;
<p class="figcap" id="ch7fig27"><em>Figure 7-27: Closed and open</em></p>&#13;
<p class="indent">The values shown at the top of the closed nodes are the latest estimated costs. The values at the top of the open nodes are the same three cost values described above. With this introduction we walk through an iteration of how the A* algorithm processes the game tree.</p>&#13;
<p class="indent">The first step is to pop the lowest-priority value off the open queue. This node is then added to the closed dictionary. The next step is to compute the costs for the child nodes, which are shown on the second level of <a href="ch07.xhtml#ch7fig26">Figure 7-26</a>. If any of these nodes are not on the closed list, they are simply queued to open with no further analysis. Notice that the first child node <em>is</em> on the closed list. Since its current estimated cost is less than the cost on the closed list, it’s removed from the closed list and the node is added back to the queue with its new value. In the situation where a child node is on the closed list, but its estimated value is <em>larger</em> than the value on the closed list, no change is made, and it’s not added to the queue. Once this phase is complete, the open and closed structures will appear as shown in <a href="ch07.xhtml#ch7fig28">Figure 7-28</a>.</p>&#13;
<p class="indent">Since the first child node in <a href="ch07.xhtml#ch7fig26">Figure 7-26</a> has a lower cost than the other nodes in the open queue, it moves to the head of the queue and becomes the next item to be popped off. Notice that its first child is already in the closed list, but its newly computed cost is higher than the cost in the closed list, so it’s ignored. The remaining child node would be processed as before.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_204"/><img alt="Image" src="../images/07fig28.jpg"/></div>&#13;
<p class="figcap" id="ch7fig28"><em>Figure 7-28: Closed and open, updated</em></p>&#13;
<p class="indent">The process continues until one of two things happens: either a node is popped off the open queue that’s in the solved state, in which case the algorithm completes and prints the answer (details on how this is accomplished are described in the next section), or the open queue becomes empty, which indicates that the puzzle was not solvable.</p>&#13;
<h4 class="h4" id="ch00lev2sec_61"><strong><em>The 8-Puzzle in Racket</em></strong></h4>&#13;
<p class="noindent">We’ll begin by implementing a solution to the smaller 3-by-3 version of the puzzle before we move on the full 4-by-4 version.</p>&#13;
<p class="indent">As with Dijkstra’s algorithm, we’ll use Racket’s heap object for the open priority queue:</p>&#13;
<pre>#lang racket&#13;
(require data/heap)&#13;
&#13;
(define (comp n1 n2)&#13;
  (let ([d1 (cdr n1)]&#13;
        [d2 (cdr n2)])&#13;
    (&lt;= d1 d2)))&#13;
&#13;
(define queue (make-heap comp))&#13;
&#13;
(define (enqueue n) (heap-add! queue n))&#13;
&#13;
(define (dequeue)&#13;
  (let ([n (heap-min queue)])&#13;
    (heap-remove-min! queue)&#13;
    n))</pre>&#13;
<p class="indent">A <span class="literal">SIZE</span> constant will specify the number of rows and columns in the puzzle. In addition we’ll define a number of utility functions to work with the puzzle structure. For efficiency, the puzzle state will be stored internally as <span epub:type="pagebreak" id="page_205"/>a Racket vector of size <span class="literal">SIZE*SIZE+2</span>. The last two elements of the vector will contain the row and column of the empty cell. The empty cell will have the numerical value specified by <span class="literal">(define empty (sqr SIZE))</span>. To this end, we have the following:</p>&#13;
<pre>(define SIZE 3)&#13;
(define empty (sqr SIZE))&#13;
  &#13;
(define (ref puzzle r c)&#13;
  (let ([i (+ c (* r SIZE))])&#13;
    (vector-ref puzzle i)))&#13;
&#13;
(define (empty-loc puzzle)&#13;
  (values&#13;
   (vector-ref puzzle empty)&#13;
   (vector-ref puzzle (add1 empty))))</pre>&#13;
<p class="indent">The <span class="literal">ref</span> function will take a puzzle along with and a row and column number as arguments. It returns the tile number at that location. The <span class="literal">empty-loc</span> function will return two values that give the row and column respectively of the empty cell.</p>&#13;
<p class="indent">The following functions are used to compute the Manhattan distance. The first creates a hash table used to look up the home location of a tile given the tile number. The second function computes the sum of the Manhattan distances for each tile in the puzzle. This will be used in the computation of the cost of a puzzle node.</p>&#13;
<pre>(define tile-homes&#13;
  (let ([hash (make-hash)])&#13;
    (for ([n (in-range (sqr SIZE))])&#13;
      (hash-set! hash (add1 n) (cons (quotient n SIZE) (remainder n SIZE))))&#13;
    hash))&#13;
  &#13;
(define (manhattan puzzle) &#13;
  (let ([dist 0])&#13;
    (for* ([r SIZE] [c SIZE])&#13;
      (when (not (= empty (ref puzzle r c)))&#13;
        (let* ([t (hash-ref tile-homes (ref puzzle r c))]&#13;
               [tr (car t)]&#13;
               [tc (cdr t)])&#13;
          (set! dist (+ dist&#13;
                        (abs (- tr r))&#13;
                        (abs (- tc c)))))))&#13;
    dist))</pre>&#13;
<p class="indent">The next functions are used to generate a new puzzle state given a move specifier. A move specifier is a number from zero to three that determines which of the four directions a tile can be moved into the empty space from.</p>&#13;
<pre><span epub:type="pagebreak" id="page_206"/>(define (move-offset i)&#13;
  (case i&#13;
    [(0) (values  0 -1)]&#13;
    [(1) (values  0  1)] &#13;
    [(2) (values -1  0)] &#13;
    [(3) (values  1  0)]))&#13;
&#13;
(define (make-move puzzle i)&#13;
  (let*-values ([(ro co) (move-offset i)]&#13;
                [(re ce) (empty-loc puzzle)]&#13;
                [(rt ct) (values (+ re ro) (+ ce co))]&#13;
                [(t) (ref puzzle rt ct)])&#13;
    (for/vector ([i (in-range (+ 2 (sqr SIZE)))])&#13;
      (cond [(&lt; i empty)&#13;
             (let-values ([(r c) (quotient/remainder i SIZE)])&#13;
               (cond [(and (= r re) (= c ce)) t]&#13;
                     [(and (= r rt) (= c ct)) empty]&#13;
                     [else (vector-ref puzzle i)]))]&#13;
            [(= i empty) rt]&#13;
            [else ct]))))</pre>&#13;
<p class="indent">The <span class="literal">move-offset</span> function takes a move specifier and returns two values specifying the row and column deltas needed to make the move. The <span class="literal">make-move</span> function takes a move specifier and returns a new vector representing the puzzle after the move has been made.</p>&#13;
<p class="indent">The following function will take a puzzle and return a list consisting of all the valid puzzle states that can be reached from a particular puzzle state. The local <span class="literal">legal</span> function determines whether a move specifier will result in a valid move for the current puzzle state by checking whether a move in a certain direction will extend beyond the boundaries of the puzzle.</p>&#13;
<pre>(define (next-states puzzle)&#13;
  (let-values ([(re ce) (empty-loc puzzle)])&#13;
    (define (legal i)&#13;
      (let*-values ([(ro co) (move-offset i)]&#13;
                    [(rt ct) (values (+ re ro) (+ ce co))])&#13;
        (and (&gt;= rt 0) (&gt;= ct 0) (&lt; rt SIZE) (&lt; ct SIZE))))&#13;
    (for/list ([i (in-range 4)] #:when (legal i))&#13;
      (make-move puzzle i))))</pre>&#13;
<p class="indent">It will of course be useful to actually see a visual representation of the puzzle. That functionality is provided by the following routine.</p>&#13;
<pre>(define (print puzzle)&#13;
  (for* ([r SIZE] [c SIZE])&#13;
    (when (= 0 c) (printf "\n"))&#13;
    (let ([t (ref puzzle r c)])&#13;
      (if (= t empty)&#13;
          <span epub:type="pagebreak" id="page_207"/>(printf "  ")&#13;
          (printf " ~a" t))))&#13;
  (printf "\n"))</pre>&#13;
<p class="indent">Next we define a helper function to process closed nodes.</p>&#13;
<pre>(define closed (make-hash))&#13;
&#13;
(define (process-closed node-parent node node-depth score)&#13;
  (begin&#13;
 <span class="ent">➊</span> (hash-set! closed node (list node-parent score)) &#13;
    (for ([child (next-states node)])&#13;
   <span class="ent">➋</span> (let* ([depth (add1 node-depth)]&#13;
          <span class="ent">➌</span> [next-score (+ depth (manhattan child))]&#13;
          <span class="ent">➍</span> [next (cons (list child depth node) next-score)])&#13;
        (if (hash-has-key? closed child)&#13;
         <span class="ent">➎</span> (let* ([prior-score (second (hash-ref closed child))])&#13;
           <span class="ent">➏</span> (when (&lt; next-score prior-score)&#13;
                (hash-remove! closed child)&#13;
                (enqueue next)))&#13;
         <span class="ent">➐</span> (enqueue next))))))</pre>&#13;
<p class="indent">We begin by placing the node, its parent, and its estimated cost in the <span class="literal">closed</span> table <span class="ent">➊</span>. Next, we generate a list of the possible child puzzle states and loop through them. For each child node, we generate the new node depth <span class="ent">➋</span> and estimated score <span class="ent">➌</span>. Then we compile the information that we’d need to push that node to the open queue <span class="ent">➍</span>, which happens automatically <span class="ent">➐</span> if the node is not in the <span class="literal">closed</span> table. If the node is in the <span class="literal">closed</span> table, we extract its prior cost score <span class="ent">➎</span> and compare with its current score <span class="ent">➏</span>. If the current score is less than the prior score, we remove the node from the <span class="literal">closed</span> table and place it in the open queue.</p>&#13;
<p class="indent">We finally get to the algorithm proper.</p>&#13;
<pre>(define (a-star puzzle)&#13;
  (let [(solved #f)]&#13;
    (hash-clear! closed)&#13;
 <span class="ent">➊</span> (set! queue (make-heap comp))  ; open&#13;
 <span class="ent">➋</span> (enqueue (cons (list puzzle 0 null) (manhattan puzzle)))&#13;
 <span class="ent">➌</span> (let loop ()&#13;
   <span class="ent">➍</span> (unless solved&#13;
        (let* ([node-info (dequeue)])&#13;
       <span class="ent">➎</span> (match node-info&#13;
            [(cons (list node node-depth node-parent) score)&#13;
          <span class="ent">➏</span> (if (= 0 (manhattan node))&#13;
                 (begin&#13;
                   (set! solved #t) &#13;
                   (print-solution (solution-list node-parent (list node))))&#13;
             <span class="ent">➐</span> (process-closed node-parent node node-depth score)&#13;
                 <span epub:type="pagebreak" id="page_208"/>)])&#13;
       <span class="ent">➑</span> (if (&gt; (heap-count queue) 0)&#13;
              (loop)&#13;
           <span class="ent">➒</span> (unless solved(printf "No solution found\n"))))))))</pre>&#13;
<p class="indent">First we define the <span class="literal">closed</span> hash table described above. The open queue is initialized <span class="ent">➊</span>, and the scrambled puzzle provided to the <span class="literal">a-star</span> procedure is pushed onto the open queue <span class="ent">➋</span>. The items in the queue consist of a Racket pair. The <span class="literal">cdr</span> of the pair is the estimated score, and the <span class="literal">car</span> consists of the puzzle state, the depth of the tree, and the parent puzzle state. After this initialization, the main loop starts <span class="ent">➌</span>.</p>&#13;
<p class="indent">The loop repeats until the <span class="literal">solved</span> variable is set to true. The first step of the loop is to pop the highest-priority item (lowest cost score) from the open queue and assign it to the <span class="literal">node-info</span> variable. A <span class="literal">match</span> form is used to parse the values contained in <span class="literal">node-info</span> <span class="ent">➎</span>. The puzzle state (in <span class="literal">node</span>) is first tested to see if it’s in the solved state <span class="ent">➏</span>, and if so, the function prints out the move sequence and terminates the process. Otherwise, the processing continues where we process the closed node by placing the node, its parent, and estimated cost in the <span class="literal">closed</span> table <span class="ent">➐</span>.</p>&#13;
<p class="indent">Once each iteration completes, the queue is checked <span class="ent">➑</span> to see if it contains any nodes that needs processing. If it does, then the next iteration resumes <span class="ent">➍</span>; otherwise, no solution exists and the process terminates <span class="ent">➒</span>.</p>&#13;
<p class="indent">Here are the print functions that show the solution. The <span class="literal">solution-list</span> procedure chases the parent nodes in <span class="literal">closed</span> to create a list of the puzzle states all the way back to the starting puzzle; <span class="literal">print-solution</span> takes the solution list and prints out the puzzle states it contains.</p>&#13;
<pre>(define (solution-list n l)&#13;
  (if (equal? n null)&#13;
      l&#13;
      (let* ([parent (first (hash-ref closed n))])&#13;
        (solution-list parent (cons n l)))))&#13;
&#13;
(define (print-solution l)&#13;
  (for ([p l]) (print p)))</pre>&#13;
<p class="indent">Here’s a test run on the puzzle presented in <a href="ch07.xhtml#ch7fig25">Figure 7-25</a> (to save space, the output puzzles are displayed horizontally).</p>&#13;
<pre><span epub:type="pagebreak" id="page_209"/>&gt; <span class="codestrong1">(a-star #(8 1 6 5 3 7 4 9 2 2 1))</span>&#13;
&#13;
 8 1 6  8 1 6  8 1 6    1 6  1   6  1 3 6  1 3 6&#13;
 5 3 7  5 3 7    3 7  8 3 7  8 3 7  8   7    8 7&#13;
 4   2    4 2  5 4 2  5 4 2  5 4 2  5 4 2  5 4 2&#13;
&#13;
 1 3 6  1 3 6  1 3 6  1 3 6  1 3 6  1 3 6  1 3 6  &#13;
 5 8 7  5 8 7  5 8 7  5 8    5   8  5 2 8  5 2 8  &#13;
   4 2  4   2  4 2    4 2 7  4 2 7  4   7  4 7    &#13;
&#13;
 1 3 6  1 3    1   3  1 2 3  1 2 3  1 2 3  1 2 3  &#13;
 5 2    5 2 6  5 2 6  5   6    5 6  4 5 6  4 5 6  &#13;
 4 7 8  4 7 8  4 7 8  4 7 8  4 7 8    7 8  7   8  &#13;
 &#13;
 1 2 3&#13;
 4 5 6&#13;
 7 8</pre>&#13;
<h4 class="h4" id="ch00lev2sec_62"><strong><em>Moving Up to the 15 Puzzle</em></strong></h4>&#13;
<p class="noindent">Having laid the groundwork with the 8 puzzle, the 15 puzzle requires this tricky modification: change the value of <span class="literal">SIZE</span> from 3 to 4. Okay, maybe that’s not too tricky, but before you get too excited, it’s really not quite that simple either. Observe <a href="ch07.xhtml#ch7fig29">Figure 7-29</a>. The first two puzzles are from [9], and our test computer sailed through solving these. But the third puzzle was randomly generated and caused the test computer to fall to the floor, giggling to itself that we would attempt to have it solve such a problem—no solution was forthcoming.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig29.jpg"/></div>&#13;
<p class="figcap" id="ch7fig29"><em>Figure 7-29: Some 15 puzzle examples</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_210"/>The issue is that some puzzles may result in the A* algorithm having to explore too many paths, so the computer runs out of resources (or the user runs out of patience waiting for an answer). Our solution is to settle for a slightly less elegant approach by breaking the problem into three subproblems. We will trade off a fully optimized solution for a solution that we don’t have to wait forever to get.</p>&#13;
<p class="indent">To break the problem into subproblems, we’re going to divide the puzzle into three zones as shown below in <a href="ch07.xhtml#ch7fig30">Figure 7-30</a>. The zones are chosen to take advantage of the fact that the A* algorithm was pretty zippy with the 8 puzzle.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig30.jpg"/></div>&#13;
<p class="figcap" id="ch7fig30"><em>Figure 7-30: 15 puzzle divided into zones</em></p>&#13;
<p class="indent">The medium gray section, which we designate zone 1, represents one subproblem, the white section (zone 2) will be the second subproblem, and the dark gray section (zone 3) represents another subproblem (which is equivalent to the 8 puzzle, which we know can be solved quickly). The idea is to provide different scoring functions to the <span class="literal">a-star</span> algorithm depending on which zone is being addressed. These functions will still use the Manhattan distance, but with certain restrictions applied. Once zone 1 and zone 2 have been solved, we can just call <span class="literal">manhattan</span> as before since the edge tiles in zones 1 and 2 will already be in place and the remaining tiles would be equivalent to an 8 puzzle.</p>&#13;
<h5 class="h5" id="ch00lev3sec_52"><strong>Zone 1</strong></h5>&#13;
<p class="noindent">Before we dive into solving zone 1, we’re going to create a helper function that’s quite similar to the code we saw in the <span class="literal">manhattan</span> function:</p>&#13;
<pre>(define (cost puzzle guard)&#13;
  (let ([dist 0])&#13;
    (for* ([r SIZE] [c SIZE])&#13;
      (let ([t (ref puzzle r c)])&#13;
        (when (guard r c t)&#13;
          (let* ([th (hash-ref tile-homes t)]&#13;
                 [hr (car th)]&#13;
                 [hc (cdr th)]&#13;
                 [d (+ (abs (- hr r)) (abs (- hc c)))])&#13;
            (set! dist (+ dist d))))))&#13;
    dist))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_211"/>The main difference is that instead of embedding the test for the empty square directly in the <span class="literal">cost</span> function, we’ll pass in a function for the <span class="literal">guard</span> parameter that will do the test for us. Given this, we can redefine <span class="literal">manhattan</span> as follows:</p>&#13;
<pre>(define (manhattan puzzle)&#13;
  (cost puzzle (λ (r c t) &#13;
                 (not (= t empty)))))</pre>&#13;
<p class="indent">We’ll attack zone 1 in two phases: first we nudge tiles 1 through 4 into the first two rows of the puzzle; then we get them into the proper order in the first row.</p>&#13;
<p class="indent">To get tiles 1 through 4 into the first two rows, we define <span class="literal">zone1a</span>.</p>&#13;
<pre>(define (zone1a puzzle)&#13;
  (cost puzzle (λ (r c t)&#13;
                 (or (and (&lt;= t 4) (&gt; r 1))))))</pre>&#13;
<p class="indent">In this case, we only update the distance for tiles 1 through 4, and we only update the distance if these tiles are not already in the first two rows.</p>&#13;
<p class="indent">The second phase is just slightly different. This time we always update the distance for tiles 1 through 4 to ensure they land in the proper locations.</p>&#13;
<pre>(define (zone1b puzzle)&#13;
  (cost puzzle (λ (r c t)&#13;
                 (&lt;= t 4))))</pre>&#13;
<p class="indent">It might appear that this could have been done in a single function, but trying to position the tiles all at once would result in a large search space and the consequent increase needed in time and computer resources (like memory). Our first phase, where we just get the tiles into the proximity of their proper location, reduces the search space by half, without requiring an enormous amount of resources. The sorting in phase two will normally only have to deal with the tiles in the top half of the puzzles since the remaining tiles will have a score of zero.</p>&#13;
<h5 class="h5" id="ch00lev3sec_53"><strong>Zone 2</strong></h5>&#13;
<p class="noindent">At this point, we’ve reduced the search space by 25 percent. This modest reduction is sufficient to allow us to get tiles 5, 9, and 13 into zone 2 and in their proper order in a single procedure, which we provide here as <span class="literal">zone2</span>:</p>&#13;
<pre>(define zone2-tiles (set 5 9 13))&#13;
&#13;
(define (zone2 puzzle)&#13;
  (cost puzzle (λ (r c t)&#13;
                 (and (&gt;= r 1)&#13;
                      (set-member? zone2-tiles t)))))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_212"/>At this point, we no longer need to bother with row 1, as reflected in the code <span class="literal">&gt;= r 1</span>. Aside from this, the code is nearly identical to the others, except that this time, we use the values defined in <span class="literal">zone2-tiles</span> for scoring.</p>&#13;
<h5 class="h5" id="ch00lev3sec_54"><strong>Putting It All Together</strong></h5>&#13;
<p class="noindent">Once a zone has been solved, we won’t want to disturb the tiles that are already in place. To accomplish this, a slight tweak is made to the function (<span class="literal">next-states</span>) that generates the list of permissible states. Before, we simply checked to ensure we weren’t moving beyond the first row or column. Now we define global variables <span class="literal">min-r</span> and <span class="literal">min-c</span>, which are set to 0 or 1 depending on which zone we’re currently working in.</p>&#13;
<pre>(define min-r 0)&#13;
(define min-c 0)&#13;
&#13;
(define (next-states puzzle)&#13;
  (let-values ([(re ce) (empty-loc puzzle)])&#13;
    (define (legal i)&#13;
      (let*-values ([(ro co) (move-offset i)]&#13;
                    [(rt ct) (values (+ re ro) (+ ce co))])&#13;
        (and (&gt;= rt min-r) (&gt;= ct min-c) (&lt; rt SIZE) (&lt; ct SIZE))))&#13;
    (for/list ([i (in-range 4)] #:when (legal i))&#13;
      (make-move puzzle i))))</pre>&#13;
<p class="indent">The final solver will update the values of <span class="literal">min-r</span> and <span class="literal">min-c</span> once zones 1 and 2 have been populated.</p>&#13;
<p class="indent">We now need to make a few crucial modifications to the code for <span class="literal">a-star</span> and <span class="literal">process-closed</span>.</p>&#13;
<pre>(define (process-closed node-parent node node-depth score fscore)&#13;
  (begin&#13;
    (hash-set! closed node (list node-parent score)) &#13;
    (for ([child (next-states node)])&#13;
      (let* ([depth (add1 node-depth)]&#13;
          <span class="ent">➊</span> [next-score (+ depth (fscore child))]&#13;
             [next (cons (list child depth node) next-score)])&#13;
        (if (hash-has-key? closed child)&#13;
            (let* ([prior-score (second (hash-ref closed child))])&#13;
              (when (&lt; next-score prior-score)&#13;
                (hash-remove! closed child)&#13;
                (enqueue next)))&#13;
            (enqueue next))))))</pre>&#13;
<p class="indent">The most significant change is that instead of always using <span class="literal">manhattan</span> for our scoring estimate, we now use the function <span class="literal">fscore</span> <span class="ent">➊</span>, which is passed to <span class="literal">process-closed</span> as an additional parameter. This function will be different depending on which zone of the puzzle is being solved.</p>&#13;
<pre><span epub:type="pagebreak" id="page_213"/>(define (a-star puzzle fscore)&#13;
  (let ([solution null]&#13;
        [goal null])&#13;
    (hash-clear! closed)&#13;
    (set! queue (make-heap comp))  ; open&#13;
    (enqueue (cons (list puzzle 0 null) (fscore puzzle)))&#13;
    (let loop ()&#13;
      (when (equal? solution null)&#13;
        (let* ([node-info (dequeue)])&#13;
          (match node-info&#13;
            [(cons (list node node-depth node-parent) score)&#13;
             (if (= 0 (fscore node))&#13;
                 (begin&#13;
                <span class="ent">➊</span> (set! goal node)&#13;
                <span class="ent">➋</span> (set! solution (solution-list node-parent (list node))))&#13;
                 (process-closed node-parent node node-depth score fscore))])&#13;
          (if (&gt; (heap-count queue) 0)&#13;
              (loop)&#13;
              (when (equal? solution null) (printf "No solution found\n"))))))&#13;
 <span class="ent">➌</span> (values goal solution)))</pre>&#13;
<p class="indent">Here we also include <span class="literal">fscore</span> as an additional parameter. Now, instead of immediately printing a solution once the goal state is reached, we return two values at the end <span class="ent">➌</span>: the current goal, given in the first <span class="literal">set!</span> <span class="ent">➊</span> and the solution list, given in the second <span class="literal">set!</span> <span class="ent">➋</span>. The remaining code should align closely with the original version.</p>&#13;
<p class="indent">Instead of calling <span class="literal">a-star</span> directly as we did before, we now provide a <span class="literal">solve</span> function that steps through the process of providing <span class="literal">a-star</span> with the proper scoring function, which is either one of the zone-specific functions or <span class="literal">manhattan</span>.</p>&#13;
<pre>(define (solve puzzle)  &#13;
  (set! min-r 0)&#13;
  (set! min-c 0)&#13;
  (let*-values ([(goal sol-z1a) (a-star puzzle zone1a)])&#13;
    (let*-values  ([(goal sol2) (a-star goal zone1b)]&#13;
                   [(sol-z1b) (cdr sol2)])&#13;
      (set! min-r 1)&#13;
      (let*-values  ([(goal sol3) (a-star goal zone2)]&#13;
                     [(sol-z2) (cdr sol3)])&#13;
        (set! min-c 1)&#13;
        (let*-values  ([(goal sol4) (a-star goal manhattan)]&#13;
                       [(sol-man) (cdr sol4)])&#13;
          (print-solution (append sol-z1a sol-z1b sol-z2 sol-man)))))))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_214"/>As the code executes, it stores the solution list for each step of the process and finally prints the entire solution in the last line of the code. The reason we take the <span class="literal">cdr</span> of the solution list at each step (except the first) is because the last item in the solution from the previous step is the goal of the next step; this state would be repeated if we left it in the list.</p>&#13;
<p class="indent">Finally, we resolve a little cosmetic issue with the <span class="literal">print</span> routine caused by having two-digit numbers on the tiles. The revised code follows.</p>&#13;
<pre>(define (print puzzle)&#13;
  (for* ([r SIZE] [c SIZE])&#13;
    (when (= 0 c) (printf "\n"))&#13;
    (let ([t (ref puzzle r c)])&#13;
      (if (= t empty)&#13;
          (printf "   ")&#13;
          (printf " ~a" (~a t #:min-width 2 #:align 'right) ))))&#13;
  (printf "\n"))</pre>&#13;
<p class="indent">The following are some sample inputs with which to test the code. To save space, only the output (compressed) from the first example is shown.</p>&#13;
<pre>&gt; <span class="codestrong1">(solve #(2 10 8 3 1 6 16 4 5 9 7 11 13 14 15 12 1 2))</span>&#13;
&#13;
  2 10  8  3   2 10     3    2 10  3       2 10  3  4 &#13;
  1  6     4   1  6  8  4    1  6  8  4    1  6  8   &#13;
  5  9  7 11   5  9  7 11    5  9  7 11    5  9  7 11&#13;
 13 14 15 12  13 14 15 12   13 14 15 12   13 14 15 12&#13;
 &#13;
  2 10  3  4    2 10  3  4   2     3  4       2  3  4&#13;
  1  6     8    1     6  8   1 10  6  8    1 10  6  8&#13;
  5  9  7 11    5  9  7 11   5  9  7 11    5  9  7 11&#13;
 13 14 15 12   13 14 15 12  13 14 15 12   13 14 15 12&#13;
&#13;
  1  2  3  4    1  2  3  4    1  2  3  4   1  2  3  4  &#13;
    10  6  8    5 10  6  8    5 10  6  8   5     6  8  &#13;
  5  9  7 11       9  7 11    9     7 11   9 10  7 11  &#13;
 13 14 15 12   13 14 15 12   13 14 15 12  13 14 15 12  &#13;
&#13;
  1  2  3  4    1  2  3  4    1  2  3  4    1  2  3  4 &#13;
  5  6     8    5  6  7  8    5  6  7  8    5  6  7  8&#13;
  9 10  7 11    9 10    11    9 10 11       9 10 11 12&#13;
 13 14 15 12   13 14 15 12   13 14 15 12   13 14 15   &#13;
 &#13;
&gt; <span class="codestrong1">(solve #(5 1 2 4 14 9 3 7 13 10 12 6 15 11 8 16 3 3))</span>&#13;
. . .&#13;
&#13;
&gt; <span class="codestrong1">(solve #(10 9 5 13 8 14 15 7 1 3 11 6 4 2 12 16 3 3))</span>&#13;
. . .&#13;
&#13;
&gt; <span class="codestrong1">(solve #(3 1 2 4 13 6 7 8 5 12 10 11 9 14 15 16 3 3))</span>&#13;
. . .&#13;
&#13;
&gt; <span class="codestrong1">(solve #(9 6 12 3 5 13 16 8 14 1 10 7 2 15 11 4 1 2))</span>&#13;
. . .&#13;
&#13;
&gt; <span class="codestrong1">(solve #(11 1 3 12 5 2 9 8 10 6 14 15 7 13 4 16 3 3))</span>&#13;
. . .</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_215"/>Be aware that depending on the puzzle and the power of your computer, it may take anywhere from a couple of seconds to a minute or so to generate a solution.</p>&#13;
<h3 class="h3" id="ch00lev1sec_45">Sudoku</h3>&#13;
<p class="noindent">Sudoku<sup><a href="footnote.xhtml#ch07foot_2" id="ch07foot2">2</a></sup> is a popular puzzle consisting of a 9-by-9 grid of squares in which some squares are initially populated with digits from 1 through 9, as shown in <a href="ch07.xhtml#ch7fig31">Figure 7-31</a>a. The objective is to fill in the blank squares such that each row, column, and 3-by-3 block of squares also consists of digits 1 through 9, as shown in <a href="ch07.xhtml#ch7fig31">Figure 7-31</a>b. A well-formed Sudoku puzzle should only have one possible solution.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig31.jpg"/></div>&#13;
<p class="figcap" id="ch7fig31"><em>Figure 7-31: The Sudoku puzzle</em></p>&#13;
<p class="indent">Our aim in this section is to produce a procedure that generates the solution to any given Sudoku puzzle.</p>&#13;
<p class="indent">The basic strategy is this:</p>&#13;
<ol>&#13;
<li class="noindent">Check each empty cell, to determine which numbers are available to  be used.</li>&#13;
<li class="noindent">Select a cell with the fewest available numbers.</li>&#13;
<li class="noindent">One at a time, enter one of the available numbers in the cell.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_216"/>For each available number, repeat the process until either the puzzle  is solved, or there are no numbers available for an empty cell.</li>&#13;
<li class="noindent">If there are no available numbers, backtrack to step 3 and try a  different number.</li>&#13;
</ol>&#13;
<p class="noindent">The process is another application of depth-first search.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7fig32">Figure 7-32</a> gives the coordinates used to reference locations in the puzzle: numbers across the top index columns, numbers on the left edge index rows, and numbers in the interior index blocks of 3-by-3 subgrids.</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig32.jpg"/></div>&#13;
<p class="figcap" id="ch7fig32"><em>Figure 7-32: Puzzle coordinates</em></p>&#13;
<p class="indent">To determine the available numbers for a given cell, we take the set intersection of the unused numbers in each row, column, and block. Using the cell in row 1, column 1 of <a href="ch07.xhtml#ch7fig31">Figure 7-31</a>a as an example, in row 1 the set of numbers {2, 5, 8} are free, in column 1 all the numbers except for 5 are available, and in block 0, the set of numbers {2, 3, 7, 8, 9} are available. The intersection of these sets gives the set of possible values for this cell: {2, 8}.</p>&#13;
<p class="indent">Our implementation will use a 9-by-9 array of numbers to represent the puzzle, where the number 0 will designate an empty square. The array will be constructed of a nine-element vector, each element being another nine-element integer vector. For easy access to elements of the array, we define two utility functions to set and retrieve values:</p>&#13;
<pre>(define (array-set! array r c v)&#13;
  (vector-set! (vector-ref array r) c v))&#13;
&#13;
(define (array-ref array r c)&#13;
  (vector-ref (vector-ref array r) c))</pre>&#13;
<p class="indent">Both of these functions require the array and row and column numbers to be provided as the initial arguments.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_217"/>It will also be useful to derive the corresponding block index from the row and column numbers, as given by the <span class="literal">getBlk</span> function here.</p>&#13;
<pre>(define (getBlk r c) ; block from row and column&#13;
  (+ (* 3 (quotient r 3)) (quotient c 3)))</pre>&#13;
<p class="indent">The puzzle will be input as a single string where each row of nine digits is broken by a new line as shown by the example below.</p>&#13;
<pre>&gt; <span class="codestrong1">(define puzzle-str "&#13;
150000320&#13;
604031097&#13;
000200000&#13;
000049073&#13;
400800000&#13;
000000001&#13;
503008000&#13;
002000004&#13;
007000260&#13;
")</span></pre>&#13;
<p class="indent">We define the Sudoku puzzle object as a <span class="literal">sudoku%</span> Racket object for which we give a partial implementation here. This object will maintain the puzzle state. It will contain functions that allow us to manipulate the state by setting cell values and provides functions to list potential candidates (unused numbers in a row, column, or block) and other helper functions.</p>&#13;
<pre>(define sudoku%&#13;
  (class object%&#13;
&#13;
 <span class="ent">➊</span> (init [puzzle-string ""])&#13;
    &#13;
    (define avail-row (make-markers))&#13;
    (define avail-col (make-markers))&#13;
    (define avail-blk (make-markers))&#13;
 <span class="ent">➋</span> (define count 0)&#13;
    &#13;
 <span class="ent">➌</span> (define grid&#13;
      (for/vector ([i 9]) (make-vector 9 0)))&#13;
    &#13;
    (super-new)&#13;
&#13;
 <span class="ent">➍</span> (define/public (item-set! r c n)&#13;
      (array-set! grid r c n)&#13;
      (array-set! avail-row r n #f)&#13;
      (array-set! avail-col c n #f)&#13;
      (let ([b (getBlk r c)])&#13;
        (array-set! avail-blk b n #f))&#13;
      (set! count (+ count 1)))&#13;
    <span epub:type="pagebreak" id="page_218"/>(unless (equal? puzzle-string "")&#13;
   <span class="ent">➎</span> (init-puzzle puzzle-string))&#13;
&#13;
    (define/public (get-grid) grid)&#13;
    &#13;
    (define/public (item-ref r c)&#13;
      (array-ref grid r c))&#13;
&#13;
 <span class="ent">➏</span> (define/public (init-grid grid)&#13;
      (for* ([r 9] [c 9])&#13;
        (let ([n (array-ref grid r c)])&#13;
          (when (&gt; n 0)&#13;
            (item-set! r c n)))))&#13;
            &#13;
 <span class="ent">➐</span> (define/private (init-puzzle p)&#13;
      (let ([g &#13;
             (let ([rows (string-split p)])&#13;
               (for/vector ([row rows])&#13;
                 (for/vector ([c 9])&#13;
                   (string-&gt;number (substring row c (add1 c))))))])&#13;
        (init-grid g)))&#13;
&#13;
; More to come shortly . . .&#13;
&#13;
))</pre>&#13;
<p class="indent">The <span class="literal">init</span> form <span class="ent">➊</span> captures the input string value that defines the puzzle. We initialize the puzzle <span class="ent">➎</span> by calling <span class="literal">init-puzzle</span> <span class="ent">➐</span>, which updates <span class="literal">grid</span> <span class="ent">➌</span> with the appropriate numerical values via the call to <span class="literal">init-grid</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">The <span class="literal">count</span> variable <span class="ent">➋</span> contains the number of cells that currently have a value. Once <span class="literal">count</span> reaches 81, the puzzle has been solved.</p>&#13;
<p class="indent">The <span class="literal">avail-row</span>, <span class="literal">avail-col</span>, and <span class="literal">avail-blk</span> variables are used to keep track of which numbers are currently unused in each row, column, and block respectively. The <span class="literal">make-markers</span> function, which is called to initialize each of these variables, creates a Boolean array that indicates which numbers are free for any given index (row, column, or block as applicable); <span class="literal">make-markers</span> is defined as follows:</p>&#13;
<pre>(define (make-markers)&#13;
  (for/vector ([i 10])&#13;
    (let ([v (make-vector 10 #t)])&#13;
      (vector-set! v 0 #f)  &#13;
      v)))</pre>&#13;
<p class="indent">Notice that the number 0 (designating an empty cell) is automatically marked as unavailable.</p>&#13;
<p class="indent">As numbers get added to the puzzle, <span class="literal">item-set!</span> is called <span class="ent">➍</span>. This procedure is responsible for updating <span class="literal">grid</span> and <span class="literal">avail-row</span>, <span class="literal">avail-col</span>, and <span class="literal">avail-blk</span> <span epub:type="pagebreak" id="page_219"/>when given the row, column, and number to be assigned to the puzzle. The functions <span class="literal">get-grid</span> and <span class="literal">item-ref</span> return <span class="literal">grid</span> or a cell in <span class="literal">grid</span> respectively.</p>&#13;
<p class="indent">In the following code extracts, all function definitions that are indented should be included in the class definition for <span class="literal">sudoku%</span> and aren’t global defines.</p>&#13;
<p class="indent">The following <span class="literal">avail</span> function combines the values from <span class="literal">avail-row</span>, <span class="literal">avail-col</span>, and <span class="literal">avail-blk</span> to produce a vector indicating which numbers are available.</p>&#13;
<pre>    (define (avail r c)&#13;
      (let* ([b (getBlk r c)]&#13;
             [ar (vector-ref avail-row r)]&#13;
             [ac (vector-ref avail-col c)]&#13;
             [ab (vector-ref avail-blk b)])&#13;
        (for/vector ([i 10])&#13;
          (and (vector-ref ar i)&#13;
               (vector-ref ac i)&#13;
               (vector-ref ab i)))))</pre>&#13;
<p class="indent">Given this vector, we create a list of the free numbers as follows:</p>&#13;
<pre>    (define (free-numbers v)&#13;
      (for/list ([n (in-range 1 10)] #:when (vector-ref v n)) n))</pre>&#13;
<p class="indent">For efficiency, the following code finds all the cells that only have a single available number and updates the puzzle appropriately.</p>&#13;
<pre>    (define (set-singles)&#13;
      (let ([found #f])&#13;
        (for* ([r 9] [c 9])&#13;
          (let* ([free (avail r c)]&#13;
                 [num-free (vector-count identity free)]&#13;
                 [n (item-ref r c)])&#13;
            (when (and (zero? n)  (= 1 num-free))&#13;
              (let ([first-free&#13;
                     (let loop ([i 1])&#13;
                       (if (vector-ref free i) i&#13;
                           (loop (add1 i))))])&#13;
                (item-set! r c first-free)&#13;
                (set! found #t))&#13;
              )))&#13;
        found))</pre>&#13;
<p class="indent">Performing this process once may result in other cells with only a single available number. The following code runs until no cells remain with only a single available number.</p>&#13;
<pre>    (define/public (set-all-singles)&#13;
      (when (set-singles) (set-all-singles)))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_220"/>For puzzles that can be solved directly by logic alone (no guessing is required), the above process would be sufficient, but this isn’t always the case. To support backtracking, the following two functions are provided.</p>&#13;
<pre>    (define (get-free)&#13;
      (let ([free-list '()])&#13;
        (for* ([r 9] [c 9])&#13;
          (let* ([free (avail r c)]&#13;
                 [num-free (vector-count identity free)]&#13;
                 [n (item-ref r c)])&#13;
            (when (zero? n)&#13;
              (set! free-list&#13;
                    (cons&#13;
                     (list r c num-free (free-numbers free))&#13;
                     free-list)))))&#13;
        free-list))&#13;
    &#13;
    (define/public (get-min-free)&#13;
      (let ([min-free 10]&#13;
            [min-info null]&#13;
            [free-list (get-free)])&#13;
        (let loop ([free free-list])&#13;
          (unless (equal? free '())&#13;
            (let* ([info (car free)]&#13;
                   [rem (cdr free)]&#13;
                   [num-free (third info)])&#13;
              (when (&lt; 0 num-free min-free)&#13;
                (set! min-free num-free)&#13;
                (set! min-info info))&#13;
              (loop rem))))&#13;
        min-info))</pre>&#13;
<p class="indent">The first function (<span class="literal">get-free</span>) goes cell by cell and creates a list of all the free values for each cell. Each element of the list contains another list that holds the row, column, number of free values, and a list of the free values. The second function (<span class="literal">get-min-free</span>) takes the list returned by <span class="literal">get-free</span> and returns the values for the cell with the fewest free numbers.</p>&#13;
<p class="indent">Here are a few handy utility functions.</p>&#13;
<pre>    (define/public (print)&#13;
      (for* ([r 9] [c 9])&#13;
        (when (zero? c) (printf "\n"))&#13;
        (let ([n (item-ref r c)])&#13;
          (if (zero? n)&#13;
              (printf " .")&#13;
              (printf " ~a" n)&#13;
              )))&#13;
      (printf "\n"))&#13;
&#13;
    <span epub:type="pagebreak" id="page_221"/>(define/public (solved?) (= count 81))&#13;
&#13;
    (define/public (clone)&#13;
      (let ([p (new sudoku%)])&#13;
        (send p init-grid grid)&#13;
        p))</pre>&#13;
<p class="indent">The <span class="literal">print</span> member function provides a simple text printout of the puzzle. The <span class="literal">solved?</span> function indicates whether the puzzle is in the solved state by testing whether all 81 cells have been populated. The <span class="literal">clone</span> function provides a copy of the puzzle.</p>&#13;
<p class="indent">This concludes the code that’s defined within the body of the <span class="literal">sudoku%</span> class definition and brings us to the actual code used to solve the puzzle.</p>&#13;
<pre>(define (solve-sudoku puzzle)&#13;
  (let ([solution null]&#13;
     <span class="ent">➊</span> [puzzle (send puzzle clone)])&#13;
 <span class="ent">➋</span> (define (dfs puzzle)&#13;
      (if (send puzzle solved?)&#13;
          (set! solution puzzle)&#13;
          (let ([info (send puzzle get-min-free)]) &#13;
            (match info&#13;
              ['() #f]&#13;
           <span class="ent">➌</span> [(list row col num free-nums) &#13;
               (let loop ([nums free-nums])&#13;
                 (if (equal? nums '())&#13;
                     #f&#13;
                  <span class="ent">➍</span> (let ([n (car nums)]&#13;
                        <span class="ent">➎</span> [t (cdr nums)])&#13;
                       (let ([p (send puzzle clone)])&#13;
                      <span class="ent">➏</span> (send p item-set! row col n)&#13;
                         (send p set-all-singles)&#13;
                      <span class="ent">➐</span> (unless (dfs p)(loop t))))))]))))&#13;
 <span class="ent">➑</span> (send puzzle set-all-singles)&#13;
    (dfs puzzle)&#13;
    (if (equal? solution null)&#13;
        (error "No solution found.")&#13;
        solution&#13;
        )))</pre>&#13;
<p class="indent">We begin by creating a copy of the puzzle to work with <span class="ent">➊</span>. Next, we define a depth-first search procedure, <span class="literal">dfs</span> <span class="ent">➋</span>, which we’ll explain shortly. The call to <span class="literal">set-all-singles</span> <span class="ent">➑</span> is occasionally sufficient to solve the puzzle, but the puzzle is handed off to <span class="literal">dfs</span> to ensure a complete solution is found. The remaining lines will return a solved puzzle if one exists; otherwise an error is signaled.</p>&#13;
<p class="indent">The depth-first search code, <span class="literal">dfs</span> <span class="ent">➋</span>, immediately tests whether the puzzle is solved and if so, returns the solved puzzle. Otherwise, the cell with the fewest available numbers (if any) is explored <span class="ent">➌</span>, where the <span class="literal">match</span> form <span epub:type="pagebreak" id="page_222"/>extracts the cell row, column, number of free numbers, and the list of free numbers. The list of free numbers is iterated through starting on the next line. While the list isn’t empty, the first number in the list is extracted into <span class="literal">n</span> <span class="ent">➍</span> and the remaining numbers are stored in <span class="literal">t</span> <span class="ent">➎</span>. Then a copy of the puzzle is created. Next, the puzzle copy is populated with the current available number <span class="ent">➏</span>, and <span class="literal">set-all-singles</span> is called immediately following this. If this number doesn’t produce a solution (via the recursive call to <span class="literal">dfs</span> <span class="ent">➐</span>), the loop repeats with the original puzzle and the next available number.</p>&#13;
<p class="indent">To aid testing various puzzles, we define a simple routine to take an input puzzle string, solve the puzzle, and print the solution.</p>&#13;
<pre>(define (solve pstr)&#13;
  (let* ([puzzle (new sudoku% [puzzle-string pstr])]&#13;
         [solution (solve-sudoku puzzle)])&#13;
    (send puzzle print)&#13;
    (send solution print)))</pre>&#13;
<p class="indent">Now that we’ve laid this groundwork, here’s a trial run with our example puzzle.</p>&#13;
<pre>&gt; <span class="codestrong1">(define puzzle "&#13;
150000320&#13;
604031097&#13;
000200000&#13;
000049073&#13;
400800000&#13;
000000001&#13;
503008000&#13;
002000004&#13;
007000260&#13;
")</span>&#13;
&gt; <span class="codestrong1">(solve puzzle)</span>&#13;
&#13;
 1 5 . . . . 3 2 .&#13;
 6 . 4 . 3 1 . 9 7&#13;
 . . . 2 . . . . .&#13;
 . . . . 4 9 . 7 3&#13;
 4 . . 8 . . . . .&#13;
 . . . . . . . . 1&#13;
 5 . 3 . . 8 . . .&#13;
 . . 2 . . . . . 4&#13;
 . . 7 . . . 2 6 .&#13;
&#13;
 1 5 8 9 7 4 3 2 6&#13;
 6 2 4 5 3 1 8 9 7&#13;
 7 3 9 2 8 6 1 4 5&#13;
 2 8 5 1 4 9 6 7 3&#13;
 4 7 1 8 6 3 9 5 2&#13;
 3 9 6 7 5 2 4 8 1&#13;
<span epub:type="pagebreak" id="page_223"/> 5 6 3 4 2 8 7 1 9&#13;
 8 1 2 6 9 7 5 3 4&#13;
 9 4 7 3 1 5 2 6 8</pre>&#13;
<p class="indent">While this is certainly an adequate method to generate the output, it doesn’t take a lot of additional work to produce a more attractive output.</p>&#13;
<p class="indent">To accomplish our goal, we’ll need the Racket <em>draw</em> library.</p>&#13;
<pre>(require racket/draw)</pre>&#13;
<p class="indent">Furthermore, we’ll borrow our <span class="literal">draw-centered-text</span> procedure that we used in the 15 puzzle GUI:</p>&#13;
<pre>(define CELL-SIZE 30)&#13;
&#13;
(define (draw-centered-text dc text x y)&#13;
  (let-values ([(w h d s) (send dc get-text-extent text)])&#13;
    (let ([x (+ x (/ (- CELL-SIZE w) 2))]&#13;
          [y (+ y (/ (- CELL-SIZE h d) 2))])&#13;
      (send dc draw-text text x y ))))</pre>&#13;
<p class="indent">Given these preliminaries, we can now define our <span class="literal">draw-puzzle</span> function:</p>&#13;
<pre>(define (draw-puzzle p1 p2)&#13;
  (let* ([drawing (make-bitmap (* 9 CELL-SIZE) (* 9 CELL-SIZE))]&#13;
         [dc (new bitmap-dc% [bitmap drawing])]&#13;
         [yellow (new brush% [color (make-object color% 240 210 0)])]&#13;
         [gray (new brush% [color "Gainsboro"])])&#13;
    (for* ([r 9][c 9])&#13;
      (let* ([x (* c CELL-SIZE)]&#13;
             [y (* r CELL-SIZE)]&#13;
             [n1 (send p1 item-ref r c)]&#13;
             [n2 (send p2 item-ref r c)]&#13;
             [num (if (zero? n2) "" (number-&gt;string n2))]&#13;
             [color (if (zero? n1) yellow gray)])&#13;
        (send dc set-pen "black" 1 'solid)&#13;
        (send dc set-brush color)&#13;
        (send dc draw-rectangle x y CELL-SIZE CELL-SIZE)&#13;
        (draw-centered-text dc num x y)))&#13;
    (for* ([r 3][c 3])&#13;
      (let* ([x (* 3 c CELL-SIZE)]&#13;
             [y (* 3 r CELL-SIZE)])&#13;
        (send dc set-pen "black" 2 'solid)&#13;
        (send dc set-brush "black" 'transparent)&#13;
        (send dc draw-rectangle x y (* 3 CELL-SIZE) (* 3 CELL-SIZE))))&#13;
    drawing))</pre>&#13;
<p class="indent">There’s really nothing new here. The reason we’re passing it two puzzles is because the first puzzle is the original unsolved puzzle. It’s simply used to determine which color to use to draw the squares. If a square was blank <span epub:type="pagebreak" id="page_224"/>in the original puzzle, it’ll be colored yellow in the output; otherwise it’ll be colored gray.</p>&#13;
<p class="indent">With this in hand, we can redefine <span class="literal">solve</span> as follows:</p>&#13;
<pre>(define (solve pstr)&#13;
  (let* ([puzzle (new sudoku% [puzzle-string pstr])]&#13;
         [solution (solve-sudoku puzzle)])&#13;
    (print (draw-puzzle puzzle puzzle))&#13;
    (newline)&#13;
    (newline)&#13;
    (print (draw-puzzle puzzle solution))))</pre>&#13;
<p class="indent">Using this new version yields the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(solve "&#13;
150000320&#13;
604031097&#13;
000200000&#13;
000049073&#13;
400800000&#13;
000000001&#13;
503008000&#13;
002000004&#13;
007000260&#13;
")</span></pre>&#13;
<p class="indent">It gives the starting state in <a href="ch07.xhtml#ch7fig33">Figure 7-33</a>:</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig33.jpg"/></div>&#13;
<p class="figcap" id="ch7fig33"><em>Figure 7-33: Sudoku starting-state drawing</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_225"/>And the solved state in <a href="ch07.xhtml#ch7fig34">Figure 7-34</a>:</p>&#13;
<div class="image"><img alt="Image" src="../images/07fig34.jpg"/></div>&#13;
<p class="figcap" id="ch7fig34"><em>Figure 7-34: Solved Sudoku drawing</em></p>&#13;
<h3 class="h3" id="ch00lev1sec_46">Summary</h3>&#13;
<p class="noindent">In this chapter, we’ve explored a number of algorithms that are useful in the general context of problem-solving. In particular we’ve looked at breath-first search (BFS), depth-first search (DFS), the A* algorithm, and Dijkstra’s algorithm (and discovered priority queues along the way) to find the shortest path between graph nodes. We employed DFS in the solution of the <em>n</em>-queens problem and the 15 puzzle (which also used the A* algorithm). Finally, we took a look at Sudoku, where sometimes logic alone is sufficient to solve, but failing this, DFS again comes to the rescue. While the algorithms we’ve explored are far from a comprehensive set, they form a useful toolset that’s effective in solving a wide range of problems over many domains.</p>&#13;
<p class="indent">Thus far we’ve exercised a number of programming paradigms: imperative, functional, and object-oriented. In the next chapter, we’ll look at a new technique: programming in logic or logic programming.</p>&#13;
</body></html>