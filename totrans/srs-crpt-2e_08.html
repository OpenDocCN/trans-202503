<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_87" aria-label="87"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch5">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">STREAM CIPHERS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">Symmetric ciphers can be either block ciphers or stream ciphers. Recall from <span class="chapterintro_Xref"><a href="chapter4.xhtml">Chapter 4</a></span> that block ciphers mix chunks of plaintext bits together with key bits to produce chunks of ciphertext of the same size, usually 64 or 128 bits. Stream ciphers, on the other hand, don’t mix plaintext and key bits; instead, they generate pseudorandom bits from the key and encrypt the plaintext by XORing it with the pseudorandom bits, in the same fashion as the one-time pad explained in <span class="chapterintro_Xref"><a href="chapter1.xhtml">Chapter 1</a></span>.</p>&#13;
<p class="TX">Stream ciphers are sometimes shunned because they have historically been more fragile than block ciphers and are more often broken—both the experimental ones designed by amateurs and the ciphers deployed in systems used by millions, including mobile phones, Wi-Fi, and public transport smart cards. But fortunately, although it’s taken almost 20 years, we now <span role="doc-pagebreak" epub:type="pagebreak" id="pg_88" aria-label="88"/>know how to design secure stream ciphers, and we trust them to protect Bluetooth connections, mobile 4G communications, and TLS connections.</p>&#13;
<p class="TX">This chapter first presents how stream ciphers work and discusses the two main classes of stream ciphers: stateful and counter based. We’ll then study hardware- and software-oriented stream ciphers and look at some insecure ciphers (A5/1 as used in GSM mobile communications, and RC4 in older version of TLS) and secure, state-of-the-art ones (Grain-128a for hardware and Salsa20 for software).</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-36"/><samp class="SANS_Futura_Std_Bold_B_11">How Stream Ciphers Work</samp></h3>&#13;
<p class="TNI">Stream ciphers are more akin to deterministic random bit generators (DRBGs) than block ciphers because they generate a stream of pseudorandom bits rather than directly mixing plaintext data.</p>&#13;
<p class="TX">What sets stream ciphers apart from DRBGs is that DRBGs take a single input value, whereas stream ciphers take two values: a key and a nonce. The key should be secret and is usually 128 or 256 bits. The nonce doesn’t have to be secret, but it should be unique for each key and is usually between 64 and 128 bits.</p>&#13;
<p class="TX">Stream ciphers produce a pseudorandom stream of bits we call the <i>keystream</i>. To encrypt the keystream, we XOR it to a plaintext and then XOR it again to the ciphertext to decrypt it. <a href="chapter5.xhtml#fig5-1">Figure 5-1</a> shows the basic stream cipher encryption operation, where <b>SC</b> is the stream cipher algorithm, <i>KS</i> the keystream, <i>P</i> the plaintext, and <i>C</i> the ciphertext.</p>&#13;
<figure class="IMG"><img id="fig5-1" class="img5" src="../images/fig5-1.jpg" alt="" width="454" height="182"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: How stream ciphers encrypt, taking a secret key,</samp> <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, and a public nonce,</samp> <samp class="SANS_Futura_Std_Book_11">N</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">A stream cipher computes <i>KS</i> = <b>SC</b>(<i>K</i>, <i>N</i>), encrypts as <i>C</i> = <i>P</i> <span class="symbol">⊕</span> <i>KS</i>, and decrypts as <i>P</i> = <i>C</i> <span class="symbol">⊕</span> <i>KS</i>. The encryption and decryption functions are the same because both do the same thing—namely, XOR bits with the keystream. That’s why, for example, certain cryptographic libraries provide a single <samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt</samp> function for both encryption and decryption.</p>&#13;
<p class="TX">Stream ciphers allow you to encrypt a message with key <i>K</i><sub>1</sub> and nonce <i>N</i><sub>1</sub> and then encrypt another message with key <i>K</i><sub>1</sub> and nonce <i>N</i><sub>2</sub> that’s different from <i>N</i><sub>1</sub>, or with key <i>K</i><sub>2</sub>, which is different from <i>K</i><sub>1</sub> and nonce <i>N</i><sub>1</sub>. However, you should never again encrypt with <i>K</i><sub>1</sub> and <i>N</i><sub>1</sub> because you would use the same keystream <i>KS</i> twice. That is, you’d have a first ciphertext <i>C</i><sub>1</sub> = <i>P</i><sub>1</sub> <span class="symbol">⊕</span> <i>KS</i> and a second ciphertext <i>C</i><sub>2</sub> = <i>P</i><sub>2</sub> <span class="symbol">⊕</span> <i>KS</i>, and if you know <i>P</i><sub>1</sub>, then you could determine <i>P</i><sub>2</sub> = <i>C</i><sub>1</sub> <span class="symbol">⊕</span> <i>C</i><sub>2</sub> <span class="symbol">⊕</span> <i>P</i><sub>1</sub>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_89" aria-label="89"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><span class="note_Italic">Nonce</span> <i>is short for “number used only once.” In the context of stream ciphers, we sometimes call it the</i> <span class="note_Italic">IV</span><i>, for “initial value.”</i></p>&#13;
<p class="TX">From a high-level perspective, there are two types of stream ciphers: stateful and counter based. <i>Stateful stream ciphers</i> have a secret internal state that evolves throughout keystream generation. The cipher initializes the state from the key and the nonce and then calls an update function to update the state value and produce one or more keystream bits from the state, as <a href="chapter5.xhtml#fig5-2">Figure 5-2</a> shows. For example, RC4 is stateful while Salsa20 is counter based.</p>&#13;
<figure class="IMG"><img id="fig5-2" class="img7" src="../images/fig5-2.jpg" alt="" width="917" height="397"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: A stateful stream cipher</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><i>Counter-based stream ciphers</i> produce chunks of a keystream from a key, a nonce, and a counter value, as in <a href="chapter5.xhtml#fig5-3">Figure 5-3</a>. Unlike stateful stream ciphers, counter-based stream ciphers such as Salsa20 don’t keep track of a secret during keystream generation, apart from the counter’s value.</p>&#13;
<figure class="IMG"><img id="fig5-3" class="img7" src="../images/fig5-3.jpg" alt="" width="676" height="403"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: A counter-based stream cipher</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">These two approaches define the high-level architecture of the stream cipher, regardless of how the core algorithms work. The internals of the stream cipher also fall into two categories, depending on the target platform of the cipher: hardware oriented and software oriented.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-37"/><samp class="SANS_Futura_Std_Bold_B_11">Hardware-Oriented Stream Ciphers</samp></h3>&#13;
<p class="TNI">When cryptographers talk about hardware, they mean application-specific integrated circuits (ASICs), programmable logic devices (PLDs), and field-programmable gate arrays (FPGAs). A cipher’s hardware implementation <span role="doc-pagebreak" epub:type="pagebreak" id="pg_90" aria-label="90"/>is an electronic circuit that implements the cryptographic algorithm at the bit level and that can’t be used for anything else; in other words, the circuit is <i>dedicated hardware</i>. On the other hand, software implementations of cryptographic algorithms simply tell a microprocessor what instructions to execute in order to run the algorithm. These instructions operate on bytes or words and then call pieces of electronic circuits that implement general-purpose operations such as addition and multiplication. Software deals with bytes or words of 32 or 64 bits, whereas hardware deals with bits. The first stream ciphers worked with bits to save complex wordwise operations and thus be more efficient in hardware, their target platform at the time.</p>&#13;
<p class="TX">Stream ciphers were mainly used for hardware implementations because they were cheaper than block ciphers. They needed less memory and fewer logical gates than block ciphers and therefore occupied a smaller area on an integrated circuit, which reduced fabrication costs. For example, counting in gate-equivalents, the standard area metric for integrated circuits, you could find stream ciphers taking less than 1,000 gate-equivalents; by contrast, typical software-oriented block ciphers needed at least 10,000 gate-equivalents, making crypto an order of magnitude more expensive than with stream ciphers.</p>&#13;
<p class="TX">Today, however, block ciphers are no longer more expensive than stream ciphers—first, because there are now hardware-friendly block ciphers about as small as stream ciphers, and second, because the cost of hardware has plunged. Yet stream ciphers are often associated with hardware because they used to be the best option.</p>&#13;
<p class="TX">In the next section, I’ll explain the basic mechanism behind hardware stream ciphers, called <i>feedback shift registers (FSRs)</i>. Almost all hardware stream ciphers rely on FSRs in some way, whether that’s the A5/1 cipher used in 2G mobile phones or the more recent Grain-128a cipher.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The first standard block cipher, the Data Encryption Standard (DES), was optimized for hardware rather than software. When the US government standardized DES in the 1970s, most target applications were hardware implementations. It’s therefore no surprise that the S-boxes in DES are small and fast to compute when implemented as a logical circuit in hardware but inefficient in software. Unlike DES, the current Advanced Encryption Standard (AES) deals with bytes and is therefore more efficient in software than DES.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-64"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Feedback Shift Registers</samp></h4>&#13;
<p class="TNI">Countless stream ciphers use FSRs because they’re simple and well understood. An FSR is an array of bits equipped with an update <i>feedback function</i>, which I’ll denote as <b>f</b>. The FSR’s state is stored in the array, or register, and each <i>update</i> of the FSR uses the feedback function to change the state’s value and to produce one output bit.</p>&#13;
<p class="TX">In practice, an FSR works like this: if <i>R</i><sub>0</sub> is the initial value of the FSR, the next state, <i>R</i><sub>1</sub>, is defined as <i>R</i><sub>0</sub> left-shifted by 1 bit, where the bit leaving the register is returned as output and where the empty position is filled with <b>f</b>(<i>R</i><sub>0</sub>).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_91" aria-label="91"/>We repeat the same rule to compute the subsequent state values <i>R</i><sub>2</sub>, <i>R</i><sub>3</sub>, and so on. That is, given <i>R</i><span class="ePub-I-SUB">t</span>, the FSR’s state at time <i>t</i>, the next state, <i>R</i><span class="ePub-I-SUB">t</span> <sub>+ 1</sub>, is the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg91-1.jpg" alt="" width="1392" height="42"/></figure>&#13;
<p class="TX">In this equation, <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> is the logical OR operator, and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;</samp> is the shift operator, as used in the C language. For example, given the 8-bit string 00001111, we have this:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg91-2.jpg" alt="" width="1392" height="155"/></figure>&#13;
<p class="TX">The bit shift moves the bits to the left, losing the leftmost bit to retain the state’s bit length and zeroing the rightmost bit. The update operation of an FSR is identical, except that instead of being set to 0, the rightmost bit is set to <b>f</b>(<i>R</i><span class="ePub-I-SUB">t</span>).</p>&#13;
<p class="TX">Consider, for example, a 4-bit FSR whose feedback function <b>f</b> XORs all 4 bits together. Initialize the state to the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg91-3.jpg" alt="" width="1392" height="30"/></figure>&#13;
<p class="TX">Now shift the bits to the left, where 1 is output and the rightmost bit is set to the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg91-4.jpg" alt="" width="1392" height="47"/></figure>&#13;
<p class="TX">Now the state becomes this:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg91-5.jpg" alt="" width="1392" height="30"/></figure>&#13;
<p class="TX">The next update outputs 1, left-shifts the state, and sets the rightmost bit to the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg91-6.jpg" alt="" width="1392" height="48"/></figure>&#13;
<p class="TX">Now the state is this:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg91-7.jpg" alt="" width="1392" height="30"/></figure>&#13;
<p class="TX">The next three updates return three 0 bits and give the following state values:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg91-8.jpg" alt="" width="1392" height="155"/></figure>&#13;
<p class="TX">We thus return to our initial state of 1100 after five iterations; updating the state five times from any of the values observed throughout this cycle <span role="doc-pagebreak" epub:type="pagebreak" id="pg_92" aria-label="92"/>returns us to this initial value. We say that 5 is the <i>period</i> of the FSR given any one of the values 1100, 1000, 0001, 0011, or 0110. Because the period of this FSR is 5, clocking the register 10 times yields twice the same 5-bit sequence. Likewise, if you clock the register 20 times, starting from 1100, the output bits will be 11000110001100011000, or four times the same 5-bit sequence of 11000. Intuitively, such repeating patterns should be avoided, and a longer period is better for security.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you plan to use an FSR in a stream cipher, avoid one with short periods, which make the output more predictable. With some types of FSRs, it’s easy to figure out their period, but it’s almost impossible to do so with others.</i></p>&#13;
<p class="TX"><a href="chapter5.xhtml#fig5-4">Figure 5-4</a> shows the structure of this cycle, along with the other cycles of that FSR, with each cycle being a circle whose dots represent a state of the register.</p>&#13;
<figure class="IMG"><img id="fig5-4" class="img7" src="../images/fig5-4.jpg" alt="" width="901" height="602"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: Cycles of the FSR whose feedback function XORs the 4 bits together</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Indeed, this particular FSR has two other period-5 cycles—{0100, 1001, 0010, 0101, 1010} and {1111, 1110, 1101, 1011, 0111}. Note that any given state can belong to only one cycle of states. Here, we have three cycles of five states each, covering 15 of the 2<sup>4</sup> = 16 possible values of our 4-bit register. The 16th possible value is 0000, which, as <a href="chapter5.xhtml#fig5-4">Figure 5-4</a> shows, is a period-1 cycle because the FSR transforms 0000 to 0000.</p>&#13;
<p class="TX">An FSR is essentially a register of bits, where each update of the register outputs a bit (the leftmost bit of the register) and where a function computes the new rightmost bit of the register. (All other bits are left-shifted.) The period of an FSR, from some initial state, is the number of updates needed until the FSR enters the same state again. If it takes <i>N</i> updates to do so, the FSR will produce the same <i>N</i> bits again and again.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_93" aria-label="93"/>&#13;
<h5 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Linear Feedback Shift Registers</samp></h5>&#13;
<p class="TNI"><i>Linear feedback shift registers (LFSRs)</i> are FSRs with a <i>linear</i> feedback function—namely, a function that’s the XOR of some bits of the state, such as the example of a 4-bit FSR in the previous section and its feedback function returning the XOR of the register’s 4 bits. Recall that in cryptography, linearity is synonymous with predictability and suggestive of a simple underlying mathematical structure. And, as you might expect, thanks to this linearity, we can analyze LFSRs using notions like linear complexity, finite fields, and primitive polynomials—but I’ll skip the math details and just give you the essential facts.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In linear algebra, we define a linear transform</i> <b><i>f</i></b> <i>as a function that satisfies</i> <b><i>f</i></b><i>(</i><span class="note_Italic">u</span> <i>+</i> <span class="note_Italic">v</span><i>) =</i> <b><i>f</i></b><i>(</i><span class="note_Italic">u</span><i>) +</i> <b><i>f</i></b><i>(</i><span class="note_Italic">v</span><i>). If you know</i> <b><i>f</i></b><span class="note_Italic">(u)</span> <i>and</i> <b><i>f</i></b><i>(</i><span class="note_Italic">v</span><i>), you can then determine</i> <b><i>f</i></b><i>(</i><span class="note_Italic">u</span> <i>+</i> <span class="note_Italic">v</span><i>) without knowing</i> <span class="note_Italic">u</span> <i>or</i> <span class="note_Italic">v</span><i>. With a nonlinear function, it’s much more complicated; you can’t easily find</i> <b><i>f</i></b><i>(</i><span class="note_Italic">u</span> <i>+</i> <span class="note_Italic">v</span><i>) from</i> <b><i>f</i></b><i>(</i><span class="note_Italic">u</span><i>) and</i> <b><i>f</i></b><i>(</i><span class="note_Italic">v</span><i>).</i></p>&#13;
<p class="TX">The choice of which bits to XOR together is crucial for the period of the LFSR and thus for its cryptographic value. The good news is that we know how to select the position of the bits to guarantee a maximal period of 2<i><sup>n</sup></i> – 1. Specifically, we take the indices of the bits, from 1 for the rightmost to <i>n</i> for the leftmost, and write the polynomial expression 1 + <i>X</i> + <i>X</i> <sup>2</sup> + . . . + <i>X</i> <i><sup>n</sup></i>, where we include the term <i>X</i> <i><sup>i</sup></i> only if the <i>i</i>th bit is one of the bits XORed in the feedback function. The period is maximal <i>if and only if</i> that polynomial is <i>primitive</i>. To be primitive, the polynomial must have the following qualities:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The polynomial must be irreducible, meaning that it can’t be factorized—that is, written as a product of smaller polynomials. For example, <i>X</i> + <i>X</i> <sup>3</sup> is not irreducible because it’s equal to (1 + <i>X</i>)(<i>X</i> + <i>X</i><sup>2</sup>):</li>&#13;
</ul>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg93-1.jpg" alt="" width="1384" height="60"/></figure>&#13;
<ul class="ul">&#13;
<li class="BL">The polynomial must satisfy certain other mathematical properties that cannot be easily explained without nontrivial mathematical notions but are easy to test.</li>&#13;
</ul>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The maximal period of an</i> <span class="note_Italic">n</span><i>-bit LFSR is 2</i><sup>n</sup> – <i>1, not 2</i><sup>n</sup><i>, because the all-zero state always loops on itself infinitely. Because the XOR of any number of zeros is zero, new bits entering the state from the feedback functions will always be zero; hence, the all-zero state is doomed to stay all zeros.</i></p>&#13;
<p class="TX">For example, <a href="chapter5.xhtml#fig5-5">Figure 5-5</a> shows a 4-bit LFSR with the feedback polynomial 1 + <i>X</i> + <i>X</i><sup>3</sup> + <i>X</i><sup>4</sup> in which we XOR the bits at positions 1, 3, and 4 together to compute the new bit set to <i>L</i><sub>1</sub>. However, this polynomial isn’t primitive because we can factorize it into (1 + <i>X</i><sup>3</sup>)(1 + <i>X</i>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_94" aria-label="94"/>&#13;
<figure class="IMG"><img id="fig5-5" class="img7" src="../images/fig5-5.jpg" alt="" width="695" height="156"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: An LFSR with the feedback polynomial 1 +</samp> <samp class="SANS_Futura_Std_Book_11">X</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp> <samp class="SANS_Futura_Std_Book_11">X</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp> <samp class="SANS_Futura_Std_Book_11">X</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">4</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Indeed, the period of the LFSR in <a href="chapter5.xhtml#fig5-5">Figure 5-5</a> isn’t maximal. To prove this, start from the state 0001:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg94-1.jpg" alt="" width="1376" height="30"/></figure>&#13;
<p class="TX">Now left-shift by 1 bit and set the new bit to 0 + 0 + 1 = 1:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg94-2.jpg" alt="" width="1376" height="30"/></figure>&#13;
<p class="TX">Repeating the operation five more times gives the following state values:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg94-3.jpg" alt="" width="1376" height="217"/></figure>&#13;
<p class="TX">The state after six updates is the same as the initial one, demonstrating that we’re in a period-6 cycle and proving that the LFSR’s period isn’t the maximal value of 15.</p>&#13;
<p class="TX">Let’s now look at an LFSR with a maximal period, considering the LFSR in <a href="chapter5.xhtml#fig5-6">Figure 5-6</a>.</p>&#13;
<figure class="IMG"><img id="fig5-6" class="img7" src="../images/fig5-6.jpg" alt="" width="695" height="156"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-6: An LFSR with the feedback polynomial 1 +</samp> <samp class="SANS_Futura_Std_Book_11">X</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp> <samp class="SANS_Futura_Std_Book_11">X</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">4</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, a primitive polynomial, ensuring a maximal period</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This feedback polynomial is a primitive polynomial described by 1 + <i>X</i> <sup>3</sup> + <i>X</i> <sup>4</sup>, and you can verify that its period is maximal (namely, 15). From an initial value, the state evolves as follows (from 0001 to 0010, 0100, 1001, 0011, and so on):</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg94-4.jpg" alt="" width="1376" height="180"/></figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_95" aria-label="95"/>The state spans all possible values except 0000 with no repetition until it eventually loops. This demonstrates that the period is maximal and that the feedback polynomial is primitive.</p>&#13;
<p class="TX">Alas, using an LFSR as a stream cipher is not secure. If <i>n</i> is the LFSR’s bit length, an attacker needs only <i>n</i> output bits to recover the LFSR’s initial state, allowing them to determine all previous bits and predict all future bits. This attack is possible because the LFSR is linear, implying that relations between the bits of the state obey linear equations, which are simple to solve. You can use the Berlekamp–Massey algorithm to solve the equations defined by the LFSR’s mathematical structure to find not only the LFSR’s initial state but also its feedback polynomial. In fact, you don’t even need to know the exact length of the LFSR to succeed; you can repeat the Berlekamp–Massey algorithm for all possible values of <i>n</i> until you hit the right one.</p>&#13;
<p class="TX">The upshot is that LFSRs are cryptographically weak because they’re linear. Output bits and initial state bits are related by simple and short equations that you can solve with high school linear algebra techniques. To strengthen LFSRs, let’s add a pinch of nonlinearity.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h5 class="H3" id="sec5"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Filtered LFSRs</samp></h5>&#13;
<p class="TNI">To mitigate the insecurity of LFSRs, hide their linearity by passing their output bits through a nonlinear function before returning them to produce a <i>filtered LFSR</i>, as <a href="chapter5.xhtml#fig5-7">Figure 5-7</a> illustrates.</p>&#13;
<figure class="IMG"><img id="fig5-7" class="img7" src="../images/fig5-7.jpg" alt="" width="695" height="429"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-7: A filtered LFSR</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <b>g</b> function in <a href="chapter5.xhtml#fig5-7">Figure 5-7</a> must be a <i>nonlinear</i> function—one that both XORs bits together and combines them with logical AND or OR operations. For example, <i>L</i><sub>1</sub><i>L</i><sub>2</sub> + <i>L</i><sub>3</sub><i>L</i><sub>4</sub> is a nonlinear function (I’ve omitted the multiplication sign, so <i>L</i><sub>1</sub><i>L</i><sub>2</sub> means <i>L</i><sub>1</sub> × <i>L</i><sub>2</sub>, or <i>L</i><sub>1</sub> &amp; <i>L</i><sub>2</sub> using C syntax).</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can write feedback functions either directly in terms of an FSR’s bits, like</i> <span class="note_Italic">L</span><span class="ePub-I-SUB">1</span><span class="note_Italic">L</span><span class="ePub-I-SUB">2</span> <i>+</i> <span class="note_Italic">L</span><span class="ePub-I-SUB">3</span><span class="note_Italic">L</span><span class="ePub-I-SUB">4</span><i>, or using the equivalent polynomial notation 1 +</i> <span class="note_Italic">XX</span><i><sup>2</sup></i> <i>+</i> <span class="note_Italic">X</span><i><sup>3</sup></i><span class="note_Italic">X</span><i><sup>4</sup></i><i>. The direct notation is easier to grasp, but the polynomial notation better serves the mathematical analysis of an FSR’s properties. We’ll stick to the direct notation unless we care about the mathematical properties.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_96" aria-label="96"/>Filtered LFSRs are stronger than plain LFSRs because their nonlinear function thwarts straightforward attacks. Still, more complex attacks such as the following will break the system:</p>&#13;
<p class="RunInPara"><b>Algebraic attacks </b>Solve the nonlinear equation systems deduced from the output bits, where unknowns in the equations are bits from the LFSR state.</p>&#13;
<p class="RunInPara"><b>Cube attacks </b>Compute derivatives of the nonlinear equations to reduce the degree of the system down to one and then solve it efficiently like a linear system.</p>&#13;
<p class="RunInPara"><b>Fast correlation attacks </b>Exploit filtering functions that, despite their nonlinearity, tend to behave like linear functions.</p>&#13;
<p class="TX">The lesson here, as we’ve seen in previous examples, is that Band-Aids don’t fix bullet holes. Patching a broken algorithm with a slightly stronger layer won’t make the whole thing secure. You must fix the problem at the core.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h5 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Nonlinear FSRs</samp></h5>&#13;
<p class="TNI"><i>Nonlinear FSRs (NFSRs)</i> are like LFSRs but with a nonlinear feedback function instead of a linear one. Instead of just bitwise XORs, the feedback function can include bitwise AND and OR operations—a feature with both pros and cons.</p>&#13;
<p class="TX">One benefit of the addition of nonlinear feedback functions is that they make NFSRs cryptographically stronger than LFSRs because the output bits depend on the initial secret state in a complex fashion, according to equations of exponential size. The LFSRs’ linear function keeps the relations simple, with at most <i>n</i> terms (<i>N</i><sub>1</sub>, <i>N</i><sub>2</sub>, . . . , <i>N</i><span class="ePub-I-SUB">n</span>, if the <i>N</i><span class="ePub-I-SUB">i</span>s are the NFSR’s state bits). For example, a 4-bit NFSR with an initial secret state (<i>N</i><sub>1</sub>, <i>N</i><sub>2</sub>, <i>N</i><sub>3</sub>, <i>N</i><sub>4</sub>) and a feedback function <i>N</i><sub>1</sub> + <i>N</i><sub>2</sub> + <i>N</i><sub>1</sub><i>N</i><sub>2</sub> + <i>N</i><sub>3</sub><i>N</i><sub>4</sub> produce a first output bit equal to the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg96-1.jpg" alt="" width="1389" height="40"/></figure>&#13;
<p class="TX">The second iteration replaces the <i>N</i><sub>1</sub> value with that new bit. Expressing the second output bit in terms of the initial state, we get the following equation:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg96-2.jpg" alt="" width="1389" height="111"/></figure>&#13;
<p class="TX">This new equation has algebraic degree 3 (the highest number of bits multiplied together, here in <i>N</i><sub>1</sub><i>N</i><sub>3</sub><i>N</i><sub>4</sub>) rather than degree 2 of the feedback function, and it has six terms instead of four. As a result, iterating the nonlinear function quickly yields unmanageable equations because the size of the output grows exponentially. Although you’ll never compute those equations when running the NFSR, an attacker has to solve them in order to break the system.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_97" aria-label="97"/>One downside to NFSRs is that there’s no efficient way to determine an NFSR’s period or to know whether its period is maximal. For an NFSR of <i>n</i> bits, you need to run close to 2<i><sup>n</sup></i> trials to verify that its period is maximal. This calculation is impossible for large NFSRs of 80 bits or more.</p>&#13;
<p class="TX">Fortunately, there’s a trick to using an NFSR without worrying about short periods: you can combine LFSRs and NFSRs to get both a guaranteed maximal period and the cryptographic strength—and that’s exactly how Grain-128a works.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-65"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grain-128a</samp></h4>&#13;
<p class="TNI">Remember the AES competition discussed in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, in the context of the AES block cipher? The stream cipher Grain is the offspring of a similar project called the eSTREAM competition. This competition closed in 2008 with a shortlist of recommended stream ciphers, which included four hardware-oriented ciphers and four software-oriented ones. Grain is one of these hardware ciphers, and Grain-128a is an upgraded version from the original authors of Grain. <a href="chapter5.xhtml#fig5-8">Figure 5-8</a> shows the action mechanism of Grain-128a.</p>&#13;
<figure class="IMG"><img id="fig5-8" class="img7" src="../images/fig5-8.jpg" alt="" width="744" height="426"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-8: The mechanism of Grain-128a, with a 128-bit NFSR and a 128-bit LFSR</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Grain-128a is about as simple as a stream cipher can be, combining a 128-bit LFSR, a 128-bit NFSR, and a filter function, <b>h</b>. The LFSR has a maximal period of 2<sup>128</sup> – 1, which ensures that the period of the whole system is at least 2<sup>128</sup> – 1 to protect against potential short cycles in the NFSR. At the same time, the NFSR and the nonlinear filter function <b>h</b> add cryptographic strength.</p>&#13;
<p class="TX">Grain-128a takes a 128-bit key and a 96-bit nonce. It copies the 128 key bits into the NFSR’s 128 bits and copies the 96 nonce bits into the first 96 LFSR bits, filling the 32 bits left with ones and a single zero bit at the end. The initialization phase updates the whole system 256 times before returning the first keystream bit. During initialization, the bit returned by the <b>h</b> function is thus not output as a keystream but instead goes into the LFSR to ensure that its subsequent state depends on both the key and the nonce.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_98" aria-label="98"/>Grain-128a’s LFSR feedback function is</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg98-1.jpg" alt="" width="1389" height="47"/></figure>&#13;
<p class="Continued">where <i>L</i><sub>1</sub>, <i>L</i><sub>2</sub>, . . . , <i>L</i><sub>128</sub> are the bits of the LFSR. This feedback function takes only 6 bits from the 128-bit LFSR, but that’s enough to get a primitive polynomial that guarantees a maximal period. The small number of bits minimizes the cost of a hardware implementation.</p>&#13;
<p class="TX">Here is the feedback polynomial of Grain-128a’s NFSR (<i>N</i><sub>1</sub>, . . . , <i>N</i><sub>128</sub>):</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg98-2.jpg" alt="" width="1389" height="110"/></figure>&#13;
<p class="TX">This function was carefully chosen to maximize its cryptographic strength while minimizing its implementation cost. It has an algebraic degree of 4 because its term with the most variables has four variables (namely, <i>N</i><sub>33</sub><i>N</i><sub>35</sub><i>N</i><sub>36</sub><i>N</i><sub>40</sub>). Moreover, <b>g</b> can’t be approximated by a linear function because it’s highly nonlinear. Also, in addition to <b>g</b>, Grain-128a XORs the bit coming out from the LFSRs to feed the result back as the NFSR’s new, rightmost bit.</p>&#13;
<p class="TX">The filter function <b>h</b> is another nonlinear function; it takes 9 bits from the NFSR and 7 bits from the LFSR and combines them in a way that ensures good cryptographic properties.</p>&#13;
<p class="TX">As I write this, there is no known attack on Grain-128a, and I’m confident that it will remain secure. Grain-128a is used in some low-end embedded systems that need a compact and fast stream cipher—typically industrial proprietary systems—which is why Grain-128a is little known in the open source software community.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-66"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A5/1</samp></h4>&#13;
<p class="TNI">A5/1 is a stream cipher that was used to encrypt voice communications in the 2G mobile standard. The A5/1 standard was created in 1987 but only published in the late 1990s after it was reverse engineered. Attacks appeared in the early 2000s, and A5/1 was eventually broken in a way that allows actual (rather than theoretical) decryption of encrypted communications. Let’s see why and how.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">A5/1’s Mechanism</samp></h5>&#13;
<p class="TNI">As <a href="chapter5.xhtml#fig5-9">Figure 5-9</a> shows, A5/1 relies on three LFSRs and uses a trick that looks clever at first glance but actually fails to be secure.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_99" aria-label="99"/>&#13;
<figure class="IMG"><img id="fig5-9" class="img5" src="../images/fig5-9.jpg" alt="" width="518" height="763"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-9: The A5/1 cipher</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">A5/1 uses LFSRs of 19, 22, and 23 bits, with the polynomials for each as follows:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg99-1.jpg" alt="" width="1380" height="162"/></figure>&#13;
<p class="TX">How could this be seen as secure with only LFSRs and no NFSR? The trick lies in A5/1’s update mechanism. Instead of updating all three LFSRs at each clock cycle, the designers of A5/1 added a clocking rule that does the following:</p>&#13;
<p class="NLF">  1.  Checks the value of the 9th bit of LFSR 1, the 11th bit of LFSR 2, and the 11th bit of LFSR 3, called the <i>clocking bits</i>. Of those 3 bits, either all have the same value (1 or 0) or two have the same value.</p>&#13;
<p class="NLL">  2.  Clocks the registers whose clocking bits are equal to the majority value, 0 or 1. Either two or three LFSRs are clocked at each update.</p>&#13;
<p class="TX">Without this rule, A5/1 would provide no security whatsoever, and bypassing this rule is enough to break the cipher. However, that’s easier said than done, as you’ll see.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In A5/1’s irregular clocking rule, each register is clocked with a probability of 3/4 at any update. Namely, the probability that at least one other register has the same bit value is 1 – (1/2)</i><i><sup>2</sup></i><i>, where (1/2)</i><i><sup>2</sup></i> <i>is the chance that both of the other two registers have a different bit value.</i></p>&#13;
<p class="TX">2G communications use A5/1 with a key of 64 bits and a 22-bit nonce, which changes for every new data frame. The initialization mechanism of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_100" aria-label="100"/>A5/1 first sets all registers to zero and injects the key followed by the nonce bit by bit to each register, and after each bit is injected, the registers are updated. The system is then updated 100 times following the previously described irregular rule.</p>&#13;
<p class="TX">Attacks on A5/1 recover the 64-bit initial state of the system (the 19 + 22 + 23 LFSR initial value), in turn revealing the nonce (if it wasn’t already known) and the key, by unwinding the initialization mechanism. The attacks are <i>known-plaintext attacks (KPAs)</i> because part of the encrypted data is known, which allows attackers to determine the corresponding keystream parts by XORing the ciphertext with the known plaintext chunks.</p>&#13;
<p class="TX">There are two main types of attacks on A5/1:</p>&#13;
<p class="RunInPara"><b>Subtle attacks </b>Exploit the internal linearity of A5/1 and its simple irregular clocking system.</p>&#13;
<p class="RunInPara"><b>Brutal attacks </b>Exploit only the short key of A5/1 and the invertibility of the frame number injection.</p>&#13;
<p class="TX">Let’s see how these attacks work.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h5 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Subtle Attacks</samp></h5>&#13;
<p class="TNI">We’ll examine the <i>guess-and-determine</i> subtle attack. In this kind of attack, an attacker guesses certain secret values of the state to determine others. In cryptanalysis, “guessing” means brute-forcing: for each possible value of LFSRs 1 and 2 and all possible values of LFSR 3’s clocking bit during the first 11 clocks, the attack reconstructs LFSR 3’s bits by solving equations that depend on the bits guessed. When the guess is correct, the attacker gets the right value for LFSR 3.</p>&#13;
<p class="TX">The attack’s pseudocode looks like this:</p>&#13;
<pre><code>For all 2<span class="TheSansMonoCd_W5Regular_SUP">19</span> values of LFSR 1's initial state&#13;
    For all 2<span class="TheSansMonoCd_W5Regular_SUP">22</span> values of LFSR 2's initial state&#13;
        For all 2<span class="TheSansMonoCd_W5Regular_SUP">11</span> values of LFSR 3's clocking bit during the first 11 clocks&#13;
            Reconstruct LFSR 3's initial state&#13;
            Test whether guess is correct; if yes, return; else continue</code></pre>&#13;
<p class="TX">How efficient is this attack compared to the 2<sup>64</sup>-trial brute-force search discussed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>? This attack makes at most 2<sup>19</sup> × 2<sup>22</sup> × 2<sup>11</sup> = 2<sup>52</sup> operations in the worst case, when the algorithm succeeds only at the very last test. That’s 2<sup>12</sup> (or about 4,000) times faster than in the brute-force search, assuming that the last two operations in the previous pseudocode require about as much computation as testing a 64-bit key in a brute-force search. But is this assumption correct?</p>&#13;
<p class="TX">Recall our discussion of the full attack cost in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>. When evaluating the cost of an attack, we need to consider not only the amount of computation required to perform the attack but also parallelism and memory consumption. Neither is an issue here: as with any brute-force attack, the guess-and-determine attack is embarrassingly parallel (or <i>N</i> times faster when run on <i>N</i> cores) and doesn’t need more memory than just running the cipher itself.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_101" aria-label="101"/>Our 2<sup>52</sup> attack cost estimate is inaccurate for another reason. In fact, each of the 2<sup>52</sup> operations (testing a key candidate) takes about four times as many clock cycles as does testing a key in a brute-force attack. The upshot is that the real cost of this particular attack is closer to 4 × 2<sup>52</sup> = 2<sup>54</sup> operations when compared to a brute-force attack.</p>&#13;
<p class="TX">The guess-and-determine attack on A5/1 can decrypt encrypted mobile communications, but it takes a couple of hours to recover the key when run on a cluster of dedicated hardware devices. In other words, it’s nowhere near real-time decryption. For that, we have another type of attack.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h5 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Brutal Attacks</samp></h5>&#13;
<p class="TNI">The <i>time-memory trade-off (TMTO)</i> attack is the brutal attack on A5/1. This attack doesn’t care about A5/1’s internals; it cares only that its state is 64 bits long. The TMTO attack sees A5/1 as a black box that takes in a 64-bit value (the state) and spits out a 64-bit value (the first 64 keystream bits).</p>&#13;
<p class="TX">The idea behind the attack is to reduce the cost of a brute-force search in exchange for using a lot of memory. The simplest type of TMTO is a type of codebook attack, wherein you precompute a table of 2<sup>64</sup> elements containing a combination of key and value pairs (<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">key</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">value</samp>) and store the output value for each of the 2<sup>64</sup> possible keys. To use this precomputed table for the attack, simply collect the output of an A5/1 instance and then look up in the table which key corresponds to that output. The attack itself is fast—taking only the amount of time necessary to look up a value in memory—but the creation of the table takes 2<sup>64</sup> computations of A5/1. Worse, codebook attacks require an insane amount of memory: 2<sup>64</sup> × (64 + 64) bits, which is 2<sup>68</sup> bytes or 256 exabytes. That’s dozens of data centers, so we can forget about it.</p>&#13;
<p class="TX">TMTO attacks reduce the memory requirements of codebook attacks at the price of increased computation during the online phase of the attack. The smaller the table, the more computations required to crack a key. Regardless, it costs about 2<sup>64</sup> operations to prepare the table, but that needs to be done only once.</p>&#13;
<p class="TX">In 2010, researchers took about two months to generate two terabytes’ worth of tables, using graphics processing units (GPUs) and running 100,000 instances of A5/1 in parallel. With the help of such large tables, calls encrypted with A5/1 could be decrypted almost in real time. Telecommunication operators have implemented workarounds to mitigate the attack, but a real solution came with the 3G and 4G mobile telephony standards, which ditched A5/1 altogether.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H1" id="sec12"><span id="h1-38"/><samp class="SANS_Futura_Std_Bold_B_11">Software</samp><samp class="SANS_Futura_Std_Bold_B_11">-Oriented Stream Ciphers</samp></h3>&#13;
<p class="TNI">Software stream ciphers work with bytes or 32- or 64-bit words instead of individual bits, which proves to be more efficient on modern CPUs where instructions can perform arithmetic operations on a word in the same amount of time as on a bit. Software stream ciphers are therefore better suited than <span role="doc-pagebreak" epub:type="pagebreak" id="pg_102" aria-label="102"/>hardware ciphers for servers or browsers running on personal computers, where powerful general-purpose processors run the cipher as native software.</p>&#13;
<p class="TX">Today, there is considerable interest in software stream ciphers for a few reasons. First, because many devices embed powerful CPUs and hardware has become cheaper, there’s less of a need for small bit-oriented ciphers. For example, the two stream ciphers in the mobile communications standard 4G (the European SNOW3G and the Chinese ZUC) work with 32-bit words and not bits, unlike the older A5/1.</p>&#13;
<p class="TX">Second, stream ciphers have gained popularity in software at the expense of block ciphers, notably following the fiasco of the padding oracle attack against block ciphers in CBC mode. In addition, stream ciphers are easier to specify and to implement than block ciphers: instead of mixing message and key bits together, stream ciphers just ingest key bits as a secret. In fact, one of the most popular stream ciphers is actually a block cipher in disguise: AES in counter mode (CTR).</p>&#13;
<p class="TX">One software stream cipher design, used by SNOW3G and ZUC, copies hardware ciphers and their FSRs, replacing bits with bytes or words. But these aren’t the most interesting designs for a cryptographer. As of this writing, the two designs of most interest are RC4 and Salsa20, which are used in numerous systems, despite the fact that one is completely broken.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-67"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">RC4</samp></h4>&#13;
<p class="TNI">Designed in 1987 by Ron Rivest of RSA Security and then reverse engineered and leaked in 1994, RC4 has long been the most widely used stream cipher. RC4 has been used in countless applications, most famously in the first Wi-Fi encryption standard Wired Equivalent Privacy (WEP) and in the Transport Layer Security (TLS) protocol used to establish HTTPS connections. Unfortunately, RC4 isn’t secure enough for most applications, including WEP and TLS. To understand why, let’s see how RC4 works.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h5 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">How RC4 Works</samp></h5>&#13;
<p class="TNI">RC4 is among the simplest ciphers ever created. It doesn’t perform any crypto-like operations, and it has no XORs, no multiplications, no S-boxes . . . nada. It simply swaps bytes. RC4’s internal state is an array, <i>S</i>, of 256 bytes, first set to <i>S</i>[0] = 0, <i>S</i>[1] = 1, <i>S</i>[2] = 2, . . . , <i>S</i>[255] = 255, and then initialized from an <i>n</i>-byte <i>K</i> using its <i>key scheduling algorithm (KSA)</i>, which works as in the Python code in <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a>.</p>&#13;
<span id="Lis5-1"/><pre><code>j = 0&#13;
# Set S to the array S[0] = 0, S[1] = 1, . . . , S[255] = 255.&#13;
S = range(256)&#13;
# Iterate over i from 0 to 255.&#13;
for i in range(256):&#13;
    # Compute the sum of v.&#13;
    j = (j + S[i] + K[i % n]) % 256&#13;
    # Swap S[i] and S[j].&#13;
    S[i], S[j] = S[j], S[i]</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: The key scheduling algorithm of RC4</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_103" aria-label="103"/>Once this algorithm completes, array <i>S</i> still contains all the byte values from 0 to 255 but now in a random-looking order. For example, with the all-zero 128-bit key, the state <i>S</i> (from <i>S</i>[0] to <i>S</i>[255]) becomes:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg103-1.jpg" alt="" width="1390" height="39"/></figure>&#13;
<p class="TX">However, if I flip the first key bit and run the KSA again, I get a totally different, apparently random state:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg103-2.jpg" alt="" width="1390" height="38"/></figure>&#13;
<p class="TX">Given the initial state <i>S</i>, RC4 generates a keystream, <i>KS</i>, of the same length as the plaintext, <i>P</i>, to compute a ciphertext: <i>C</i> = <i>P</i> <span class="symbol">⊕</span> <i>KS</i>. The bytes of the keystream <i>KS</i> are computed from <i>S</i> according to the Python code in <a href="chapter5.xhtml#Lis5-2">Listing 5-2</a>, if <i>P</i> is <i>m</i> bytes long.</p>&#13;
<span id="Lis5-2"/><pre><code>i = 0&#13;
j = 0&#13;
for b in range(m):&#13;
    i = (i + 1) % 256&#13;
    j = (j + S[i]) % 256&#13;
    S[i], S[j] = S[j], S[i]&#13;
    KS[b] = S[(S[i] + S[j]) % 256]</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: The keystream generation of RC4, where</samp> <samp class="SANS_Futura_Std_Book_11">S</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">is the state initialized in <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a></samp></p>&#13;
<p class="TX">In <a href="chapter5.xhtml#Lis5-2">Listing 5-2</a>, each iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop modifies up to 2 bytes of RC4’s internal state <i>S</i>: the <i>S</i>[<i>i</i>] and <i>S</i>[<i>j</i>] whose values are swapped. That is, if <i>i</i> = 0 and <i>j</i> = 4 and if <i>S</i>[0] = 56 and <i>S</i>[4] = 78, then the swap operation sets <i>S</i>[0] to 78 and <i>S</i>[4] to 56. If <i>j</i> equals <i>i</i>, then S[<i>i</i>] isn’t modified.</p>&#13;
<p class="TX">This looks too simple to be secure, yet it took 20 years for cryptanalysts to find exploitable flaws. Before the flaws were revealed, we knew RC4’s weaknesses only in specific implementations, as in the first Wi-Fi encryption standard, WEP.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h5 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">RC4 in WEP</samp></h5>&#13;
<p class="TNI">WEP, the first-generation Wi-Fi security protocol, is now completely broken due to weaknesses in the protocol’s design and in RC4.</p>&#13;
<p class="TX">In its WEP implementation, RC4 encrypts payload data of 802.11 frames, the datagrams (or packets) that transport data over the wireless network. All payloads delivered in the same session use the same secret key of 40 or 104 bits but have what is a supposedly unique 3-byte nonce encoded in the frame header (the part of the frame that encodes metadata and comes before the actual payload).</p>&#13;
<p class="TX">The problem is that RC4 doesn’t support a nonce, at least not in its official specification, and we can’t use a stream cipher without a nonce. The WEP designers addressed this limitation with a workaround: they included a 24-bit nonce in the wireless frame’s header and prepended it to the WEP key to be used as RC4’s secret key. That is, if the nonce is the bytes <i>N</i>[0], <span role="doc-pagebreak" epub:type="pagebreak" id="pg_104" aria-label="104"/><i>N</i>[1], <i>N</i>[2] and the WEP key is <i>K</i>[0], <i>K</i>[1], <i>K</i>[2], <i>K</i>[3], <i>K</i>[4], the actual RC4 key is <i>N</i>[0], <i>N</i>[1], <i>N</i>[2], <i>K</i>[0], <i>K</i>[1], <i>K</i>[2], <i>K</i>[3], <i>K</i>[4]. The net effect is to have 40-bit secret keys yield 64-bit effective keys and to have 104-bit keys yield 128-bit effective keys. The result? The advertised 128-bit WEP protocol actually offers only 104-bit security, at best.</p>&#13;
<p class="TX">But here are the real problems with WEP’s nonce trick:</p>&#13;
<p class="RunInPara"><b>The nonces are too small at only 24 bits </b>This means that if a nonce is chosen randomly for each new message, you have to wait about 2<sup>24/2</sup> = 2<sup>12</sup> packets, or a few megabytes’ worth of traffic, until you can find two packets encrypted with the same nonce and thus the same keystream. Even if the nonce is a counter running from 0 to 2<sup>24</sup> – 1, it takes a few gigabytes’ worth of data until a rollover, when the repeated nonce can allow the attacker to decrypt packets. But there’s a bigger problem.</p>&#13;
<p class="RunInPara"><b>Combining the nonce and key in this fashion helps recover the key </b>WEP’s three nonsecret nonce bytes let an attacker determine the value of <i>S</i> after three iterations of the key scheduling algorithm. Because of this, cryptanalysts found that the first keystream byte strongly depends on the first secret key byte—the fourth byte ingested by the KSA—and that this bias can be exploited to recover the secret key.</p>&#13;
<p class="TX">Exploiting those weaknesses requires access to both ciphertexts and the keystream—that is, known or chosen plaintexts. But that’s easy enough: known plaintexts occur when the Wi-Fi frames encapsulate data with a known header, and chosen plaintexts occur when the attacker injects known plaintext encrypted with the target key. The upshot is that the attacks work in practice, not just on paper.</p>&#13;
<p class="TX">Following the appearance of the first attacks on WEP in 2001, researchers found faster attacks that required fewer ciphertexts. Today, you can even find tools such as aircrack-ng that implement the entire attack, from network sniffing to cryptanalysis.</p>&#13;
<p class="TX">WEP’s insecurity is due to both weaknesses in RC4, which takes a single one-use key instead of a key and a nonce (as in any decent stream cipher), and weaknesses in the WEP design itself.</p>&#13;
<p class="TX">Now let’s look at the second biggest failure of RC4.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h5 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">RC4 in TLS</samp></h5>&#13;
<p class="TNI">TLS is the single most important security protocol used on the internet. It’s best known for underlying HTTPS connections, but it’s also used to protect some virtual private network (VPN) connections, as well as email servers, mobile applications, and many others. And sadly, TLS has long supported RC4.</p>&#13;
<p class="TX">Unlike WEP, the TLS implementation doesn’t make the same blatant mistake of tweaking the RC4 specs in order to use a public nonce. Instead, TLS just feeds RC4 a unique 128-bit session key, which means it’s a bit less broken than WEP.</p>&#13;
<p class="TX">The weakness in TLS is due only to RC4 and its inexcusable flaws: statistical biases, or nonrandomness, which we know is a total deal-breaker for a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_105" aria-label="105"/>stream cipher. For example, the second keystream byte produced by RC4 is zero, with a probability of 1/128, whereas it should ideally be 1/256. (Recall that a byte can take 256 values from 0 to 255; hence, a truly random byte is zero with a chance of 1/256.) Crazier still is the fact that most experts continued to trust RC4 as late as 2013, even though its statistical biases have been known since 2001.</p>&#13;
<p class="TX">RC4’s known statistical biases should have been enough to ditch the cipher altogether, even if we didn’t know how to exploit the biases to compromise actual applications. In TLS, RC4’s flaws weren’t publicly exploited until 2011, but the NSA allegedly managed to exploit RC4’s weaknesses to compromise TLS’s RC4 connections well before then.</p>&#13;
<p class="TX">As it turned out, not only was RC4’s second keystream byte biased, but all of the first 256 bytes were biased as well. In 2011, researchers found that the probability that one of those bytes comes to zero equals 1/256 + <i>c</i>/256<sup>2</sup> for some constant, <i>c</i>, taking values between 0.24 and 1.34. It’s not just for the byte zero but for other byte values as well. The amazing thing about RC4 is that it fails where even many noncryptographic PRNGs succeed—namely, at producing uniformly distributed pseudorandom bytes (that is, where each of the 256 bytes has a chance of 1/256 of showing up).</p>&#13;
<p class="TX">RC4’s flawed TLS implementation can even be exploited in the weakest attack model, the chosen-ciphertext: you collect ciphertexts and look for the plaintext, not the key. But there’s a caveat: you’ll need many ciphertexts, encrypting <i>the same plaintext</i> several times using different secret keys. We sometimes call this attack model the <i>broadcast model</i> because it’s akin to broadcasting the same message to multiple recipients.</p>&#13;
<p class="TX">Say you want to decrypt the plaintext byte <i>P</i><sub>1</sub> of a plaintext P given many ciphertext bytes obtained by intercepting the different ciphertexts of the same message. You’ll thus obtain the first bytes of each of the four ciphertexts <i>C</i><sup>1</sup>, . . . , <i>C</i><sup>4</sup>, for four keystreams <i>KS</i><sup>1</sup>, . . . , <i>KS</i><sup>4</sup> such that:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg105-1.jpg" alt="" width="1387" height="245"/></figure>&#13;
<p class="TX">Because of RC4’s bias, keystream bytes <i>KS</i><sub>1</sub><i><sup>i</sup></i> (the first byte in each of the four instances) are more likely to be zero than any other byte value. Therefore, <i>C</i><sub>1</sub><i><sup>i</sup></i> bytes are more likely to be equal to <i>P</i><sub>1</sub> than to any other value. To determine <i>P</i><sub>1</sub> given the <i>C</i><sub>1</sub><i><sup>i</sup></i> bytes, simply count the number of occurrences of each byte value and return the most frequent one as <i>P</i><sub>1</sub>. However, because the statistical bias is very small, you need millions of values to get it right with any certainty.</p>&#13;
<p class="TX">The attack generalizes to recover more than one plaintext byte and to exploit more than one biased value (zero here). The algorithm just becomes a bit more complicated. However, this attack is hard to put into practice because it needs to collect many ciphertexts encrypting the same plaintext but using different keys. For example, the attack can’t break all <span role="doc-pagebreak" epub:type="pagebreak" id="pg_106" aria-label="106"/>TLS-protected connections that use RC4 because you need to trick the server into encrypting the same plaintext to many different recipients, or many times to the same recipient with different keys.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H2" id="sec17"><span id="h2-68"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Salsa20</samp></h4>&#13;
<p class="TNI">Salsa20 is a simple, software-oriented cipher optimized for modern CPUs that has been implemented in numerous protocols and libraries, along with its variant, ChaCha. Its designer, respected cryptographer Daniel J. Bernstein, submitted Salsa20 to the eSTREAM competition in 2005 and won a place in eSTREAM’s software portfolio. Salsa20’s simplicity and speed have made it popular among developers.</p>&#13;
<p class="TX">Salsa20 is a counter-based stream cipher—it generates its keystream by repeatedly processing a counter incremented for each block. As <a href="chapter5.xhtml#fig5-10">Figure 5-10</a> shows, the <i>Salsa20 core</i> algorithm transforms a 512-bit block using a key (<i>K</i>), a nonce (<i>N</i>), and a counter value (<i>Ctr</i>). Salsa20 then adds the result to the original value of the block to produce a <i>keystream block</i>. (If the algorithm were to return the core’s permutation directly as an output, Salsa20 would be totally insecure because it could be inverted. The final addition of the initial secret state <i>K</i> || <i>N</i> || <i>Ctr</i> makes the transform key-to-keystream-block noninvertible.)</p>&#13;
<figure class="IMG"><img id="fig5-10" class="img4" src="../images/fig5-10.jpg" alt="" width="273" height="479"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-10: Salsa20’s encryption scheme for a 512-bit plaintext block</samp></p></figcaption>&#13;
</figure>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h5 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using the Quarter-Round Function</samp></h5>&#13;
<p class="TNI">Salsa20’s core permutation uses a function called <i>quarter-round</i> (<b>QR</b>), which transforms four 32-bit words (<i>a</i>, <i>b</i>, <i>c</i>, and <i>d</i>) as follows:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg106-1.jpg" alt="" width="1373" height="242"/></figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_107" aria-label="107"/>We compute these four lines from top to bottom, meaning that the new value of <i>b</i> depends on <i>a</i> and on <i>d</i>, the new value of <i>c</i> depends on <i>a</i> and on the new value of <i>b</i> (and thus <i>d</i> as well), and so on.</p>&#13;
<p class="TX">The operation &lt;&lt;&lt; is wordwise left-rotation by the specified number of bits, which can be any value between 1 and 31 (for 32-bit words). For example, &lt;&lt;&lt; 8 rotates a word’s bits of eight positions toward the left, as the following examples show:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg107-1.jpg" alt="" width="1388" height="159"/></figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h5 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Transforming Salsa20’s 512-Bit State</samp></h5>&#13;
<p class="TNI">Salsa20’s core permutation transforms a 512-bit internal state viewed as a 4×4 array of 32-bit words. <a href="chapter5.xhtml#fig5-11">Figure 5-11</a> shows the initial state, using a key of eight words (256 bits), a nonce of two words (64 bits), a counter of two words (64 bits), and four fixed constant words (128 bits) that are identical for each encryption/decryption and all blocks.</p>&#13;
<figure class="IMG"><img id="fig5-11" class="img4" src="../images/fig5-11.jpg" alt="" width="414" height="413"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-11: The initialization of Salsa20’s state</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To transform the initial 512-bit state, Salsa20 first applies the <b>QR</b> transform to all four columns independently (known as the <i>column-round</i>) and then to all four rows independently (the <i>row-round</i>), as <a href="chapter5.xhtml#fig5-12">Figure 5-12</a> illustrates. The sequence column-round/row-round is a <i>double-round</i>. Salsa20 repeats 10 double-rounds, for 20 rounds in total, which is the reason for the <i>20</i> in <i>Salsa20</i>.</p>&#13;
<figure class="IMG"><img id="fig5-12" class="img7" src="../images/fig5-12.jpg" alt="" width="930" height="413"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-12: Columns and rows transformed by Salsa20’s quarter-round (</samp><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">QR</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">) function</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_108" aria-label="108"/>The column-round transforms the four columns like so:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg108-1.jpg" alt="" width="1389" height="238"/></figure>&#13;
<p class="TX">The row-round transforms the rows by doing the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg108-2.jpg" alt="" width="1389" height="239"/></figure>&#13;
<p class="TX">In a column-round, each <b>QR</b> takes <i>x</i><span class="ePub-I-SUB">i</span> arguments ordered from the top to the bottom line, whereas a row-round’s <b>QR</b> takes as a first argument the words on the diagonal (as in the array on the right in <a href="chapter5.xhtml#fig5-12">Figure 5-12</a>) rather than words from the first column.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h5 class="H3" id="sec20"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Evaluating Salsa20</samp></h5>&#13;
<p class="TNI"><a href="chapter5.xhtml#Lis5-3">Listing 5-3</a> shows Salsa20’s initial states for the first and second blocks when initialized with an all-zero key (<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes) and an all-one nonce (<samp class="SANS_TheSansMonoCd_W5Regular_11">ff</samp> bytes). These two states differ in only 1 bit, in the counter, which is in bold: specifically, 0 for the first block and 1 for the second.</p>&#13;
<span id="Lis5-3"/><pre><code>61707865 00000000 00000000 00000000      61707865 00000000 00000000 00000000&#13;
00000000 3320646e ffffffff ffffffff      00000000 3320646e ffffffff ffffffff&#13;
<b>00000000</b> 00000000 79622d32 00000000      <b>00000001</b> 00000000 79622d32 00000000&#13;
00000000 00000000 00000000 6b206574      00000000 00000000 00000000 6b206574</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: Salsa20’s initial states for the first two blocks with an all-zero key and an all-one nonce</samp></p>&#13;
<p class="TX">Yet, despite only a 1-bit difference, the respective internal states after 10 double-rounds are totally different from each other, as <a href="chapter5.xhtml#Lis5-4">Listing 5-4</a> shows.</p>&#13;
<span id="Lis5-4"/><pre><code>e98680bc f730ba7a 38663ce0 5f376d93      1ba4d492 c14270c3 9fb05306 ff808c64&#13;
85683b75 a56ca873 26501592 64144b6d      b49a4100 f5d8fbbd 614234a0 e20663d1&#13;
6dcb46fd 58178f93 8cf54cfe cfdc27d7      12e1e116 6a61bc8f 86f01bcb 2efead4a&#13;
68bbe09e 17b403a1 38aa1f27 54323fe0      77775a13 d17b99d5 eb773f5b 2c3a5e7d</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: The states from <a href="chapter5.xhtml#Lis5-3">Listing 5-3</a> after 10 Salsa20 double-rounds</samp></p>&#13;
<p class="TX">But remember, even though word values in the keystream block may look random, it’s far from a guarantee of security. RC4’s output looks random, but it has blatant biases. Fortunately, Salsa20 is much more secure than RC4 and doesn’t have statistical biases. Keep in mind, however, that even when keystreams are statistically indistinguishable from perfectly random bytes, this isn’t sufficient to achieve cryptographic security.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_109" aria-label="109"/>&#13;
<h5 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Learning Differential Cryptanalysis</samp></h5>&#13;
<p class="TNI">To demonstrate why Salsa20 is more secure than RC4, let’s look at the basics of <i>differential cryptanalysis</i>, the study of the differences between states rather than their actual values. For example, the two initial states in <a href="chapter5.xhtml#Lis5-3">Listing 5-3</a> differ by 1 bit in the counter or by the word <i>x</i><sub>8</sub> in the Salsa20 state array. The following array shows the bitwise difference between these two states:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg109-1.jpg" alt="" width="1386" height="181"/></figure>&#13;
<p class="TX">The difference between the two states is actually the XOR of these states. The 1 bit in bold corresponds to a 1-bit difference between the two states. In the XOR of the two states, any nonzero bits indicate differences.</p>&#13;
<p class="TX">To see how fast changes propagate in the initial state as a result of Salsa20’s core algorithm, let’s look at the difference between two states throughout the rounds iteration. After one round, the difference propagates across the first column to two of the three other words in that column:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg109-2.jpg" alt="" width="1386" height="185"/></figure>&#13;
<p class="TX">After two rounds, differences further propagate across the rows that already include a difference, which is all but the second row. At this point the differences between the states are rather sparse; not many bits have changed within a word:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg109-3.jpg" alt="" width="1386" height="189"/></figure>&#13;
<p class="TX">After three rounds, the differences between the states become more dense, though the many zero nibbles indicate that many bit positions are still not affected by the initial difference:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg109-4.jpg" alt="" width="1386" height="174"/></figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_110" aria-label="110"/>After four rounds, differences look random to a human observer, and they are also almost random statistically as well:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg110-1.jpg" alt="" width="1386" height="174"/></figure>&#13;
<p class="TX">After only four rounds, a single difference propagates to most of the bits in the 512-bit state. In cryptography, we call this <i>full diffusion</i>.</p>&#13;
<p class="TX">Not only do differences propagate across all states, they also do so according to complex equations that make future differences hard to predict because highly <i>nonlinear</i> relations drive the state’s evolution, thanks to the mix of XOR, addition, and rotation. If we used only XORs, we’d still have many differences propagating, but the process would be linear and therefore insecure.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h5 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacking Salsa20/8</samp></h5>&#13;
<p class="TNI">Salsa20 makes 20 rounds by default, but we sometimes use it with only 12 rounds, in a version called Salsa20/12, to make it faster. Although Salsa20/12 uses eight fewer rounds than Salsa20, it’s in practice as reliable as the 20-round version, according to the state-of-the-art research progress. Even Salsa20/8, with only eight rounds, is known to be only theoretically weaker but as solid in practice as Salsa20.</p>&#13;
<p class="TX">Breaking Salsa20 should ideally take 2<sup>256</sup> operations, thanks to its use of a 256-bit key. If one can recover the key by performing fewer than 2<sup>256</sup> operations, the cipher is in theory broken. That’s exactly the case with Salsa20/8.</p>&#13;
<p class="TX">The attack on Salsa20/8 (published in the 2008 paper “New Features of Latin Dances: Analysis of Salsa, ChaCha, and Rumba,” of which I’m a co-author and for which we won a cryptanalysis prize from Daniel J. Bernstein) exploits a statistical bias in Salsa’s core algorithm after four rounds to recover the key of eight-round Salsa20. In reality, this is mostly a theoretical attack: we estimate its complexity at 2<sup>251</sup> operations of the core function—infeasible, like any computation of, say, 2<sup>100</sup> operations or more, but less so than breaking the expected 2<sup>256</sup> complexity.</p>&#13;
<p class="TX">The attack exploits not only a bias over the first four rounds of Salsa20/8 but also a property of the last four rounds: knowing the nonce, <i>N</i>, and the counter, <i>Ctr</i> (refer to <a href="chapter5.xhtml#fig5-10">Figure 5-10</a>), the only value needed to invert the computation from the keystream back to the initial state is the key, <i>K</i>. But as <a href="chapter5.xhtml#fig5-13">Figure 5-13</a> shows, if you know only some part of <i>K</i>, you can partially invert the computation up until the fourth round and observe some bits of that intermediate state—including the biased bit! You’ll observe the bias only if you have the correct guess of the partial key; hence, the bias serves as an indicator that you’ve got the correct key.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_111" aria-label="111"/>&#13;
<figure class="IMG"><img id="fig5-13" class="img7" src="../images/fig5-13.jpg" alt="" width="911" height="464"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-13: The principle of the attack on Salsa20/8</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In the actual attack on Salsa20/8, to determine the correct guess we need to guess 220 bits of the key, and we need 2<sup>31</sup> pairs of keystream blocks, all with the same specific difference in the nonce. Once we single out the correct 220 bits, we brute-force 36 bits. The brute-forcing takes 2<sup>36</sup> operations, a computation that is dwarfed by the unrealistic 2<sup>220</sup> × 2<sup>31</sup> = 2<sup>251</sup> trials needed to find the 220 bits to complete the first part of the attack.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h3 class="H1" id="sec23"><span id="h1-39"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">Alas, many things can go wrong with stream ciphers, from brittle, insecure designs to strong algorithms incorrectly implemented. I’ll explore each category of potential problems in the following sections.</p>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h4 class="H2" id="sec24"><span id="h2-69"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nonce Reuse</samp></h4>&#13;
<p class="TNI">The most common failure with stream ciphers occurs when reusing a nonce more than once with the same key. This produces identical keystreams, allowing you to break the encryption—for example, by XORing two ciphertexts together; the keystream then vanishes, and you’re left with the XOR of the two plaintexts.</p>&#13;
<p class="TX">A real example is older versions of Microsoft Word and Excel that used a unique nonce for each document, but modifying a document didn’t change the nonce. As a result, one could use the clear and encrypted text of an older version of a document to decrypt later encrypted versions. If Microsoft made this blunder, you can imagine how large the problem might be.</p>&#13;
<p class="TX">Certain stream ciphers designed in the 2010s tried to mitigate the risk of nonce reuse by building “misuse-resistant” constructions, or ciphers that remain secure even if a nonce is used twice. However, achieving this level of security comes with a performance penalty, as you’ll see in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> with the SIV mode.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h4 class="H2" id="sec25"><span id="h2-70"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Broken RC4 Implementation</samp></h4>&#13;
<p class="TNI">Though it’s intrinsically weak, RC4 can become even weaker if you blindly optimize its implementation. For example, let’s consider an entry in the 2007 Underhanded C Contest, an informal competition where programmers write benign-looking code that actually includes a malicious function.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_112" aria-label="112"/>Here’s how it works. The naive way to implement the line <samp class="SANS_TheSansMonoCd_W5Regular_11">swap(S[i], S[j])</samp> in RC4’s algorithm is to do the following, as this Python code shows:</p>&#13;
<pre><code>buf = S[i]&#13;
S[i] = S[j]&#13;
S[j] = buf</code></pre>&#13;
<p class="TX">This way of swapping two variables works, but you need to create a new variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">buf</samp>. To avoid this, programmers often use the following <i>XOR-swap</i> trick to swap the values of the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>:</p>&#13;
<pre><code>x = x <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> y&#13;
y = x <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> y&#13;
x = x <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> y</code></pre>&#13;
<p class="TX">This works because the second line sets <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, and the third line sets <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">y = y</samp>. Using this trick to implement RC4 gives the implementation in <a href="chapter5.xhtml#Lis5-5">Listing 5-5</a> (adapted from David Wagner and Philippe Biondi’s program submitted to the 2007 Underhanded C Contest, and online at <i><a href="http://www.underhanded-c.org/_page_id_16.html">http://<wbr/>www<wbr/>.underhanded<wbr/>-c<wbr/>.org<wbr/>/<wbr/>_page<wbr/>_id<wbr/>_16<wbr/>.html</a></i>).</p>&#13;
<span id="Lis5-5"/><pre><code>#define TOBYTE(x) (x) &amp; 255&#13;
#define SWAP(x,y) do {x^=y; y^=x; x^=y;} while (0)&#13;
&#13;
static unsigned char S[256];&#13;
static int i=0, j=0;&#13;
&#13;
void init(char *passphrase) {&#13;
    int passlen = strlen(passphrase);&#13;
    for (i=0; i&lt;256; i++)&#13;
        S[i] = i;&#13;
    for (i=0; i&lt;256; i++) {&#13;
        j = TOBYTE(j + S[TOBYTE(i)] + passphrase[j % passlen]);&#13;
        SWAP(S[TOBYTE(i)], S[j]);&#13;
    }&#13;
    i = 0; j = 0;&#13;
}&#13;
&#13;
unsigned char encrypt_one_byte(unsigned char c) {&#13;
    int k;&#13;
    i = TOBYTE(i+1);&#13;
    j = TOBYTE(j + S[i]);&#13;
    SWAP(S[i], S[j]);&#13;
    k = TOBYTE(S[i] + S[j]);&#13;
    return c ^ S[k];&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: An incorrect C implementation of RC4, due to its use of an XOR swap</samp></p>&#13;
<p class="TX">Can you spot the problem with the XOR swap?</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_113" aria-label="113"/>Things go south when <samp class="SANS_TheSansMonoCd_W5Regular_11">i = j</samp>. Instead of leaving the state unchanged, the XOR swap sets <samp class="SANS_TheSansMonoCd_W5Regular_11">S[i]</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">S[i]</samp> <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">S[i] = 0</samp>. In effect, a byte of the state is set to zero each time <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> equals <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> in the key schedule or during encryption, ultimately leading to an all-zero state and thus to an all-zero keystream. For example, after processing 68KB of data, most of the bytes in the 256-byte state are zero, and the output keystream looks like this:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg113-1.jpg" alt="" width="1415" height="25"/></figure>&#13;
<p class="TX">The lesson here is to refrain from over-optimizing your crypto implementations. Clarity and confidence always trump performance in cryptography.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h4 class="H2" id="sec26"><span id="h2-71"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weak Ciphers Baked into Hardware</samp></h4>&#13;
<p class="TNI">When a cryptosystem fails to be secure, some systems quickly respond by silently updating the affected software remotely (as with web applications) or by releasing a new version and prompting the users to upgrade (as with mobile applications). Other systems aren’t so lucky and need to stick to the compromised cryptosystem for a while before upgrading to a secure version, as is the case with certain satellite phones.</p>&#13;
<p class="TX">In the early 2000s, US and European telecommunication standardization institutes (TIA and ETSI) jointly developed two standards for satellite phone (satphone) communications. Satphones are like mobile phones, except that their signal goes through satellites rather than terrestrial stations. The advantage is that you can use them pretty much everywhere in the world, as long as you have satellite coverage. Their downsides are the price, quality, latency, and, as it turns out, security.</p>&#13;
<p class="TX">GMR-1 and GMR-2 are the two satphone standards adopted by most commercial vendors, such as Thuraya and Inmarsat. Both include stream ciphers to encrypt voice communications. GMR-1’s cipher is hardware oriented, with a combination of four LFSRs, similar to A5/2, the deliberately insecure cipher in the 2G mobile standard aimed at non-Western countries. GMR-2’s cipher is software oriented, with an 8-byte state and the use of S-boxes. Both stream ciphers are insecure and protect users only against amateurs, not against state agencies.</p>&#13;
<p class="TX">This story reminds us that stream ciphers used to be easier to break than block ciphers and that they’re easier to sabotage. Why? Well, if you design a weak stream cipher on purpose, when you find the flaw, you can still blame it on the weakness of stream ciphers and deny any malicious intent.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h3 class="H1" id="sec27"><span id="h1-40"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">To learn more about stream ciphers, begin with the archives of the eSTREAM competition at <i><a href="https://www.ecrypt.eu.org/stream/project.html">https://<wbr/>www<wbr/>.ecrypt<wbr/>.eu<wbr/>.org<wbr/>/stream<wbr/>/project<wbr/>.html</a></i>, where you’ll find hundreds of papers on stream ciphers, including details of more than 30 candidates and many attacks. Some of the most interesting attacks are the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_114" aria-label="114"/>correlation attacks, algebraic attacks, and cube attacks. See in particular the work of Nicolas Courtois and Willi Meier for the first two attack types and that of Itai Dinur and Adi Shamir for cube attacks.</p>&#13;
<p class="TX">For more about attacks on RC4, look up the 2001 Scott Fluhrer, Itsik Mantin, and Adi Shamir (FMS) attack, and the 2013 research article “On the Security of RC4 in TLS.”</p>&#13;
<p class="TX">Salsa20’s legacy deserves your attention, too. The stream cipher ChaCha is similar to Salsa20 but with a slightly different core permutation that was later used in the hash function BLAKE, as you’ll see in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. These algorithms all leverage Salsa20’s software implementation techniques using parallelized instructions, as discussed at <i><a href="https://cr.yp.to/snuffle.html">https://<wbr/>cr<wbr/>.yp<wbr/>.to<wbr/>/snuffle<wbr/>.html</a></i>.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>