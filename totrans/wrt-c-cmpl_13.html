<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_242" aria-label="242"/>&#13;
<figure class="co-img"><img id="fig-pg242" class="img60" src="../images/pg242.jpg" alt="" width="687" height="1737"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-26.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_243" aria-label="243"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch11">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">LONG INTEGERS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In this chapter, you’ll add a new type: <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. This is a signed integer type, just like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>; the only difference between the two types is the range of values they hold. You’ll also add an explicit cast operation, which converts a value to a different type.</p>&#13;
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is so similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type we already support, we won’t need to add many new assembly or TACKY instructions or implement complicated type casting logic. Instead, we’ll focus on laying the groundwork we’ll need for the rest of <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. We’ll track the types of constants and variables, attach type information to the AST, identify implicit casts and make them explicit, and determine the operand sizes for assembly instructions. We’ll need to make at least a small change to every stage of the compiler except for loop labeling. Before we get started, let’s see what operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>s look like in assembly.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_244" aria-label="244"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-89"/><samp class="SANS_Futura_Std_Bold_B_11">Long Integers in Assembly</samp></h3>&#13;
<p class="TNI">The C standard doesn’t specify the sizes of integer types, but the System V x64 ABI says that an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is 4 bytes and a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is 8. To wildly oversimplify things, C expressions with <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> operands are ultimately translated into assembly instructions on quadwords (8-byte operands). For example, the following assembly instructions operate on quadwords to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> and produce a quadword result:</p>&#13;
<pre><code>movq    $2, %rax&#13;
addq    $2, %rax</code></pre>&#13;
<p class="TX">This looks almost identical to the equivalent code using longwords, which are 4 bytes:</p>&#13;
<pre><code>movl    $2, %eax&#13;
addl    $2, %eax</code></pre>&#13;
<p class="TX">The only differences are the suffix on the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> instructions and whether we use the whole RAX register or just EAX, its lower 4 bytes.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The terms</i> <span class="note_Italic">word</span><i>,</i> <span class="note_Italic">longword</span><i>, and</i> <span class="note_Italic">quadword</span> <i>date back to the era of 16-bit processors, when an int was 2 bytes and a long was 4 bytes. To make matters worse, 4-byte values are often called</i> <span class="note_Italic">doublewords</span> <i>instead of longwords. I use the term</i> <span class="note_Italic">longword</span> <i>to mirror AT&amp;T assembly syntax, but Intel’s documentation uses</i> <span class="note_Italic">doubleword</span><i>.</i></p>&#13;
<p class="TX">Most quadword instructions accept only 8-byte operands and produce 8-byte results, just as most longword instructions accept only 4-byte operands and produce 4-byte results. Expressions in C, on the other hand, often use several operand types at once or assign a value of one type to an object of a different type. During compilation, we’ll decompose these expressions into simple instructions that either take operands of a single type and produce results of the same type or explicitly perform type conversions. Luckily, the C standard tells us exactly where these type conversions occur.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-76"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Conversions</samp></h4>&#13;
<p class="TNI">Section 6.3.1.3, paragraph 1, of the C standard defines how to convert between integer types: “If the value can be represented by the new type, it is unchanged.” In other words, if some expression evaluates to, say, 3, and then you cast it to a different integer type, the result of that cast expression should still be 3.</p>&#13;
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, we can safely cast any <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> without changing its value. We’re using a two’s complement representation of signed integers, so we’ll cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> using sign extension, which you learned about in <span class="Xref-1"><a href="chapter3.xhtml">Chapter 3</a></span>. Specifically, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp> (or “move with sign extension”) assembly instruction. This instruction moves a 4-byte <span role="doc-pagebreak" epub:type="pagebreak" id="pg_245" aria-label="245"/>source into an 8-byte destination, sign extending the value into the destination’s upper 4 bytes.</p>&#13;
<p class="TX">Converting a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is trickier because it may be too large or too small to represent as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Paragraph 3 of section 6.3.1.3 goes on to tell us that when “the new type is signed and the value cannot be represented in it[,] either the result is implementation-defined or an implementation-defined signal is raised.” In other words, it’s up to us to decide what to do. Our implementation will handle this conversion in the same way as GCC, as specified in its documentation: “For conversion to a type of width <i>N</i>, the value is reduced modulo 2<i>^N</i> to be within range of the type; no signal is raised” (<i><a href="https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html">https://<wbr/>gcc<wbr/>.gnu<wbr/>.org<wbr/>/onlinedocs<wbr/>/gcc<wbr/>/Integers<wbr/>-implementation<wbr/>.html</a></i>).</p>&#13;
<p class="TX">Reducing a value modulo 2<sup>32</sup> means adding or subtracting a multiple of 2<sup>32</sup> to bring it into the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Here’s a quick example. The largest value you can represent as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is 2<sup>31</sup> – 1, or 2,147,483,647. Suppose you need to convert the next largest integer value (2<sup>31</sup>, or 2,147,483,648) from a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Subtracting 2<sup>32</sup> from this value gives you –2<sup>31</sup>, or –2,147,483,648, which is the smallest value that <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> can represent.</p>&#13;
<p class="TX">In practice, we’ll convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> by dropping its upper 4 bytes. If a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> can be represented as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, dropping those bytes won’t change its value. For example, here’s the 8-byte binary representation of –3:</p>&#13;
<pre><code>11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111101</code></pre>&#13;
<p class="BodyContinued">And here’s the 4-byte representation of the same value:</p>&#13;
<pre><code>                                    11111111 11111111 11111111 11111101</code></pre>&#13;
<p class="TX">If a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> can’t be represented as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, dropping its upper 4 bytes has the effect of reducing its value modulo 2<sup>32</sup>. To return to our earlier example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 2,147,483,648 has the following binary representation:</p>&#13;
<pre><code>00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000</code></pre>&#13;
<p class="TX">After we convert it to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, the result, with the value –2,147,483,648, has the following binary representation:</p>&#13;
<pre><code>                                    10000000 00000000 00000000 00000000</code></pre>&#13;
<p class="TX">To drop a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>’s upper bytes, we just copy its lower bytes with a <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction. For example, the following instruction truncates a value stored in RCX:</p>&#13;
<pre><code>movl    %ecx, %eax</code></pre>&#13;
<p class="TX">When we store a value in a register’s lower 4 bytes, the register’s upper 4 bytes will be zeroed out.</p>&#13;
<aside class="box" aria-label="box-13"><p class="BoxTitle" id="box-13"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_246" aria-label="246"/><samp class="SANS_Dogma_OT_Bold_B_11">IMPLEMENTATION-DEFINED BEHAVIOR ALERT!</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">We’ve run into undefined behavior several times already, but overflow when we convert from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> <samp class="SANS_Futura_Std_Book_11">to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">is the first</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">implementation-defined behavior</samp> <samp class="SANS_Futura_Std_Book_11">we’ve encountered. Language implementations are supposed to handle implementation-defined behavior in a reliable, documented way. Often, when a behavior is implementation-defined, the standard presents several options for the implementation to choose from. In this case, signed integer overflow can produce an integer result, like it does in our implementation, or it can raise a signal, but it can’t crash your program, print obscenities to your terminal, or do something else that’s obviously incorrect.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-77"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Long Variables</samp></h4>&#13;
<p class="TNI">Variables with static storage duration are defined in assembly in basically the same way regardless of their type, but there are a few small differences between static quadwords and longwords. Consider the following file scope variable declaration:</p>&#13;
<pre><code>static long var = 100;</code></pre>&#13;
<p class="TX">We’ll convert this declaration to the assembly in <a href="chapter11.xhtml#list11-1">Listing 11-1</a>.</p>&#13;
<a id="list11-1"/>&#13;
<pre><code>    .data&#13;
    .align 8&#13;
var:&#13;
    .quad 100</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Initializing an 8-byte value in the data section</samp></p>&#13;
<p class="TX">This differs from the assembly we generate for a static <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in two ways: the alignment is <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, and we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> directive to initialize an 8-byte value instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> to initialize 4 bytes.</p>&#13;
<p class="TX">The System V x64 ABI specifies that <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> are 8-byte and 4-byte aligned, respectively. The C standard leaves their alignment, like their size, unspecified.</p>&#13;
<p class="TX">Now that we have some idea of what assembly we want to generate, let’s get to work on the compiler!</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_247" aria-label="247"/>&#13;
<h3 class="H1" id="sec4"><span id="h1-90"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add the following two tokens in this chapter:</p>&#13;
<p class="RunInParaF"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">long</samp> A keyword.</p>&#13;
<p class="RunInParaL"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Long integer constants</samp> These differ from our current integer constants because they have an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> suffix. A long constant token matches the regex <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+[lL]\b</samp>.</p>&#13;
<aside class="box" aria-label="box-14"><p class="BoxTitle" id="box-14"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out your lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 11 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The lexer should fail on the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11/invalid_lex</samp><samp class="SANS_Futura_Std_Book_11">, which include constant tokens with invalid suffixes. It should successfully process all the other test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-91"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">We’ll add long constants, cast expressions, and type information to the AST in this chapter. <a href="chapter11.xhtml#list11-2">Listing 11-2</a> shows the updated AST definition.</p>&#13;
<a id="list11-2"/>&#13;
<pre><code>program = Program(declaration*)&#13;
declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)&#13;
variable_declaration = (identifier name, exp? init,&#13;
                      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span><b> type var_type, </b>storage_class?)&#13;
function_declaration = (identifier name, identifier* params, block? body,&#13;
                      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span><b> type fun_type, </b>storage_class?)&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span><b> type = Int | Long | FunType(type* params, type ret)</b>&#13;
storage_class = Static | Extern&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
for_init = InitDecl(variable_declaration) | InitExp(exp?)&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
          | Compound(block)&#13;
          | Break&#13;
          | Continue&#13;
          | While(exp condition, statement body)&#13;
          | DoWhile(statement body, exp condition)&#13;
          | For(for_init init, exp? condition, exp? post, statement body)&#13;
          | Null&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_248" aria-label="248"/>exp = Constant(<b>const</b>)&#13;
    | Var(identifier)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> <b>| Cast(type target_type, exp)</b>&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    | Assignment(exp, exp)&#13;
    | Conditional(exp condition, exp, exp)&#13;
    | FunctionCall(identifier, exp* args)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual&#13;
<span class="CodeAnnotationHang" aria-label="annotation5">❺</span> <b>const = ConstInt(int) | ConstLong(int)</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: The abstract syntax tree with long constants, type information, and cast expressions</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST node can represent <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, and function types <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Rather than defining a brand-new data structure here, we can extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> structure we started using in symbol table entries in <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>. From now on, we’ll use that data structure in both the symbol table and the AST.</p>&#13;
<p class="TX">In <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>, we defined <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> like this:</p>&#13;
<pre><code>type = Int | FunType(int param_count)</code></pre>&#13;
<p class="TX">In <a href="chapter11.xhtml#list11-2">Listing 11-2</a>, we modify this definition by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">Long</samp> and tracking additional information about function types, including the return type and the list of parameter types. We didn’t need that information before, because the type of every parameter and the return type had to be <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Note that our new, recursive definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> can represent some invalid types, like functions that return functions, but the parser will never produce those invalid types.</p>&#13;
<p class="TX">Once we’ve updated how we represent <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>, we attach type information to variable <span class="CodeAnnotation" aria-label="annotation1">❶</span> and function declarations <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We don’t add type information to <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> in function declarations because the function’s type already includes the types of its parameters. We also extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node to represent cast expressions <span class="CodeAnnotation" aria-label="annotation4">❹</span> and define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> AST node with distinct constructors for <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> constants <span class="CodeAnnotation" aria-label="annotation5">❺</span>. We’ll need to distinguish between different types of constants during type checking.</p>&#13;
<p class="TX">If your implementation language has signed 64-bit and 32-bit integer types and supports conversions between those types with the same semantics as conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in our implementation of C, I recommend using those types to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp> in the AST. (Most languages provide fixed-width integer types with these semantics, either by default or through a library.) This will make it easier to cast static initializers to the correct type at compile time; it will also simplify constant folding, an optimization we’ll implement in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>. If your implementation language doesn’t have integer types with the right semantics, you should at least make sure the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> node uses an integer type that can represent all <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> values.</p>&#13;
<p class="TX">After updating the AST, we’ll make the corresponding changes to the grammar, shown in <a href="chapter11.xhtml#list11-3">Listing 11-3</a>.</p>&#13;
<a id="list11-3"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_249" aria-label="249"/>&lt;program&gt; ::= {&lt;declaration&gt;}&#13;
&lt;declaration&gt; ::= &lt;variable-declaration&gt; | &lt;function-declaration&gt;&#13;
&lt;variable-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;identifier&gt; ["=" &lt;exp&gt;] ";"&#13;
&lt;function-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;identifier&gt; "(" &lt;param-list&gt; ")" (&lt;block&gt; | ";")&#13;
&lt;param-list&gt; ::= "void"&#13;
               | <b>{&lt;type-specifier&gt;}+</b> &lt;identifier&gt; {"," <b>{&lt;type-specifier&gt;}+</b> &lt;identifier&gt;}&#13;
<b>&lt;type-specifier&gt; ::= "int" | "long"</b>&#13;
&lt;specifier&gt; ::= <b>&lt;type-specifier&gt; |</b> "static" | "extern"&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
&lt;for-init&gt; ::= &lt;variable-declaration&gt; | [&lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              | "break" ";"&#13;
              | "continue" ";"&#13;
              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;&#13;
              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"&#13;
              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
&lt;factor&gt; ::= <b>&lt;const&gt;</b> | &lt;identifier&gt;&#13;
           <b>| "(" {&lt;type-specifier&gt;}+ ")" &lt;factor&gt;</b>&#13;
           | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"&#13;
           | &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"&#13;
&lt;argument-list&gt; ::= &lt;exp&gt; {"," &lt;exp&gt;}&#13;
&lt;unop&gt; ::= "-" | "~" | "!"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
<b>&lt;const&gt; ::= &lt;int&gt; | &lt;long&gt;</b>&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? An int token ?&#13;
<b>&lt;long&gt; ::= ? An int or long token ?</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: The grammar with long constants, the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">long</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">type specifier, and cast expressions</samp></p>&#13;
<p class="TX">We need to handle two slightly tricky details here. First, whenever we parse a list of type specifiers, we need to convert them into a single <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST node. A long integer can be declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> specifier or with both <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, in either order. <a href="chapter11.xhtml#list11-4">Listing 11-4</a> illustrates how to turn a list of type specifiers into a type.</p>&#13;
<a id="list11-4"/>&#13;
<pre><code>parse_type(specifier_list):&#13;
    if specifier_list == ["int"]:&#13;
        return Int&#13;
    if (specifier_list == ["int", "long"]&#13;
        or specifier_list == ["long", "int"]&#13;
        or specifier_list == ["long"]):&#13;
        return Long&#13;
    fail("Invalid type specifier")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: Determining a type from a list of type specifiers</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_250" aria-label="250"/>This works for types with no storage class, which we’ll find in parameter lists or cast expressions. For function and variable declarations, we’ll build on the specifier parsing code from <span class="Xref-1"><a href="chapter10.xhtml#list10-21">Listing 10-21</a></span>. <a href="chapter11.xhtml#list11-5">Listing 11-5</a> reproduces that code, with changes bolded.</p>&#13;
<a id="list11-5"/>&#13;
<pre><code>parse_type_and_storage_class(specifier_list):&#13;
    types = []&#13;
    storage_classes = []&#13;
    for specifier in specifier_list:&#13;
        if specifier is "int" <b>or "long"</b>:&#13;
            types.append(specifier)&#13;
        else:&#13;
            storage_classes.append(specifier)&#13;
&#13;
    <b>type = parse_type(types)</b>&#13;
&#13;
    if length(storage_classes) &gt; 1:&#13;
        fail("Invalid storage class")&#13;
    if length(storage_classes) == 1:&#13;
        storage_class = parse_storage_class(storage_classes[0])&#13;
    else:&#13;
        storage_class = null&#13;
&#13;
    return (type, storage_class)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-5: Determining type and storage class from a list of specifiers</samp></p>&#13;
<p class="TX">We still separate type specifiers from storage class specifiers and determine storage class just like we did in <span class="Xref-1"><a href="chapter10.xhtml#list10-21">Listing 10-21</a></span>, but we’ve made a few small changes here. First, we recognize <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> as a type specifier. Second, we no longer expect the list of type specifiers to have exactly one element (this change isn’t bolded because we just deleted some existing code). Third, rather than always setting <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>, we use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp> function to determine the type.</p>&#13;
<p class="TX">The second tricky detail is parsing constant tokens. <a href="chapter11.xhtml#list11-6">Listing 11-6</a> shows how to convert these into <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> AST nodes.</p>&#13;
<a id="list11-6"/>&#13;
<pre><code>parse_constant(token):&#13;
    v = integer value of token&#13;
    if v &gt; 2^63 - 1:&#13;
        fail("Constant is too large to represent as an int or long")&#13;
&#13;
    if token is an int token and v &lt;= 2^31 - 1:&#13;
        return ConstInt(v)&#13;
&#13;
    return ConstLong(v)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-6: Converting a constant token to an AST node</samp></p>&#13;
<p class="TX">We parse an integer constant token (without an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> suffix) into a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp> node unless its value is outside the range of the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. Similarly, we parse a long constant token (with an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> suffix) into a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> node <span role="doc-pagebreak" epub:type="pagebreak" id="pg_251" aria-label="251"/>unless its value is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. If an integer constant token is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> but in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, we parse it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> node. If an integer or long constant token is too large for <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to represent, we throw an error.</p>&#13;
<p class="TX">An <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is 32 bits, so it can hold any value between –2<sup>31</sup> and 2<sup>31</sup> – 1, inclusive. By the same logic, a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> can hold any value between –2<sup>63</sup> and 2<sup>63</sup> – 1. Your parser should check each constant token against the maximum value of the corresponding type. It doesn’t need to check against the minimum value, because these tokens can’t represent negative numbers; the negative sign is a separate token.</p>&#13;
<aside class="box" aria-label="box-15"><p class="BoxTitle" id="box-15"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 11 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">It should fail on all the test cases in the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11/invalid_parse</samp> <samp class="SANS_Futura_Std_Book_11">directory, which contains test programs with missing and invalid type specifiers. None of the test cases include constants that are too large to fit into a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp><samp class="SANS_Futura_Std_Book_11">, since they may still be valid in a C implementation that supports larger integer types. Your parser should be able to handle every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11/invalid_types</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11/valid</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-92"/><samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp></h3>&#13;
<p class="TNI">Next, we’ll extend the compiler passes that perform semantic analysis. We’ll make one tiny mechanical change to identifier resolution: we’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> to traverse cast expressions the same way it traverses other kinds of expressions. I won’t always explicitly mention this sort of modification in later chapters; from now on, whenever we add a new expression that contains subexpressions, go ahead and extend the identifier resolution pass to traverse it. Once we’ve made this change, we can turn to the more interesting problem of extending the type checker.</p>&#13;
<p class="TX">Just as every object in a C program has a type, the result of every expression has a type too. For example, performing any binary arithmetic operation on two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> operands results in an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, performing the same operation on two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> operands results in a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, and calling a function with a particular return type produces a result of that type.</p>&#13;
<p class="TX">During the type checking pass, we’ll annotate every expression in the AST with the type of its result. We’ll use this type information to determine the types of the temporary variables we generate in TACKY to hold intermediate results. That, in turn, will tell us the appropriate operand sizes for <span role="doc-pagebreak" epub:type="pagebreak" id="pg_252" aria-label="252"/>assembly instructions and the amount of stack space we need to allocate for each temporary variable.</p>&#13;
<p class="TX">While we’re annotating expressions with type information, we’ll also identify any implicit type conversions in the program and make them explicit by inserting <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp> expressions in the AST. Then, we can easily generate the correct type casting instructions during TACKY generation.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-78"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Type Information to the AST</samp></h4>&#13;
<p class="TNI">Before we update the type checker, we need a way to attach type information to <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST nodes. The obvious solution, shown in <a href="chapter11.xhtml#list11-7">Listing 11-7</a>, is to mechanically add a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> field to every <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> constructor.</p>&#13;
<a id="list11-7"/>&#13;
<pre><code>exp = Constant(const, <b>type</b>)&#13;
    | Var(identifier, <b>type</b>)&#13;
    | Cast(type target_type, exp, <b>type</b>)&#13;
    | Unary(unary_operator, exp, <b>type</b>)&#13;
    | Binary(binary_operator, exp, exp, <b>type</b>)&#13;
    | Assignment(exp, exp, <b>type</b>)&#13;
    | Conditional(exp condition, exp, exp, <b>type</b>)&#13;
    | FunctionCall(identifier, exp* args, <b>type</b>)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-7: Adding type information to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">nodes</samp></p>&#13;
<p class="TX">This is easy enough if you’re using an object-oriented implementation language and you have a common base class for every <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>. You can just add a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> field to the base class, as shown in <a href="chapter11.xhtml#list11-8">Listing 11-8</a>.</p>&#13;
<a id="list11-8"/>&#13;
<pre><code>class BaseExp {&#13;
    <var>--snip--</var>&#13;
<b>    type expType;</b>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-8: Adding a type to the base class for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">nodes</samp></p>&#13;
<p class="TX">If, on the other hand, you’ve implemented your AST using algebraic data types, this approach is deeply annoying. Not only will you have to update every single <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> constructor, but you’ll also have to pattern match on every constructor whenever you want to get an expression’s type. A slightly less tedious approach, shown in <a href="chapter11.xhtml#list11-9">Listing 11-9</a>, is to define mutually recursive <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_exp</samp> AST nodes.</p>&#13;
<a id="list11-9"/>&#13;
<pre><code>typed_exp = TypedExp(type, exp)&#13;
exp = Constant(const)&#13;
    | Var(identifier)&#13;
    | Cast(type target_type, typed_exp)&#13;
    | Unary(unary_operator, typed_exp)&#13;
    | Binary(binary_operator, typed_exp, typed_exp)&#13;
    | Assignment(typed_exp, typed_exp)&#13;
    | Conditional(typed_exp condition, typed_exp, typed_exp)&#13;
    | FunctionCall(identifier, typed_exp* args)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-9: Another way to add type information to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">nodes</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_253" aria-label="253"/>Whichever option you choose, you’ll need to either define two separate AST data structures—one with type information and one without—or initialize every <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> with a null or dummy type when you build the AST in the parser. There’s no one right answer here; it depends on your implementation language and personal taste. Rather than imposing a specific approach, the pseudocode in the rest of the book will use two functions to handle type information in the AST: <samp class="SANS_TheSansMonoCd_W5Regular_11">set_type(e, t)</samp> returns a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> annotated with type <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_type(e)</samp> returns the type annotation from <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.</p>&#13;
<aside class="box" aria-label="box-16"><p class="BoxTitle" id="box-16"><samp class="SANS_Dogma_OT_Bold_B_11">THE AST TYPING PROBLEM</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The challenge of defining an AST that you can easily annotate with type information, without resorting to hacks or producing a lot of boilerplate, is sometimes called the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AST typing problem</samp><samp class="SANS_Futura_Std_Book_11">. It’s a problem because nobody has a great solution to it (the options I’ve presented here, for example, have obvious drawbacks). The AST typing problem generally comes up when you’re writing a compiler in functional languages like ML or Haskell. Compiler authors have proposed a wide range of solutions in these languages, some of them quite elaborate. If you’d like to learn about a few different approaches, “The AST Typing Problem” by Edward Yang is a good overview (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="http://blog.ezyang.com/2013/05/the-ast-typing-problem/">http://<wbr/>blog<wbr/>.ezyang<wbr/>.com<wbr/>/2013<wbr/>/05<wbr/>/the<wbr/>-ast<wbr/>-typing<wbr/>-problem<wbr/>/</a></samp><samp class="SANS_Futura_Std_Book_11">).</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-79"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Expressions</samp></h4>&#13;
<p class="TNI">Once we’ve extended our AST definition, we’ll rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>, which we defined in <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>, to return a new annotated copy of each <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node it processes.</p>&#13;
<p class="TX"><a href="chapter11.xhtml#list11-10">Listing 11-10</a> shows how to type check a variable.</p>&#13;
<a id="list11-10"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
    | Var(v) -&gt;&#13;
        v_type = symbols.get(v).type&#13;
        if v_type is a function type:&#13;
            fail("Function name used as variable")&#13;
        return set_type(e, v_type)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-10: Type checking a variable</samp></p>&#13;
<p class="TX">First, we look up the variable’s type in the symbol table. Then, we validate that we’re not using a function name as a variable, just like we did in earlier chapters. Finally, we annotate the expression with the variable’s type and return it.</p>&#13;
<p class="TX"><a href="chapter11.xhtml#list11-11">Listing 11-11</a> shows how to type check a constant. This is easy, since different types of constants have different constructors in the AST.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_254" aria-label="254"/>&#13;
<a id="list11-11"/>&#13;
<pre><code>    | Constant(c) -&gt;&#13;
        match c with&#13;
        | ConstInt(i) -&gt; return set_type(e, Int)&#13;
        | ConstLong(l) -&gt; return set_type(e, Long)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-11: Type checking a constant</samp></p>&#13;
<p class="TX">For the remaining expressions, we’ll need to traverse any subexpressions and annotate them too. The result of a cast expression has whatever type we cast it to. We type check these in <a href="chapter11.xhtml#list11-12">Listing 11-12</a>.</p>&#13;
<a id="list11-12"/>&#13;
<pre><code>    | Cast(t, inner) -&gt;&#13;
        typed_inner = typecheck_exp(inner, symbols)&#13;
        cast_exp = Cast(t, typed_inner)&#13;
        return set_type(cast_exp, t)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-12: Type checking a cast expression</samp></p>&#13;
<p class="TX">The results of expressions that evaluate to 1 or 0 to indicate true or false, including comparisons and logical operations like <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>, have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The results of arithmetic and bitwise expressions have the same type as their operands. This is straightforward for unary expressions, which we type check in <a href="chapter11.xhtml#list11-13">Listing 11-13</a>.</p>&#13;
<a id="list11-13"/>&#13;
<pre><code>    | Unary(op, inner) -&gt;&#13;
        typed_inner = typecheck_exp(inner, symbols)&#13;
        unary_exp = Unary(op, typed_inner)&#13;
        match op with&#13;
        | Not -&gt; return set_type(unary_exp, Int)&#13;
        | _   -&gt; return set_type(unary_exp, get_type(typed_inner))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-13: Type checking a unary expression</samp></p>&#13;
<p class="TX">Binary expressions are more complicated because the two operands may have different types. This doesn’t matter for logical <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operations, which can evaluate the truth value of each operand in turn. It does matter for comparisons and arithmetic operations, which need to use both operands at once. The C standard defines a set of rules, called the <i>usual arithmetic conversions</i>, for implicitly converting both operands of an arithmetic expression to the same type, called its <i>common type</i> or <i>common real type</i>.</p>&#13;
<p class="TX">Given the types of two operands, <a href="chapter11.xhtml#list11-14">Listing 11-14</a> shows how to find their common real type. For now this is simple, since there are only two possible types.</p>&#13;
<a id="list11-14"/>&#13;
<pre><code>get_common_type(type1, type2):&#13;
    if type1 == type2:&#13;
        return type1&#13;
    else:&#13;
        return Long</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-14: Finding the common real type</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_255" aria-label="255"/>If the two types are already the same, no conversion is necessary. If they’re different, we convert the smaller type (which must be <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>) to the larger type (which must be <samp class="SANS_TheSansMonoCd_W5Regular_11">Long</samp>), so the common type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Long</samp>. Once we add more types, finding the common type won’t be quite this straightforward.</p>&#13;
<p class="TX">Once we know the common type that both operands will be converted to, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp> helper function, shown in <a href="chapter11.xhtml#list11-15">Listing 11-15</a>, to make those type conversions explicit.</p>&#13;
<a id="list11-15"/>&#13;
<pre><code>convert_to(e, t):&#13;
    if get_type(e) == t:&#13;
        return e&#13;
    cast_exp = Cast(t, e)&#13;
    return set_type(cast_exp, t)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-15: Making an implicit type conversion explicit</samp></p>&#13;
<p class="TX">If an expression already has the correct result type, <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp> returns it unchanged. Otherwise, it wraps the expression in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp> AST node, then annotates the result with the correct type.</p>&#13;
<p class="TX">With both of these helper functions in place, we can type check binary expressions. <a href="chapter11.xhtml#list11-16">Listing 11-16</a> shows the relevant clause of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>.</p>&#13;
<a id="list11-16"/>&#13;
<pre><code>    | Binary(op, e1, e2) -&gt;&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> typed_e1 = typecheck_exp(e1, symbols)&#13;
        typed_e2 = typecheck_exp(e2, symbols)&#13;
        if op is And or Or:&#13;
            binary_exp = Binary(op, typed_e1, typed_e2)&#13;
            return set_type(binary_exp, Int)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> t1 = get_type(typed_e1)&#13;
        t2 = get_type(typed_e2)&#13;
        common_type = get_common_type(t1, t2)&#13;
        converted_e1 = convert_to(typed_e1, common_type)&#13;
        converted_e2 = convert_to(typed_e2, common_type)&#13;
        binary_exp = Binary(op, converted_e1, converted_e2)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> if op is Add, Subtract, Multiply, Divide, or Remainder:&#13;
            return set_type(binary_exp, common_type)&#13;
        else:&#13;
            return set_type(binary_exp, Int)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-16: Type checking a binary expression</samp></p>&#13;
<p class="TX">We start by type checking both operands <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the operator is <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Or</samp>, we don’t perform any type conversions. Otherwise, we perform the usual arithmetic conversions <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We first get the common type, then convert both operands to that type. (In practice, at least one operand will have the correct type already, so <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp> will return it unchanged.) Next, we construct our new <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> AST node using these converted operands. Finally, we annotate the new AST node with the correct result type <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If this is an arithmetic operation, the result will have the same type as its operands, which is the common type we found earlier. Otherwise, it’s a comparison that results in an integer representation of true or false, so the result type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_256" aria-label="256"/>In assignment expressions, we convert the value being assigned to the type of the object it’s assigned to. <a href="chapter11.xhtml#list11-17">Listing 11-17</a> gives the pseudocode for this case.</p>&#13;
<a id="list11-17"/>&#13;
<pre><code>    | Assignment(left, right) -&gt;&#13;
        typed_left = typecheck_exp(left, symbols)&#13;
        typed_right = typecheck_exp(right, symbols)&#13;
        left_type = get_type(typed_left)&#13;
        converted_right = convert_to(typed_right, left_type)&#13;
        assign_exp = Assignment(typed_left, converted_right)&#13;
        return set_type(assign_exp, left_type)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-17: Type checking an assignment expression</samp></p>&#13;
<p class="TX">Remember that the result of an assignment expression is the value of the left-hand side after assignment; unsurprisingly, the result has the type of the left-hand side as well.</p>&#13;
<p class="TX">Conditional expressions work a lot like binary arithmetic expressions: we find the common type of both branches, convert both branches to that common type, and annotate the result with that type. We’ll type check the controlling condition, but we don’t need to convert it to anything. I won’t give you the pseudocode for this case.</p>&#13;
<p class="TX">Last but not least, <a href="chapter11.xhtml#list11-18">Listing 11-18</a> shows how to type check function calls.</p>&#13;
<a id="list11-18"/>&#13;
<pre><code>    | FunctionCall(f, args) -&gt;&#13;
        f_type = symbols.get(f).type&#13;
        match f_type with&#13;
        | FunType(param_types, ret_type) -&gt;&#13;
            if length(param_types) != length(args):&#13;
                fail("Function called with the wrong number of arguments")&#13;
            converted_args = []&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> for (arg, param_type) in zip(args, param_types):&#13;
                typed_arg = typecheck_exp(arg, symbols)&#13;
                converted_args.append(convert_to(typed_arg, param_type))&#13;
            call_exp = FunctionCall(f, converted_args)&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> return set_type(call_exp, ret_type)&#13;
        | _ -&gt; fail("Variable used as function name")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-18: Type checking a function call</samp></p>&#13;
<p class="TX">We start by looking up the function type in the symbol table. Just like in previous chapters, we need to make sure that the identifier we’re trying to call is actually a function and that we’re passing it the right number of arguments. Then, we iterate over the function’s arguments and parameters together <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We type check each argument, then convert it to the corresponding parameter type. Finally, we annotate the whole expression with the function’s return type <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-80"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking return Statements</samp></h4>&#13;
<p class="TNI">When a function returns a value, it’s implicitly converted to the function’s return type. The type checker needs to make this implicit conversion <span role="doc-pagebreak" epub:type="pagebreak" id="pg_257" aria-label="257"/>explicit. To type check a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, we look up the enclosing function’s return type and convert the return value to that type. This requires us to keep track of the name, or at least the return type, of whatever function we’re currently type checking. I’ll omit the pseudocode to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements, since it’s straightforward.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-81"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Declarations and Updating the Symbol Table</samp></h4>&#13;
<p class="TNI">Next, we’ll update how we type check function and variable declarations and what information we store in the symbol table. First, we’ll need to record the correct type for each entry in the symbol table; we can’t just assume that every variable, parameter, and return value is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Second, whenever we check for conflicting declarations, we’ll need to validate that the current and previous declarations have the same type. It’s not enough to check whether a variable was previously declared as a function or a function was previously declared with a different number of parameters; the types must be identical. For example, if a variable is declared as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and then redeclared as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, the type checker should throw an error. Third, when we type check an automatic variable, we’ll need to convert its initializer to the type of the variable, much like we convert the right-hand side of an assignment expression to the type of the left-hand side.</p>&#13;
<p class="TX">Finally, we’ll change how we represent static initializers in the symbol table. A static initializer, like a constant expression, can now be either an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. <a href="chapter11.xhtml#list11-19">Listing 11-19</a> gives the updated definition for static initializers.</p>&#13;
<a id="list11-19"/>&#13;
<pre><code>initial_value = Tentative | Initial(<b>static_init</b>) | NoInitializer&#13;
<b>static_init = IntInit(int) | LongInit(int)</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-19: Static initializers in the symbol table</samp></p>&#13;
<p class="TX">This definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> may seem redundant, since it’s basically identical to the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> AST node defined in <a href="chapter11.xhtml#list11-2">Listing 11-2</a>, but they’ll diverge in later chapters. As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> AST nodes, you should carefully choose what integer types in your implementation language you use to represent both initializers. It’s particularly important to make sure that <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit</samp> can accommodate any signed 64-bit integer.</p>&#13;
<p class="TX">You may need to perform type conversions when converting expressions to static initializers. For example, suppose a program contains the following declaration:</p>&#13;
<pre><code>static int i = 100L;</code></pre>&#13;
<p class="TX">The constant <samp class="SANS_TheSansMonoCd_W5Regular_11">100L</samp> will be parsed as a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> in our AST. Since it’s being assigned to a static <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, we’ll need to cast it from a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> at compile time and store it as an <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit(100)</samp> in the symbol table. This sort of conversion is especially tricky when a variable with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is initialized <span role="doc-pagebreak" epub:type="pagebreak" id="pg_258" aria-label="258"/>with a long constant that’s too large to be represented in 32 bits, as in this declaration:</p>&#13;
<pre><code>static int i = 2147483650L;</code></pre>&#13;
<p class="TX">According to the implementation-defined behavior we specified earlier, we need to subtract 2<sup>32</sup> from this value until it’s small enough to fit in an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. That results in –2,147,483,646, so the initial value we record in the symbol table should be <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit(-2147483646)</samp>. Ideally, you can use signed integer types that already have the right semantics for type conversions so you won’t have to mess with the binary representations of these constants yourself.</p>&#13;
<p class="TX">Here are a couple of tips to help you handle static initializers:</p>&#13;
<p class="ListHead"><b>Make your constant type conversion code reusable.</b></p>&#13;
<p class="ListPlainFirst">The type checker isn’t the only place where you’ll convert constants to a different type. In <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>, you’ll implement constant folding in TACKY. The constant folding pass will evaluate constant expressions, including type conversions. You may want to structure your type conversion code as a separate module that you can reuse for constant folding later.</p>&#13;
<p class="ListHead"><b>Don’t call typecheck_exp on static initializers.</b></p>&#13;
<p class="ListPlainFirst">Convert each static initializer directly to a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>, without calling <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp> first. This will simplify things in later chapters, when <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp> will transform expressions in more complex ways.</p>&#13;
<aside class="box" aria-label="box-17"><p class="BoxTitle" id="box-17"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TYPE CHECKER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the type checking pass, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 11 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your compiler should fail on the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11/invalid _types</samp><samp class="SANS_Futura_Std_Book_11">. It should succeed on every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11/valid.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h1-93"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">We’ll make a few changes to the TACKY AST in this chapter. First, we’ll add a type to each top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> and represent each static variable’s initial value with our newly defined <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> construct:</p>&#13;
<pre><code>StaticVariable(identifier, bool global, <b>type t, static_init init</b>)</code></pre>&#13;
<p class="TX">We’ll also reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> construct from the AST in <a href="chapter11.xhtml#list11-2">Listing 11-2</a> to represent constants:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_259" aria-label="259"/>val = Constant(<b>const</b>) | Var(identifier)</code></pre>&#13;
<p class="TX">Finally, we’ll introduce a couple of new instructions to convert values between types:</p>&#13;
<pre><code>SignExtend(val src, val dst)&#13;
Truncate(val src, val dst)</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp> instructions convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, respectively. <a href="chapter11.xhtml#list11-20">Listing 11-20</a> gives the complete updated TACKY IR. This listing uses <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> without defining them, since we’ve defined these three constructs already.</p>&#13;
<a id="list11-20"/>&#13;
<pre><code>program = Program(top_level*)&#13;
top_level = Function(identifier, bool global, identifier* params, instruction* body)&#13;
          | StaticVariable(identifier, bool global, <b>type t, static_init init</b>)&#13;
instruction = Return(val)&#13;
            <b>| SignExtend(val src, val dst)</b>&#13;
            <b>| Truncate(val src, val dst)</b>&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            | Binary(binary_operator, val src1, val src2, val dst)&#13;
            | Copy(val src, val dst)&#13;
            | Jump(identifier target)&#13;
            | JumpIfZero(val condition, identifier target)&#13;
            | JumpIfNotZero(val condition, identifier target)&#13;
            | Label(identifier)&#13;
            | FunCall(identifier fun_name, val* args, val dst)&#13;
val = Constant(<b>const</b>) | Var(identifier)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual&#13;
                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-20: Adding support for long integers to TACKY</samp></p>&#13;
<p class="TX">We’ll handle the changes to <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> by looking up type and initializer information in the symbol table during TACKY generation. If a static variable has a tentative definition in the symbol table, we’ll initialize it to <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit(0)</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit(0)</samp>, depending on its type.</p>&#13;
<p class="TX">Handling constants is even easier; the logic is essentially unchanged from earlier chapters. We’ll convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp> AST node directly to a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>, since they both use the same definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>.</p>&#13;
<p class="TX">Recall that when we convert a logical <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> expression to TACKY, we explicitly assign 1 or 0 to the variable that holds the result of the expression. Since these logical expressions both have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, we represent their results as <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(1)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(0)</samp>.</p>&#13;
<p class="TX"><a href="chapter11.xhtml#list11-21">Listing 11-21</a> shows how to convert cast expressions to TACKY. We’ll use the type information we added in the previous pass to determine what type we’re casting from.</p>&#13;
<a id="list11-21"/>&#13;
<pre><code>emit_tacky(e, instructions, symbols):&#13;
    match e with&#13;
    | <var>--snip--</var>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_260" aria-label="260"/>    | Cast(t, inner) -&gt;&#13;
        result = emit_tacky(inner, instructions, symbols)&#13;
        if t == get_type(inner):&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> return result&#13;
        dst_name = make_temporary()&#13;
        symbols.add(dst_name, t, attrs=LocalAttr)&#13;
        dst = Var(dst_name)&#13;
        if t == Long:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> instructions.append(SignExtend(result, dst))&#13;
        else:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> instructions.append(Truncate(result, dst))&#13;
        return dst</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-21: Converting a cast expression to TACKY</samp></p>&#13;
<p class="TX">If the inner expression already has the type we want to cast it to, the cast has no effect; we emit TACKY to evaluate the inner expression but don’t do anything else <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Otherwise, we emit either a <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp> instruction to cast an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span> or a <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp> instruction to cast a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-82"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tracking the Types of Temporary Variables</samp></h4>&#13;
<p class="TNI">When we create the temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> in <a href="chapter11.xhtml#list11-21">Listing 11-21</a>, we add it to the symbol table with the appropriate type. We need to do this for every temporary variable we create so that we can look up their types during assembly generation. The assembly generation stage will use this type information in two ways: to determine the operand size of each assembly instruction and to figure out how much stack space to allocate for each variable.</p>&#13;
<p class="TX">Every temporary variable we add holds the result of an expression, so we can determine its type by checking the expression’s type annotation. Let’s take another look at <span class="Xref-1"><a href="chapter3.xhtml#list3-9">Listing 3-9</a></span>, which demonstrated how to convert a binary arithmetic expression to TACKY. <a href="chapter11.xhtml#list11-22">Listing 11-22</a> demonstrates the same conversion, with changes from <span class="Xref-1"><a href="chapter3.xhtml#list3-9">Listing 3-9</a></span> bolded.</p>&#13;
<a id="list11-22"/>&#13;
<pre><code>emit_tacky(e, instructions, <b>symbols</b>):&#13;
    match e with&#13;
    | <var>--snip--</var>&#13;
    | Binary(op, e1, e2) -&gt;&#13;
        v1 = emit_tacky(e1, instructions, <b>symbols</b>)&#13;
        v2 = emit_tacky(e2, instructions, <b>symbols</b>)&#13;
        dst_name = make_temporary()&#13;
        <b>symbols.add(dst_name, get_type(e), attrs=LocalAttr)</b>&#13;
        dst = Var(dst_name)&#13;
        tacky_op = convert_binop(op)&#13;
        instructions.append(Binary(tacky_op, v1, v2, dst))&#13;
        return dst&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-22: Tracking temporary variable types when converting a binary expression to TACKY</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_261" aria-label="261"/>The main change here is adding <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> to the symbol table. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> holds the result of expression <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>, we look up <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>’s type annotation to figure out <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>’s type. Like every temporary variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is a local, automatic variable, so we’ll give it the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalAttr</samp> attribute in the symbol table.</p>&#13;
<p class="TX">Let’s refactor this into a helper function, shown in <a href="chapter11.xhtml#list11-23">Listing 11-23</a>.</p>&#13;
<a id="list11-23"/>&#13;
<pre><code>make_tacky_variable(var_type, symbols):&#13;
    var_name = make_temporary()&#13;
    symbols.add(var_name, var_type, attrs=LocalAttr)&#13;
    return Var(var_name)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-23: A helper function for generating TACKY variables</samp></p>&#13;
<p class="TX">From now on, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">make_tacky_variable</samp> whenever we generate a new temporary variable in TACKY.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-83"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Extra Return Instructions</samp></h4>&#13;
<p class="TNI">In <span class="Xref-1"><a href="chapter5.xhtml">Chapter 5</a></span>, I mentioned that we add an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction to the end of each TACKY function, in case not every execution path in the original C function reaches a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. This extra instruction can always return <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(0)</samp>, even when the function’s return type isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. When we return from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, this is the correct return type. When we return from any other function that’s missing an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, the return value is undefined. We still need to return control to the caller, but we aren’t obligated to return any particular value, so it doesn’t matter if we get the type wrong.</p>&#13;
<aside class="box" aria-label="box-18"><p class="BoxTitle" id="box-18"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test TACKY generation, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 11 --stage tacky</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h1-94"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">We’ll make several changes to the assembly AST in this chapter. <a href="chapter11.xhtml#list11-24">Listing 11-24</a> gives the complete definition, with changes bolded.</p>&#13;
<a id="list11-24"/>&#13;
<pre><code>program = Program(top_level*)&#13;
<b>assembly_type = Longword | Quadword</b>&#13;
top_level = Function(identifier name, bool global, instruction* instructions)&#13;
          | StaticVariable(identifier name, bool global, <b>int alignment, static_init init</b>)&#13;
instruction = Mov(<b>assembly_type, </b>operand src, operand dst)&#13;
            <b>| Movsx(operand src, operand dst)</b>&#13;
            | Unary(unary_operator, <b>assembly_type</b>, operand)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_262" aria-label="262"/>            | Binary(binary_operator, <b>assembly_type</b>, operand, operand)&#13;
            | Cmp(<b>assembly_type</b>, operand, operand)&#13;
            | Idiv(<b>assembly_type</b>, operand)&#13;
            | Cdq(<b>assembly_type</b>)&#13;
            | Jmp(identifier)&#13;
            | JmpCC(cond_code, identifier)&#13;
            | SetCC(cond_code, operand)&#13;
            | Label(identifier)&#13;
            | Push(operand)&#13;
            | Call(identifier)&#13;
            | Ret&#13;
&#13;
unary_operator = Neg | Not&#13;
binary_operator = Add | Sub | Mult&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int) | Data(identifier)&#13;
cond_code = E | NE | G | GE | L | LE&#13;
reg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | <b>SP</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-24: The assembly AST with support for quadword operands and 8-byte static variables</samp></p>&#13;
<p class="TX">The biggest change is tagging most instructions with the type of their operands. That allows us to choose the correct suffix for each instruction during assembly emission. We’ll also add a type to <samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq</samp>, since the 32-bit version of <samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq</samp> extends EAX into EDX and the 64-bit version extends RAX into RDX. There are just three instructions that take an operand but don’t need a type: <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>, which takes only byte-size operands; <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>, which always pushes quadwords; and the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp> instruction, which we’ll cover in a moment.</p>&#13;
<p class="TX">Instead of reusing the source-level type we defined earlier, we’ll define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp> construct. This will simplify working with assembly types as we introduce more C types in later chapters. For example, we’ll add unsigned integers in <span class="Xref-1"><a href="chapter12.xhtml">Chapter 12</a></span>, but assembly doesn’t distinguish between signed and unsigned integers.</p>&#13;
<p class="TX">During assembly generation, we’ll figure out each instruction’s type based on the type of its operands. For example, we’ll convert the TACKY instruction</p>&#13;
<pre><code>Binary(Add, Constant(ConstInt(3)), Var("src"), Var("dst"))</code></pre>&#13;
<p class="BodyContinued">to these assembly instructions:</p>&#13;
<pre><code>Mov(Longword, Imm(3), Pseudo("dst"))&#13;
Binary(Add, Longword, Pseudo("src"), Pseudo("dst"))</code></pre>&#13;
<p class="TX">Since the first operand is a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>, we know that the resulting <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> instructions should use longword operands. We can assume that the second operand and the destination have the same type as the first operand, since we inserted the appropriate type conversion instructions during TACKY generation. If an operand is a variable instead of a constant, we’ll look up its type in the symbol table.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_263" aria-label="263"/>We’ll also figure out how to pass stack arguments based on their type. <a href="chapter11.xhtml#list11-25">Listing 11-25</a> reproduces the relevant part of <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_function_call</samp>, which we defined back in <span class="Xref-1"><a href="chapter9.xhtml#list9-31">Listing 9-31</a></span>, with this change bolded.</p>&#13;
<a id="list11-25"/>&#13;
<pre><code>convert_function_call(FunCall(fun_name, args, dst)):&#13;
    <var>--snip--</var>&#13;
    // pass args on stack&#13;
    for tacky_arg in reverse(stack_args):&#13;
        assembly_arg = convert_val(tacky_arg)&#13;
        if assembly_arg is a Reg or Imm operand <b>or has type Quadword</b>:&#13;
            emit(Push(assembly_arg))&#13;
        else:&#13;
            emit(Mov(<b>Longword</b>, assembly_arg, Reg(AX)))&#13;
            emit(Push(Reg(AX)))&#13;
    <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-25: Passing quadwords on the stack in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">convert_function_call</samp></p>&#13;
<p class="TX">In <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>, we learned that we could run into trouble if we used an 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> instruction to push a 4-byte operand from memory onto the stack. To work around this issue, we emit two instructions to push a 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> onto the stack: we copy it into EAX, then push RAX. An 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> doesn’t require this workaround; we pass it on the stack with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instruction, the same way we pass an immediate value.</p>&#13;
<p class="TX">To handle conversions from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, we’ll use the sign extension instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>. At the moment, this instruction doesn’t need type information, since its source must be an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and its destination must be a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. We’ll convert</p>&#13;
<pre><code>SignExtend(src, dst)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Movsx(src, dst)</code></pre>&#13;
<p class="TX">To truncate a value, we just move its lowest 4 bytes into the destination using a 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction. We’ll convert</p>&#13;
<pre><code>Truncate(src, dst)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Mov(Longword, src, dst)</code></pre>&#13;
<p class="TX">We’ve also tweaked the <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> construct:</p>&#13;
<pre><code>StaticVariable(identifier name, bool global, <b>int alignment, static_init init</b>)</code></pre>&#13;
<p class="TX">We hold onto the <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> construct from TACKY, so we know whether to initialize 4 or 8 bytes for each static variable. We add an <span role="doc-pagebreak" epub:type="pagebreak" id="pg_264" aria-label="264"/><samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> field too, since we’ll need to specify each static variable’s alignment in assembly.</p>&#13;
<p class="TX">Finally, we’ve removed the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> instructions from the assembly AST. These instructions were just placeholders for quadword addition and subtraction, which we can now represent with ordinary <samp class="SANS_TheSansMonoCd_W5Regular_11">addq</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp> instructions. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> represented adding to and subtracting from RSP, we’ve also added the RSP register to the assembly AST so we can use it in normal instructions. In earlier chapters, we maintained the stack alignment before function calls with the instruction:</p>&#13;
<pre><code>AllocateStack(bytes)</code></pre>&#13;
<p class="TX">Now we’ll use this instruction instead:</p>&#13;
<pre><code>Binary(Sub, Quadword, Imm(bytes), Reg(SP))</code></pre>&#13;
<p class="TX">Similarly, instead of</p>&#13;
<pre><code>DeallocateStack(bytes)</code></pre>&#13;
<p class="BodyContinued">we’ll use</p>&#13;
<pre><code>Binary(Add, Quadword, Imm(bytes), Reg(SP))</code></pre>&#13;
<p class="BodyContinued">to restore the stack pointer after function calls.</p>&#13;
<p class="TX"><a href="chapter11.xhtml#tab11-1">Tables 11-1</a> through <a href="chapter11.xhtml#tab11-4">11-4</a> summarize this chapter’s updates to the conversion from TACKY to assembly. New constructs and changes to the conversions for existing constructs are bolded.</p>&#13;
<p class="TT" id="tab11-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Top-Level TACKY Constructs to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, global, params,          instructions)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, global,&#13;
          [Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;param1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(DI), param1),&#13;
           Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;param2 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(SI), param2),</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">           &lt;copy next four parameters from registers&gt;,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#13;
           Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;param7 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Stack(16), param7),&#13;
           Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;param8 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Stack(24), param8),</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">           &lt;copy remaining parameters from stack&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+&#13;
        instructions)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">t,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">init)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;alignment of t&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">init)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab11-2"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_265" aria-label="265"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;val type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, val, Reg(AX))<br/>Ret</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Not, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(0), src)<br/>Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(0), dst)<br/>SetCC(E, dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)<br/>Unary(unary_operator,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Divide, src1, src2, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src1, Reg(AX))<br/>Cdq(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)<br/>Idiv(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src2)<br/>Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Remainder, src1, src2, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src1, Reg(AX))<br/>Cdq(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)<br/>Idiv(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src2)<br/>Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(DX), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(arithmetic_operator, src1, src2, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src1, dst)<br/>Binary(arithmetic_operator,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src2, dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(relational_operator, src1, src2, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src2, src1)<br/>Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), dst)<br/>SetCC(relational_operator, dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero(condition, target)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;condition type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), condition)<br/>JmpCC(E, target)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero(condition, target)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;condition type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), condition)<br/>JmpCC(NE, target)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall(fun_name, args, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;fix stack alignment&gt;<br/>&lt;set up arguments&gt;</samp> <br/><samp class="SANS_TheSansMonoCd_W5Regular_11">Call(fun_name)</samp> <br/><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;deallocate arguments/padding&gt;</samp> <br/><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(AX), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SignExtend(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Movsx(src, dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Truncate(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(Longword, src, dst)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab11-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Operands to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ConstInt(int)</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstLong(int))</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Imm(int)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab11-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Types to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Int</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">4</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Long</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Quadword</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_266" aria-label="266"/>In <a href="chapter11.xhtml#tab11-3">Table 11-3</a>, we convert both types of TACKY constants to <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp> operands. In assembly, there’s no distinction between 4-byte and 8-byte immediate values. The assembler infers how large an immediate value should be based on the operand size of the instruction where it appears.</p>&#13;
<p class="TX"><a href="chapter11.xhtml#tab11-4">Table 11-4</a> gives the conversion from source-level to assembly types, as well as each type’s alignment. Note that this conversion fits into the whole compiler pass a bit differently than the conversions in <a href="chapter11.xhtml#tab11-1">Tables 11-1</a> through <a href="chapter11.xhtml#tab11-3">11-3</a>, because when we traverse a TACKY program, we won’t encounter <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST nodes that we can convert directly to <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp> nodes in the assembly program. As we’ve seen, we typically need to infer a TACKY instruction’s operand type before we can convert it to an assembly type. The one TACKY construct with an explicit type is <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>, but we don’t need to convert this type to an assembly type; we only need to calculate its alignment. We’ll use the conversion shown in <a href="chapter11.xhtml#tab11-4">Table 11-4</a> again in the next step of this compiler pass, where we’ll construct a new symbol table to track assembly types.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-84"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tracking Assembly Types in the Backend Symbol Table</samp></h4>&#13;
<p class="TNI">After converting the TACKY program to assembly, we’ll convert the symbol table to a form that’s better suited to the remaining compiler passes. This new symbol table will store variables’ assembly types, rather than their source types. It will also store a handful of other properties that we’ll need to look up in the pseudoregister replacement, instruction fix-up, and code emission passes. I’ll call this new symbol table the <i>backend symbol table</i>. I’ll call the existing one either the <i>frontend symbol table</i> or just the <i>symbol table</i>.</p>&#13;
<p class="TX">The backend symbol table maps each identifier to an <samp class="SANS_TheSansMonoCd_W5Regular_11">asm_symtab_entry</samp> construct, defined in <a href="chapter11.xhtml#list11-26">Listing 11-26</a>.</p>&#13;
<a id="list11-26"/>&#13;
<pre><code>asm_symtab_entry = ObjEntry(assembly_type, bool is_static)&#13;
                 | FunEntry(bool defined)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-26: The definition of an entry in the backend symbol table</samp></p>&#13;
<p class="TX">We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjEntry</samp> to represent variables (and, in later chapters, constants). We’ll track each object’s assembly type and whether it has static storage duration. <samp class="SANS_TheSansMonoCd_W5Regular_11">FunEntry</samp> represents functions. We don’t need to track the types of functions—which is just as well, since <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp> can’t represent function types—but we do track whether they’re defined in the current translation unit. If you’re tracking each function’s stack frame size in the symbol table, add an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_frame_size</samp> field to the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunEntry</samp> constructor. I recommend making the backend symbol table a global variable or singleton, just like the existing frontend symbol table.</p>&#13;
<p class="TX">At the very end of the TACKY-to-assembly conversion pass, you should iterate over the frontend symbol table and convert each entry to an entry in the backend symbol table. This process is simple enough that I won’t provide the pseudocode for it. You’ll also need to update any spots in the pseudoregister replacement, instruction fix-up, and code emission passes that refer to the frontend symbol table and have them use the backend symbol table instead.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_267" aria-label="267"/>&#13;
<h4 class="H2" id="sec16"><span id="h2-85"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Longword and Quadword Pseudoregisters</samp></h4>&#13;
<p class="TNI">The pseudoregister replacement pass requires a couple of changes. First, we’ll extend it to replace pseudoregisters in the new <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp> instruction. Second, whenever we assign a stack address to a pseudoregister, we’ll look up the pseudoregister’s type in the backend symbol table to determine how much space to allocate. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, we’ll allocate 8 bytes; if it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, we’ll allocate 4 bytes, as before. Finally, we’ll make sure that the address of each <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> pseudoregister is 8-byte aligned on the stack. Consider the following fragment of assembly:</p>&#13;
<pre><code>Mov(Longword, Imm(0), Pseudo("foo"))&#13;
Mov(Quadword, Imm(1), Pseudo("bar"))</code></pre>&#13;
<p class="TX">Suppose we look up the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> in the backend symbol table and see that it’s 4 bytes. We’ll assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>, as usual. Next, we’ll look up <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> and see that it’s 8 bytes. We could assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>, which is 8 bytes below <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. But then <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> would be misaligned, since its address wouldn’t be a multiple of 8 bytes. (Remember that the address in RBP is always 16-byte aligned.) To maintain the correct alignment, we’ll round down to the next multiple of 8 and store <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> at <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp> instead. Alignment requirements are part of the System V ABI; if you ignore them, your code may not interact correctly with code in other translation units.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-86"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up Instructions</samp></h4>&#13;
<p class="TNI">We’ll make several updates to the instruction fix-up pass in this chapter. First, we need to specify operand sizes for all the instructions in our existing rewrite rules. These should always have the same operand size as the original instruction being rewritten.</p>&#13;
<p class="TX">Next, we’ll rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp> instruction. It can’t use a memory address as a destination or an immediate value as a source. If both operands to <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp> are invalid, we’ll need to use both R10 and R11 to fix them. For example, we’ll rewrite</p>&#13;
<pre><code>Movsx(Imm(10), Stack(-16))</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Mov(Longword, Imm(10), Reg(R10))&#13;
Movsx(Reg(R10), Reg(R11))&#13;
Mov(Quadword, Reg(R11), Stack(-16))</code></pre>&#13;
<p class="TX">It’s important to use the right operand size for each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction in this rewrite rule. Since the source operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp> is 4 bytes, we specify a longword operand size when moving that operand into a register. Since the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp> is 8 bytes, we specify a quadword operand size when we move the result to its final memory location.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_268" aria-label="268"/>The quadword versions of our three binary arithmetic instructions (<samp class="SANS_TheSansMonoCd_W5Regular_11">addq</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">imulq</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp>) can’t handle immediate values that don’t fit into an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and neither can <samp class="SANS_TheSansMonoCd_W5Regular_11">cmpq</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp>. If the source of any of these instructions is a constant outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, we’ll need to copy it into R10 before we can use it.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction can move these very large immediate values into registers, but not directly into memory, so</p>&#13;
<pre><code>Mov(Quadword, Imm(4294967295), Stack(-16))</code></pre>&#13;
<p class="BodyContinued">should be rewritten as:</p>&#13;
<pre><code>Mov(Quadword, Imm(4294967295), Reg(R10))&#13;
Mov(Quadword, Reg(R10), Stack(-16))</code></pre>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The assembler permits an immediate value in addq, imulq, subq, cmpq, or pushq only if it can be represented as a</i> <span class="note_Italic">signed</span> <i>32-bit integer. That’s because these instructions all sign extend their immediate operands from 32 to 64 bits. If an immediate value can be represented in 32 bits only as an</i> <span class="note_Italic">unsigned</span> <i>integer—which implies that its upper bit is set—sign extending it will change its value. For more details, see this Stack Overflow question:</i> <span class="note_LinkURL_Italic"><a href="https://stackoverflow.com/questions/64289590/integer-overflow-in-gas">https://<wbr/>stackoverflow<wbr/>.com<wbr/>/questions<wbr/>/64289590<wbr/>/integer<wbr/>-overflow<wbr/>-in<wbr/>-gas</a></span><i>.</i></p>&#13;
<p class="TX">We’ll also fix how we allocate stack space at the start of each function. Instead of adding <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack(bytes)</samp> to each function to allocate space on the stack, we’ll add the following instruction, which does the same thing:</p>&#13;
<pre><code>Binary(Sub, Quadword, Imm(bytes), Reg(SP))</code></pre>&#13;
<p class="TX">We’ll add one last rewrite rule to placate the assembler, although it isn’t strictly necessary. Remember that we convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp> TACKY instruction to a 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>, which means we can generate <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instructions that move 8-byte immediate values to 4-byte destinations:</p>&#13;
<pre><code>Mov(Longword, Imm(4294967299), Reg(R10))</code></pre>&#13;
<p class="TX">Since <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> can’t use 8-byte immediate values, the assembler automatically truncates these values to 32 bits. When it processes the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $4294967299, %r10d</samp>, for example, it will convert the immediate value <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967299</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>. The GNU assembler issues a warning when it performs this conversion, although the LLVM assembler doesn’t. To avoid these warnings, we’ll truncate 8-byte immediate values in <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instructions ourselves. That means we’ll rewrite the previous instruction as:</p>&#13;
<pre><code>Mov(Longword, Imm(3), Reg(R10))</code></pre>&#13;
<p class="TX">Assembler warnings aside, your assembly programs will still work even if you don’t include this rewrite rule.</p>&#13;
<aside class="box" aria-label="box-19"><p class="BoxTitle" id="box-19"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_269" aria-label="269"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test that your compiler can generate assembly programs without throwing an error, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 11 --stage codegen</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h1-95"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">Our final task is to extend the code emission stage. We’ll add the appropriate suffix to every instruction, emit the correct alignment and initial value for static variables, and handle the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp> instruction. Whenever an instruction uses a register, we’ll emit the appropriate register name for that instruction’s operand size.</p>&#13;
<p class="TX">Instructions with 4-byte operands have an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix, for longword, and instructions with 8-byte operands have a <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> suffix, for quadword, with one exception: the 8-byte version of <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> has a completely different mnemonic, <samp class="SANS_TheSansMonoCd_W5Regular_11">cqo</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp> instruction takes suffixes for both its source and destination operand sizes. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">movslq</samp> sign extends a longword to a quadword. For now, we’ll always emit this instruction with an <samp class="SANS_TheSansMonoCd_W5Regular_11">lq</samp> suffix; we’ll need more suffixes as we add more assembly types in later chapters. (You may also see this instruction written as <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp> when it’s possible for the assembler to infer the size of both operands. For example, the assembler will accept the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx %r10d, %r11</samp>, since it can infer the source and destination sizes from the register names.)</p>&#13;
<p class="TX"><a href="chapter11.xhtml#tab11-5">Tables 11-5</a> through <a href="chapter11.xhtml#tab11-10">11-10</a> summarize this chapter’s updates to the code emission pass. New constructs and changes to existing constructs are bolded.</p>&#13;
<p class="TT" id="tab11-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Top-Level Assembly Constructs</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">alignment</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">init)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Initialized to zero</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;global-directive&gt;</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    .bss</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;alignment-directive&gt;&#13;
&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&#13;
    &lt;init&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"/>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Initialized to nonzero value</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;global-directive&gt;</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    .data</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;alignment-directive&gt;&#13;
&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">    &lt;init&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg1 TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Alignment directive</samp></p></td>&#13;
<td class="Basic-Table graybg1 TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Linux only</samp></p></td>&#13;
<td class="Basic-Table graybg1 TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;alignment&gt;</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">macOS or Linux</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">.balign</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;alignment&gt;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab11-6"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_270" aria-label="270"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Static Initializers</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">IntInit(0)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">.zero 4</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">IntInit(i)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">.long</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;i&gt;</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">LongInit(0)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">.zero</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">LongInit(i)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">.quad</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;i&gt;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab11-7"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Instructions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">t</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;t&gt;   </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> &lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Movsx(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">movslq   </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"> &lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">t</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, operand)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;unary_operator&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;t&gt;    </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;operand&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(binary_operator,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">t</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;binary_operator&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;t&gt;   </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src&gt;, &lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">t</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, operand)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;t&gt;  </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;operand&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Quadword</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">cqo</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">t</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, operand, operand)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;t&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;operand&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"> &lt;operand&gt;</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab11-8"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Instruction Names for Assembly Operators</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">neg</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">not</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Add</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">add</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Sub</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">sub</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mult</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">imul</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab11-9"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-9:</samp></span> <samp class="SANS_Futura_Std_Book_11">Instruction Suffixes for Assembly Types</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction suffix</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">l</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Quadword</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">q</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab11-10"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-10:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(SP)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rsp</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><a href="chapter11.xhtml#tab11-6">Table 11-6</a> shows how to print out the <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> constructs representing static variable initializers. <a href="chapter11.xhtml#tab11-8">Table 11-8</a> shows the mapping from unary and binary operators to instruction names without suffixes; the suffix now <span role="doc-pagebreak" epub:type="pagebreak" id="pg_271" aria-label="271"/>depends on the instruction’s type (as shown in <a href="chapter11.xhtml#tab11-9">Table 11-9</a>). Aside from the suffix, these instruction names are the same as in earlier chapters.</p>&#13;
<p class="TX">Once you’ve updated the code emission stage, you’re ready to test out your compiler.</p>&#13;
<aside class="box" aria-label="box-20"><p class="BoxTitle" id="box-20"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 11</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11/valid/long_expressions</samp> <samp class="SANS_Futura_Std_Book_11">validate that the expressions we implemented in earlier chapters, like addition, subtraction, and comparisons, work correctly with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> <samp class="SANS_Futura_Std_Book_11">operands. The programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11/valid/explicit_casts</samp> <samp class="SANS_Futura_Std_Book_11">test explicit casts between</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp><samp class="SANS_Futura_Std_Book_11">, and the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11/valid/implicit_casts</samp> <samp class="SANS_Futura_Std_Book_11">test that we perform the correct implicit type conversions to evaluate expressions involving both types. Finally, the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_11/valid/libraries</samp> <samp class="SANS_Futura_Std_Book_11">validate that compiled code dealing with long integers conforms to the System V ABI.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1" id="sec19"><span id="h1-96"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">Your compiler has a type system now! In this chapter, you annotated the AST with type information, used the symbol table to track type information through multiple compiler stages, and added support for multiple operand sizes during assembly generation. Long integers aren’t the flashiest language feature, so it might feel like you’ve done a lot of work and don’t have much to show for it. But the infrastructure you created in this chapter is the basis for everything you’ll do in the rest of <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. In the next chapter, you’ll build on that work by implementing unsigned integers.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>