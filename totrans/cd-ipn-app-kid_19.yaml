- en: '16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: USING THE SPRITEKIT PHYSICS ENGINE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll use SpriteKit’s physics engine in our skateboarder game.
    A *physics engine* handles physical actions in games, such as how gravity works,
    objects’ speeds, how things bounce off one another, and more so that you can make
    more complex games with less code. When coding a game, you define how the game
    elements (the skater, the bricks, the gems) should behave, and then the physics
    engine takes care of moving everything around.
  prefs: []
  type: TYPE_NORMAL
- en: For example, rather than changing the skater’s velocity when she jumps, we’ll
    simply tell the computer how heavy she is and then apply an upward force. This
    tells the physics engine to push the skater upward and lets gravity pull her back
    down. We don’t have to do anything else. The physics engine takes care of changing
    the skater’s velocity and position as she jumps, and it makes sure her wheels
    collide with the sidewalk bricks when she comes back down to land.
  prefs: []
  type: TYPE_NORMAL
- en: But first, the physics engine needs you to tell it a few things about the game’s
    *physics world* . For example, if your game takes place in outer space, you’d
    tell it there is no gravity. For a game on Earth, you’d tell it to use a downward
    gravity. You also need to define *physics bodies* for each sprite or node in your
    world. This helps the computer determine how each item should behave based on
    its weight, whether it’s affected by gravity, and its bounciness. Once you’ve
    done that, the sprites will automatically move around and behave like real-world
    objects when you run your game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what the physics engine does, let’s see it in action.
    We’ll set up our physics world, create physics bodies for our sprites, apply forces,
    and check for collisions.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE PHYSICS WORLD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every SKScene comes with an SKPhysicsWorld property called physicsWorld . This
    is where we set global properties that apply to everything in this scene, such
    as gravity. Add the following line to the top of your didMove(to:) method inside
    the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: USING THE SPRITEKIT PHYSICS ENGINE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll use SpriteKit’s physics engine in our skateboarder game.
    A *physics engine* handles physical actions in games, such as how gravity works,
    objects’ speeds, how things bounce off one another, and more so that you can make
    more complex games with less code. When coding a game, you define how the game
    elements (the skater, the bricks, the gems) should behave, and then the physics
    engine takes care of moving everything around.
  prefs: []
  type: TYPE_NORMAL
- en: For example, rather than changing the skater’s velocity when she jumps, we’ll
    simply tell the computer how heavy she is and then apply an upward force. This
    tells the physics engine to push the skater upward and lets gravity pull her back
    down. We don’t have to do anything else. The physics engine takes care of changing
    the skater’s velocity and position as she jumps, and it makes sure her wheels
    collide with the sidewalk bricks when she comes back down to land.
  prefs: []
  type: TYPE_NORMAL
- en: But first, the physics engine needs you to tell it a few things about the game’s
    *physics world* . For example, if your game takes place in outer space, you’d
    tell it there is no gravity. For a game on Earth, you’d tell it to use a downward
    gravity. You also need to define *physics bodies* for each sprite or node in your
    world. This helps the computer determine how each item should behave based on
    its weight, whether it’s affected by gravity, and its bounciness. Once you’ve
    done that, the sprites will automatically move around and behave like real-world
    objects when you run your game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what the physics engine does, let’s see it in action.
    We’ll set up our physics world, create physics bodies for our sprites, apply forces,
    and check for collisions.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE PHYSICS WORLD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every SKScene comes with an SKPhysicsWorld property called physicsWorld . This
    is where we set global properties that apply to everything in this scene, such
    as gravity. Add the following line to the top of your didMove(to:) method inside
    the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll use SpriteKit’s physics engine in our skateboarder game.
    A *physics engine* handles physical actions in games, such as how gravity works,
    objects’ speeds, how things bounce off one another, and more so that you can make
    more complex games with less code. When coding a game, you define how the game
    elements (the skater, the bricks, the gems) should behave, and then the physics
    engine takes care of moving everything around.
  prefs: []
  type: TYPE_NORMAL
- en: For example, rather than changing the skater’s velocity when she jumps, we’ll
    simply tell the computer how heavy she is and then apply an upward force. This
    tells the physics engine to push the skater upward and lets gravity pull her back
    down. We don’t have to do anything else. The physics engine takes care of changing
    the skater’s velocity and position as she jumps, and it makes sure her wheels
    collide with the sidewalk bricks when she comes back down to land.
  prefs: []
  type: TYPE_NORMAL
- en: But first, the physics engine needs you to tell it a few things about the game’s
    *physics world* . For example, if your game takes place in outer space, you’d
    tell it there is no gravity. For a game on Earth, you’d tell it to use a downward
    gravity. You also need to define *physics bodies* for each sprite or node in your
    world. This helps the computer determine how each item should behave based on
    its weight, whether it’s affected by gravity, and its bounciness. Once you’ve
    done that, the sprites will automatically move around and behave like real-world
    objects when you run your game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what the physics engine does, let’s see it in action.
    We’ll set up our physics world, create physics bodies for our sprites, apply forces,
    and check for collisions.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE PHYSICS WORLD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every SKScene comes with an SKPhysicsWorld property called physicsWorld . This
    is where we set global properties that apply to everything in this scene, such
    as gravity. Add the following line to the top of your didMove(to:) method inside
    the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use SpriteKit’s physics engine in our skateboarder game.
    A *physics engine* handles physical actions in games, such as how gravity works,
    objects’ speeds, how things bounce off one another, and more so that you can make
    more complex games with less code. When coding a game, you define how the game
    elements (the skater, the bricks, the gems) should behave, and then the physics
    engine takes care of moving everything around.
  prefs: []
  type: TYPE_NORMAL
- en: For example, rather than changing the skater’s velocity when she jumps, we’ll
    simply tell the computer how heavy she is and then apply an upward force. This
    tells the physics engine to push the skater upward and lets gravity pull her back
    down. We don’t have to do anything else. The physics engine takes care of changing
    the skater’s velocity and position as she jumps, and it makes sure her wheels
    collide with the sidewalk bricks when she comes back down to land.
  prefs: []
  type: TYPE_NORMAL
- en: But first, the physics engine needs you to tell it a few things about the game’s
    *physics world* . For example, if your game takes place in outer space, you’d
    tell it there is no gravity. For a game on Earth, you’d tell it to use a downward
    gravity. You also need to define *physics bodies* for each sprite or node in your
    world. This helps the computer determine how each item should behave based on
    its weight, whether it’s affected by gravity, and its bounciness. Once you’ve
    done that, the sprites will automatically move around and behave like real-world
    objects when you run your game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what the physics engine does, let’s see it in action.
    We’ll set up our physics world, create physics bodies for our sprites, apply forces,
    and check for collisions.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE PHYSICS WORLD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every SKScene comes with an SKPhysicsWorld property called physicsWorld . This
    is where we set global properties that apply to everything in this scene, such
    as gravity. Add the following line to the top of your didMove(to:) method inside
    the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: For example, rather than changing the skater’s velocity when she jumps, we’ll
    simply tell the computer how heavy she is and then apply an upward force. This
    tells the physics engine to push the skater upward and lets gravity pull her back
    down. We don’t have to do anything else. The physics engine takes care of changing
    the skater’s velocity and position as she jumps, and it makes sure her wheels
    collide with the sidewalk bricks when she comes back down to land.
  prefs: []
  type: TYPE_NORMAL
- en: But first, the physics engine needs you to tell it a few things about the game’s
    *physics world* . For example, if your game takes place in outer space, you’d
    tell it there is no gravity. For a game on Earth, you’d tell it to use a downward
    gravity. You also need to define *physics bodies* for each sprite or node in your
    world. This helps the computer determine how each item should behave based on
    its weight, whether it’s affected by gravity, and its bounciness. Once you’ve
    done that, the sprites will automatically move around and behave like real-world
    objects when you run your game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what the physics engine does, let’s see it in action.
    We’ll set up our physics world, create physics bodies for our sprites, apply forces,
    and check for collisions.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE PHYSICS WORLD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every SKScene comes with an SKPhysicsWorld property called physicsWorld . This
    is where we set global properties that apply to everything in this scene, such
    as gravity. Add the following line to the top of your didMove(to:) method inside
    the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: But first, the physics engine needs you to tell it a few things about the game’s
    *physics world* . For example, if your game takes place in outer space, you’d
    tell it there is no gravity. For a game on Earth, you’d tell it to use a downward
    gravity. You also need to define *physics bodies* for each sprite or node in your
    world. This helps the computer determine how each item should behave based on
    its weight, whether it’s affected by gravity, and its bounciness. Once you’ve
    done that, the sprites will automatically move around and behave like real-world
    objects when you run your game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what the physics engine does, let’s see it in action.
    We’ll set up our physics world, create physics bodies for our sprites, apply forces,
    and check for collisions.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE PHYSICS WORLD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every SKScene comes with an SKPhysicsWorld property called physicsWorld . This
    is where we set global properties that apply to everything in this scene, such
    as gravity. Add the following line to the top of your didMove(to:) method inside
    the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what the physics engine does, let’s see it in action.
    We’ll set up our physics world, create physics bodies for our sprites, apply forces,
    and check for collisions.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE PHYSICS WORLD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every SKScene comes with an SKPhysicsWorld property called physicsWorld . This
    is where we set global properties that apply to everything in this scene, such
    as gravity. Add the following line to the top of your didMove(to:) method inside
    the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE PHYSICS WORLD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every SKScene comes with an SKPhysicsWorld property called physicsWorld . This
    is where we set global properties that apply to everything in this scene, such
    as gravity. Add the following line to the top of your didMove(to:) method inside
    the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every SKScene comes with an SKPhysicsWorld property called physicsWorld . This
    is where we set global properties that apply to everything in this scene, such
    as gravity. Add the following line to the top of your didMove(to:) method inside
    the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: This sets the gravity of the world using a CGVector , a data type that holds
    an x and a y value. It’s just like a CGPoint , except that these values represent
    the components of a vector instead of the coordinates of a point. A *vector* is
    a speed combined with a direction that is determined by horizontal (x ) and vertical
    (y ) components. In other words, when we set the x and y values, we’re setting
    the speed in the x-direction and the speed in the y-direction, which are then
    combined to make a vector. In our game, we set an x value of 0.0 and a y value
    of -6.0 . This means there’s no gravity in the horizontal direction and moderate
    gravity in the down direction. Normal Earth gravity has a y value of -9.8 , so
    our value of -6.0 should make for a lighter, cartoony world. If we wanted gravity
    to pull everything upward, we could set a positive y value for the gravity.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: The other physicsWorld property we can set is speed , which tells the physics
    engine how fast everything should run. The default value is 1.0 , which means
    everything runs at normal speed. Setting a speed of 2.0 would make the entire
    physics simulation run twice as fast. This property can be useful for special
    effects in your game, such as slow motion or fast forward. For Schoolhouse Skateboarder,
    we’ll leave the speed at the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: When you add a sprite (like your skater) to a scene, the computer knows what
    that sprite should look like, but that’s about it. It doesn’t know if the sprite
    is light or heavy, rough or smooth, and whether it should bounce off other objects.
    SpriteKit has a class called SKPhysicsBody that we add to sprites to give them
    physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING SHAPE TO THE PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: All sprites are rectangles. An image file of a baseball, for example, is a rectangular
    image with a baseball drawn in the middle. When you create a sprite using that
    baseball image, the computer won’t know it’s round unless you tell it that information.
    If you want that sprite to bounce around like a real baseball, you need to add
    a *circular* physics body to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can apply a physics body to a sprite, you need to create one using
    the SKPhysicsBody class. This example code shows three different ways of creating
    physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: The first example creates a circular physics body with a radius of 30.0 points
    ➊ . This would be perfect for a ball. The second example creates a rectangular
    body for a box-shaped sprite ➋ . If you have a sprite you’ve already created,
    you can just use the size of the sprite for the physics body’s size. In this case,
    we have a hypothetical box sprite that we use to set the size.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: The final example creates a physics body by supplying a *texture* ➌ , an image
    format commonly used in game development. Every SKSpriteNode you create has a
    property, texture , that you can use to access the sprite’s texture, no matter
    which file type was used to create the sprite (PNG, JPEG, and so on). When you
    use a sprite’s texture to create its physics body, SpriteKit automatically inspects
    the texture and creates a physics body that approximates the image’s actual shape
    by finding any edges and ignoring the transparent parts of the image. In this
    case, we’re using the texture skaterTexture , which we would have defined earlier
    in the code (you’ll learn how to access the texture of a sprite in “[Giving the
    skater Sprite a Physics Body](text00028.html#ch16lev2sec3) ” on [page 244](text00028.html#page_244)
    ; don’t worry about it for now). A texture doesn’t define the size of a physics
    body, so we’ve also set the body’s size to the skater sprite’s size.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite’s texture is what gets displayed on the screen, and the physics body
    defines how that sprite will behave. The two don’t need to line up exactly. You
    could use a circular physics body for a skater sprite, and that sprite would look
    like a skater but would roll around like a ball. While that would be funny to
    see, it’s usually best to create a physics body that most closely matches the
    look of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-1](text00028.html#ch16fig1) shows a skater sprite with different
    physics bodies applied. The figure shows the physics bodies in gray, but you won’t
    actually see them on your screen. They are completely invisible and are only used
    by the computer to determine how that sprite should behave.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-1: Various physics bodies applied to a* skater *sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: The skater with the circular physics body would roll around like a ball. The
    one with the rectangular body would behave like a box. And the third one, with
    a physics body based on the actual texture, would behave much more like we would
    expect a real-world skater to behave. If the tip of her hand hits something, it
    will look like that’s exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING PROPERTIES OF PHYSICS BODIES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: You set properties on physics bodies in order to describe them to the computer.
    A cloud would have a very low mass, meaning it’s lightweight and wouldn’t be affected
    by gravity. A bowling ball would be heavy and have a high mass, and it would definitely
    be affected by gravity. [Table 16-1](text00028.html#ch16tab1) lists some common
    properties of physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-1:** Common Properties of SKPhysicsBody'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mass | Defines how heavy something is. You can use any valid CGFloat value
    for this. The actual values used are not important as long as you are consistent
    throughout your app. |'
  prefs: []
  type: TYPE_TB
- en: '| friction | Defines how rough the surface is. For example, ice would have
    low friction, and objects touching it would tend to keep sliding. Values range
    from 0.0 to 1.0 . |'
  prefs: []
  type: TYPE_TB
- en: '| restitution | Defines the bounciness of an object. It’s used when objects
    collide with each other. Values range from 0.0 to 1.0 , where higher values mean
    bouncier. |'
  prefs: []
  type: TYPE_TB
- en: '| affectedByGravity | Defines whether this object should be affected by gravity.
    |'
  prefs: []
  type: TYPE_TB
- en: '| allowsRotation | Defines whether something should be allowed to rotate. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we would use these properties. Since we won’t actually use these
    examples for our game, you don’t need to enter this code. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, the bowling ball is heavy ➊ , has low friction ➋ , and has
    low restitution (bounciness) ➌ . The basketball’s code is the same, but its values
    are set so that it is light, has moderate friction, and is very bouncy. The ice
    cube is light, has low friction, and isn’t very bouncy. And the cloud is very
    light, has no friction, and has no bounciness. All of the physics bodies are set
    to be affected by gravity ➍ except the cloud ➏ (since we don’t want it to fall
    to Earth). Also, the bowling ball and basketball physics bodies are set to allow
    rotation of the object ➎ , while the ice cube and the cloud are not.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up physics bodies for your game sprites, it will take some
    trial and error to find the right values that make your objects behave the way
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING THE SKATER SPRITE A PHYSICS BODY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we talked about the various ways to assign a shape to a physics body.
    For our skater sprite, we’re going to use the sprite’s texture so that the physics
    body is shaped exactly like our skater. Switch to the *Skater.swift* file and
    add the following method to the Skater class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a physics body based on the skater sprite’s texture, we first
    need to check that the texture exists, since texture is an optional property of
    SKSpriteNode . The line at ➊ unwraps the texture as skaterTexture . The line at
    ➋ sets the skater’s physicsBody to a new SKPhysicsBody created using the texture
    and size of the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set some properties of the physics body in order to get it to behave
    the way we want. Setting the body’s isDynamic property to true ➌ indicates that
    we want this object to be moved by the physics engine. Sometimes you want an object
    to be part of the physics simulation so that you can know when it contacts something,
    but you don’t want the object to be moved around by the physics engine’s forces,
    gravity, or collisions. In that case, you would set isDynamic to false .
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: At ➍ , we set the density property of the skater sprite’s physics body to 6.0
    . Density is how heavy something is for its size. A bowling ball is much more
    dense than a volleyball—in other words, it’s the same size but much heavier. Setting
    the density tells the physics engine how this object should behave when it bumps
    into other objects or when forces are applied to it. If a bowling ball bumps into
    another object, it’s more likely to push the other object away than a volleyball
    would be, because of the bowling ball’s high density.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the allowsRotation property to true ➎ tells the physics engine that
    this physics body may rotate, or spin. If we wanted the skater to never tip over,
    we could set this to false .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set an angularDamping value ➏ . *Angular damping* is how much a
    physics body resists rotating. A lower value allows the object to spin more freely,
    while a higher value means the object is less likely to tip over. Right now we’ll
    set angularDamping to a value of 1.0 , but later we may discover that the skater
    tips over too easily or not easily enough, and we may come back to change this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a method on the Skater class to set up the skater sprite’s
    physics body, we just need to call this method after the skater is created. Switch
    back to *GameScene.swift* and add this line inside the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Since our skater sprite is created as a property of the GameScene class, it
    will already exist when didMove(to:) is called on the scene, so this is a good
    spot to set up the skater’s physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up physics bodies for the sidewalk bricks as well so that the
    skater will be able to bump into them.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PHYSICS BODIES TO BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add physics bodies to the bricks where they’re created. Inside the
    spawnBrick(_:) method, add the following to the end of the method but before the
    last line, return brick :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE988]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE989]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE990]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE991]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE992]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE993]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE994]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE995]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE996]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE997]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE998]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1008]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1009]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1010]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1011]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1012]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: For the bricks, we want to specify the physics body as a simple rectangle. Therefore,
    we’ll need to know the size and the center point to place the rectangular body.
    The line at ➊ finds the center point of the newly created brick . The line at
    ➋ creates and assigns the brick sprite’s physics body by specifying a rectangle
    the same size as the brick and placing it at the brick’s center. Now that this
    physics body is set, it’s attached directly on top of the brick sprite. The line
    at ➌ tells the brick sprite’s physics body that it shouldn’t be affected by gravity.
    We don’t want the sidewalk to fall through the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1016]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1032]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1033]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1041]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1042]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1043]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1044]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1045]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing the computer needs to know about your physics bodies is which
    ones should *collide* with each other. For example, we want the skater to collide
    with the sidewalk bricks so she won’t pass through them. Some objects shouldn’t
    collide, though. Later we’ll add gems for our skater to collect. We *don’t* want
    her to bounce off of the gems, so we’ll tell the computer that the skater and
    gems do not have collisions. We’ll want to know when the skater touches a gem,
    however. This is called *contact* . When any two objects contact each other, a
    special SpriteKit method is called to let us know so we can handle it. When the
    skater makes contact with a gem, we’ll want to remove the gem so it looks like
    she collected it.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1046]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1047]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1048]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1049]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1050]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1051]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1052]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1053]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1054]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1055]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1056]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1057]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1058]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1059]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1060]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**HANDLING CONTACTS AND COLLISIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1061]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1062]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1063]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1064]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1065]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1066]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1067]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1068]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1069]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1070]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1071]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1072]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1073]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1074]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1075]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up the world’s gravity and given physics bodies to some sprites,
    try running the game and see what happens. Pay close attention when the app first
    starts or you’ll miss it. You should see something like [Figure 16-2](text00028.html#ch16fig2)
    , but the skater will disappear quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1076]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1077]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1078]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1079]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1080]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1081]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1082]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1083]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1084]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1085]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1086]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1087]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1088]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1089]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1090]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1091]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1092]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1093]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1094]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1095]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1096]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1097]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1098]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1099]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1100]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1101]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1102]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1103]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1104]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1105]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-2: She looks a little too happy for what’s happening.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1106]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1107]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1108]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1109]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1110]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1111]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1112]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1113]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1114]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1115]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1116]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1117]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1118]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1119]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1120]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here? The skater and the bricks are all part of the physics
    simulation now, so the skater falls due to gravity, and we’re moving the bricks
    to the left, so they bump into her. To fix this, we need to tell SpriteKit which
    objects should collide with one another and which ones shouldn’t. In order to
    do that, we need a way to classify each object as a skater, a brick, or a gem
    (we won’t add gems until later, but we’ll create a category for them now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1121]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1122]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1123]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1124]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1125]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1126]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1127]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1128]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1129]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1130]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1131]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1132]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1133]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1134]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1135]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *GameScene.swift* , add the following struct at the top of the file after
    the import statement but before the GameScene ’s class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1136]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1137]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1138]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1139]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1140]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1141]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1142]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1143]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1144]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1145]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1146]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1147]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1148]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1149]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1150]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1151]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1152]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1153]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1154]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1155]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1156]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1157]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1158]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1159]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1160]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1161]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1162]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1163]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1164]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1165]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1166]'
  prefs: []
  type: TYPE_PRE
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1167]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1168]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1169]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1170]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1171]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1172]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1173]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1174]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1175]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1176]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1177]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1178]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1179]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1180]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: This PhysicsCategory struct defines a few different categories to which physics
    bodies can belong. The values must be of type UInt32 , a special type of unsigned
    32-bit integer SpriteKit uses for physics categories. *Unsigned* means that the
    integer has no positive or negative sign. Unsigned integers must always be zero
    or positive, never negative. A 32-bit integer is a type of integer that can hold
    a very large number. Integers may be specified as 8-bit, 16-bit, 32-bit, or 64-bit.
    In Swift, we normally don’t have to specify how many bits to use for an integer
    because the Swift type Int automates this. But since SpriteKit physics categories
    specifically require a UInt32 , we need to specify this type or we’ll get an error
    later when we assign these physics categories to our physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1181]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1182]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1183]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1184]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1185]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1186]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1187]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1188]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1189]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1190]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1191]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1192]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1193]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1194]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: We assign these PhysicsCategory values using a bitmask (0x1 << 0 ). It’s not
    necessary at this point to understand what a bitmask is. It’s enough to know that
    each physics category needs a unique bitmask number that distinguishes it from
    other categories. Each new category you add should have a value after the << that
    is 1 higher than the previous one—but all the values must be less than 32\. Now
    that we’ve defined this struct , we can put each physics body into the appropriate
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1195]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1196]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1197]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1198]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1199]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1200]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1201]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1202]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1203]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1204]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1205]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1206]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1207]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1208]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bricks, add the following code inside the spawnBrick(atPosition:) method,
    just after the line of code that sets the affectedByGravity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1209]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1210]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1211]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1212]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1213]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1214]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1215]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1216]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1217]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1218]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1219]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1220]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1221]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1222]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1223]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1224]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1225]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1226]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1227]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1228]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1229]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1230]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1231]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1232]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1233]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1234]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1235]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1236]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➊ sets the physics body’s categoryBitMask to the brick category
    we created. This tells SpriteKit what type of object this body is. Next, we set
    the physics body’s collisionBitMask to 0 ➋ . Setting one of the physics body’s
    bitmasks to 0 means it should not be assigned to any categories for that bitmask
    property. So setting the collisionBitMask to 0 tells SpriteKit that bricks shouldn’t
    collide with anything. In SpriteKit, when a physics body hits and bounces off
    another physics body, that’s called a collision. When we want something to collide
    with other physics bodies, we define collisionBitMask . But since we don’t want
    the bricks to ever bounce off anything, including the skater, we don’t want them
    to collide with anything. They should stay where they are. The collisionBitMask
    tells SpriteKit only how the current object should behave for collisions. It doesn’t
    tell *other* objects how they should behave when hitting the bricks—that’s up
    to the other objects’ physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1237]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1238]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1239]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1240]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1241]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1242]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1243]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1244]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1245]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1246]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1247]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1248]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1249]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the skater, open *Skater.swift* and add the following code inside setupPhysicsBody()
    at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1250]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1251]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1252]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1253]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1254]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1255]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1256]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1257]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1258]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1259]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1260]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1261]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1262]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1263]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1264]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1265]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1266]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1267]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1268]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1269]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1270]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1271]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1272]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1273]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1274]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1275]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1276]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1277]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1278]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1279]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1280]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1281]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1282]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1283]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1284]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1285]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1286]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1287]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1288]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: First, we set the category of the skater equal to the skater physics category
    we created ➊ . Next, we set the collisionBitMask equal to the brick category ➋
    . This tells SpriteKit that we want the skater to be affected by collisions with
    bricks—she should bounce off the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1289]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1290]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1291]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1292]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1293]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1294]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1295]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1296]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1297]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1298]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1299]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1300]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1301]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1302]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1303]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1304]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1305]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1306]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1307]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1308]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1309]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1310]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1311]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1312]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the contactTestBitMask to be both the brick and the gem categories
    ➌ . This tells SpriteKit that we want to know when the skater has contacted, or
    touched, either of these types of objects. The vertical line (| ), or pipe character,
    is a way of specifying multiple bitmask values for a property. Since we defined
    the PhysicsCategory struct using a bitmask, we can set one or more values for
    any of the physics category properties using this pipe character to separate the
    values. We could string together as many different categories as we wanted here
    using pipes. Setting the contactTestBitMask doesn’t affect how the objects behave
    in the physics simulation. It simply means we’ll be notified when these objects
    touch. We want to know when the skater touches a brick because that tells us whether
    she is on the ground. We also want to know when she touches a gem so that she
    can collect the gem and get points for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1313]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1314]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1315]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1316]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1317]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1318]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1319]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1320]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1321]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1322]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1323]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1324]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project now, you should see the skater skating along the top
    of the bricks. If you watch closely, you should also see that she dips into the
    gaps in the bricks, thanks to the physics engine. If you make the skater jump
    a bunch of times, you may even be able to get her to tip over.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1325]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1326]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1327]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1328]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1329]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1330]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1331]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1332]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1333]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1334]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1335]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1336]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**RESPONDING TO CONTACTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1337]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1338]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1339]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1340]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1341]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1342]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1343]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1344]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1345]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1346]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1347]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1348]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set the categories of the physics bodies, and set a contact bitmask
    for the skater’s physics body, we can have the physics engine tell us when the
    skater touches a brick. We’ll use this information to know when the skater sprite
    is on the ground. If she’s touching any brick objects, then she is on the ground.
    The physics engine reports contacts to us through a protocol called SKPhysicsContactDelegate
    . Let’s make our GameScene class implement this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1349]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1350]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1351]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1352]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1353]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1354]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1355]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1356]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1357]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1358]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1359]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1360]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in *GameScene.swift* , add the protocol to the class definition by typing
    a comma followed by the protocol name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1361]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1362]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1363]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1364]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1365]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1366]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1367]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1368]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1369]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1370]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1371]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1372]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1373]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1374]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1375]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1376]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1377]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1378]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1379]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1380]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1381]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1382]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1383]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1384]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1385]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1386]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1387]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1388]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1389]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1390]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1391]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1392]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1393]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1394]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1395]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1396]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to set our GameScene as the contact delegate of the physics world.
    This means that our GameScene class is where contacts will be reported. Inside
    the didMove(to:) method, add this line just below the existing line where we set
    the gravity of the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1397]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1398]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1399]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1400]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1401]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1402]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1403]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1404]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1405]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1406]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1407]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1408]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1409]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1410]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1411]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1412]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1413]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1414]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1415]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1416]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1417]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1418]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to add the method that will be called whenever two physics
    bodies come into contact with each other. SKPhysicsContactDelegate defines a method
    called didBegin(_:) to do this. Add this method inside *GameScene.swift* at the
    bottom of the GameScene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1419]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1420]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1421]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1422]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1423]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1424]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1425]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1426]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1427]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1428]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1429]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1430]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1431]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1432]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1433]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1434]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1435]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1436]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1437]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1438]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that when you start typing func didBegin ➊ , Xcode autocomplete
    suggests this method declaration. Xcode is expecting you to add this method since
    you added the SKPhysicsContactDelegate protocol to the class definition. The contact
    object passed in to this method has two physics bodies as properties called bodyA
    and bodyB . By checking the categories of the bodies ➋ , we can test if this contact
    occurred between the skater and a brick. If so, at ➌ we set the skater sprite’s
    isOnGround property to true because we know the skater is on the ground. We’ll
    add code to handle gem contacts in [Chapter 17](text00029.html#ch17) .
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1439]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1440]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1441]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1442]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1443]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1444]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1445]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1446]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1447]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**APPLYING FORCES TO PHYSICS BODIES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1448]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1449]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1450]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1451]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1452]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1453]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1454]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1455]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1456]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make objects move around, we can apply forces to them. Earlier, we used
    the example of applying an upward force to the skater to make her jump, but forces
    can be applied in any direction. Think of a force as an unseen hand pushing on
    something in our game. Forces can also be applied as a *continuous* force or as
    an *impulse* . A continuous force is one that keeps pushing on something, like
    the thrust of a rocket. An impulse is a one-time force that is applied instantaneously
    to an object, such as kicking a soccer ball. There are two different functions
    we could use on a physics body to apply an upward force: applyForce(_:) for continuous
    forces, and applyImpulse(_:) for impulses.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1457]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1458]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1459]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1460]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1461]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1462]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1463]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1464]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1465]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1466]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1467]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1468]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1469]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1470]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1471]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1472]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1473]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1474]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Before implementing the physics engine, we handled jumping by setting a velocity
    on the skater when the player tapped on the screen. But now that we have physics
    bodies, we want to make her jump by applying a one-time force. To make our skater
    jump, we’ll apply an impulse by calling applyImpulse(_:) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1475]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1476]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1477]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1478]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1479]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1480]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1481]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1482]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1483]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the existing code from the handleTap(_:) method, and add the following
    code so that the entire method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1484]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1485]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1486]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1487]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1488]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1489]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1490]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1491]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1492]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1493]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1494]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1495]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1496]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1497]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1498]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1499]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1500]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1501]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1502]'
  prefs: []
  type: TYPE_PRE
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1503]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1504]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1505]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1506]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1507]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1508]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1509]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1510]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we apply an impulse force to the skater sprite’s physics body ➊ . When
    you apply a force to a physics body, you have to supply a CGVector to determine
    how much that force pushes in the x-direction (dx ) and how much it pushes in
    the y-direction (dy ). We want this jump to go straight up, so we give it a positive
    y value only. Through trial and error, we already found a value that works—260.0
    , the second parameter. You can try other values and see how they affect the jump.
    In fact, run the game now and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1511]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1512]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1513]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1514]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1515]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1516]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1517]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1518]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are no longer setting skater.isOnGround = false in this handleTap(_:)
    method. Now that we’re using the physics engine to make the skater jump, applying
    an upward force doesn’t necessarily mean she’ll be off the ground. For example,
    what if there are bricks just above her head that block her from jumping up? Even
    though an upward force was applied, she wouldn’t leave the ground. For this reason,
    it’s not always right to set skater.isOnGround = false after applying an upward
    force to the skater sprite. Instead, we will inspect her velocity in the updateSkater()
    method to determine whether she’s on the ground. We’ll update that method in “[Ending
    the Game](text00028.html#ch16lev2sec8) ” on [page 254](text00028.html#page_254)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1519]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1520]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1521]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1522]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1523]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1524]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1525]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1526]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING AND ENDING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1527]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1528]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1529]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1530]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1531]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1532]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1533]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1534]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the SpriteKit physics engine working in our game, we can use
    it to determine when the game is over. For example, when the skater tips over,
    the game should end. But before we end the game, we need a way to start a new
    game. Currently, when you run the app, the game starts because the code we put
    into the didMove(to:) function is called. But we don’t have a way to make the
    game end and start over. We need to arrange our code so the work done in didMove(to:)
    is everything that we want to happen only once (like adding the skater sprite
    to the scene). Also, we’ll need to create a startGame() method that does the work
    that should be done at the start of every game (like moving the skater sprite
    into her starting position).
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1535]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1536]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1537]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1538]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1539]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1540]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1541]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1542]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**STARTING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1543]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1544]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1545]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1546]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1547]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1548]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1549]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1550]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this game, the skater will go faster and faster as the game goes on. But
    when the game starts over again, she needs to go back to her slower starting speed.
    So the first thing we need to do is create a class property to store her starting
    speed. Near the top of your GameScene class, next to the line where we declared
    the scrollSpeed class property, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1551]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1552]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1553]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1554]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1555]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1556]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1557]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1558]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1559]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1560]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1561]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1562]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1563]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1564]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1565]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1566]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1567]'
  prefs: []
  type: TYPE_PRE
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1568]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1569]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1570]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1571]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1572]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1573]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1574]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Now as we increase the scrollSpeed , we’ll always know what the starting speed
    should be when the game starts over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1575]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1576]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1577]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1578]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1579]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1580]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1581]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the existing resetSkater() method, add the following new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1582]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1583]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1584]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1585]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1586]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1587]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1588]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1589]'
  prefs: []
  type: TYPE_PRE
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1590]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1591]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1592]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1593]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1594]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1595]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: This method’s job is to reset the game so that everything is back to how it
    should be at the start of a new game. First, we call the method to reset the skater
    ➊ . This will move her back into the starting position. Then we reset a few class
    variables. The scrollSpeed is set to the starting speed ➋ , and the lastUpdateTime
    is set back to nil ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1596]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1597]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1598]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1599]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1600]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1601]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to remove all the brick sprites from the scene. At the end
    of a game, the bricks could be all over the place (especially later when we add
    higher bricks that the skater needs to jump to reach), so it’s best to just remove
    them all and let the updateBricks(withScrollAmount:) method take care of adding
    them back in at the right place. At ➍ , we loop through all the brick sprites
    in our bricks array and remove each one from the scene by calling removeFromParent()
    . Then we have to remove the brick sprites from the bricks array. The easiest
    way to do this is to call removeAll(_:) on the bricks array ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1602]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1603]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1604]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1605]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1606]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1607]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a startGame() method, we need to call it when the scene first
    appears. Add the following line to the end of the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1608]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1609]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1610]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1611]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1612]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1613]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1614]'
  prefs: []
  type: TYPE_PRE
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1615]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1616]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1617]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1618]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1619]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Since the startGame() method now calls resetSkater() , we no longer need to
    call it in didMove(to:) . Remove the following line from the didMove(to:) method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1620]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1621]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1622]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1623]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1624]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1625]'
  prefs: []
  type: TYPE_PRE
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1626]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1627]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1628]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1629]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your didMove(to:) method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1630]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1631]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1632]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1633]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1634]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1635]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1636]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1637]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to take care of when starting a new game is to reset
    some extra properties of the skater sprite that may have changed because of the
    physics simulation. Add the following code to the end of your resetSkater() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1638]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1639]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1640]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1641]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1642]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1643]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➊ sets the skater sprite’s zRotation back to 0.0 . The zRotation
    is how far the sprite is rotated to the right or left. Setting this to 0.0 will
    make the skater stand up straight in case she tipped over. The line at ➋ sets
    the velocity of her physics body to 0.0 . If she was jumping or falling, this
    will make her stand still again. The line at ➌ sets her angularVelocity , or rotational
    speed, back to 0.0 . It’s one thing to set the sprite’s zRotation to 0.0 so she
    appears to be standing up straight, but the physics body may still be rotating,
    so we need to zero that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1644]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1645]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING THE GAME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1646]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1647]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the game now and don’t make the skater jump at all, you should see
    that she just tips over and then slides along like that or falls down a hole,
    but nothing else happens. Let’s add some code to detect if she tipped over and
    end the game when she does. Add the following method after the existing startGame()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1648]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1649]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1650]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1651]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1652]'
  prefs: []
  type: TYPE_PRE
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1653]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game ends, we can call the gameOver() method now, and it will start
    a new game. Next, replace the entire contents of the updateSkater() method to
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1654]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1655]'
  prefs: []
  type: TYPE_PRE
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: The updateSkater() method needs to do two things. First, it needs to check if
    the skater is jumping, because she can’t jump while she’s already in the air.
    Second, it needs to see if she has tipped over or has been pushed off the screen.
    If so, then the game should be over.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the skater is on the ground, we will inspect her y velocity. In
    order to use the y velocity, we need to unwrap it, which we do at ➊ . When the
    skater is jumping or falling, her physics body will have a large velocity—it will
    be positive if she’s jumping up and negative if she’s falling down. In either
    case, she should not be allowed to jump again. So the line at ➋ checks if her
    physics body’s y velocity is either less than -100.0 or greater than 100.0 . If
    so, the skater sprite’s isOnGround property is set to false .
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: If the skater falls off the bottom of the screen, her y-position will be less
    than zero, and if she gets pushed off the left side of the screen, her x-position
    will be less than zero. The line at ➌ sets a Bool called isOffScreen to true if
    either of these conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether the skater tipped over, we need to check her sprite’s
    zRotation . If it’s greater than 85 degrees or less than -85 degrees, we’ll say
    she has tipped over, since she’d be flat on her side at 90 degrees. Using 85 degrees
    as the check instead of 90 gives a little buffer in case she hasn’t quite tipped
    all the way over but has tipped far enough that she’s not getting back up. The
    zRotation property is measured in *radians* , which are another way of measuring
    angles. Since it’s easier to think about angles in degrees, we use a math function
    to create a maxRotation constant in radians that is equal to 85 degrees ➍ . The
    line at ➎ sets a Bool called isTippedOver to true if the skater’s rotation is
    greater than 85 degrees or less than -85 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these Bool variables representing the game-over conditions,
    we simply check if either is true ➏ , and if so, we call the gameOver() function.
    That’s it! Now every update frame we’ll check if the skater has gone off the screen
    or tipped over, and the game will end if she has. Right now, ending the game will
    automatically start a new game. In [Chapter 18](text00030.html#ch18) , we’ll add
    a simple “game over” screen where the player has to tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SpriteKit’s physics engine to do some
    of the heavy lifting for game development. You did this by setting up physics
    bodies for your sprites to define how each sprite should behave in the physics
    simulation. You learned how to make sprites collide with each other, how to detect
    contact between two sprites, and how to apply a force to a sprite to make it move.
    Finally, you learned how to cleanly start and stop your game by making separate
    methods for each process.
  prefs: []
  type: TYPE_NORMAL
