- en: '**18'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ALGORITHMS**
  prefs: []
  type: TYPE_NORMAL
- en: '*And that’s really the essence of programming. By the time you’ve sorted out
    a complicated idea into little steps that even a stupidmachine can deal with,
    you’ve learned something about it yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: —Douglas Adams*, Dirk Gently’s Holistic Detective Agency
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An *algorithm* is a procedure for solving a class of problems. The stdlib and
    Boost libraries contain a multitude of algorithms that you can use in your programs.
    Because many very smart people have put a lot of time into ensuring these algorithms
    are correct and efficient, you should usually not attempt to, for example, write
    your own sorting algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Because this chapter covers almost the entire stdlib algorithm suite, it’s lengthy;
    however, the individual algorithm presentations are succinct. On first reading,
    you should skim through each section to survey the wide range of algorithms available
    to you. Don’t try to memorize them. Instead, focus on getting insight into the
    kinds of problems you can solve with them as you write code in the future. That
    way, when you need to use an algorithm, you can say, “Wait, didn’t someone already
    invent this wheel?”
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin working with the algorithms, you’ll need some grounding in
    complexity and parallelism. These two algorithmic characteristics are the main
    drivers behind how your code will perform.
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithmic Complexity**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Algorithmic complexity* describes the difficulty of a computational task.
    One way to quantify this complexity is with *Bachmann-Landau* or *“Big O” nota**tion*.
    Big O notation characterizes functions according to how computation grows with
    respect to the size of input. This notation only includes the leading term of
    the complexity function. The *leading term* is the one that grows most quickly
    as input size increases.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, an algorithm whose complexity increases by roughly a fixed amount
    for each additional input element has a Big O notation of **O(N)**, whereas an
    algorithm whose complexity doesn’t change given additional input has a Big O notation
    of **O(1)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter characterizes the stdlib’s algorithms that fall into five complexity
    classes, as outlined in the list that follows. To give you some idea of how these
    algorithms scale, each class is listed with its Big O notation and an idea of
    roughly how many additional operations would be required due to the leading term
    when input increases from 1,000 elements to 10,000 elements. Each example provides
    an operation with the given complexity class, where *N* is the number of elements
    involved in the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constant time O(1)** No additional computation. An example is determining
    the size of a `std::vector`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logarithmic time O(log *N*)** About one additional computation. An example
    is finding an element in a `std::set`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear time O(*N*)** About 9,000 additional computations. An example is summing
    all the elements in a collection.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quasilinear time O(*N* log *N*)** About 37,000 additional computations. An
    example is quicksort, a commonly used sorting algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Polynomial (or quadratic) time O(*N*²)** About 99,000,000 additional computations.
    An example is comparing all the elements in a collection with all the elements
    in another collection.'
  prefs: []
  type: TYPE_NORMAL
- en: An entire field of computer science is dedicated to classifying computational
    problems according to their difficulty, so this is an involved topic. This chapter
    mentions each algorithm’s complexity according to how the size of the target sequence
    affects the amount of required work. In practice, you should profile performance
    to determine whether an algorithm has suitable scaling properties. But these complexity
    classes can give you a sense of how expensive a particular algorithm is.
  prefs: []
  type: TYPE_NORMAL
- en: '**Execution Policies**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some algorithms, those that are commonly called *parallel algorithms*, can divide
    an algorithm so that independent entities can work on different parts of the problem
    simultaneously. Many stdlib algorithms allow you to specify parallelism with an
    *execution policy*. An execution policy indicates the allowed parallelism for
    an algorithm. From the stdlib’s perspective, an algorithm can be executed either
    *sequentially* or *in parallel*. A sequential algorithm can have only a single
    entity working on the problem at a time; a parallel algorithm can have many entities
    working in concert to resolve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, parallel algorithms can either be *vectorized* or *non-vectorized*.
    Vectorized algorithms allow entities to perform work in an unspecified order,
    even allowing a single entity to work on multiple portions of the problem simultaneously.
    For example, an algorithm that requires synchronization among entities is usually
    non-vectorizable because the same entity could attempt to acquire a lock multiple
    times, resulting in a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three execution policies exist in the `<execution>` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::execution::seq` specifies sequential (not parallel) execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::execution::par` specifies parallel execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::execution::par_unseq` specifies parallel *and* vectorized execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For those algorithms that support an execution policy, the default is `seq`,
    meaning you have to opt into parallelism and the associated performance benefits.
    Note that the C++ Standard doesn’t specify the precise meaning of these execution
    policies because different platforms handle parallelism differently. When you
    provide a non-sequential execution policy, you’re simply declaring that “this
    algorithm is safe to parallelize.”
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml#ch01)9, you’ll explore execution policies in greater
    detail. For now, just note that some algorithms permit parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The algorithm descriptions in this chapter aren’t complete. They contain enough
    information to give you a good background on many algorithms available to you
    in the Standard library. I suggest that, once you’ve identified an algorithm that
    fits your needs, you look at one of the resources in the “Further Reading” section
    at the end of this chapter. Algorithms that accept an optional execution policy
    often have different requirements when non-default policies are provided, especially
    where iterators are concerned. For example, if an algorithm normally takes an
    input iterator, using an execution policy will typically cause the algorithm to
    require forward iterators instead. Listing these differences would lengthen an
    already prodigious chapter, so the descriptions omit them.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW TO USE THIS CHAPTER**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is a quick reference that contains more than 50 algorithms. Coverage
    of each algorithm is necessarily succinct. Each algorithm begins with a terse
    description. A shorthand representation of the algorithm’s function declaration
    follows along with an explanation of each argument. The declaration depicts optional
    arguments in brackets. Next, the listing displays the algorithmic complexity.
    The listing concludes with a non-exhaustive but illustrative example that employs
    the algorithm. Almost all examples in this chapter are unit tests and implicitly
    include the following frontmatter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the relevant subsection [algorithms] for algorithm details should you
    need them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-Modifying Sequence Operations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *non-modifying sequence operation* is an algorithm that performs computation
    over a sequence but doesn’t modify the sequence in any way. You can think of these
    as `const` algorithms. Each algorithm explained in this section is in the `<algorithm>`
    header.
  prefs: []
  type: TYPE_NORMAL
- en: '***all_of***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `all_of` algorithm determines whether each element in a sequence meets some
    user-specified criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm returns `true` if the target sequence is empty or if `pred` is
    `true` for *all* elements in the sequence; otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary predicate, `pred`, that accepts an element from the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `pred` at most `distance(ipt_begin, ipt_end)`
    times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you construct the lambda predicate `starts_with_a`, which takes a single object
    called `word` ➋. If `word` is empty, `starts_with_a` returns `false` ➌; otherwise,
    it returns `true` if `word` starts with either `a` or `A` ➍. Because all of the
    `word` elements start with either `a` or `A`, `all_of` returns `true` when it
    applies `starts_with_a` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, you construct the predicate `has_length_six`, which returns
    `true` only if `word` has length six ➏. Because `alligator` doesn’t have length
    six, `all_of` returns `false` when it applies `has_length_six` to `words` ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '***any_of***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `any_of` algorithm determines whether any element in a sequence meets some
    user-specified criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm returns `false` if the target sequence is empty or if `pred` is
    `true` for *any* element in the sequence; otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary predicate, `pred`, that accepts an element from the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `pred` at most `distance(ipt_begin, ipt_end)`
    times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you construct the lambda predicate `contains_bar` that takes a single object called
    `word` ➋. If `word` contains the substring `Bar`, it returns `true`; otherwise,
    it returns `false`. Because `Barber` contains `Bar`, `any_of` returns `true` when
    it applies `contains_bar` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, you construct the predicate `is_empty`, which returns
    `true` only if a `word` is empty ➍. Because none of the words are empty, `any_of`
    returns `false` when it applies `is_empty` to `words` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***none_of***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `none_of` algorithm determines whether no element in a sequence meets some
    user-specified criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm returns `true` if the target sequence is empty or if `pred` is
    `true` for *no* element in the sequence; otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary predicate, `pred`, that accepts an element from the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `pred` at most `distance(ipt_begin, ipt_end)`
    times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you construct the lambda predicate `is_hump_day` that takes a single object called
    `word` ➋. If `word` equals `hump day`, it returns `true`; otherwise, it returns
    `false`. Because `words` doesn’t contain `hump day`, `none_of` returns `true`
    when it applies `is_hump_day` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, you construct the predicate `is_definite_article`, which
    returns `true` only if `word` is a definite article ➍. Because `the` is a definite
    article, `none_of` returns `false` when it applies `is_definite_article` to `words`
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***for_each***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `for_each` algorithm applies some user-defined function to each element
    in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm applies `fn` to each element of the target sequence. Although
    `for_each` is considered a non-modifying sequence operation, if `ipt_begin` is
    a mutable iterator, `fn` can accept a non-`const` argument. Any values that `fn`
    returns are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: If you omit `ep`, `for_each` will return `fn`. Otherwise, `for_each` returns
    `void`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary function, `fn`, that accepts an element from the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `fn` exactly `distance(ipt_begin, ipt_end)`
    times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`fn` must be movable if you omit `ep`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn` must be copyable if you provide `ep`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects called `words` ➊ and
    a counter variable `number_of_Ds` ➋, you construct the lambda predicate `count_Ds`
    that captures a reference to `number_of_Ds` ➌ and takes a single object called
    `word` ➍. If `word` is empty, you return ➎; otherwise, if the first letter of
    `word` is `D`, you increment `number_of_Ds` ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you use `for_each` to iterate over every word, passing each to `count_Ds`
    ➐. The result is that `number_of_Ds` is three ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '***for_each_n***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `for_each_n` algorithm applies some user-defined function to each element
    in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm applies `fn` to each element of the target sequence. Although
    `for_each_n` is considered a non-modifying sequence operation, if `ipt_begin`
    is a mutable iterator, `fn` can accept a non-`const` argument. Any values that
    `fn` returns are ignored. It returns `ipt_begin+n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `InputIterator` `ipt_begin` representing the target sequence’s first element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer `n` representing the desired number of iterations so that the half-open
    range representing the target sequence is `ipt_begin` to `ipt_begin+n` (`Size`
    is the templated type of `n`.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary function `fn` that accepts an element from the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `fn` exactly `n` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`fn` must be movable if you omit `ep`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn` must copyable if you provide `ep`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n` must be non-negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects called `words` ➊ and
    a counter variable `characters` ➋, you construct the lambda predicate `count_characters`
    that captures a reference to `characters` ➌ and takes a single object called `word`
    ➍. The lambda adds the length of `word` to `characters` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you use `for_each_n` to iterate over every word, passing each to `count_characters`
    ➏. The result is that `characters` is `14` ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '***find, find_if, and find_if_not***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `find`, `find_if`, and `find_if_not` algorithms find the first element in
    a sequence matching some user-defined criteria.
  prefs: []
  type: TYPE_NORMAL
- en: These algorithms return the `InputIterator` pointing to the target sequence’s
    first element matching `value` (`find`), resulting in a `true` result when invoked
    with `pred` (`find_if`), or resulting in a `false` result when invoked with `pred`
    (`find_if_not`).
  prefs: []
  type: TYPE_NORMAL
- en: If the algorithm finds no match, it returns `ipt_end`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `const` reference `value` that is equality comparable to the target sequence’s
    underlying type (`find`) or a predicate that accepts a single argument with the
    target sequence’s underlying type (`find_if` and `find_if_not`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm makes at most `distance(ipt_begin, ipt_end)` comparisons
    (`find`) or invocations of `pred` (`find_if` and `find_if_not`).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you use `find` to locate `feff` ➋, which is at the end of `words` ➌. Next, you
    construct the predicate `defends_digital_privacy`, which returns `true` if `word`
    contains the letters `eff` ➍. You then use `find_if` to locate the first string
    in `words` that contains `eff` ➎, `feffer` ➏. Finally, you use `find_if_not` to
    apply `defends_digital_privacy` to `words` ➐, which returns the first element
    `fiffer` (because it doesn’t contain `eff`) ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '***find_end***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `find_end` algorithm finds the last occurrence of a subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: If the algorithm finds no such sequence, it returns `fwd_end1`. If `find_end`
    does find a subsequence, it returns a `ForwardIterator` pointing to the first
    element of the last matching subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two pairs of `ForwardIterator`s, `fwd_begin1` / `fwd_end1` and `fwd_begin2`
    / `fwd_end2`, representing the target sequences 1 and 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary predicate `pred` to compare whether two elements are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Quadratic** The algorithm makes at most the following number of comparisons
    or invocations of `pred`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects called `words1` ➊
    and another called `words2` ➋, you invoke `find_end` to determine which element
    in `words1` begins the subsequence equal to `words2` ➌. The result is `find_``end_result1`,
    which equals the element `girl` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you construct the lambda `has_length`, which takes two arguments, `word`
    and `len`, and returns `true` if `word.length()` equals `len` ➎. You construct
    a `vector` of `size_t` objects called `sizes` ➏ and invoke `find_end` with `words1`,
    `sizes`, and `has_length` ➐. The result, `find_end_result2`, points to the first
    element in `words1` that has length `4` with the subsequent word having length
    `6`. Because `girl` has length `4` and `googoo` has length `6`, `find_end_result2`
    points to `girl` ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '***find_first***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `find_first_of` algorithm finds the first occurrence in sequence 1 equal
    to some element in sequence 2.
  prefs: []
  type: TYPE_NORMAL
- en: If you provide `pred`, the algorithm finds the first occurrence i in sequence
    1 where, for some `j` in sequence 2, `pred (`i, j`)` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: If `find_first_of` finds no such sequence, it returns `ipt_end1`. If `find_first_of`
    does find a subsequence, it returns an `InputIterator` pointing to the first element
    of the first matching subsequence. (Note that if `ipt_begin1` is also a `ForwardIterator`,
    `find_first_of` instead returns a `ForwardIterator`.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin1` / `ipt_end1`, representing the
    target sequence 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin2` / `fwd_end2`, representing the target
    sequence 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary predicate, `pred`, to compare whether two elements are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Quadratic** The algorithm makes at most the following number of comparisons
    or invocations of `pred`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects called `words` ➊ and
    another called `indefinite_articles` ➋, you invoke `find_first_of` to determine
    which element in `words` begins the subsequence equal to `indefinite_articles`
    ➌. The result is `find_first_of_result`, which equals the element `a` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '***adjacent_find***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `adjacent_find` algorithm finds the first repeat in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm finds the first occurrence in the target sequence where two adjacent
    elements are equal or where, if you provide `pred`, the algorithm finds the first
    occurrence element i in the sequence where `pred (`i, i`+1)` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: If `adjacent_find` finds no such element, it returns `fwd_end`. If `adjacent_find`
    does find such an element, it returns a `ForwardIterator` pointing to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` / `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary predicate `pred` to compare whether two elements are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** When no execution policy is given, the algorithm makes at most the
    following number of comparisons or invocations of `pred`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: where i is the index of the return value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you construct a lambda called `first_letters_match`, which takes two words and
    evaluates whether they start with the first letter ➋. You invoke `adjacent_find`
    to determine which element has the same first letter as the subsequent letter
    ➌. The result, `adjacent_find_result` ➍, equals `is` because it shares a first
    letter with `itchy` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '***count***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `count` algorithm counts the elements in a sequence matching some user-defined
    criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm returns the number of elements `i` in the target sequence where
    `pred` `(`i`)` is `true` or where `value ==` i. Usually, `DifferenceType` is `size_t`,
    but it depends on the implementation of `InputIterator`. You use `count` when
    you want to count the occurrences of a particular value, and you use `count_if`
    when you have a more complicated predicate you want to use for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` / `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either a `value` or a unary predicate `pred` to evaluate whether an element
    `x` in the target sequence should be counted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** When no execution policy is given, the algorithm makes `distance
    (ipt_begin, ipt_end)` comparisons or invocations of `pred`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you use it to invoke `count` with the value `and` ➋. This returns `1`, because
    a single element equals `and` ➌. Next, you construct a lambda called `contains_a`,
    which takes a word and evaluates whether it contains `a` ➍. You invoke `count_if`
    to determine how many words contain `a` ➎. The result equals `3` because three
    elements contain `a` ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '***mismatch***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `mismatch` algorithm finds the first mismatch in two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm finds the first mismatched element pair `i`, `j` from sequence
    1 and sequence 2\. Specifically, it finds the first index n such that i `= (ipt_begin1
    +` n`)`; j `= (ipt_begin2 +` n`)`; and i `!=` j or `pred(`i`,` j`)` `== false`.
  prefs: []
  type: TYPE_NORMAL
- en: The types of the iterators in the returned `pair` equal the types of `ipt_begin1`
    and `ipt_begin2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two pairs of `InputIterator`s, `ipt_begin1` / `ipt_end1` and `ipt_begin2` /
    `ipt_end2`, representing the target sequences `1` and `2`. If you don’t provide
    `ipt_``end2`, sequence 1’s length implies sequence 2’s length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary predicate `pred` to compare whether two elements are equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** When no execution policy is given, at worst the algorithm makes
    the following number of comparisons or invocations of `pred`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After constructing two `vector`s of `string`s called `words1` ➊ and `words2`
    ➋, you use them as the target sequences for `mismatch` ➌. This returns a `pair`
    pointing to the elements `Kangaroo` and `bandicoot` ➍ ➎. Next, you construct a
    lambda called `second_letter_matches`, which takes two words and evaluates whether
    their second letters match ➏. You invoke `mismatch` to determine the first pair
    of elements with mismatched second letters ➐. The result is the pair `Kick` ➑
    and `roundhouse` ➒.
  prefs: []
  type: TYPE_NORMAL
- en: '***equal***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `equal` algorithm determines whether two sequences are equal.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm determines whether sequence 1’s elements equal sequence 2’s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two pairs of `InputIterator`s, `ipt_begin1` / `ipt_end1` and `ipt_begin2` /
    `ipt_end2`, representing the target sequences `1` and `2`. If you don’t provide
    `ipt_end2`, sequence 1’s length implies sequence 2’s length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary predicate `pred` to compare whether two elements are equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** When no execution policy is given, at worst the algorithm makes
    the following number of comparisons or invocations of `pred`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After constructing two `vector`s of `string`s called `words1` and `words2` ➊
    ➋, you use them as the target sequences for `equal` ➌. Because their last elements,
    `lick` and `kick`, aren’t equal, `equal_result1` is `false` ➍. After setting the
    third element of `words2` to the third element of `words1` ➎, you again invoke
    `equal` with the same arguments ➏. Because the sequences are now identical, `equal_result2`
    is `true` ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '***is_permutation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `is_permutation` algorithm determines whether two sequences are permutations,
    meaning they contain the same elements but potentially in a different order.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm determines whether some permutation of sequence 2 exists such
    that sequence 1’s elements equal the permutation’s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two pairs of `ForwardIterator`s, `fwd_begin1` / `fwd_end1` and `fwd_begin2`
    / `fwd_end2`, representing the target sequences 1 and 2\. If you don’t provide
    `fwd_end2`, sequence 1’s length implies sequence 2’s length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary predicate `pred` to compare whether two elements are equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Quadratic** When no execution policy is given, at worst the algorithm makes
    the following number of comparisons or invocations of `pred`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After constructing two `vector`s of `string`s called `words1` and `words2` ➊
    ➋, you use them as the target sequences for `is_permutation` ➌. Because `words2`
    is a permutation of `words1`, `is_permutation` returns `true` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The <algorithm> header also contains next_permutation and prev_permutation
    for manipulating a range of elements so you can generate permutations. See [alg.permutation.generators].*'
  prefs: []
  type: TYPE_NORMAL
- en: '***search***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `search` algorithm locates a subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm locates sequence 2 within sequence 1\. In other words, it returns
    the first iterator i in sequence 1 such that for each non-negative integer `n`,
    `*(i + n)` equals `*(ipt_begin2 + n)`, or if you provide a predicate `pred(*(i
    + n)`, `*(ipt_begin2 + n))` is `true`. The `search` algorithm returns `ipt_begin1`
    if sequence 2 is empty or `ipt_begin2` if no subsequence is found. This is different
    from `find` because it locates a subsequence rather than a single element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two pairs of `ForwardIterator`s, `fwd_begin1` / `fwd_end1` and `fwd_begin2`
    / `fwd_end2`, representing the target sequences 1 and 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary predicate `pred` to compare whether two elements are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Quadratic** When no execution policy is given, at worst the algorithm makes
    the following number of comparisons or invocations of `pred`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After constructing two `vector`s of `string`s called `words1` ➊ and `words2`
    ➋, you use them as the target sequences for `search` ➌. Because `words2` is a
    subsequence of `words1`, `search` returns an iterator pointing to `and` ➍. The
    `vector` containing `string` objects `words3` ➎ contains the word `nightpant`
    instead of `nightshirt`, so invoking `search` with it instead of `words2` ➏ yields
    the end iterator of `words1` ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '***search_n***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `search_n` algorithm locates a subsequence containing identical, consecutive
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm searches for `count` consecutive `values` in the sequence and
    returns an iterator pointing to the first `value`, or it returns `fwd_end` if
    no such subsequence is found. This is different from `adjacent_find` because it
    locates a subsequence rather than a single element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::``seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` / `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integral `count` value representing the number of consecutive matches you
    want to find
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `value` representing the element you want to find
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary predicate `pred` to compare whether two elements are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** When no execution policy is given, at worst the algorithm makes
    `distance(fwd_begin, fwd_end)` comparisons or invocations of `pred`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` of `string`s called `words` ➊, you use it as the
    target sequence for `search_n` ➋. Because `words` contains three instances of
    the word `owl`, it returns an iterator pointing to the first instance ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutating Sequence Operations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *mutating sequence operation* is an algorithm that performs computation over
    a sequence and is allowed to modify the sequence in some way. Each algorithm explained
    in this section is in the `<algorithm>` header.
  prefs: []
  type: TYPE_NORMAL
- en: '***copy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `copy` algorithm copies one sequence into another.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm copies the target sequence into `result` and returns the receiving
    sequence’s end iterator. It’s your responsibility to ensure that `result` represents
    a sequence with enough space to store the target sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OutputIterator`, `result`, that receives the copied sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm copies elements from the target sequence exactly `distance(ipt_begin,
    ipt_end)` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sequences 1 and 2 must not overlap unless the operation is a *copy to the left*.
    For example, for a vector `v` with 10 elements, `std::copy(v.begin()+3, v.end(),
    v.begin())` is well defined, but `std::copy(v.begin(), v.begin()+7, v.begin()+3)`
    is not.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Recall the back_inserter in “Insert Iterators” on [page 464](ch14.xhtml#page_464),
    which returns an output iterator that converts write operations into insert operations
    on the underlying container.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After constructing two `vector`s of `string` objects ➊ ➋, you invoke `copy`
    with `words1` as the sequence to `copy` ➌ and `words2` as the destination sequence
    ➍. The result is that `words2` contains the contents of `words1` appended to the
    original contents ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***copy_n***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `copy_n` algorithm copies one sequence into another.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm copies the target sequence into `result` and returns the receiving
    sequence’s end iterator. It’s your responsibility to ensure that `result` represents
    a sequence with enough space to store the target sequence and that `n` represents
    the correct length of the target sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A begin iterator, `ipt_begin`, representing the beginning of the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of the target sequence, `n`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OutputIterator result` that receives the copied sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm copies elements from the target sequence exactly `distance(ipt_begin,
    ipt_end)` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sequences 1 and 2 must not contain the same objects unless the operation is
    a *copy to the left*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: After constructing two `vector`s of `string` objects ➊➋, you invoke `copy_n`
    with `words1` as the sequence to `copy_n` ➌ and `words2` as the destination sequence
    ➍. The result is that `words2` contains the contents of `words1` appended to the
    original contents ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***copy_backward***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `copy_backward` algorithm copies the reverse of one sequence into another.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm copies sequence 1 into sequence 2 and returns the receiving sequence’s
    end iterator. Elements copy backward but will appear in the target sequence in
    the original order. It’s your responsibility to ensure that sequence 1 represents
    a sequence with enough space to store sequence 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin1` and `ipt_end1`, representing
    sequence 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `InputIterator`, `ipt_end2`, representing 1 past the end of sequence 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm copies elements from the target sequence exactly `distance(ipt_begin1,
    ipt_end1)` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sequences 1 and 2 must not overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: After constructing two `vector`s of `string`s ➊ ➋, you invoke `copy_backward`
    with `words2` as the sequence to copy ➌ and `words1` as the destination sequence
    ➍. The result is that the contents of `word2` replace the last three words of
    `words1` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***move***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `move` algorithm moves one sequence into another.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm moves the target sequence and returns the receiving sequence’s
    end iterator. It’s your responsibility to ensure that the target sequence represents
    a sequence with at least as many elements as the source sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `InputIterator`, `result`, representing the beginning of the sequence to
    move into
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm moves elements from the target sequence exactly `distance(ipt_begin,
    ipt_end)` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sequences must not overlap unless *moving to the left*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types must be moveable but not necessarily copyable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: First, you declare the `MoveDetector`’s class ➊, which defines a default constructor
    setting its only member `owner` to `true` ➋. It deletes the copy and move constructor
    and the copy assignment operator but defines a move assignment operator that swaps
    `owner` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: After constructing two `vector`s of `MoveDetector` objects ➍ ➎, you invoke `move`
    with `detectors1` as the sequence to `move` and `detectors2` as the destination
    sequence ➏. The result is that the elements of `detector1` are in a *moved from*
    state ➐➑ and the elements of `detector2` are moved into `detectors2` ➒➓.
  prefs: []
  type: TYPE_NORMAL
- en: '***move_backward***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `move_backward` algorithm moves the reverse of one sequence into another.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm moves sequence 1 into sequence 2 and returns an iterator pointing
    to the last moved element. Elements move backward but will appear in the target
    sequence in the original order. It’s your responsibility to ensure that the target
    sequence represents a sequence with at least as many elements as the source sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `InputIterator`, `result`, representing the sequence to move into
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm moves elements from the target sequence exactly `distance(ipt_begin,
    ipt_end)` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sequences must not overlap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types must be moveable but not necessarily copyable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, you declare the `MoveDetector` class ➊ (see “`move`” back on [page 595](ch18.xhtml#page_595)
    for the implementation).
  prefs: []
  type: TYPE_NORMAL
- en: After constructing two `vector`s of `MoveDetector` objects ➋ ➌, you invoke `move`
    with `detectors1` as the sequence to `move` and `detectors2` as the destination
    sequence ➍. The result is that the elements of `detector1` are in a *moved from*
    state ➎➏ and the elements of `detector2` are *moved into* ➐➑.
  prefs: []
  type: TYPE_NORMAL
- en: '***swap_ranges***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `swap_ranges` algorithm exchanges elements from one sequence into another.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm calls `swap` on each element of sequence 1 and sequence 2, and
    it returns the receiving sequence’s end iterator. It’s your responsibility to
    ensure that the target sequence represents a sequence with at least as many elements
    as the source sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `ipt_begin1` and `ipt_end1`, representing sequence
    1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ForwardIterator`, `ipt_begin2`, representing the beginning of sequence 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm calls `swap` exactly `distance(ipt_begin1, ipt_end1)`
    times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements contained in each sequence must be swappable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After constructing two `vector`s of `string`s ➊ ➋, you invoke `swap` with `words1`
    and `words2` as the sequences to swap ➌. The result is that `words1` and `words2`
    swap contents ➍ ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***transform***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `transform` algorithm modifies the elements of one sequence and writes them
    into another.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm invokes `unary_op` on each element of the target sequence and
    outputs it into the output sequence, or it invokes `binary_op` on corresponding
    elements of each target sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin1` and `ipt_end1`, representing
    the target sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional `InputIterator`, `ipt_begin2`, representing a second target sequence.
    You must ensure that this second target sequence has at least as many elements
    as the first target sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OutputIterator`, `result`, representing the beginning of the output sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary operation, `unary_op`, that transforms elements of the target sequence
    into elements of the output sequence. If you supply two target sequences, you
    instead provide a binary operation, `binary_op`, which accepts an element from
    each target sequence and transforms each into an element of the output sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `unary_op` or `binary_op` exactly `distance(ipt_begin1,
    ipt_end1)` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: After constructing a `vector` containing `string` objects ➊, you construct a
    lambda called `upper`, which takes a `string` by value and converts it to uppercase
    using the Boost `to_upper` algorithm discussed in [Chapter 15](ch15.xhtml#ch15)
    ➋. You invoke transform with `words1` as the target sequence, a `back_inserter`
    for an empty `results1` vector, and `upper` as the unary operation ➌. After `transform`,
    `results1` contains the uppercase version of `words1` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, you construct two `vector`s of `string` objects ➎➏. You
    also construct a lambda called `portmantize` that accepts two `string` objects
    ➐. The lambda returns a new `string` containing up to two letters from the beginning
    of the first argument and up to three letters from the end of the second argument.
    You pass the two target sequences, a `back_inserter` to an empty `vector` called
    `results2` and `portmantize` ➑. The `result2` contains portmanteaus of the contents
    of `words1` and `words2` ➒.
  prefs: []
  type: TYPE_NORMAL
- en: '***replace***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `replace` algorithm replaces certain elements of a sequence with some new
    element.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm searches for target sequence elements x for which either x `==
    old_ref` or `pred(`x`) == true` and assigns them to `new_ref`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OutputIterator`, `result`, representing the beginning of the output sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `old` `const` reference representing the element to find
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary predicate, `pred`, that determines whether an element meets the criteria
    for replacement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `new_ref` `const` reference that represents the element to replace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `pred` exactly `distance(fwd_begin, fwd_end)`
    times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements contained in each sequence must be comparable to `old_ref` and
    assignable to `new_ref`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You first bring in the `std::literals` namespace ➊ so you can employ the `string_view`
    literal later on. After constructing a `vector` containing `string` objects ➋,
    you invoke `replace` with the `vector` ➌ to replace all instances of `try` with
    `spoon` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, you construct two `vector`s of `string` objects ➎➏ and
    a lambda called `has_two_os`, which accepts a string and returns `true` if it
    contains exactly two `o`s ➐. You then pass `words2` as the target sequence and
    `words3` as the destination sequence to `replace_copy_if`, which applies `has_two_os`
    to each element of `words2` and replaces elements that evaluate to `true` with
    `try` ➑. The result is that `words2` is unaffected and `words3` has the element
    `spoon` replaced with `try` ➒.
  prefs: []
  type: TYPE_NORMAL
- en: '***fill***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `fill` algorithm fills a sequence with some value.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm writes a value into each element of the target sequence. The `fill_n`
    function returns `opt_begin+n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ForwardIterator`, `fwd_begin`, representing the target sequence’s beginning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ForwardIterator`, `fwd_end`, representing one past the sequence’s end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Size n` representing the number of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `value` to write into each element of the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm assigns `value` exactly `distance(fwd_begin, fwd_end)`
    or `n` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `value` parameter must be writable into the sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects of type `Size` must be convertible into an integral type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You first initialize a `vector` containing `string` objects containing six empty
    elements ➊. Next, you invoke `fill` using this `vector` as the target sequence
    and `police` as the value ➋. The result is that your `vector` contains six `police`
    ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example, you initialize an empty `vector` containing `string`
    objects ➍. You then invoke `fill_n` with a `back_inserter` pointing to the empty
    vector, a length of 6, and `police` as the value ➎. The result is the same as
    before: your `vector` contains six `police` ➏.'
  prefs: []
  type: TYPE_NORMAL
- en: '***generate***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `generate` algorithm fills a sequence by invoking a function object.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm invokes `generator` and assigns the result into the target sequence.
    The `generate_n` function returns `opt_begin+n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ForwardIterator`, `fwd_begin`, representing the target sequence’s beginning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ForwardIterator`, `fwd_end`, representing 1 past the sequence’s end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Size n` representing the number of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `generator` that, when invoked with no arguments, produces an element to write
    into the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `generator` exactly `distance(fwd_begin, fwd_end)`
    or `n` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `value` parameter must be writable into the sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects of type `Size` must be convertible into an integral type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You first initialize an `int` called `i` to 1 ➊. Next, you create a lambda called
    `pow_of_2`, which takes `i` by reference ➋. Each time you invoke `pow_of_2`, it
    doubles `i` and returns its value just before the doubling. Next, you initialize
    a `vector` of `int` objects with six elements ➌. You then invoke `generate` with
    the `vector` as the target sequence and `pow_of_2` as the generator ➍. The result
    is that the `vector` contains the first six powers of two ➎.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, you initialize an empty `vector` of `int` objects ➏.
    Next, you invoke `generate_n` using a `back_inserter` to your empty `vector`,
    a size of 6, and `pow_of_2` as your generator ➐. The `result` is the next six
    powers of two ➑. Notice that `pow_of_2` has state because it captures `i` by reference.
  prefs: []
  type: TYPE_NORMAL
- en: '***remove***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `remove` algorithm removes certain elements from a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm moves all elements where `pred` evaluates to `true` or where the
    element equals `value` in such a way that the remaining elements’ order is preserved,
    and it returns an iterator pointing to the first moved element. This iterator
    is called the resulting sequence’s *logical end*. The sequence’s physical size
    remains unchanged, and a call to `remove` is typically followed by a call to a
    container’s `erase` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OutputIterator`, `result`, representing the destination sequence (if copying)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `value` representing the element to remove
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unary predicate, `pred`, that determines whether an element meets the criteria
    for removal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `pred` or compares with `value` exactly `distance(fwd_begin,
    fwd_end)` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements of the target sequence must be moveable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If copying, the elements must be copyable, and the target and destination sequences
    must not overlap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You first create a lambda called `is_vowel` that returns `true` if the given
    `char` is a vowel ➊. Next, you construct a `string` called `pilgrim` containing
    a sentence ➋. You then invoke `remove_if` with `pilgrim` as the target sentence
    and `is_vowel` as the predicate ➌. This eliminates all the vowels in the sentence
    by shifting the remaining characters to the left each time `remove_if` encounters
    a vowel. The result is that `pilgrim` contains the original sentence with vowels
    removed plus the phrase `present, and the future.` ➍. This phrase contains 24
    characters, which is exactly the number of vowels that `remove_if` removed from
    the original sentence. The phrase `present, and the future.` is the detritus from
    shifting the remaining string during removal.
  prefs: []
  type: TYPE_NORMAL
- en: To eliminate these leftovers, you save the iterator `new_end`, which `remove_if`
    returns. This points to 1 past the last character in the new target sequence,
    the `p` in `present, and the future.` To eliminate, you simply use the `erase`
    method on `pilgrim`, which has an overload that accepts a half-open range. You
    pass the logical end returned by `remove_if`, `new_end`, as the begin iterator.
    You also pass `pilgrim.end()` as the end iterator ➎. The result is that `pilgrim`
    is now equal to the original sentence with vowels removed ➏.
  prefs: []
  type: TYPE_NORMAL
- en: This combination of `remove` (or `remove_if`) and the `erase` method, which
    is called the *erase-remove idiom*, is widely used.
  prefs: []
  type: TYPE_NORMAL
- en: '***unique***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `unique` algorithm removes redundant elements from a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm moves all repeat elements where `pred` evaluates to `true` or
    where the elements are equal such that the remaining elements are unique from
    their neighbors and original ordering is preserved. It returns an iterator pointing
    to the new logical end. As with `std::remove`, the physical storage doesn’t change.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OutputIterator`, `result`, representing the destination sequence (if copying)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A binary predicate, `pred`, that determines whether two elements are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `pred` exactly `distance(fwd_begin, fwd_end)
    - 1` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements of the target sequence must be moveable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If copying, elements of the target sequence must by copyable, and the target
    and destination ranges cannot overlap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You first construct a `string` containing a word with multiple repeated characters
    ➊. You then invoke `unique` with the `string` as the target sequence ➋. This returns
    the logical end, which you assign to `new_end`. Next, you erase the range beginning
    with `new_end` and ending with `without_walls.end()` ➌. This is a corollary to
    the erase-remove idiom: you’re left with the contents `Wales`, which contains
    consecutively unique characters ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: '***reverse***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `reverse` algorithm reverses the order of a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm reverses a sequence by either swapping its elements or copying
    them into a target sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `BidirectionalIterator`s, `bi_begin` and `bi_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OutputIterator`, `result`, representing the destination sequence (if copying)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm invokes `swap` exactly `distance(bi_begin, bi_end)/2`
    times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements of the target sequence must be swappable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If copying, elements of the target sequence must by copyable, and the target
    and destination ranges cannot overlap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a `string` containing the word `diaper` ➊. Next, you invoke
    reverse with this `string` as the target sequence ➋. The result is the word `repaid`
    ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '***sample***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `sample` algorithm generates random, stable subsequences.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm samples `min(pop_end - pop_begin, n)` elements from the population
    sequence. Somewhat unintuitively, the sample will be sorted if and only if `ipt_begin`
    is a forward iterator. It returns the resulting destination sequence’s end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    population sequence (the sequence to sample from)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `OutputIterator`, `result`, representing the destination sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Distance` `n` representing the number of elements to sample
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `UniformRandomBitGenerator` `urb_generator`, such as the Mersenne Twister
    `std::mt19937_64` introduced in [Chapter 12](ch12.xhtml#ch12)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm’s complexity scales with `distance(ipt_begin, ipt_end)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a `const string` called `population` containing the letters
    `ABCD` ➊. You also initialize a `const size_t` called `n_samples` equal to a million
    ➋ and a Mersenne Twister called `urbg` ➌. All of these objects have static storage
    duration.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you initialize the function `sample_length`, which takes a single
    `size_t` argument called `n` ➍. Within the function, you construct a `map` of
    `string` to `size_t` objects ➎ that will count the frequency of each `sample`
    invocation. Within a `for` loop, you invoke `sample` with `population` as the
    population sequence, a `back_inserter` to a `result` string as the destination
    sequence, `n` as the sample length, and `urbg` as the random bit generator ➏.
  prefs: []
  type: TYPE_NORMAL
- en: After a million iterations, you iterate over each element of `counts` ➐ and
    print the probability distribution of each sample for the given length `n` ➑.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you configure floating-point formatting with `fixed` and `setprecision`
    ➒. Finally, you invoke `sample_length` with each value from `0` to `4` inclusive
    ➓.
  prefs: []
  type: TYPE_NORMAL
- en: Because `string` provides random access iterators, `sample` provides *stable*
    (sorted) samples.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that the output doesn’t contain any unsorted samples like DC or CAB.
    This sorting behavior isn’t necessarily obvious from the algorithm’s name, so
    be careful!*'
  prefs: []
  type: TYPE_NORMAL
- en: '***shuffle***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `shuffle` algorithm generates random permutations.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm randomizes the target sequence such that each possible permutation
    of those elements has equal probability of appearance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pair of `RandomAccessIterator`s, `rnd_begin` and `rnd_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `UniformRandomBitGenerator` `urb_generator`, such as the Mersenne Twister
    `std::mt19937_64` introduced in [Chapter 12](ch12.xhtml#ch12)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm swaps exactly `distance(rnd_begin, rnd_end) - 1` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements of the target sequence must be swappable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a `const string` called `population` containing the letters
    `ABCD` ➊. You also initialize a `const size_t` called `n_samples` equal to a million
    ➋, a Mersenne Twister called `urbg` ➌, and a `map` of `string` to `size_t` objects
    ➍ that will count the frequencies of each `shuffle` sample. In addition, you configure
    floating-point formatting with `fixed` and `setprecision` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Within a `for` loop, you copy `population` into a new string called `sample`
    because `shuffle` modifies the target sequence ➏. You then invoke `shuffle` with
    `result` as the target sequence and `urbg` as the random bit generator ➐, and
    you record the result within `samples` ➑.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you iterate over each element in `samples` ➒ and print the probability
    distribution of each sample ➓.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, unlike with `sample`, `shuffle` always produces an *unordered*
    distribution of elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting and Related Operations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *sorting operation* is an algorithm that reorders a sequence in some desired
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each sorting algorithm has two versions: one that takes a function object called
    a *comparison operator* and one that uses `operator<`. A comparison operator is
    a function object that is invokable with two objects to compare. It returns `true`
    if the first argument is *less than* the second argument; otherwise, it returns
    `false`. The sort interpretation of `x < y` is that `x` is sorted before `y`.
    All the algorithms explained in this section are in the `<algorithm>` header.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that operator< is a valid comparison operator.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparison operators must be transitive. This means that for any elements `a`,
    `b`, and `c` the comparison operator `comp` must preserve the following relationship:
    if `comp(a, b)` and `comp(b, c)`, then `comp(a, c)`. This should make sense: if
    `a` is ordered before `b` and `b` is ordered before `c`, then `a` must be ordered
    before `c`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***sort***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `sort` algorithm sorts a sequence (unstably).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A stable sort retains the relative, pre-sort ordering of equal elements, whereas
    an unstable sort might reorder them.*'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm sorts the target sequence in place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `RandomAccessIterator`s, `rnd_begin` and `rnd_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison operator, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Quasilinear** O(N log N) where N = `distance(rnd_begin, rnd_end)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements of the target sequence must be swappable, move constructible, and
    move assignable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a `string` containing the word `spoilage` ➊. Next, you invoke
    `sort` with this `string` as the target sequence ➋. The result is that `goat_``grass`
    now contains the word `aegilops` (a genus of invasive weeds) ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '***stable_sort***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `stable_sort` algorithm sorts a sequence stably.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm sorts the target sequence in place. Equal elements retain their
    original ordering.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `RandomAccessIterator`s, `rnd_begin` and `rnd_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison operator, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Polylog-linear** O(N log² N) where N = `distance(rnd_begin, rnd_end)`. If
    additional memory is available, complexity reduces to quasilinear.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements of the target sequence must be swappable, move constructible, and
    move assignable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This example sorts a `string` using the *ascenders* and *descenders*. In typography,
    an ascender is a letter with a portion that extends above what is known as the
    mean line of a font. A descender is a letter with a portion that extends below
    what is known as the baseline. Letters commonly typed with descenders are *g*,
    *j*, *p*, *q*, and *y*. Letters commonly typed with ascenders are *b*, *d*, *f*,
    *h*, *k*, *l*, and *t*. This example seeks a `stable_sort` so that all letters
    with ascenders appear before all other letters and letters with descenders appear
    after all other letters. Letters with neither an ascender nor a descender lie
    in the middle. As a `stable_sort`, the relative ordering of letters with common
    ascender/descender categorization must not change.
  prefs: []
  type: TYPE_NORMAL
- en: 'You first define an `enum class` called `CharCategory` that takes on three
    possible values: `Ascender`, `Normal`, or `Descender` ➊. Next, you define a function
    that categorizes a given char into a `CharCategory` ➋. (Recall from “Switch Statements”
    on [page 50](ch02.xhtml#page_50) that labels “fall through” if you don’t include
    a `break`.) You also define an `ascension_compare` function that converts two
    given `char` objects into `CharCategory` objects and compares them with `operator<`
    ➌. Because `enum class` objects convert implicitly to `int` objects and because
    you define `CharCategory` with its values in the intended order, this will sort
    letters with ascenders ahead of normal letters ahead of letters with descenders.'
  prefs: []
  type: TYPE_NORMAL
- en: Within the test case, you initialize a `string` containing the word `outgrin`
    ➍. Next, you invoke `stable_sort` with this `string` as the target sequence and
    `ascension_compare` as the comparison operator ➎. The result is that `word` now
    contains `touring` ➏. Notice that `t`, the only ascender, appears before all the
    normal characters (which are in the same order as in `outgrin`), which appear
    before `g`, the only descender.
  prefs: []
  type: TYPE_NORMAL
- en: '***partial_sort***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `partial_sort` algorithm sorts a sequence into two groups.
  prefs: []
  type: TYPE_NORMAL
- en: If modifying, the algorithm sorts the first `(rnd_middle – rnd_first)` elements
    in the target sequence so all elements in `rnd_begin` to `rnd_middle` are less
    than the rest of the elements. If copying, the algorithm places the first `min(distance(ipt_begin,
    ipt_end), distance(rnd_begin, rnd_end))` sorted elements into the destination
    sequence, and it returns an iterator pointing to the end of the destination sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, a partial sort allows you to find the first few elements of a sorted
    sequence without having to sort the entire sequence. For example, if you had the
    sequence D C B A, you could partial sort the first two elements and obtain the
    result A B D C. The first two elements are the same as if you’d sorted the entire
    sequence, but the remaining elements aren’t.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If modifying, a trio of `RandomAccessIterator`s, `rnd_begin`, `rnd_middle`,
    and `rnd_end`, representing the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If copying, a pair `ipt_begin` and `ipt_end` representing the target sequence
    and a pair `rnd_begin` and `rnd_end` representing the destination sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison operator, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Quasilinear** O(N log N) where N = `distance(rnd_begin, rnd_end) * log(distance(rnd_begin,
    rnd_middle)` or `distance(rnd_begin, rnd_end) * log(min(distance(rnd_begin, rnd_end),
    distance(ipt_begin, ipt_end))` for the copy variant'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements of the target sequence must be swappable, move constructible, and
    move assignable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You first initialize a `string` containing the word `nectarous` ➊. Next, you
    invoke `partial_sort` with this `string` as the target sequence and the fifth
    letter (`a`) as the second argument to `partial_sort` ➋. The result is that the
    sequence now contains the word `acentrous` ➌. Notice that the first four letters
    of `acentrous` are sorted and that they’re less than the remaining characters
    in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, you initialize a `string` containing the word `pretanning`
    ➍, which you use as the target sequence for `partial_sort` ➎. In this example,
    you specify the fourth character (`t`) as the second argument to `partial_sort`,
    and you use the `ascension_compare` function from the `stable_sort` example as
    the comparison operator. The result is that the sequence now contains the word
    `trepanning` ➏. Notice that the first three letters are sorted according to `ascension_compare`
    and none of the remaining characters in the second argument to `partial_sort`
    to `z` is less than the first three characters.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Technically, the REQUIRE statements in the preceding example might fail on
    some standard library implementations. Because std::partial_sort isn’t guaranteed
    to be stable, results may vary.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***is_sorted***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `is_sorted` algorithm determines whether a sequence is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm returns true if the target sequence is sorted according to `operator<`
    or `comp`, if given. The `is_sorted_until` algorithm returns an iterator pointing
    to the first unsorted element or `rnd_end` if the target sequence is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `RandomAccessIterator`s, `rnd_begin` and `rnd_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison operator, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm compares `distance(rnd_begin, rnd_end)` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a `string` containing the word `billowy` ➊. Next, you invoke
    `is_sort` with this `string` as the target sequence, which returns `true` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, you construct a `string` containing the word `floppy`
    ➌. You then invoke `is_sorted_until` with this `string` as the target sequence,
    which returns `rnd_end` because the sequence is sorted ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '***nth_element***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `nth_element` algorithm places a particular element in a sequence into its
    correct sorted position.
  prefs: []
  type: TYPE_NORMAL
- en: 'This partial sorting algorithm modifies the target sequence in the following
    way: the element in the position pointed to by `rnd_nth` is in that position as
    if the whole range were sorted. All elements from `rnd_begin` to `rnd_nth-1` will
    be less than `rnd_nth`. If `rnd_nth == rnd_end`, the function performs no operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::``seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trio of `RandomAccessIterator`s, `rnd_begin`, `rnd_nth`, and `rnd_end`, representing
    the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison operator, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** The algorithm compares `distance(rnd_begin, rnd_end)` times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements of the target sequence must be swappable, move constructible, and
    move assignable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a `vector` of `int` objects containing the number sequence
    1 to 10 inclusive ➊. Next, you invoke `nth_element` with this `vector` as the
    target sequence ➋. You then initialize a lambda named `less_than_6th_elem`, which
    compares an `int` with the sixth element of `numbers` with `operator<` ➌. This
    allows you to check that all elements before the sixth element are less than the
    sixth element ➍. The sixth element is 6 ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary Search**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Binary search algorithms* assume that a target sequence is already sorted.
    These algorithms have desirable complexity characteristics compared with generic
    search over an unspecified sequence. Each algorithm explained in this section
    is in the `<algorithm>` header.'
  prefs: []
  type: TYPE_NORMAL
- en: '***lower_bound***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `lower_bound` algorithm finds a partition in a sorted sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm returns an iterator corresponding to the element `result`, which
    partitions the sequence so the elements before `result` are less than `value`,
    whereas `result` and all elements after it aren’t less than `value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `value` to partition the target sequence with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison operator, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Logarithmic** If you provide a random iterator, `O(log N)` where `N = distance
    (fwd_begin, fwd_end`); otherwise, `O(N)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The target sequence must be sorted according to `operator<` or `comp` if provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a `vector` of `int` objects ➊. Next, you invoke `lower_bound`
    with this `vector` as the target sequence and a `value` of `5` ➋. The result is
    the third element, `5` ➌. The elements `2` and `4` are less than `5`, whereas
    the elements `5`, `6`, `6`, and `9` are not.
  prefs: []
  type: TYPE_NORMAL
- en: '***upper_bound***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `upper_bound` algorithm finds a partition in a sorted sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm returns an iterator corresponding to the element `result`, which
    is the first element in the target sequence greater than `value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `value` to partition the target sequence with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison operator, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Logarithmic** If you provide a random iterator, `O(log N)` where `N = distance
    (fwd_begin, fwd_end`); otherwise, `O(N)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The target sequence must be sorted according to `operator<` or `comp` if provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a `vector` of `int` objects ➊. Next, you invoke `upper_bound`
    with this `vector` as the target sequence and a `value` of `5` ➋. The result is
    the fourth element, `6`, which is the first element in the target sequence greater
    than `value` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '***equal_range***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `equal_range` algorithm finds a range of certain elements in a sorted sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm returns a `std::pair` of iterators corresponding to the half-open
    range equal to `value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `value` to seek
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison operator, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Logarithmic** If you provide a random iterator, `O(log N)` where `N = distance
    (fwd_begin, fwd_end)`; otherwise, `O(N)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The target sequence must be sorted according to `operator<` or `comp` if provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a `vector` of `int` objects ➊. Next, you invoke `equal_range`
    with this `vector` as the target sequence and a `value` of `6` ➋. The result is
    an iterator pair representing the matching range. The begin iterator points to
    the fourth element ➌, and the second iterator points to the sixth element ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '***binary_search***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `binary_search` algorithm finds a particular element in a sorted sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm returns `true` if the range contains `value`. Specifically, it
    returns `true` if the target sequence contains an element `x` such that neither
    `x < value` nor `value < x`. If `comp` is provided, it returns `true` if the target
    sequence contains an element `x` such that neither `comp(x, value)` nor `comp(value,
    x)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `value` to seek
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison operator, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Logarithmic** If you provide a random iterator, `O(log N)` where `N = distance
    (fwd_begin, fwd_end)`; otherwise, `O(N)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The target sequence must be sorted according to `operator<` or `comp` if provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a `vector` of `int` objects ➊. Next, you invoke `binary_search`
    with this `vector` as the target sequence and a value of `6`. Because the sequence
    contains 6, `binary_search` returns `true` ➋. When you invoke `binary_search`
    with `7`, it returns `false` because the target sequence doesn’t contain `7` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partitioning Algorithms**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *partitioned sequence* contains two contiguous, distinct groups of elements.
    These groups don’t mix, and the first element of the second distinct group is
    called the *partition point*. The stdlib contains algorithms to partition sequences,
    determine whether a sequence is partitioned, and find partition points. Each algorithm
    explained in this section is in the `<algorithm>` header.
  prefs: []
  type: TYPE_NORMAL
- en: '***is_partitioned***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `is_partitioned` algorithm determines whether a sequence is partitioned.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A sequence is partitioned if all elements with some attribute appear before
    the elements that don’t.*'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm returns `true` if every element in the target sequence for which
    `pred` evaluates to `true` appears before the other elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A predicate, `pred`, that determines group membership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** At most `distance(ipt_begin, ipt_end)` evaluations of `pred`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a lambda called `is_odd`, which returns `true` if the given
    number is odd ➊. Next, you construct a `vector` of `int` objects ➋ and invoke
    `is_partitioned` with this `vector` as the target sequence and `is_odd` as the
    predicate. Because the sequence contains all its odd numbers placed before its
    even numbers, `is_partitioned` returns `true` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: You then construct another `vector` of `int` objects ➍ and again invoke `is_partitioned`
    with this `vector` as the target sequence and `is_odd` as the predicate. Because
    the sequence doesn’t contain all its odd numbers placed before its even numbers
    (4 is even and before the second 9), `is_partitioned` returns `false` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***partition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `partition` algorithm partitions a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm mutates the target sequence so it’s partitioned according to `pred`.
    It returns the partition point. The elements’ original ordering isn’t necessarily
    preserved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A predicate, `pred`, that determines group membership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** At most `distance(fwd_begin, fwd_end)` evaluations of `pred`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The target sequence’s elements must be swappable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a lambda called `is_odd`, which returns `true` if the given
    number is `odd` ➊. Next, you construct a `vector` of `int` objects ➋ and invoke
    `partition` with this `vector` as the target sequence and `is_odd` as the predicate.
    You assign the resulting partition point into `partition_point` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: When you invoke `is_partitioned` on the target sequence with `is_odd` as the
    predicate, it returns `true` ➍. Per the specification of the algorithm, *you cannot
    rely on the ordering within the groups*, but the `partition_point` will always
    be the fourth element, because the target sequence contains three odd numbers
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***partition_copy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `partition_copy` algorithm partitions a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm partitions the target sequence by evaluating `pred` on each element.
    All true elements copy into `opt_true`, and all false elements copy into `opt_false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OutputIterator`, `opt_true`, to receive copies of `true` elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OutputIterator`, `opt_false`, to receive copies of `false` elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A predicate, `pred`, that determines group membership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** Exactly `distance(ipt_begin, ipt_end)` evaluations of `pred`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The target sequence’s elements must be copy assignable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input and output ranges must not overlap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a lambda called `is_odd`, which returns `true` if the given
    number is `odd` ➊. Next, you construct a `vector` of `int` objects containing
    the `numbers` from 1 to 5 and two empty `vector` objects called `odds` and `evens`
    ➋. Next, you invoke `partition_copy` with `numbers` as the target sequence, a
    `back_inserter` to `odds` as the output for true elements, a `back_inserter` to
    `evens` as the output for false elements, and `is_odd` as the predicate ➌. The
    result is that all of the elements in `odds` are odd ➍ and none of the elements
    in `evens` are odd ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***stable_partition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `stable_partition` algorithm partitions a sequence stably.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A stable partition might take more computation than an unstable partition,
    so the user is given the choice.*'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm mutates the target sequence so it’s partitioned according to `pred`.
    It returns the partition point. The elements’ original ordering is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `BidirectionalIterator`s, `bid_begin` and `bid_end`, representing
    the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A predicate, `pred`, that determines group membership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Quasilinear** `O(N log N)` swaps where `N = distance(bid_begin, bid_end)`,
    or `O(N)` swaps if sufficient memory is available.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The target sequence’s elements must be swappable, move constructible, and move
    assignable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: You first construct a lambda called `is_odd`, which returns `true` if the given
    number is `odd` ➊. Next, you construct a `vector` of `int` objects ➋ and invoke
    `stable_partition` with this `vector` as the target sequence and `is_odd` as the
    predicate ➌. The result is that the `vector` contains the elements 1, 3, 5, 2,
    4 because this is the only way to partition these numbers while preserving their
    original within-group order ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**Merging Algorithms**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Merging algorithms* merge two sorted target sequences such that the resulting
    sequence contains copies of both target sequences and is also sorted. Each algorithm
    explained in this section is in the `<algorithm>` header.'
  prefs: []
  type: TYPE_NORMAL
- en: '***merge***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `merge` algorithm merges two sorted sequences.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm copies both target sequences into the destination sequence. The
    destination sequence is sorted according to `operator<` or `comp` if provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two pairs of `InputIterator`s, `ipt_begin` and `ipt_end`, representing the target
    sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OutputIterator`, `opt_result`, representing the destination sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A predicate, `pred`, that determines group membership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** At most `N-1` comparisons where `N = distance(ipt_begin1, ipt_end1)
    + distance(ipt_begin2, ipt_end2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The target sequences must be sorted according to `operator<` or `comp` if provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'You construct three `vector` objects: two containing sorted `int` objects and
    another that is empty ➊. Next, you merge the non-empty `vector` and use the empty
    `vector` as the destination sequence via a `back_inserter` ➋. The `result` contains
    copies of all the elements from the original sequences, and it too is sorted ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extreme-Value Algorithms**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several algorithms, called *extreme-value algorithms*, determine minimum and
    maximum elements or place limits on the minimum or maximum value of an element.
    Each algorithm explained in this section is in the `<algorithm>` header.
  prefs: []
  type: TYPE_NORMAL
- en: '***min and max***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `min` or `max` algorithm determines a sequence’s extrema.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms use `operator<` or `comp` and return the minimum (`min`) or maximum
    (`max`) object. The `minmax` algorithm returns both as a `std::pair` with `first`
    as the minimum and `second` as the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Two objects, `obj1` and `obj2`, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An initializer list, `init_list`, representing the objects to compare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison function, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Constant or Linear** For the overloads taking `obj1` and `obj2`, exactly
    one comparison. For the initializer list, at most `N-1` comparisons where `N`
    is the length of the initializer list. In the case of `minmax`, given an initializer
    list, this grows to `3/2 N`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements must be copy constructible and comparable using the given comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: You first initialize a lambda called `length_compare`, which uses `operator<`
    to compare the lengths of two inputs ➊. Next, you use `min` to determine whether
    *undiscriminativeness* or *vermin* has lesser length ➋, and you use `max` to determine
    whether *maxim* or *ultramaximal* has greater length ➌. Finally, you use `minmax`
    to determine which of *minimaxes* and *maximin* has minimum and maximum length
    ➍. The result is a pair ➎➏.
  prefs: []
  type: TYPE_NORMAL
- en: '***min_element and max_element***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `min_element` or `max_element` algorithm determines a sequence’s extrema.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms use `operator<` or `comp` and return an iterator pointing to
    the minimum (`min_element`) or maximum (`max_element`) object. The `minimax_element`
    algorithm returns both as a `std::pair` with `first` as the minimum and `second`
    as the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison function, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** For `max` and `min`, at most `N-1` comparisons where `N=distance(fwd_begin,
    fwd_end)`; for `minmax`, `3/2 N`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elements must be comparable using the given operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: You first initialize a lambda called `length_compare`, which uses `operator<`
    to compare the lengths of two inputs ➊. Next, you initialize a `vector` of `string`
    objects called `words` containing four words ➋. You use `min_element` to determine
    the smallest of these words by passing it as the target sequence and `length_compare`
    as the comparison function (`deed`) ➌, and you use `max_element` to determine
    the largest (`malayalam`) ➍. Finally, you use `minmax_element`, which returns
    both as a `std::pair` ➎. The `first` element refers to the shortest `word` ➏,
    and `second` refers to the longest ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '***clamp***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `clamp` algorithm bounds a value.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm uses `operator<` or `comp` to determine whether `obj` is inside
    the bounds from `low` to `high`. If it is, the algorithm simply returns `obj`;
    otherwise, if `obj` is less than `low`, it returns `low`. If `obj` is greater
    than `high`, it returns `high`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An object, `obj`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `low` and `high` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional comparison function, `comp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Constant** At most two comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The objects must be comparable using the given operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, you clamp `9000` to the interval from 0 to 100 inclusive.
    Because 9,000 > 100, the result is `100` ➊. In the second example, you clamp `-123`
    to the same interval. Because −123 < 0, the result is `0` ➋. Finally, you clamp
    `3.14` and because it’s within the interval, the result is `3.14` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**Numeric Operations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<numeric>` header was discussed in [Chapter 12](ch12.xhtml#ch12) when you
    learned about its mathematical types and functions. It also provides algorithms
    well suited to numeric operations. This section introduces many of them. Each
    algorithm explained in this section is in the `<numeric>` header.
  prefs: []
  type: TYPE_NORMAL
- en: '***Useful Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some stdlib numeric operations permit you to pass an operator to customize
    behavior. For convenience, the `<functional>` header provides the following class
    templates that expose various binary arithmetic operations through `operator(T
    x, T y)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`plus<T>` implements addition `x + y`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minus<T>` implements subtraction `x - y`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiplies<T>` implements multiplication `x * y`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`divides<T>` implements division `x / y`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modulus<T>` implements addition `x % y`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, you could add two numbers using the `plus` template, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: You first instantiate a `plus` called `adder` ➊, and then you invoke it with
    the values `1` and `2`, which yields `3` ➋. You can also skip the variable entirely
    and simply use a newly constructed `plus` directly to achieve the same result
    ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You generally wouldn’t use these operator types unless you were using generic
    code that required them.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***iota***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `iota` algorithm fills a sequence with incremental values.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm assigns incremental values beginning with `start` to the target
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pair of iterators, `fwd_begin` and `fwd_end`, representing the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `start` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** `N` increments and assignments, where `N=distance(fwd_begin, fwd_end)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The objects must be assignable to `start`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: You first initialize an `array` of `int` objects with length `3` ➊. Next, you
    invoke `iota` with the `array` as the target sequence and `1` as the `start` value
    ➋. The result is that `array` contains the elements 1, 2, and 3 ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '***accumulate***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `accumulate` algorithm folds a sequence (in order).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Folding a sequence means to apply a particular operation over the elements
    of a sequence while passing the cumulative result along to the next operation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm applies `op` to `start` and the target sequence’s first element.
    It takes the result and the target sequence’s next element and again applies `op`,
    proceeding in this fashion until it visits each element in the target sequence.
    Loosely, this algorithm adds the target sequence elements and the `start` value,
    and it returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pair of iterators, `ipt_begin` and `ipt_end`, representing the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `start` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary operator, `op`, that defaults to `plus`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** `N` applications of `op`, where `N=distance(ipt_begin, ipt_end)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The target sequence’s elements must be copyable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: You first initialize a `vector` of `int` objects with length `3` ➊. Next, you
    invoke `accumulate` with the `vector` as the target sequence and `-1` as the `start`
    value ➋. The result is −1 + 1 + 2 + 3 = 5 ➌.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, you use the same target sequence but a start value of
    `2` and the `multiplies` operator instead ➍. The result is 2 * 1 * 2 * 3 = 12
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***reduce***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `reduce` algorithm folds a sequence (not necessarily in order).
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is identical to `accumulate` except it accepts an optional `execution`
    and doesn’t guarantee the order of operator applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of iterators, `ipt_begin` and `ipt_end`, representing the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `start` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary operator, `op`, that defaults to `plus`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** `N` applications of `op`, where `N=distance(ipt_begin, ipt_end)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Elements must be movable if you omit `ep`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements must copyable if you provide `ep`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: You first initialize a `vector` of `int` objects with length `3` ➊. Next, you
    invoke `reduce` with the `vector` as the target sequence and `-1` as the `start`
    value ➋. The result is −1 + 1 + 2 + 3 = 5 ➌.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, you use the same target sequence but a start value of
    `2` and the `multiplies` operator instead ➍. The result is 2 * 1 * 2 * 3 = 12
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***inner_product***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `inner_product` algorithm computes the inner product of two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*An inner product (or dot product) is a scalar value associated with a pair
    of sequences.*'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm applies `op2` to each pair of corresponding elements in the target
    sequence and sums them together with `start` using `op1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pair of iterators, `ipt_begin1` and `ipt_end1`, representing target sequence
    1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An iterator, `ipt_begin2`, representing target sequence 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `start` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two optional binary operators, `op1` and `op2`, that default to `plus` and `multiply`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** `N` applications of `op1` and `op2`, where `N=distance(ipt_begin1,
    ipt_end1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Elements must be copyable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: You first initialize two `vector`s of `int` objects ➊ ➋. Next, you invoke `inner_product`
    with the two `vector` objects as the target sequences and `10` as the `start`
    value ➌. The result is 10 + 1 * 1 + 2 * 0 + 3 * 1 + 4 * 0 + 4 * 1 = 13 ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '***adjacent_difference***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `adjacent_difference` algorithm generates adjacent differences.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*An adjacent difference is the result of applying some operation to each pair
    of neighboring elements.*'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm sets the first element of the destination sequence equal to the
    first element of the target sequence. For each subsequent element, it applies
    `op` to the prior element and the current element and writes the return value
    into `result`. The algorithm returns the end of the destination sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pair of iterators, `ipt_begin` and `ipt_end`, representing target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An iterator, `result`, representing the destination sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary operator, `op`, that defaults to `minus`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** `N-1` applications of `op`, where `N=distance(ipt_begin, ipt_end)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Elements must be movable if you omit `ep`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements must copyable if you provide `ep`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'You first two initialize a `vector` of `int` objects, one containing the first
    six numbers of the Fibonacci sequence and another that is empty ➊. Next, you invoke
    `adjacent_difference` with the two `vector` objects as the target sequences ➋.
    The result is as expected: the first element equals the first element of the Fibonacci
    sequence, and the following elements are the adjacent differences (1 – 1 = 0),
    (2 – 1 = 1), (3 – 2 = 1), (5 – 3 = 2), (8 – 5 = 3) ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '***partial_sum***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `partial_sum` algorithm generates partial sums.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm sets an accumulator equal to the first element of the target sequence.
    For each subsequent element of the target sequence, the algorithm adds that element
    to the accumulator and then writes the accumulator into the destination sequence.
    The algorithm returns the end of the destination sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '**Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pair of iterators, `ipt_begin` and `ipt_end`, representing the target sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An iterator, `result`, representing the destination sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional binary operator, `op`, that defaults to `plus`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Linear** `N-1` applications of `op`, where `N=distance(ipt_begin, ipt_end)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: You first initialize two `vector` of `int` objects, one called `num` containing
    the first four counting and an empty one called `result` ➊. Next, you invoke `partial_sum`
    with `num` as the target sequence and `result` as the destination ➋. The first
    element equals the first element of the target sequence, and the following elements
    are the partial sums (1 + 2 = 3), (3 + 3 = 6), (6 + 4 = 10) ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Algorithms***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To keep a long chapter from getting much longer, many algorithms are omitted.
    This section provides a survey of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**(Max) Heap Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A range of length *N* is a max heap if for all 0 < *i* < *N*, the ![Image](../images/fig635_1.jpg)-th
    element (rounded down) doesn’t compare less than the *i*-th element. These structures
    have strong performance properties in situations where maximum element lookup
    and insertions must be fast.
  prefs: []
  type: TYPE_NORMAL
- en: The `<algorithm>` header contains functions that are useful for handling such
    ranges, such as those in [Table 18-1](ch18.xhtml#ch18tab01). See [alg.heap.operations]
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Heap-Related Algorithms in the `<algorithm>` Header'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `is_heap` | Checks whether a range is a max heap |'
  prefs: []
  type: TYPE_TB
- en: '| `is_heap_until` | Finds the largest subrange that is a max heap |'
  prefs: []
  type: TYPE_TB
- en: '| `make_heap` | Creates a max heap |'
  prefs: []
  type: TYPE_TB
- en: '| `push_heap` | Adds an element |'
  prefs: []
  type: TYPE_TB
- en: '| `pop_heap` | Removes the largest element |'
  prefs: []
  type: TYPE_TB
- en: '| `sort_heap` | Transforms a max heap into a sorted range |'
  prefs: []
  type: TYPE_TB
- en: '**Set Operations on Sorted Ranges**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `<algorithm>` header contains functions that perform set operations on sorted
    ranges, such as those in [Table 18-2](ch18.xhtml#ch18tab02). See [alg.set.operations]
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Set-Related Algorithms in the `<algorithm>` Header'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `includes` | Returns `true` if one range is a subset of another range |'
  prefs: []
  type: TYPE_TB
- en: '| `set_difference` | Computes the difference between two sets |'
  prefs: []
  type: TYPE_TB
- en: '| `set_intersection` | Computes the intersection of two sets |'
  prefs: []
  type: TYPE_TB
- en: '| `set_symmetric_difference` | Computes the symmetric difference between two
    sets |'
  prefs: []
  type: TYPE_TB
- en: '| `set_union` | Computes the union of two sets |'
  prefs: []
  type: TYPE_TB
- en: '**Other Numeric Algorithms**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `<numeric>` header contains several more functions in addition to those
    introduced in the “Numeric Operations” section. [Table 18-3](ch18.xhtml#ch18tab03)
    lists them. See [numeric.ops] for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Additional Numerical Algorithms in the `<numeric>` Header'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `exclusive_scan` | Like `partial_sum` but excludes the `i`-th element from
    the `i`-th sum |'
  prefs: []
  type: TYPE_TB
- en: '| `inclusive_scan` | Like `partial_sum` but executes out of order and requires
    an associative operation |'
  prefs: []
  type: TYPE_TB
- en: '| `transform_reduce` | Applies a function object; then reduces out of order
    |'
  prefs: []
  type: TYPE_TB
- en: '| `transform_exclusive_scan` | Applies a function object; then calculates an
    exclusive scan |'
  prefs: []
  type: TYPE_TB
- en: '| `transform_inclusive_scan` | Applies a function object; then calculates an
    inclusive scan |'
  prefs: []
  type: TYPE_TB
- en: '**Memory Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `<memory>` header contains a number of low-level functions for handling
    uninitialized memory. [Table 18-4](ch18.xhtml#ch18tab04) lists them. See [memory.syn]
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-4:** Operations for Uninitialized Memory in the `<memory>` Header'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `uninitialized_copy``uninitialized_copy_n``uninitialized_fill``uninitialized_fill_n`
    | Copy objects into uninitialized memory |'
  prefs: []
  type: TYPE_TB
- en: '| `uninitialized_move``uninitialized_move_n` | Move objects into uninitialized
    memory |'
  prefs: []
  type: TYPE_TB
- en: '| `uninitialized_default_construct``uninitialized_default_construct_n``uninitialized_value_construct``uninitialized_value_construct_n`
    | Construct objects in uninitialized memory |'
  prefs: []
  type: TYPE_TB
- en: '| `destroy_at``destroy``destroy_n` | Destroy objects |'
  prefs: []
  type: TYPE_TB
- en: '**Boost Algorithm**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boost Algorithm is a large algorithm library that overlaps partially with the
    standard library. For space reasons, [Table 18-5](ch18.xhtml#ch18tab05) lists
    only a quick reference to those algorithms not already contained in the standard
    library. Refer to the Boost Algorithm documentation for further information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-5:** Additional Algorithms Available in Boost Algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boyer_moore``boyer_moore_horspool``knuth_morris_pratt` | Fast algorithms
    for searching sequences of values |'
  prefs: []
  type: TYPE_TB
- en: '| `hex``unhex` | Writes/reads hexadecimal characters |'
  prefs: []
  type: TYPE_TB
- en: '| `gather` | Takes a sequence and moves elements satisfying a predicate into
    a given position |'
  prefs: []
  type: TYPE_TB
- en: '| `find_not` | Finds the first element in a sequence not equal to a value |'
  prefs: []
  type: TYPE_TB
- en: '| `find_backward` | Like `find` but works backward |'
  prefs: []
  type: TYPE_TB
- en: '| `is_partitioned_until` | Returns the end iterator for the largest partitioned
    subsequence that begins with the target sequence’s first element |'
  prefs: []
  type: TYPE_TB
- en: '| `apply_permutation``apply_reverse_permutation` | Takes an item sequence and
    an order sequence and reshuffles the item sequence according to the order sequence
    |'
  prefs: []
  type: TYPE_TB
- en: '| `is_palindrome` | Returns `true` if a sequence is a palindrome |'
  prefs: []
  type: TYPE_TB
- en: '**A NOTE ON RANGES**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.xhtml) introduced range expressions as part of the range-based
    `for` loop. Recall from this discussion that a range is a concept that exposes
    `begin` and `end` methods that return iterators. Because you can place requirements
    on iterators to support certain operations, you can place transitive requirements
    on ranges so they provide certain iterators. Each algorithm has certain operational
    requirements, and these are reflected in the sorts of iterators they require.
    Because you can encapsulate an algorithm’s input sequence requirements in terms
    of ranges, you must understand the various range types to understand each algorithm’s
    constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: Like concepts, ranges are not yet formally part of C++. Although you’ll still
    get tremendous benefit from understanding the relationship among ranges, iterators,
    and algorithms, there are two drawbacks. First, algorithms still require iterators
    as input arguments, so even if a range is at hand, you’ll need to extract iterators
    manually (for example, with `begin` and `end`). Second, as with other function
    templates, you’ll sometimes get spectacularly poor error messages when you violate
    an algorithm’s operational requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Work is underway to introduce ranges into the language formally. In fact, concepts
    and ranges will likely enter the C++ Standard simultaneously because they dovetail
    so nicely.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to experiment with one possible implementation of ranges, refer
    to Boost Range.
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The C++ Standard Library: A Tutorial and Reference*, 2nd Edition, by Nicolai
    Josuttis (Addison-Wesley Professional, 2012)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Algorithmic Complexity” by Victor Adamchik ([*https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html*](https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
