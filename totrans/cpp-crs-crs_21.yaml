- en: '**18'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**18**'
- en: ALGORITHMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法**'
- en: '*And that’s really the essence of programming. By the time you’ve sorted out
    a complicated idea into little steps that even a stupidmachine can deal with,
    you’ve learned something about it yourself.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这才是编程的精髓。通过将一个复杂的想法拆解成小步骤，甚至是一个愚蠢的机器也能处理时，你自己已经学到了关于它的某些东西。*'
- en: —Douglas Adams*, Dirk Gently’s Holistic Detective Agency
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —**道格拉斯·亚当斯**，《Dirk Gently的全息侦探事务所》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: An *algorithm* is a procedure for solving a class of problems. The stdlib and
    Boost libraries contain a multitude of algorithms that you can use in your programs.
    Because many very smart people have put a lot of time into ensuring these algorithms
    are correct and efficient, you should usually not attempt to, for example, write
    your own sorting algorithm.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法*是一种解决一类问题的过程。std库和Boost库包含了大量你可以在程序中使用的算法。因为许多聪明的人花了大量时间来确保这些算法的正确性和效率，所以你通常不需要尝试自己编写排序算法等。'
- en: Because this chapter covers almost the entire stdlib algorithm suite, it’s lengthy;
    however, the individual algorithm presentations are succinct. On first reading,
    you should skim through each section to survey the wide range of algorithms available
    to you. Don’t try to memorize them. Instead, focus on getting insight into the
    kinds of problems you can solve with them as you write code in the future. That
    way, when you need to use an algorithm, you can say, “Wait, didn’t someone already
    invent this wheel?”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章涵盖了几乎整个std库算法集，因此篇幅较长；然而，每个算法的介绍都很简洁。首次阅读时，你应该浏览每一节，了解可以使用的各种算法。不要试图记住它们。相反，应该专注于获得对未来编写代码时，能通过它们解决哪些问题的洞察。这样，当你需要使用某个算法时，你可以说：“等等，难道不是有人已经发明过这个轮子了吗？”
- en: Before you begin working with the algorithms, you’ll need some grounding in
    complexity and parallelism. These two algorithmic characteristics are the main
    drivers behind how your code will perform.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用算法之前，你需要对复杂度和并行性有所了解。这两种算法特性是决定你的代码性能的主要因素。
- en: '**Algorithmic Complexity**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**算法复杂度**'
- en: '*Algorithmic complexity* describes the difficulty of a computational task.
    One way to quantify this complexity is with *Bachmann-Landau* or *“Big O” nota**tion*.
    Big O notation characterizes functions according to how computation grows with
    respect to the size of input. This notation only includes the leading term of
    the complexity function. The *leading term* is the one that grows most quickly
    as input size increases.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法复杂度*描述了计算任务的难度。一种量化这种复杂度的方法是使用*巴赫曼-兰道*或*“大O”表示法*。大O表示法根据计算随着输入大小的变化情况来描述函数。此表示法仅包括复杂度函数的主项。*主项*是输入大小增加时增长最快的项。'
- en: For example, an algorithm whose complexity increases by roughly a fixed amount
    for each additional input element has a Big O notation of **O(N)**, whereas an
    algorithm whose complexity doesn’t change given additional input has a Big O notation
    of **O(1)**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，复杂度大约随着每个额外输入元素增加一个固定值的算法，其Big O表示法为**O(N)**，而复杂度在额外输入下不会变化的算法，其Big O表示法为**O(1)**。
- en: 'This chapter characterizes the stdlib’s algorithms that fall into five complexity
    classes, as outlined in the list that follows. To give you some idea of how these
    algorithms scale, each class is listed with its Big O notation and an idea of
    roughly how many additional operations would be required due to the leading term
    when input increases from 1,000 elements to 10,000 elements. Each example provides
    an operation with the given complexity class, where *N* is the number of elements
    involved in the operation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了std库算法，它们属于以下五个复杂度类别。为了让你了解这些算法如何扩展，每个类别都列出了其Big O符号以及输入从1,000个元素增加到10,000个元素时，因主项而需要的大致额外操作次数。每个示例提供了一个具有给定复杂度类别的操作，其中*N*是涉及该操作的元素数量：
- en: '**Constant time O(1)** No additional computation. An example is determining
    the size of a `std::vector`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**常数时间 O(1)** 无需额外计算。一个例子是确定`std::vector`的大小。'
- en: '**Logarithmic time O(log *N*)** About one additional computation. An example
    is finding an element in a `std::set`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**对数时间 O(log *N*)** 大约需要进行一次额外的计算。一个例子是查找`std::set`中的元素。'
- en: '**Linear time O(*N*)** About 9,000 additional computations. An example is summing
    all the elements in a collection.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性时间 O(*N*)** 大约需要9,000次额外计算。一个例子是对集合中的所有元素求和。'
- en: '**Quasilinear time O(*N* log *N*)** About 37,000 additional computations. An
    example is quicksort, a commonly used sorting algorithm.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**准线性时间 O(*N* log *N*)** 大约增加37,000次计算。一个例子是快速排序，常用的排序算法。'
- en: '**Polynomial (or quadratic) time O(*N*²)** About 99,000,000 additional computations.
    An example is comparing all the elements in a collection with all the elements
    in another collection.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**多项式时间（或二次时间）O(*N*²)** 大约增加99,000,000次计算。一个例子是将一个集合中的所有元素与另一个集合中的所有元素进行比较。'
- en: An entire field of computer science is dedicated to classifying computational
    problems according to their difficulty, so this is an involved topic. This chapter
    mentions each algorithm’s complexity according to how the size of the target sequence
    affects the amount of required work. In practice, you should profile performance
    to determine whether an algorithm has suitable scaling properties. But these complexity
    classes can give you a sense of how expensive a particular algorithm is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学的一个完整领域致力于根据计算问题的难度来对其进行分类，因此这是一个复杂的话题。本章提到的每个算法的复杂度取决于目标序列的大小如何影响所需工作量。实际上，你应该对性能进行分析，以确定某个算法是否具备合适的扩展性。但这些复杂度类别可以让你大致了解某个算法的开销。
- en: '**Execution Policies**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**执行策略**'
- en: Some algorithms, those that are commonly called *parallel algorithms*, can divide
    an algorithm so that independent entities can work on different parts of the problem
    simultaneously. Many stdlib algorithms allow you to specify parallelism with an
    *execution policy*. An execution policy indicates the allowed parallelism for
    an algorithm. From the stdlib’s perspective, an algorithm can be executed either
    *sequentially* or *in parallel*. A sequential algorithm can have only a single
    entity working on the problem at a time; a parallel algorithm can have many entities
    working in concert to resolve the problem.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法，通常被称为*并行算法*，可以将一个算法分解，使得独立的实体可以同时在不同部分解决问题。许多标准库算法允许你通过*执行策略*来指定并行性。执行策略表示算法允许的并行度。从标准库的角度看，算法可以按*顺序*执行或*并行*执行。顺序算法一次只能由单个实体处理问题；并行算法可以有多个实体共同协作解决问题。
- en: In addition, parallel algorithms can either be *vectorized* or *non-vectorized*.
    Vectorized algorithms allow entities to perform work in an unspecified order,
    even allowing a single entity to work on multiple portions of the problem simultaneously.
    For example, an algorithm that requires synchronization among entities is usually
    non-vectorizable because the same entity could attempt to acquire a lock multiple
    times, resulting in a deadlock.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，并行算法可以是*向量化*的或*非向量化*的。向量化算法允许实体以未指定的顺序执行工作，甚至允许单个实体同时处理问题的多个部分。例如，需要在实体之间进行同步的算法通常是不可向量化的，因为同一实体可能会多次尝试获取锁，导致死锁。
- en: 'Three execution policies exist in the `<execution>` header:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`<execution>`头文件中存在三种执行策略：'
- en: '`std::execution::seq` specifies sequential (not parallel) execution.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::execution::seq`指定顺序执行（非并行执行）。'
- en: '`std::execution::par` specifies parallel execution.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::execution::par`指定并行执行。'
- en: '`std::execution::par_unseq` specifies parallel *and* vectorized execution.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::execution::par_unseq`指定并行*且*向量化的执行。'
- en: For those algorithms that support an execution policy, the default is `seq`,
    meaning you have to opt into parallelism and the associated performance benefits.
    Note that the C++ Standard doesn’t specify the precise meaning of these execution
    policies because different platforms handle parallelism differently. When you
    provide a non-sequential execution policy, you’re simply declaring that “this
    algorithm is safe to parallelize.”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些支持执行策略的算法，默认策略是`seq`，这意味着你必须显式选择并行执行及其相关的性能优势。请注意，C++标准没有明确指定这些执行策略的具体含义，因为不同平台处理并行性的方式不同。当你提供非顺序执行策略时，你仅仅是在声明“这个算法是安全的，可以并行化”。
- en: In [Chapter 1](ch01.xhtml#ch01)9, you’ll explore execution policies in greater
    detail. For now, just note that some algorithms permit parallelism.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch01)中，你将更详细地探讨执行策略。目前，只需注意一些算法允许并行性。
- en: '**WARNING**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The algorithm descriptions in this chapter aren’t complete. They contain enough
    information to give you a good background on many algorithms available to you
    in the Standard library. I suggest that, once you’ve identified an algorithm that
    fits your needs, you look at one of the resources in the “Further Reading” section
    at the end of this chapter. Algorithms that accept an optional execution policy
    often have different requirements when non-default policies are provided, especially
    where iterators are concerned. For example, if an algorithm normally takes an
    input iterator, using an execution policy will typically cause the algorithm to
    require forward iterators instead. Listing these differences would lengthen an
    already prodigious chapter, so the descriptions omit them.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章中的算法描述并不完整。它们包含足够的信息，能够为您提供有关标准库中许多可用算法的良好背景。我建议您在确定适合自己需求的算法后，查阅本章末尾的“进一步阅读”部分中的资源。接受可选执行策略的算法，在提供非默认策略时，通常会有不同的要求，特别是在涉及迭代器时。例如，如果一个算法通常接受输入迭代器，使用执行策略通常会导致该算法要求使用前向迭代器。列出这些差异会使已经相当庞大的章节更长，因此描述中省略了这些差异。*'
- en: '**HOW TO USE THIS CHAPTER**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何使用本章**'
- en: 'This chapter is a quick reference that contains more than 50 algorithms. Coverage
    of each algorithm is necessarily succinct. Each algorithm begins with a terse
    description. A shorthand representation of the algorithm’s function declaration
    follows along with an explanation of each argument. The declaration depicts optional
    arguments in brackets. Next, the listing displays the algorithmic complexity.
    The listing concludes with a non-exhaustive but illustrative example that employs
    the algorithm. Almost all examples in this chapter are unit tests and implicitly
    include the following frontmatter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一本快速参考，包含50多个算法。每个算法的覆盖面简洁明了。每个算法以简短的描述开始，紧接着是该算法的函数声明的简写表示，并附有每个参数的解释。声明中用括号表示可选参数。接下来，列出了算法的复杂度。最后是一个非详尽但具有说明性的示例，展示了该算法的应用。本章中的几乎所有示例都是单元测试，隐含地包括以下前言：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Refer to the relevant subsection [algorithms] for algorithm details should you
    need them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如有需要，参阅相关小节[算法]获取详细信息。
- en: '**Non-Modifying Sequence Operations**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**非修改序列操作**'
- en: A *non-modifying sequence operation* is an algorithm that performs computation
    over a sequence but doesn’t modify the sequence in any way. You can think of these
    as `const` algorithms. Each algorithm explained in this section is in the `<algorithm>`
    header.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*非修改序列操作*是一个在序列上执行计算但不以任何方式修改序列的算法。您可以将这些算法视为`const`算法。本节中解释的每个算法都在`<algorithm>`头文件中。'
- en: '***all_of***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***all_of***'
- en: The `all_of` algorithm determines whether each element in a sequence meets some
    user-specified criteria.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`all_of`算法用于判断序列中的每个元素是否符合用户指定的某些标准。'
- en: The algorithm returns `true` if the target sequence is empty or if `pred` is
    `true` for *all* elements in the sequence; otherwise, it returns `false`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标序列为空，或者`pred`对序列中的*所有*元素返回`true`，则算法返回`true`；否则，返回`false`。
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Arguments**'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略`ep`（默认：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin`和`ipt_end`，表示目标序列
- en: A unary predicate, `pred`, that accepts an element from the target sequence
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元谓词`pred`，接受目标序列中的一个元素
- en: '**Complexity**'
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `pred` at most `distance(ipt_begin, ipt_end)`
    times.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法最多调用`pred``distance(ipt_begin, ipt_end)`次。'
- en: '**Examples**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you construct the lambda predicate `starts_with_a`, which takes a single object
    called `word` ➋. If `word` is empty, `starts_with_a` returns `false` ➌; otherwise,
    it returns `true` if `word` starts with either `a` or `A` ➍. Because all of the
    `word` elements start with either `a` or `A`, `all_of` returns `true` when it
    applies `starts_with_a` ➎.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造一个包含`string`对象的`vector`，名为`words` ➊之后，您构造了一个名为`starts_with_a`的lambda谓词，它接受一个名为`word`的单一对象
    ➋。如果`word`为空，`starts_with_a`返回`false` ➌；否则，如果`word`以`a`或`A`开头，返回`true` ➍。由于所有的`word`元素都以`a`或`A`开头，当应用`starts_with_a`时，`all_of`返回`true`
    ➎。
- en: In the second example, you construct the predicate `has_length_six`, which returns
    `true` only if `word` has length six ➏. Because `alligator` doesn’t have length
    six, `all_of` returns `false` when it applies `has_length_six` to `words` ➐.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，你构造了谓词`has_length_six`，只有当`word`的长度为六时，它才返回`true` ➏。因为`alligator`的长度不是六，`all_of`在应用`has_length_six`到`words`时返回`false`
    ➐。
- en: '***any_of***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***any_of***'
- en: The `any_of` algorithm determines whether any element in a sequence meets some
    user-specified criteria.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`any_of`算法判断序列中是否有任何元素满足用户指定的标准。'
- en: The algorithm returns `false` if the target sequence is empty or if `pred` is
    `true` for *any* element in the sequence; otherwise, it returns `false`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标序列为空，或`pred`对于序列中的*任何*元素为`true`，则算法返回`false`；否则返回`false`。
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Arguments**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin`和`ipt_end`，表示目标序列
- en: A unary predicate, `pred`, that accepts an element from the target sequence
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元谓词`pred`，接受来自目标序列的一个元素
- en: '**Complexity**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `pred` at most `distance(ipt_begin, ipt_end)`
    times.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 算法最多调用`pred` `distance(ipt_begin, ipt_end)`次。'
- en: '**Examples**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you construct the lambda predicate `contains_bar` that takes a single object called
    `word` ➋. If `word` contains the substring `Bar`, it returns `true`; otherwise,
    it returns `false`. Because `Barber` contains `Bar`, `any_of` returns `true` when
    it applies `contains_bar` ➌.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造了一个包含`string`对象的`vector`，命名为`words` ➊之后，你构造了一个名为`contains_bar`的lambda谓词，它接受一个名为`word`的单一对象
    ➋。如果`word`包含子串`Bar`，它返回`true`；否则返回`false`。因为`Barber`包含`Bar`，`any_of`在应用`contains_bar`时返回`true`
    ➌。
- en: In the second example, you construct the predicate `is_empty`, which returns
    `true` only if a `word` is empty ➍. Because none of the words are empty, `any_of`
    returns `false` when it applies `is_empty` to `words` ➎.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，你构造了谓词`is_empty`，只有当`word`为空时，它才返回`true` ➍。因为没有任何单词为空，`any_of`在应用`is_empty`到`words`时返回`false`
    ➎。
- en: '***none_of***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***none_of***'
- en: The `none_of` algorithm determines whether no element in a sequence meets some
    user-specified criteria.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`none_of`算法判断序列中是否没有任何元素满足用户指定的标准。'
- en: The algorithm returns `true` if the target sequence is empty or if `pred` is
    `true` for *no* element in the sequence; otherwise, it returns `false`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标序列为空，或`pred`对于序列中的*任何*元素为`true`，则算法返回`true`；否则返回`false`。
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Arguments**'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin`和`ipt_end`，表示目标序列
- en: A unary predicate, `pred`, that accepts an element from the target sequence
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元谓词`pred`，接受来自目标序列的一个元素
- en: '**Complexity**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `pred` at most `distance(ipt_begin, ipt_end)`
    times.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 算法最多调用`pred` `distance(ipt_begin, ipt_end)`次。'
- en: '**Examples**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you construct the lambda predicate `is_hump_day` that takes a single object called
    `word` ➋. If `word` equals `hump day`, it returns `true`; otherwise, it returns
    `false`. Because `words` doesn’t contain `hump day`, `none_of` returns `true`
    when it applies `is_hump_day` ➌.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造了一个包含`string`对象的`vector`，命名为`words` ➊之后，你构造了一个名为`is_hump_day`的lambda谓词，它接受一个名为`word`的单一对象
    ➋。如果`word`等于`hump day`，它返回`true`；否则返回`false`。因为`words`中不包含`hump day`，所以`none_of`在应用`is_hump_day`时返回`true`
    ➌。
- en: In the second example, you construct the predicate `is_definite_article`, which
    returns `true` only if `word` is a definite article ➍. Because `the` is a definite
    article, `none_of` returns `false` when it applies `is_definite_article` to `words`
    ➎.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，你构造了谓词`is_definite_article`，只有当`word`是定冠词时，它才返回`true` ➍。因为`the`是定冠词，`none_of`在应用`is_definite_article`到`words`时返回`false`
    ➎。
- en: '***for_each***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***for_each***'
- en: The `for_each` algorithm applies some user-defined function to each element
    in a sequence.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`for_each`算法对序列中的每个元素应用某个用户定义的函数。'
- en: The algorithm applies `fn` to each element of the target sequence. Although
    `for_each` is considered a non-modifying sequence operation, if `ipt_begin` is
    a mutable iterator, `fn` can accept a non-`const` argument. Any values that `fn`
    returns are ignored.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法对目标序列的每个元素应用 `fn`。虽然 `for_each` 被认为是一个不修改序列的操作，如果 `ipt_begin` 是一个可变迭代器，`fn`
    可以接受一个非 `const` 参数。`fn` 返回的任何值都会被忽略。
- en: If you omit `ep`, `for_each` will return `fn`. Otherwise, `for_each` returns
    `void`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了 `ep`，`for_each` 将返回 `fn`。否则，`for_each` 返回 `void`。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Arguments**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `std::execution` 执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对 `InputIterator` 对象，`ipt_begin` 和 `ipt_end`，表示目标序列
- en: A unary function, `fn`, that accepts an element from the target sequence
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元函数，`fn`，接受目标序列中的一个元素
- en: '**Complexity**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `fn` exactly `distance(ipt_begin, ipt_end)`
    times.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法恰好调用 `fn` `distance(ipt_begin, ipt_end)` 次。'
- en: '**Additional Requirements**'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: '`fn` must be movable if you omit `ep`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略了 `ep`，`fn` 必须是可移动的。
- en: '`fn` must be copyable if you provide `ep`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了 `ep`，`fn` 必须是可复制的。
- en: '**Example**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After constructing a `vector` containing `string` objects called `words` ➊ and
    a counter variable `number_of_Ds` ➋, you construct the lambda predicate `count_Ds`
    that captures a reference to `number_of_Ds` ➌ and takes a single object called
    `word` ➍. If `word` is empty, you return ➎; otherwise, if the first letter of
    `word` is `D`, you increment `number_of_Ds` ➏.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个包含 `string` 对象的 `vector`，名为 `words` ➊ 和一个计数器变量 `number_of_Ds` ➋ 后，构建捕获
    `number_of_Ds` 引用的 lambda 谓词 `count_Ds` ➌，并接收一个名为 `word` ➍ 的单一对象。如果 `word` 为空，则返回
    ➎；否则，如果 `word` 的第一个字母是 `D`，则递增 `number_of_Ds` ➏。
- en: Next, you use `for_each` to iterate over every word, passing each to `count_Ds`
    ➐. The result is that `number_of_Ds` is three ➑.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `for_each` 遍历每个单词，将每个单词传递给 `count_Ds` ➐。结果是 `number_of_Ds` 为三 ➑。
- en: '***for_each_n***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***for_each_n***'
- en: The `for_each_n` algorithm applies some user-defined function to each element
    in a sequence.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`for_each_n` 算法对序列中的每个元素应用某个用户定义的函数。'
- en: The algorithm applies `fn` to each element of the target sequence. Although
    `for_each_n` is considered a non-modifying sequence operation, if `ipt_begin`
    is a mutable iterator, `fn` can accept a non-`const` argument. Any values that
    `fn` returns are ignored. It returns `ipt_begin+n`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法对目标序列的每个元素应用 `fn`。虽然 `for_each_n` 被认为是一个不修改序列的操作，如果 `ipt_begin` 是一个可变迭代器，`fn`
    可以接受一个非 `const` 参数。`fn` 返回的任何值都会被忽略。它返回 `ipt_begin+n`。
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Arguments**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `std::execution` 执行策略，`ep`（默认值：`std::execution::seq`）
- en: An `InputIterator` `ipt_begin` representing the target sequence’s first element
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `InputIterator` `ipt_begin`，表示目标序列的第一个元素
- en: An integer `n` representing the desired number of iterations so that the half-open
    range representing the target sequence is `ipt_begin` to `ipt_begin+n` (`Size`
    is the templated type of `n`.)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数 `n`，表示期望的迭代次数，以便表示目标序列的半开区间为 `ipt_begin` 到 `ipt_begin+n`（`Size` 是 `n` 的模板类型）。
- en: A unary function `fn` that accepts an element from the target sequence
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元函数 `fn`，接受目标序列中的一个元素
- en: '**Complexity**'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `fn` exactly `n` times.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法恰好调用 `fn` `n` 次。'
- en: '**Additional Requirements**'
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: '`fn` must be movable if you omit `ep`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略了 `ep`，`fn` 必须是可移动的。
- en: '`fn` must copyable if you provide `ep`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了 `ep`，`fn` 必须是可复制的。
- en: '`n` must be non-negative.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` 必须是非负数。'
- en: '**Example**'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After constructing a `vector` containing `string` objects called `words` ➊ and
    a counter variable `characters` ➋, you construct the lambda predicate `count_characters`
    that captures a reference to `characters` ➌ and takes a single object called `word`
    ➍. The lambda adds the length of `word` to `characters` ➎.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个包含 `string` 对象的 `vector`，名为 `words` ➊ 和一个计数器变量 `characters` ➋ 后，构建捕获 `characters`
    引用的 lambda 谓词 `count_characters` ➌，并接收一个名为 `word` ➍ 的单一对象。lambda 将 `word` 的长度加到
    `characters` 上 ➎。
- en: Next, you use `for_each_n` to iterate over every word, passing each to `count_characters`
    ➏. The result is that `characters` is `14` ➐.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `for_each_n` 遍历每个单词，将每个单词传递给 `count_characters` ➏。结果是 `characters` 为
    `14` ➐。
- en: '***find, find_if, and find_if_not***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***find, find_if, 和 find_if_not***'
- en: The `find`, `find_if`, and `find_if_not` algorithms find the first element in
    a sequence matching some user-defined criteria.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`、`find_if` 和 `find_if_not` 算法查找序列中第一个匹配某些用户定义标准的元素。'
- en: These algorithms return the `InputIterator` pointing to the target sequence’s
    first element matching `value` (`find`), resulting in a `true` result when invoked
    with `pred` (`find_if`), or resulting in a `false` result when invoked with `pred`
    (`find_if_not`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法返回指向目标序列中第一个匹配`value`元素的`InputIterator`（`find`），在与`pred`一起调用时返回`true`（`find_if`），或者在与`pred`一起调用时返回`false`（`find_if_not`）。
- en: If the algorithm finds no match, it returns `ipt_end`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法未找到匹配项，则返回`ipt_end`。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Arguments**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin`和`ipt_end`，表示目标序列
- en: A `const` reference `value` that is equality comparable to the target sequence’s
    underlying type (`find`) or a predicate that accepts a single argument with the
    target sequence’s underlying type (`find_if` and `find_if_not`)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与目标序列的底层类型（`find`）相等可比较的`const`引用`value`，或者一个接受目标序列底层类型作为单一参数的谓词（`find_if`
    和 `find_if_not`）
- en: '**Complexity**'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm makes at most `distance(ipt_begin, ipt_end)` comparisons
    (`find`) or invocations of `pred` (`find_if` and `find_if_not`).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法最多进行`distance(ipt_begin, ipt_end)`次比较（`find`）或调用`pred`（`find_if`
    和 `find_if_not`）。'
- en: '**Examples**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you use `find` to locate `feff` ➋, which is at the end of `words` ➌. Next, you
    construct the predicate `defends_digital_privacy`, which returns `true` if `word`
    contains the letters `eff` ➍. You then use `find_if` to locate the first string
    in `words` that contains `eff` ➎, `feffer` ➏. Finally, you use `find_if_not` to
    apply `defends_digital_privacy` to `words` ➐, which returns the first element
    `fiffer` (because it doesn’t contain `eff`) ➑.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造一个包含`string`对象的`vector`，命名为`words` ➊之后，你使用`find`来定位`feff` ➋，它位于`words`的末尾
    ➌。接下来，你构造了谓词`defends_digital_privacy`，如果`word`包含字母`eff` ➍，则返回`true`。然后你使用`find_if`来定位`words`中第一个包含`eff`的字符串
    ➎，即`feffer` ➏。最后，你使用`find_if_not`将`defends_digital_privacy`应用于`words` ➐，它返回第一个元素`fiffer`（因为它不包含`eff`）
    ➑。
- en: '***find_end***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***find_end***'
- en: The `find_end` algorithm finds the last occurrence of a subsequence.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_end`算法查找子序列的最后一次出现。'
- en: If the algorithm finds no such sequence, it returns `fwd_end1`. If `find_end`
    does find a subsequence, it returns a `ForwardIterator` pointing to the first
    element of the last matching subsequence.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法未找到符合条件的序列，则返回`fwd_end1`。如果`find_end`确实找到了一个子序列，则返回一个`ForwardIterator`，指向最后一个匹配子序列的第一个元素。
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Arguments**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: Two pairs of `ForwardIterator`s, `fwd_begin1` / `fwd_end1` and `fwd_begin2`
    / `fwd_end2`, representing the target sequences 1 and 2
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两对`ForwardIterator`，`fwd_begin1` / `fwd_end1`和`fwd_begin2` / `fwd_end2`，表示目标序列1和2
- en: An optional binary predicate `pred` to compare whether two elements are equal
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元谓词`pred`，用于比较两个元素是否相等
- en: '**Complexity**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Quadratic** The algorithm makes at most the following number of comparisons
    or invocations of `pred`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**二次** 该算法最多进行以下次数的比较或调用`pred`：'
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Examples**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After constructing a `vector` containing `string` objects called `words1` ➊
    and another called `words2` ➋, you invoke `find_end` to determine which element
    in `words1` begins the subsequence equal to `words2` ➌. The result is `find_``end_result1`,
    which equals the element `girl` ➍.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造一个包含`string`对象的`vector`，命名为`words1` ➊，另一个名为`words2` ➋之后，你调用`find_end`来确定`words1`中哪个元素开始匹配`words2`的子序列
    ➌。结果是`find_end_result1`，其值为`girl` ➍。
- en: Next, you construct the lambda `has_length`, which takes two arguments, `word`
    and `len`, and returns `true` if `word.length()` equals `len` ➎. You construct
    a `vector` of `size_t` objects called `sizes` ➏ and invoke `find_end` with `words1`,
    `sizes`, and `has_length` ➐. The result, `find_end_result2`, points to the first
    element in `words1` that has length `4` with the subsequent word having length
    `6`. Because `girl` has length `4` and `googoo` has length `6`, `find_end_result2`
    points to `girl` ➑.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你构造了一个lambda表达式`has_length`，它接受两个参数`word`和`len`，如果`word.length()`等于`len`
    ➎，则返回`true`。你构造了一个名为`sizes`的`size_t`类型的`vector` ➏，并用`words1`、`sizes`和`has_length`调用`find_end`
    ➐。结果`find_end_result2`指向`words1`中第一个长度为`4`的元素，后面的单词长度为`6`。由于`girl`的长度为`4`，`googoo`的长度为`6`，所以`find_end_result2`指向`girl`
    ➑。
- en: '***find_first***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***find_first***'
- en: The `find_first_of` algorithm finds the first occurrence in sequence 1 equal
    to some element in sequence 2.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_first_of`算法查找序列1中第一个等于序列2中某个元素的位置。'
- en: If you provide `pred`, the algorithm finds the first occurrence i in sequence
    1 where, for some `j` in sequence 2, `pred (`i, j`)` is `true`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`pred`，算法查找目标序列1中第一个满足对于序列2中的某个`j`，`pred(i, j)`为`true`的元素i。
- en: If `find_first_of` finds no such sequence, it returns `ipt_end1`. If `find_first_of`
    does find a subsequence, it returns an `InputIterator` pointing to the first element
    of the first matching subsequence. (Note that if `ipt_begin1` is also a `ForwardIterator`,
    `find_first_of` instead returns a `ForwardIterator`.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`find_first_of`没有找到该子序列，则返回`ipt_end1`。如果`find_first_of`找到一个子序列，则返回一个指向第一个匹配子序列元素的`InputIterator`。（注意，如果`ipt_begin1`也是一个`ForwardIterator`，`find_first_of`将返回一个`ForwardIterator`。）
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Arguments**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin1` / `ipt_end1`, representing the
    target sequence 1
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin1` / `ipt_end1`，表示目标序列1
- en: A pair of `ForwardIterator`s, `fwd_begin2` / `fwd_end2`, representing the target
    sequence 2
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`对象，`fwd_begin2` / `fwd_end2`，表示目标序列2
- en: An optional binary predicate, `pred`, to compare whether two elements are equal
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元谓词`pred`，用于比较两个元素是否相等
- en: '**Complexity**'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Quadratic** The algorithm makes at most the following number of comparisons
    or invocations of `pred`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**二次** 算法最多进行以下次数的比较或`pred`调用：'
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Example**'
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After constructing a `vector` containing `string` objects called `words` ➊ and
    another called `indefinite_articles` ➋, you invoke `find_first_of` to determine
    which element in `words` begins the subsequence equal to `indefinite_articles`
    ➌. The result is `find_first_of_result`, which equals the element `a` ➍.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造一个包含`string`对象的`vector`，名为`words` ➊，以及另一个名为`indefinite_articles` ➋之后，调用`find_first_of`来确定`words`中哪个元素开始的子序列等于`indefinite_articles`
    ➌。结果是`find_first_of_result`，其值为元素`a` ➍。
- en: '***adjacent_find***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***adjacent_find***'
- en: The `adjacent_find` algorithm finds the first repeat in a sequence.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`adjacent_find`算法找到序列中的第一个重复元素。'
- en: The algorithm finds the first occurrence in the target sequence where two adjacent
    elements are equal or where, if you provide `pred`, the algorithm finds the first
    occurrence element i in the sequence where `pred (`i, i`+1)` is `true`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 算法查找目标序列中第一个相邻元素相等的位置，或者如果提供了`pred`，算法查找目标序列中第一个满足`pred(i, i+1)`为`true`的元素。
- en: If `adjacent_find` finds no such element, it returns `fwd_end`. If `adjacent_find`
    does find such an element, it returns a `ForwardIterator` pointing to it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`adjacent_find`没有找到该元素，则返回`fwd_end`。如果`adjacent_find`找到了该元素，则返回一个指向该元素的`ForwardIterator`。
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Arguments**'
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `ForwardIterator`s, `fwd_begin` / `fwd_end`, representing the target
    sequence
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`对象，`fwd_begin` / `fwd_end`，表示目标序列
- en: An optional binary predicate `pred` to compare whether two elements are equal
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元谓词`pred`用于比较两个元素是否相等
- en: '**Complexity**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** When no execution policy is given, the algorithm makes at most the
    following number of comparisons or invocations of `pred`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 如果没有提供执行策略，算法最多进行以下次数的比较或`pred`调用：'
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: where i is the index of the return value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 其中i是返回值的索引。
- en: '**Example**'
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you construct a lambda called `first_letters_match`, which takes two words and
    evaluates whether they start with the first letter ➋. You invoke `adjacent_find`
    to determine which element has the same first letter as the subsequent letter
    ➌. The result, `adjacent_find_result` ➍, equals `is` because it shares a first
    letter with `itchy` ➍.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造一个包含`string`对象的`vector`，名为`words` ➊之后，构造一个名为`first_letters_match`的lambda，该lambda接受两个单词并判断它们是否以相同的字母开头
    ➋。调用`adjacent_find`来确定哪个元素与后续字母具有相同的首字母 ➌。结果`adjacent_find_result` ➍为`is`，因为它与`itchy`共享首字母
    ➍。
- en: '***count***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***count***'
- en: The `count` algorithm counts the elements in a sequence matching some user-defined
    criteria.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`算法统计序列中符合某些用户定义标准的元素数量。'
- en: The algorithm returns the number of elements `i` in the target sequence where
    `pred` `(`i`)` is `true` or where `value ==` i. Usually, `DifferenceType` is `size_t`,
    but it depends on the implementation of `InputIterator`. You use `count` when
    you want to count the occurrences of a particular value, and you use `count_if`
    when you have a more complicated predicate you want to use for comparison.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 算法返回目标序列中`i`元素的数量，其中`pred`(`i`)为`true`，或者`value == i`。通常，`DifferenceType`是`size_t`，但它取决于`InputIterator`的实现。当你想要统计某个特定值的出现次数时，你使用`count`，而当你有一个更复杂的谓词想要用于比较时，你使用`count_if`。
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Arguments**'
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` / `ipt_end`, representing the
    target sequence
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin` / `ipt_end`，表示目标序列。
- en: Either a `value` or a unary predicate `pred` to evaluate whether an element
    `x` in the target sequence should be counted
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`value`或一个一元谓词`pred`，用于评估目标序列中的元素`x`是否应被计数。
- en: '**Complexity**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** When no execution policy is given, the algorithm makes `distance
    (ipt_begin, ipt_end)` comparisons or invocations of `pred`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 如果没有给定执行策略，算法会进行`distance (ipt_begin, ipt_end)`次比较或`pred`调用。'
- en: '**Examples**'
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After constructing a `vector` containing `string` objects called `words` ➊,
    you use it to invoke `count` with the value `and` ➋. This returns `1`, because
    a single element equals `and` ➌. Next, you construct a lambda called `contains_a`,
    which takes a word and evaluates whether it contains `a` ➍. You invoke `count_if`
    to determine how many words contain `a` ➎. The result equals `3` because three
    elements contain `a` ➏.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造一个包含`string`对象的`vector`，名为`words` ➊之后，你用它来调用`count`，值为`and` ➋。这会返回`1`，因为一个元素等于`and`
    ➌。接下来，你构造一个名为`contains_a`的lambda，它接受一个单词并判断它是否包含`a` ➍。你调用`count_if`来确定有多少个单词包含`a`
    ➎。结果为`3`，因为有三个元素包含`a` ➏。
- en: '***mismatch***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不匹配***'
- en: The `mismatch` algorithm finds the first mismatch in two sequences.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`mismatch`算法用于查找两个序列中的第一个不匹配项。'
- en: The algorithm finds the first mismatched element pair `i`, `j` from sequence
    1 and sequence 2\. Specifically, it finds the first index n such that i `= (ipt_begin1
    +` n`)`; j `= (ipt_begin2 +` n`)`; and i `!=` j or `pred(`i`,` j`)` `== false`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 算法找到来自序列1和序列2的第一个不匹配元素对`i`、`j`。具体来说，它找出第一个索引n，使得`i = (ipt_begin1 + n)`；`j =
    (ipt_begin2 + n)`；并且`i != j`或`pred(i, j) == false`。
- en: The types of the iterators in the returned `pair` equal the types of `ipt_begin1`
    and `ipt_begin2`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`pair`中的迭代器类型与`ipt_begin1`和`ipt_begin2`的类型相等。
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Arguments**'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`).'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）。
- en: Two pairs of `InputIterator`s, `ipt_begin1` / `ipt_end1` and `ipt_begin2` /
    `ipt_end2`, representing the target sequences `1` and `2`. If you don’t provide
    `ipt_``end2`, sequence 1’s length implies sequence 2’s length.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两对`InputIterator`，`ipt_begin1` / `ipt_end1`和`ipt_begin2` / `ipt_end2`，表示目标序列`1`和`2`。如果你没有提供`ipt_end2`，则序列1的长度隐含着序列2的长度。
- en: An optional binary predicate `pred` to compare whether two elements are equal.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元谓词`pred`用于比较两个元素是否相等。
- en: '**Complexity**'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** When no execution policy is given, at worst the algorithm makes
    the following number of comparisons or invocations of `pred`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 如果没有给定执行策略，最坏情况下算法会进行以下次数的比较或`pred`调用：'
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Examples**'
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After constructing two `vector`s of `string`s called `words1` ➊ and `words2`
    ➋, you use them as the target sequences for `mismatch` ➌. This returns a `pair`
    pointing to the elements `Kangaroo` and `bandicoot` ➍ ➎. Next, you construct a
    lambda called `second_letter_matches`, which takes two words and evaluates whether
    their second letters match ➏. You invoke `mismatch` to determine the first pair
    of elements with mismatched second letters ➐. The result is the pair `Kick` ➑
    and `roundhouse` ➒.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造两个`vector`类型的`string`序列，名为`words1` ➊和`words2` ➋之后，你将它们作为`mismatch`的目标序列 ➌。这会返回一个`pair`，指向元素`Kangaroo`和`bandicoot`
    ➍ ➎。接下来，你构造一个名为`second_letter_matches`的lambda，它接受两个单词并判断它们的第二个字母是否相同 ➏。你调用`mismatch`来找出第一个第二个字母不匹配的元素对
    ➐。结果是元素对`Kick` ➑和`roundhouse` ➒。
- en: '***equal***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***相等***'
- en: The `equal` algorithm determines whether two sequences are equal.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal`算法用于判断两个序列是否相等。'
- en: The algorithm determines whether sequence 1’s elements equal sequence 2’s.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 算法用于判断序列1的元素是否与序列2的元素相等。
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Arguments**'
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)
    .'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略`ep`（默认：`std::execution::seq`）。
- en: Two pairs of `InputIterator`s, `ipt_begin1` / `ipt_end1` and `ipt_begin2` /
    `ipt_end2`, representing the target sequences `1` and `2`. If you don’t provide
    `ipt_end2`, sequence 1’s length implies sequence 2’s length.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两对`InputIterator`，`ipt_begin1` / `ipt_end1` 和 `ipt_begin2` / `ipt_end2`，表示目标序列1和2。如果没有提供`ipt_end2`，则序列1的长度意味着序列2的长度。
- en: An optional binary predicate `pred` to compare whether two elements are equal.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元谓词`pred`，用于比较两个元素是否相等。
- en: '**Complexity**'
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** When no execution policy is given, at worst the algorithm makes
    the following number of comparisons or invocations of `pred`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 当没有给出执行策略时，算法在最坏情况下进行以下数量的比较或调用`pred`：'
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Examples**'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After constructing two `vector`s of `string`s called `words1` and `words2` ➊
    ➋, you use them as the target sequences for `equal` ➌. Because their last elements,
    `lick` and `kick`, aren’t equal, `equal_result1` is `false` ➍. After setting the
    third element of `words2` to the third element of `words1` ➎, you again invoke
    `equal` with the same arguments ➏. Because the sequences are now identical, `equal_result2`
    is `true` ➐.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造两个名为`words1`和`words2`的`vector<string>` ➊ ➋ 后，您将它们作为`equal`的目标序列 ➌。因为它们的最后一个元素`lick`和`kick`不相等，`equal_result1`为`false`
    ➍。在将`words2`的第三个元素设置为`words1`的第三个元素 ➎ 后，您再次使用相同的参数调用`equal` ➏。因为序列现在相同，`equal_result2`为`true`
    ➐。
- en: '***is_permutation***'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***is_permutation***'
- en: The `is_permutation` algorithm determines whether two sequences are permutations,
    meaning they contain the same elements but potentially in a different order.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_permutation`算法确定两个序列是否是排列，即它们包含相同的元素，但可能顺序不同。'
- en: The algorithm determines whether some permutation of sequence 2 exists such
    that sequence 1’s elements equal the permutation’s.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 算法确定是否存在序列2的某个排列，使得序列1的元素等于该排列的元素。
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Arguments**'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)
    .'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略`ep`（默认：`std::execution::seq`）。
- en: Two pairs of `ForwardIterator`s, `fwd_begin1` / `fwd_end1` and `fwd_begin2`
    / `fwd_end2`, representing the target sequences 1 and 2\. If you don’t provide
    `fwd_end2`, sequence 1’s length implies sequence 2’s length.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两对`ForwardIterator`，`fwd_begin1` / `fwd_end1` 和 `fwd_begin2` / `fwd_end2`，表示目标序列1和2。如果没有提供`fwd_end2`，则序列1的长度意味着序列2的长度。
- en: An optional binary predicate `pred` to compare whether two elements are equal.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元谓词`pred`，用于比较两个元素是否相等。
- en: '**Complexity**'
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Quadratic** When no execution policy is given, at worst the algorithm makes
    the following number of comparisons or invocations of `pred`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**二次方** 当没有给出执行策略时，算法在最坏情况下进行以下数量的比较或调用`pred`：'
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Example**'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After constructing two `vector`s of `string`s called `words1` and `words2` ➊
    ➋, you use them as the target sequences for `is_permutation` ➌. Because `words2`
    is a permutation of `words1`, `is_permutation` returns `true` ➍.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造两个名为`words1`和`words2`的`vector<string>` ➊ ➋ 后，您将它们作为`is_permutation`的目标序列
    ➌。因为`words2`是`words1`的排列，`is_permutation`返回`true` ➍。
- en: '**NOTE**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The <algorithm> header also contains next_permutation and prev_permutation
    for manipulating a range of elements so you can generate permutations. See [alg.permutation.generators].*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*<algorithm>头文件还包含next_permutation和prev_permutation，用于操作元素范围，以便生成排列。参见[alg.permutation.generators]。*'
- en: '***search***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***search***'
- en: The `search` algorithm locates a subsequence.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`算法用于定位子序列。'
- en: The algorithm locates sequence 2 within sequence 1\. In other words, it returns
    the first iterator i in sequence 1 such that for each non-negative integer `n`,
    `*(i + n)` equals `*(ipt_begin2 + n)`, or if you provide a predicate `pred(*(i
    + n)`, `*(ipt_begin2 + n))` is `true`. The `search` algorithm returns `ipt_begin1`
    if sequence 2 is empty or `ipt_begin2` if no subsequence is found. This is different
    from `find` because it locates a subsequence rather than a single element.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在序列1中定位序列2。换句话说，它返回序列1中的第一个迭代器i，使得对于每个非负整数`n`，`*(i + n)`等于`*(ipt_begin2 +
    n)`，或者如果提供了谓词`pred(*(i + n), *(ipt_begin2 + n))`为`true`。如果序列2为空，`search`算法返回`ipt_begin1`，如果没有找到子序列，则返回`ipt_begin2`。这与`find`不同，因为它定位的是子序列，而不是单个元素。
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Arguments**'
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略`ep`（默认：`std::execution::seq`）。
- en: Two pairs of `ForwardIterator`s, `fwd_begin1` / `fwd_end1` and `fwd_begin2`
    / `fwd_end2`, representing the target sequences 1 and 2
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两对 `ForwardIterator`，`fwd_begin1` / `fwd_end1` 和 `fwd_begin2` / `fwd_end2`，表示目标序列
    1 和 2
- en: An optional binary predicate `pred` to compare whether two elements are equal
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元谓词 `pred`，用于比较两个元素是否相等
- en: '**Complexity**'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Quadratic** When no execution policy is given, at worst the algorithm makes
    the following number of comparisons or invocations of `pred`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**二次复杂度** 如果没有给定执行策略，最坏情况下该算法会进行以下次数的比较或 `pred` 调用：'
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Examples**'
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After constructing two `vector`s of `string`s called `words1` ➊ and `words2`
    ➋, you use them as the target sequences for `search` ➌. Because `words2` is a
    subsequence of `words1`, `search` returns an iterator pointing to `and` ➍. The
    `vector` containing `string` objects `words3` ➎ contains the word `nightpant`
    instead of `nightshirt`, so invoking `search` with it instead of `words2` ➏ yields
    the end iterator of `words1` ➐.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了两个名为 `words1` ➊ 和 `words2` ➋ 的 `vector` 类型的 `string` 序列后，你将它们作为 `search`
    的目标序列 ➌。由于 `words2` 是 `words1` 的子序列，`search` 返回指向 `and` 的迭代器 ➍。包含 `string` 对象的
    `vector` `words3` ➎ 包含了单词 `nightpant` 而不是 `nightshirt`，因此使用它而不是 `words2` 调用 `search`
    会返回 `words1` 的末尾迭代器 ➐。
- en: '***search_n***'
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***search_n***'
- en: The `search_n` algorithm locates a subsequence containing identical, consecutive
    values.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`search_n` 算法定位包含相同连续值的子序列。'
- en: The algorithm searches for `count` consecutive `values` in the sequence and
    returns an iterator pointing to the first `value`, or it returns `fwd_end` if
    no such subsequence is found. This is different from `adjacent_find` because it
    locates a subsequence rather than a single element.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法在序列中查找 `count` 个连续的 `values`，并返回一个指向第一个 `value` 的迭代器，或者如果未找到此子序列，则返回 `fwd_end`。与
    `adjacent_find` 不同，它定位的是一个子序列而不是单个元素。
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Arguments**'
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::``seq`)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `std::execution` 执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `ForwardIterator`s, `fwd_begin` / `fwd_end`, representing the target
    sequence
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对 `ForwardIterator`，`fwd_begin` / `fwd_end`，表示目标序列
- en: An integral `count` value representing the number of consecutive matches you
    want to find
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数型 `count` 值，表示你想查找的连续匹配的数量
- en: A `value` representing the element you want to find
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `value`，表示你要查找的元素
- en: An optional binary predicate `pred` to compare whether two elements are equal
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元谓词 `pred`，用于比较两个元素是否相等
- en: '**Complexity**'
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** When no execution policy is given, at worst the algorithm makes
    `distance(fwd_begin, fwd_end)` comparisons or invocations of `pred`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 如果没有给定执行策略，最坏情况下该算法会进行 `distance(fwd_begin, fwd_end)` 次比较或 `pred` 调用。'
- en: '**Example**'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After constructing a `vector` of `string`s called `words` ➊, you use it as the
    target sequence for `search_n` ➋. Because `words` contains three instances of
    the word `owl`, it returns an iterator pointing to the first instance ➌.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了一个名为 `words` 的 `vector` 类型的 `string` 序列后 ➊，你将它作为 `search_n` 的目标序列 ➋。由于 `words`
    中包含三个 `owl` 单词的实例，它会返回指向第一个实例的迭代器 ➌。
- en: '**Mutating Sequence Operations**'
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**变异序列操作**'
- en: A *mutating sequence operation* is an algorithm that performs computation over
    a sequence and is allowed to modify the sequence in some way. Each algorithm explained
    in this section is in the `<algorithm>` header.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *变异序列操作* 是一种算法，它对序列进行计算，并允许以某种方式修改序列。本节中解释的每个算法都位于 `<algorithm>` 头文件中。
- en: '***copy***'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***copy***'
- en: The `copy` algorithm copies one sequence into another.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy` 算法将一个序列复制到另一个序列中。'
- en: The algorithm copies the target sequence into `result` and returns the receiving
    sequence’s end iterator. It’s your responsibility to ensure that `result` represents
    a sequence with enough space to store the target sequence.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法将目标序列复制到 `result` 中，并返回接收序列的末尾迭代器。你有责任确保 `result` 表示一个具有足够空间来存储目标序列的序列。
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Arguments**'
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `std::execution` 执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对 `InputIterator` 对象，`ipt_begin` 和 `ipt_end`，表示目标序列
- en: An `OutputIterator`, `result`, that receives the copied sequence
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `OutputIterator`，`result`，接收复制的序列
- en: '**Complexity**'
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm copies elements from the target sequence exactly `distance(ipt_begin,
    ipt_end)` times.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法会从目标序列中复制元素，恰好执行 `distance(ipt_begin, ipt_end)` 次。'
- en: '**Additional Requirements**'
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: Sequences 1 and 2 must not overlap unless the operation is a *copy to the left*.
    For example, for a vector `v` with 10 elements, `std::copy(v.begin()+3, v.end(),
    v.begin())` is well defined, but `std::copy(v.begin(), v.begin()+7, v.begin()+3)`
    is not.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 序列 1 和 2 必须不重叠，除非操作是 *向左复制*。例如，对于一个包含 10 个元素的向量 `v`，`std::copy(v.begin()+3,
    v.end(), v.begin())` 是合法的，但 `std::copy(v.begin(), v.begin()+7, v.begin()+3)` 不是。
- en: '**NOTE**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Recall the back_inserter in “Insert Iterators” on [page 464](ch14.xhtml#page_464),
    which returns an output iterator that converts write operations into insert operations
    on the underlying container.*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*回顾一下“插入迭代器”中的 back_inserter，见 [第 464 页](ch14.xhtml#page_464)，它返回一个输出迭代器，将写操作转换为在底层容器上的插入操作。*'
- en: '**Example**'
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After constructing two `vector`s of `string` objects ➊ ➋, you invoke `copy`
    with `words1` as the sequence to `copy` ➌ and `words2` as the destination sequence
    ➍. The result is that `words2` contains the contents of `words1` appended to the
    original contents ➎.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造两个 `vector` 类型的 `string` 对象后 ➊ ➋，你使用 `copy`，将 `words1` 作为待复制序列 ➌，`words2`
    作为目标序列 ➍。结果是 `words2` 包含了 `words1` 的内容，并追加到原始内容后 ➎。
- en: '***copy_n***'
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***copy_n***'
- en: The `copy_n` algorithm copies one sequence into another.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy_n` 算法将一个序列复制到另一个序列中。'
- en: The algorithm copies the target sequence into `result` and returns the receiving
    sequence’s end iterator. It’s your responsibility to ensure that `result` represents
    a sequence with enough space to store the target sequence and that `n` represents
    the correct length of the target sequence.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法将目标序列复制到 `result` 中，并返回接收序列的末尾迭代器。你需要确保 `result` 代表一个具有足够空间存储目标序列的序列，并且 `n`
    代表目标序列的正确长度。
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Arguments**'
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `std::execution` 执行策略，`ep`（默认值：`std::execution::seq`）
- en: A begin iterator, `ipt_begin`, representing the beginning of the target sequence
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示目标序列起始位置的开始迭代器，`ipt_begin`
- en: The size of the target sequence, `n`
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标序列的大小，`n`
- en: An `OutputIterator result` that receives the copied sequence
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `OutputIterator result`，接收复制后的序列
- en: '**Complexity**'
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm copies elements from the target sequence exactly `distance(ipt_begin,
    ipt_end)` times.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法将从目标序列中复制 `distance(ipt_begin, ipt_end)` 次元素。'
- en: '**Additional Requirements**'
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: Sequences 1 and 2 must not contain the same objects unless the operation is
    a *copy to the left*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 序列 1 和 2 必须不包含相同的对象，除非操作是 *向左复制*。
- en: '**Example**'
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE41]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After constructing two `vector`s of `string` objects ➊➋, you invoke `copy_n`
    with `words1` as the sequence to `copy_n` ➌ and `words2` as the destination sequence
    ➍. The result is that `words2` contains the contents of `words1` appended to the
    original contents ➎.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造两个 `vector` 类型的 `string` 对象后 ➊ ➋，你使用 `copy_n`，将 `words1` 作为待复制序列 ➌，`words2`
    作为目标序列 ➍。结果是 `words2` 包含了 `words1` 的内容，并追加到原始内容后 ➎。
- en: '***copy_backward***'
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***copy_backward***'
- en: The `copy_backward` algorithm copies the reverse of one sequence into another.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy_backward` 算法将一个序列的元素反向复制到另一个序列中。'
- en: The algorithm copies sequence 1 into sequence 2 and returns the receiving sequence’s
    end iterator. Elements copy backward but will appear in the target sequence in
    the original order. It’s your responsibility to ensure that sequence 1 represents
    a sequence with enough space to store sequence 2.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法将序列 1 复制到序列 2 中，并返回接收序列的末尾迭代器。元素会反向复制，但在目标序列中仍然按原顺序出现。你需要确保序列 1 有足够的空间来存储序列
    2。
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Arguments**'
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `std::execution` 执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin1` and `ipt_end1`, representing
    sequence 1
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对 `InputIterator` 对象，`ipt_begin1` 和 `ipt_end1`，表示序列 1
- en: An `InputIterator`, `ipt_end2`, representing 1 past the end of sequence 2
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `InputIterator`，`ipt_end2`，表示序列 2 末尾之后的位置
- en: '**Complexity**'
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm copies elements from the target sequence exactly `distance(ipt_begin1,
    ipt_end1)` times.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法将从目标序列中复制 `distance(ipt_begin1, ipt_end1)` 次元素。'
- en: '**Additional Requirements**'
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: Sequences 1 and 2 must not overlap.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 序列 1 和 2 必须不重叠。
- en: '**Example**'
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE43]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After constructing two `vector`s of `string`s ➊ ➋, you invoke `copy_backward`
    with `words2` as the sequence to copy ➌ and `words1` as the destination sequence
    ➍. The result is that the contents of `word2` replace the last three words of
    `words1` ➎.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造了两个`string`类型的`vector`对象 ➊ ➋后，你调用`copy_backward`，以`words2`作为要复制的序列 ➌，`words1`作为目标序列
    ➍。结果是，`word2`的内容替换了`words1`的最后三个单词 ➎。
- en: '***move***'
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***move***'
- en: The `move` algorithm moves one sequence into another.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`move`算法将一个序列移动到另一个序列中。'
- en: The algorithm moves the target sequence and returns the receiving sequence’s
    end iterator. It’s your responsibility to ensure that the target sequence represents
    a sequence with at least as many elements as the source sequence.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 算法将目标序列移动并返回接收序列的结束迭代器。你有责任确保目标序列的元素至少与源序列一样多。
- en: '[PRE44]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Arguments**'
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin`和`ipt_end`，表示目标序列
- en: An `InputIterator`, `result`, representing the beginning of the sequence to
    move into
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`InputIterator`，`result`，表示要移动到的序列的起始位置
- en: '**Complexity**'
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm moves elements from the target sequence exactly `distance(ipt_begin,
    ipt_end)` times.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 算法从目标序列中移动元素，恰好`distance(ipt_begin, ipt_end)`次。'
- en: '**Additional Requirements**'
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: Sequences must not overlap unless *moving to the left*.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列不得重叠，除非是*向左移动*。
- en: Types must be moveable but not necessarily copyable.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型必须是可移动的，但不一定是可复制的。
- en: '**Example**'
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE45]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: First, you declare the `MoveDetector`’s class ➊, which defines a default constructor
    setting its only member `owner` to `true` ➋. It deletes the copy and move constructor
    and the copy assignment operator but defines a move assignment operator that swaps
    `owner` ➌.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明了`MoveDetector`类 ➊，它定义了一个默认构造函数，将唯一的成员`owner`设置为`true` ➋。它删除了复制构造函数和移动构造函数，以及复制赋值运算符，但定义了一个移动赋值运算符，用于交换`owner`
    ➌。
- en: After constructing two `vector`s of `MoveDetector` objects ➍ ➎, you invoke `move`
    with `detectors1` as the sequence to `move` and `detectors2` as the destination
    sequence ➏. The result is that the elements of `detector1` are in a *moved from*
    state ➐➑ and the elements of `detector2` are moved into `detectors2` ➒➓.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造了两个`MoveDetector`对象的`vector` ➍ ➎后，你调用`move`，以`detectors1`作为要`move`的序列，`detectors2`作为目标序列
    ➏。结果是，`detector1`的元素处于*moved from*状态 ➐➑，而`detectors2`的元素被移动到`detectors2` ➒➓。
- en: '***move_backward***'
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***move_backward***'
- en: The `move_backward` algorithm moves the reverse of one sequence into another.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`move_backward`算法将一个序列的反向内容移动到另一个序列中。'
- en: The algorithm moves sequence 1 into sequence 2 and returns an iterator pointing
    to the last moved element. Elements move backward but will appear in the target
    sequence in the original order. It’s your responsibility to ensure that the target
    sequence represents a sequence with at least as many elements as the source sequence.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 算法将序列1移动到序列2，并返回一个指向最后一个移动元素的迭代器。元素向后移动，但会以原始顺序出现在目标序列中。你有责任确保目标序列的元素至少与源序列一样多。
- en: '[PRE46]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Arguments**'
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin`和`ipt_end`，表示目标序列
- en: An `InputIterator`, `result`, representing the sequence to move into
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`InputIterator`，`result`，表示要移动到的序列
- en: '**Complexity**'
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm moves elements from the target sequence exactly `distance(ipt_begin,
    ipt_end)` times.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 算法从目标序列中移动元素，恰好`distance(ipt_begin, ipt_end)`次。'
- en: '**Additional Requirements**'
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: Sequences must not overlap.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列不得重叠。
- en: Types must be moveable but not necessarily copyable.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型必须是可移动的，但不一定是可复制的。
- en: '**Example**'
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE47]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, you declare the `MoveDetector` class ➊ (see “`move`” back on [page 595](ch18.xhtml#page_595)
    for the implementation).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明了`MoveDetector`类 ➊（有关实现，请参见“`move`”章节，第[595页](ch18.xhtml#page_595)）。
- en: After constructing two `vector`s of `MoveDetector` objects ➋ ➌, you invoke `move`
    with `detectors1` as the sequence to `move` and `detectors2` as the destination
    sequence ➍. The result is that the elements of `detector1` are in a *moved from*
    state ➎➏ and the elements of `detector2` are *moved into* ➐➑.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造了两个`MoveDetector`对象的`vector`后 ➋ ➌，你调用`move`，将`detectors1`作为要`move`的序列，`detectors2`作为目标序列
    ➍。结果是，`detector1`的元素处于*已移动出*状态 ➎➏，`detector2`的元素处于*已移动入*状态 ➐➑。
- en: '***swap_ranges***'
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***swap_ranges***'
- en: The `swap_ranges` algorithm exchanges elements from one sequence into another.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap_ranges`算法将一个序列的元素交换到另一个序列中。'
- en: The algorithm calls `swap` on each element of sequence 1 and sequence 2, and
    it returns the receiving sequence’s end iterator. It’s your responsibility to
    ensure that the target sequence represents a sequence with at least as many elements
    as the source sequence.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法对序列1和序列2的每个元素调用`swap`，并返回接收序列的结束迭代器。你有责任确保目标序列的元素数量至少与源序列相同。
- en: '[PRE48]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Arguments**'
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）。
- en: A pair of `ForwardIterator`s, `ipt_begin1` and `ipt_end1`, representing sequence
    1
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`，`ipt_begin1`和`ipt_end1`，表示序列1。
- en: A `ForwardIterator`, `ipt_begin2`, representing the beginning of sequence 2
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ForwardIterator`，`ipt_begin2`，表示序列2的开始。
- en: '**Complexity**'
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm calls `swap` exactly `distance(ipt_begin1, ipt_end1)`
    times.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法会调用`swap`正好`distance(ipt_begin1, ipt_end1)`次。'
- en: '**Additional Requirements**'
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements contained in each sequence must be swappable.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 每个序列中包含的元素必须是可交换的。
- en: '**Example**'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE49]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After constructing two `vector`s of `string`s ➊ ➋, you invoke `swap` with `words1`
    and `words2` as the sequences to swap ➌. The result is that `words1` and `words2`
    swap contents ➍ ➎.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造了两个包含`string`对象的`vector`后 ➊ ➋，你调用`swap`，将`words1`和`words2`作为要交换的序列 ➌。结果是`words1`和`words2`交换内容
    ➍ ➎。
- en: '***transform***'
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***transform***'
- en: The `transform` algorithm modifies the elements of one sequence and writes them
    into another.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform`算法修改一个序列中的元素，并将其写入另一个序列。'
- en: The algorithm invokes `unary_op` on each element of the target sequence and
    outputs it into the output sequence, or it invokes `binary_op` on corresponding
    elements of each target sequence.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法对目标序列的每个元素调用`unary_op`并将其输出到输出序列，或者对每个目标序列中的相应元素调用`binary_op`。
- en: '[PRE50]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Arguments**'
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`).'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）。
- en: A pair of `InputIterator` objects, `ipt_begin1` and `ipt_end1`, representing
    the target sequence.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin1`和`ipt_end1`，表示目标序列。
- en: An optional `InputIterator`, `ipt_begin2`, representing a second target sequence.
    You must ensure that this second target sequence has at least as many elements
    as the first target sequence.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`InputIterator`，`ipt_begin2`，表示第二个目标序列。你必须确保第二个目标序列的元素数量至少与第一个目标序列相同。
- en: An `OutputIterator`, `result`, representing the beginning of the output sequence.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`OutputIterator`，`result`，表示输出序列的开始。
- en: A unary operation, `unary_op`, that transforms elements of the target sequence
    into elements of the output sequence. If you supply two target sequences, you
    instead provide a binary operation, `binary_op`, which accepts an element from
    each target sequence and transforms each into an element of the output sequence.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元操作，`unary_op`，用于将目标序列的元素转换为输出序列的元素。如果你提供了两个目标序列，则提供一个二元操作`binary_op`，它接受每个目标序列中的一个元素，并将它们转换为输出序列中的元素。
- en: '**Complexity**'
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `unary_op` or `binary_op` exactly `distance(ipt_begin1,
    ipt_end1)` times.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法会调用`unary_op`或`binary_op`，正好调用`distance(ipt_begin1, ipt_end1)`次。'
- en: '**Examples**'
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE51]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After constructing a `vector` containing `string` objects ➊, you construct a
    lambda called `upper`, which takes a `string` by value and converts it to uppercase
    using the Boost `to_upper` algorithm discussed in [Chapter 15](ch15.xhtml#ch15)
    ➋. You invoke transform with `words1` as the target sequence, a `back_inserter`
    for an empty `results1` vector, and `upper` as the unary operation ➌. After `transform`,
    `results1` contains the uppercase version of `words1` ➍.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造了一个包含`string`对象的`vector`后 ➊，你构造了一个名为`upper`的lambda，它按值接受一个`string`并使用Boost的`to_upper`算法将其转换为大写，如[第15章](ch15.xhtml#ch15)中讨论的
    ➋。你使用`transform`，将`words1`作为目标序列，使用一个空的`results1``vector`的`back_inserter`，并将`upper`作为一元操作
    ➌。调用`transform`后，`results1`包含了`words1`的大写版本 ➍。
- en: In the second example, you construct two `vector`s of `string` objects ➎➏. You
    also construct a lambda called `portmantize` that accepts two `string` objects
    ➐. The lambda returns a new `string` containing up to two letters from the beginning
    of the first argument and up to three letters from the end of the second argument.
    You pass the two target sequences, a `back_inserter` to an empty `vector` called
    `results2` and `portmantize` ➑. The `result2` contains portmanteaus of the contents
    of `words1` and `words2` ➒.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，您构造了两个 `vector` 类型的 `string` 对象 ➎➏。您还构造了一个名为 `portmantize` 的 lambda
    函数，该函数接受两个 `string` 对象 ➐。该 lambda 返回一个新的 `string`，包含第一个参数的前两个字母和第二个参数的后三个字母。您将两个目标序列、一个指向空
    `vector` 的 `back_inserter` 以及 `portmantize` ➑ 一同传递。`result2` 包含了 `words1` 和 `words2`
    的混合词 ➒。
- en: '***replace***'
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***replace***'
- en: The `replace` algorithm replaces certain elements of a sequence with some new
    element.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace` 算法将序列中的某些元素替换为新的元素。'
- en: The algorithm searches for target sequence elements x for which either x `==
    old_ref` or `pred(`x`) == true` and assigns them to `new_ref`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 算法查找目标序列元素 x，对于满足 `x == old_ref` 或 `pred(x) == true` 的元素，将其赋值为 `new_ref`。
- en: '[PRE52]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**Arguments**'
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `std::execution` 执行策略 `ep`（默认值：`std::execution::seq`）
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对 `ForwardIterator`，`fwd_begin` 和 `fwd_end`，表示目标序列
- en: An `OutputIterator`, `result`, representing the beginning of the output sequence
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `OutputIterator`，`result`，表示输出序列的起始位置
- en: An `old` `const` reference representing the element to find
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `old` `const` 引用，表示要查找的元素
- en: A unary predicate, `pred`, that determines whether an element meets the criteria
    for replacement
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元谓词 `pred`，用于判断元素是否符合替换条件
- en: A `new_ref` `const` reference that represents the element to replace
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `new_ref` `const` 引用，表示要替换的元素
- en: '**Complexity**'
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `pred` exactly `distance(fwd_begin, fwd_end)`
    times.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 算法调用 `pred` 恰好 `distance(fwd_begin, fwd_end)` 次。'
- en: '**Additional Requirements**'
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements contained in each sequence must be comparable to `old_ref` and
    assignable to `new_ref`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 每个序列中的元素必须能够与 `old_ref` 进行比较，并且能够赋值给 `new_ref`。
- en: '**Examples**'
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE53]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You first bring in the `std::literals` namespace ➊ so you can employ the `string_view`
    literal later on. After constructing a `vector` containing `string` objects ➋,
    you invoke `replace` with the `vector` ➌ to replace all instances of `try` with
    `spoon` ➍.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 首先引入 `std::literals` 命名空间 ➊，这样您就可以稍后使用 `string_view` 字面量。构造一个包含 `string` 对象的
    `vector` ➋ 后，您调用 `replace` 并使用该 `vector` ➌ 来将所有 `try` 替换为 `spoon` ➍。
- en: In the second example, you construct two `vector`s of `string` objects ➎➏ and
    a lambda called `has_two_os`, which accepts a string and returns `true` if it
    contains exactly two `o`s ➐. You then pass `words2` as the target sequence and
    `words3` as the destination sequence to `replace_copy_if`, which applies `has_two_os`
    to each element of `words2` and replaces elements that evaluate to `true` with
    `try` ➑. The result is that `words2` is unaffected and `words3` has the element
    `spoon` replaced with `try` ➒.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，您构造了两个 `vector` 类型的 `string` 对象 ➎➏ 和一个名为 `has_two_os` 的 lambda 函数，该函数接受一个字符串并返回
    `true`，如果该字符串恰好包含两个 `o` ➐。然后，您将 `words2` 作为目标序列，`words3` 作为目标序列传递给 `replace_copy_if`，它对
    `words2` 中的每个元素应用 `has_two_os`，并将满足条件的元素替换为 `try` ➑。结果是 `words2` 不受影响，而 `words3`
    中的元素 `spoon` 被替换为 `try` ➒。
- en: '***fill***'
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***fill***'
- en: The `fill` algorithm fills a sequence with some value.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill` 算法用某个值填充序列。'
- en: The algorithm writes a value into each element of the target sequence. The `fill_n`
    function returns `opt_begin+n`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 算法将一个值写入目标序列的每个元素。`fill_n` 函数返回 `opt_begin + n`。
- en: '[PRE54]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Arguments**'
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `std::execution` 执行策略 `ep`（默认值：`std::execution::seq`）
- en: A `ForwardIterator`, `fwd_begin`, representing the target sequence’s beginning
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `ForwardIterator`，`fwd_begin`，表示目标序列的起始位置
- en: A `ForwardIterator`, `fwd_end`, representing one past the sequence’s end
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `ForwardIterator`，`fwd_end`，表示序列末尾的下一个位置
- en: A `Size n` representing the number of elements
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示元素数量的 `Size n`
- en: A `value` to write into each element of the target sequence
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个要写入目标序列每个元素的 `value`
- en: '**Complexity**'
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm assigns `value` exactly `distance(fwd_begin, fwd_end)`
    or `n` times.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 算法将 `value` 赋值给目标序列的每个元素，恰好 `distance(fwd_begin, fwd_end)` 或 `n` 次。'
- en: '**Additional Requirements**'
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The `value` parameter must be writable into the sequence.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` 参数必须能够写入序列。'
- en: Objects of type `Size` must be convertible into an integral type.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Size`类型的对象必须可以转换为整型。'
- en: '**Examples**'
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE55]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You first initialize a `vector` containing `string` objects containing six empty
    elements ➊. Next, you invoke `fill` using this `vector` as the target sequence
    and `police` as the value ➋. The result is that your `vector` contains six `police`
    ➌.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化一个包含六个空元素的`vector`，其中包含`string`对象 ➊。接下来，使用`vector`作为目标序列并将`police`作为值来调用`fill`
    ➋。结果是你的`vector`包含六个`police` ➌。
- en: 'In the second example, you initialize an empty `vector` containing `string`
    objects ➍. You then invoke `fill_n` with a `back_inserter` pointing to the empty
    vector, a length of 6, and `police` as the value ➎. The result is the same as
    before: your `vector` contains six `police` ➏.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，你初始化一个空的`vector`，其中包含`string`对象 ➍。然后，你用`back_inserter`调用`fill_n`，指向空的`vector`、长度为6，并将`police`作为值
    ➎。结果和之前一样：你的`vector`包含六个`police` ➏。
- en: '***generate***'
  id: totrans-415
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***generate***'
- en: The `generate` algorithm fills a sequence by invoking a function object.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate`算法通过调用一个函数对象来填充序列。'
- en: The algorithm invokes `generator` and assigns the result into the target sequence.
    The `generate_n` function returns `opt_begin+n`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 算法调用`generator`并将结果赋值到目标序列中。`generate_n`函数返回`opt_begin+n`。
- en: '[PRE56]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**Arguments**'
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A `ForwardIterator`, `fwd_begin`, representing the target sequence’s beginning
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ForwardIterator`，`fwd_begin`，表示目标序列的起始位置
- en: A `ForwardIterator`, `fwd_end`, representing 1 past the sequence’s end
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ForwardIterator`，`fwd_end`，表示序列末尾之后的位置
- en: A `Size n` representing the number of elements
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示元素数量的`Size n`
- en: A `generator` that, when invoked with no arguments, produces an element to write
    into the target sequence
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`generator`，当没有参数调用时，生成一个元素以写入目标序列
- en: '**Complexity**'
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `generator` exactly `distance(fwd_begin, fwd_end)`
    or `n` times.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 算法调用`generator`恰好`distance(fwd_begin, fwd_end)`次或`n`次。'
- en: '**Additional Requirements**'
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The `value` parameter must be writable into the sequence.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`参数必须可以写入序列。'
- en: Objects of type `Size` must be convertible into an integral type.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Size`类型的对象必须可以转换为整型。'
- en: '**Examples**'
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE57]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You first initialize an `int` called `i` to 1 ➊. Next, you create a lambda called
    `pow_of_2`, which takes `i` by reference ➋. Each time you invoke `pow_of_2`, it
    doubles `i` and returns its value just before the doubling. Next, you initialize
    a `vector` of `int` objects with six elements ➌. You then invoke `generate` with
    the `vector` as the target sequence and `pow_of_2` as the generator ➍. The result
    is that the `vector` contains the first six powers of two ➎.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化一个名为`i`的`int`为1 ➊。接着，你创建一个名为`pow_of_2`的lambda，它通过引用获取`i` ➋。每次调用`pow_of_2`时，它将`i`加倍，并返回加倍前的值。然后，你初始化一个包含六个元素的`vector`，其元素类型为`int`
    ➌。然后，你用`vector`作为目标序列，`pow_of_2`作为生成器来调用`generate` ➍。结果是`vector`包含前六个2的幂 ➎。
- en: In the second example, you initialize an empty `vector` of `int` objects ➏.
    Next, you invoke `generate_n` using a `back_inserter` to your empty `vector`,
    a size of 6, and `pow_of_2` as your generator ➐. The `result` is the next six
    powers of two ➑. Notice that `pow_of_2` has state because it captures `i` by reference.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，你初始化一个空的`vector`，其中包含`int`对象 ➏。接下来，你使用`back_inserter`调用`generate_n`，传入空的`vector`、大小为6和`pow_of_2`作为生成器
    ➐。`result`是接下来的六个2的幂 ➑。注意，`pow_of_2`有状态，因为它通过引用捕获了`i`。
- en: '***remove***'
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***remove***'
- en: The `remove` algorithm removes certain elements from a sequence.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`算法从序列中移除某些元素。'
- en: The algorithm moves all elements where `pred` evaluates to `true` or where the
    element equals `value` in such a way that the remaining elements’ order is preserved,
    and it returns an iterator pointing to the first moved element. This iterator
    is called the resulting sequence’s *logical end*. The sequence’s physical size
    remains unchanged, and a call to `remove` is typically followed by a call to a
    container’s `erase` method.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 算法将所有`pred`为`true`或元素等于`value`的元素移动，确保剩余元素的顺序保持不变，并返回指向第一个移动元素的迭代器。这个迭代器被称为结果序列的*逻辑结束*。序列的物理大小保持不变，通常`remove`调用后会跟着调用容器的`erase`方法。
- en: '[PRE58]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**Arguments**'
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`，`fwd_begin`和`fwd_end`，表示目标序列
- en: An `OutputIterator`, `result`, representing the destination sequence (if copying)
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`OutputIterator`，`result`，表示目标序列（如果是复制的情况下）
- en: A `value` representing the element to remove
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示要移除元素的`value`
- en: A unary predicate, `pred`, that determines whether an element meets the criteria
    for removal
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元谓词`pred`，用于判断元素是否符合移除的标准
- en: '**Complexity**'
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `pred` or compares with `value` exactly `distance(fwd_begin,
    fwd_end)` times.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法调用`pred`或与`value`进行比较的次数恰好是`distance(fwd_begin, fwd_end)`次。'
- en: '**Additional Requirements**'
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements of the target sequence must be moveable.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可移动的。
- en: If copying, the elements must be copyable, and the target and destination sequences
    must not overlap.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进行复制，元素必须是可复制的，且目标序列和源序列不能重叠。
- en: '**Examples**'
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE59]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You first create a lambda called `is_vowel` that returns `true` if the given
    `char` is a vowel ➊. Next, you construct a `string` called `pilgrim` containing
    a sentence ➋. You then invoke `remove_if` with `pilgrim` as the target sentence
    and `is_vowel` as the predicate ➌. This eliminates all the vowels in the sentence
    by shifting the remaining characters to the left each time `remove_if` encounters
    a vowel. The result is that `pilgrim` contains the original sentence with vowels
    removed plus the phrase `present, and the future.` ➍. This phrase contains 24
    characters, which is exactly the number of vowels that `remove_if` removed from
    the original sentence. The phrase `present, and the future.` is the detritus from
    shifting the remaining string during removal.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个名为`is_vowel`的lambda函数，当给定的`char`是元音时返回`true` ➊。接着，构造一个名为`pilgrim`的`string`，其中包含一个句子
    ➋。然后，调用`remove_if`，以`pilgrim`作为目标句子，`is_vowel`作为谓词 ➌。每当`remove_if`遇到一个元音时，它会将剩余字符向左移动，从而消除句子中的所有元音。结果是，`pilgrim`包含了原始句子，去除了元音，并加上了`present,
    and the future.`这一短语 ➍。这个短语包含24个字符，这正好是`remove_if`从原句中移除的元音数量。`present, and the
    future.`这个短语是移除过程中剩余字符串移动所产生的碎片。
- en: To eliminate these leftovers, you save the iterator `new_end`, which `remove_if`
    returns. This points to 1 past the last character in the new target sequence,
    the `p` in `present, and the future.` To eliminate, you simply use the `erase`
    method on `pilgrim`, which has an overload that accepts a half-open range. You
    pass the logical end returned by `remove_if`, `new_end`, as the begin iterator.
    You also pass `pilgrim.end()` as the end iterator ➎. The result is that `pilgrim`
    is now equal to the original sentence with vowels removed ➏.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这些剩余元素，你保存`remove_if`返回的迭代器`new_end`，它指向新目标序列中最后一个字符后的一个位置，即`present, and
    the future.`中的`p`。要消除这些元素，你只需在`pilgrim`上使用`erase`方法，`erase`方法有一个接受半开区间的重载。你将`remove_if`返回的逻辑末尾`new_end`作为开始迭代器，同时将`pilgrim.end()`作为结束迭代器
    ➎。结果是，`pilgrim`现在等于去除元音后的原始句子 ➏。
- en: This combination of `remove` (or `remove_if`) and the `erase` method, which
    is called the *erase-remove idiom*, is widely used.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将`remove`（或`remove_if`）与`erase`方法结合使用的方式，称为*擦除-移除惯用法*，被广泛应用。
- en: '***unique***'
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***unique***'
- en: The `unique` algorithm removes redundant elements from a sequence.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique`算法从序列中移除冗余元素。'
- en: The algorithm moves all repeat elements where `pred` evaluates to `true` or
    where the elements are equal such that the remaining elements are unique from
    their neighbors and original ordering is preserved. It returns an iterator pointing
    to the new logical end. As with `std::remove`, the physical storage doesn’t change.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法移动所有`pred`判断为`true`的重复元素，或是相等的元素，确保剩余的元素是唯一的且保留原始顺序。它返回指向新逻辑末尾的迭代器。与`std::remove`一样，物理存储不会改变。
- en: '[PRE60]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Arguments**'
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`，`fwd_begin`和`fwd_end`，表示目标序列
- en: An `OutputIterator`, `result`, representing the destination sequence (if copying)
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`OutputIterator`，`result`，表示目标序列（如果是复制的情况下）
- en: A binary predicate, `pred`, that determines whether two elements are equal
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个二元谓词`pred`，用于判断两个元素是否相等
- en: '**Complexity**'
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `pred` exactly `distance(fwd_begin, fwd_end)
    - 1` times.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法调用`pred`的次数恰好是`distance(fwd_begin, fwd_end) - 1`次。'
- en: '**Additional Requirements**'
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements of the target sequence must be moveable.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可移动的。
- en: If copying, elements of the target sequence must by copyable, and the target
    and destination ranges cannot overlap.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是复制，目标序列的元素必须是可复制的，并且目标范围与目标位置的范围不能重叠。
- en: '**Example**'
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE61]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You first construct a `string` containing a word with multiple repeated characters
    ➊. You then invoke `unique` with the `string` as the target sequence ➋. This returns
    the logical end, which you assign to `new_end`. Next, you erase the range beginning
    with `new_end` and ending with `without_walls.end()` ➌. This is a corollary to
    the erase-remove idiom: you’re left with the contents `Wales`, which contains
    consecutively unique characters ➍.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先构造一个包含多个重复字符的`string` ➊。然后，你使用`string`作为目标序列调用`unique` ➋。这将返回逻辑上的结束位置，并将其赋值给`new_end`。接下来，你删除从`new_end`到`without_walls.end()`的范围
    ➌。这是删除-移除模式的推论：最终你会得到`Wales`，其中包含连续的唯一字符 ➍。
- en: '***reverse***'
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***reverse***'
- en: The `reverse` algorithm reverses the order of a sequence.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse`算法反转序列的顺序。'
- en: The algorithm reverses a sequence by either swapping its elements or copying
    them into a target sequence.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通过交换元素或将其复制到目标序列来反转序列。
- en: '[PRE62]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Arguments**'
  id: totrans-475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `BidirectionalIterator`s, `bi_begin` and `bi_end`, representing the
    target sequence
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`BidirectionalIterator`，`bi_begin`和`bi_end`，表示目标序列。
- en: An `OutputIterator`, `result`, representing the destination sequence (if copying)
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`OutputIterator`，`result`，表示目标序列（如果是复制）。
- en: '**Complexity**'
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm invokes `swap` exactly `distance(bi_begin, bi_end)/2`
    times.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法精确调用`swap` `distance(bi_begin, bi_end)/2`次。'
- en: '**Additional Requirements**'
  id: totrans-481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements of the target sequence must be swappable.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可交换的。
- en: If copying, elements of the target sequence must by copyable, and the target
    and destination ranges cannot overlap.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是复制，目标序列的元素必须是可复制的，并且目标范围与目标位置的范围不能重叠。
- en: '**Example**'
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE63]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You first construct a `string` containing the word `diaper` ➊. Next, you invoke
    reverse with this `string` as the target sequence ➋. The result is the word `repaid`
    ➌.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先构造一个包含单词`diaper`的`string` ➊。接下来，你使用此`string`作为目标序列调用reverse ➋。结果是单词`repaid`
    ➌。
- en: '***sample***'
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***sample***'
- en: The `sample` algorithm generates random, stable subsequences.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample`算法生成随机且稳定的子序列。'
- en: The algorithm samples `min(pop_end - pop_begin, n)` elements from the population
    sequence. Somewhat unintuitively, the sample will be sorted if and only if `ipt_begin`
    is a forward iterator. It returns the resulting destination sequence’s end.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法从种群序列中抽取`min(pop_end - pop_begin, n)`个元素。稍微不直观的是，当且仅当`ipt_begin`是正向迭代器时，抽样结果才会被排序。它返回结果目标序列的结束位置。
- en: '[PRE64]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Arguments**'
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    population sequence (the sequence to sample from)
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin`和`ipt_end`，表示种群序列（即要抽样的序列）。
- en: A `OutputIterator`, `result`, representing the destination sequence
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`OutputIterator`，`result`，表示目标序列。
- en: A `Distance` `n` representing the number of elements to sample
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Distance`类型的`n`，表示要抽样的元素数量。
- en: A `UniformRandomBitGenerator` `urb_generator`, such as the Mersenne Twister
    `std::mt19937_64` introduced in [Chapter 12](ch12.xhtml#ch12)
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`UniformRandomBitGenerator`类型的`urb_generator`，例如在[第12章](ch12.xhtml#ch12)中介绍的Mersenne
    Twister `std::mt19937_64`。
- en: '**Complexity**'
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm’s complexity scales with `distance(ipt_begin, ipt_end)`.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法的复杂度与`distance(ipt_begin, ipt_end)`成比例。'
- en: '**Example**'
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE65]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You first construct a `const string` called `population` containing the letters
    `ABCD` ➊. You also initialize a `const size_t` called `n_samples` equal to a million
    ➋ and a Mersenne Twister called `urbg` ➌. All of these objects have static storage
    duration.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先构造一个名为`population`的`const string`，其中包含字母`ABCD` ➊。然后你初始化一个名为`n_samples`的`const
    size_t`，值为一百万 ➋，以及一个名为`urbg`的Mersenne Twister ➌。所有这些对象的存储持续时间都是静态的。
- en: In addition, you initialize the function `sample_length`, which takes a single
    `size_t` argument called `n` ➍. Within the function, you construct a `map` of
    `string` to `size_t` objects ➎ that will count the frequency of each `sample`
    invocation. Within a `for` loop, you invoke `sample` with `population` as the
    population sequence, a `back_inserter` to a `result` string as the destination
    sequence, `n` as the sample length, and `urbg` as the random bit generator ➏.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您初始化了一个名为`sample_length`的函数，该函数接受一个名为`n`的`size_t`参数➍。在该函数中，您构造一个`map`类型的`string`到`size_t`对象的集合➎，用于统计每次调用`sample`的频率。在一个`for`循环中，您调用`sample`，将`population`作为种群序列，将`back_inserter`作为目标序列的`result`字符串，`n`作为样本长度，以及`urbg`作为随机位生成器➏。
- en: After a million iterations, you iterate over each element of `counts` ➐ and
    print the probability distribution of each sample for the given length `n` ➑.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在一百万次迭代后，您迭代`counts`中的每个元素➐，并打印给定长度`n`的每个样本的概率分布➑。
- en: Within `main`, you configure floating-point formatting with `fixed` and `setprecision`
    ➒. Finally, you invoke `sample_length` with each value from `0` to `4` inclusive
    ➓.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，您使用`fixed`和`setprecision`配置浮点数格式➒。最后，您使用从`0`到`4`的每个值调用`sample_length`➓。
- en: Because `string` provides random access iterators, `sample` provides *stable*
    (sorted) samples.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`string`提供了随机访问迭代器，`sample`提供*稳定*（已排序）的样本。
- en: '**WARNING**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Notice that the output doesn’t contain any unsorted samples like DC or CAB.
    This sorting behavior isn’t necessarily obvious from the algorithm’s name, so
    be careful!*'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，输出不包含像DC或CAB这样的未排序样本。这个排序行为可能并不是算法名称中显而易见的，所以请小心！*'
- en: '***shuffle***'
  id: totrans-508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***洗牌***'
- en: The `shuffle` algorithm generates random permutations.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffle`算法生成随机排列。'
- en: The algorithm randomizes the target sequence such that each possible permutation
    of those elements has equal probability of appearance.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法随机化目标序列，使得这些元素的每种可能排列出现的概率相等。
- en: '[PRE66]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**Arguments**'
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: A pair of `RandomAccessIterator`s, `rnd_begin` and `rnd_end`, representing the
    target sequence
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`RandomAccessIterator`（随机访问迭代器）`rnd_begin`和`rnd_end`，表示目标序列。
- en: A `UniformRandomBitGenerator` `urb_generator`, such as the Mersenne Twister
    `std::mt19937_64` introduced in [Chapter 12](ch12.xhtml#ch12)
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`UniformRandomBitGenerator`（均匀随机位生成器）`urb_generator`，例如在[第12章](ch12.xhtml#ch12)中介绍的梅森旋转算法`std::mt19937_64`
- en: '**Complexity**'
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm swaps exactly `distance(rnd_begin, rnd_end) - 1` times.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法恰好交换`distance(rnd_begin, rnd_end) - 1`次。'
- en: '**Additional Requirements**'
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements of the target sequence must be swappable.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可交换的。
- en: '**Example**'
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE67]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You first construct a `const string` called `population` containing the letters
    `ABCD` ➊. You also initialize a `const size_t` called `n_samples` equal to a million
    ➋, a Mersenne Twister called `urbg` ➌, and a `map` of `string` to `size_t` objects
    ➍ that will count the frequencies of each `shuffle` sample. In addition, you configure
    floating-point formatting with `fixed` and `setprecision` ➎.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先构造一个名为`population`的`const string`，其中包含字母`ABCD`➊。您还初始化一个名为`n_samples`的`const
    size_t`，它的值为一百万➋，一个名为`urbg`的梅森旋转算法（Mersenne Twister）➌，以及一个`map`类型的`string`到`size_t`对象的集合➍，用于统计每个`shuffle`样本的频率。此外，您使用`fixed`和`setprecision`配置浮点数格式➎。
- en: Within a `for` loop, you copy `population` into a new string called `sample`
    because `shuffle` modifies the target sequence ➏. You then invoke `shuffle` with
    `result` as the target sequence and `urbg` as the random bit generator ➐, and
    you record the result within `samples` ➑.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，您将`population`复制到一个名为`sample`的新字符串中，因为`shuffle`会修改目标序列➏。然后，您调用`shuffle`，将`result`作为目标序列，`urbg`作为随机位生成器➐，并将结果记录在`samples`中➑。
- en: Finally, you iterate over each element in `samples` ➒ and print the probability
    distribution of each sample ➓.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您迭代`sample`中的每个元素➒并打印每个样本的概率分布➓。
- en: Notice that, unlike with `sample`, `shuffle` always produces an *unordered*
    distribution of elements.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`sample`不同，`shuffle`始终生成一个*无序*的元素分布。
- en: '**Sorting and Related Operations**'
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**排序及相关操作**'
- en: A *sorting operation* is an algorithm that reorders a sequence in some desired
    way.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '*排序操作*是一个将序列重新排列为所需方式的算法。'
- en: 'Each sorting algorithm has two versions: one that takes a function object called
    a *comparison operator* and one that uses `operator<`. A comparison operator is
    a function object that is invokable with two objects to compare. It returns `true`
    if the first argument is *less than* the second argument; otherwise, it returns
    `false`. The sort interpretation of `x < y` is that `x` is sorted before `y`.
    All the algorithms explained in this section are in the `<algorithm>` header.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 每个排序算法都有两个版本：一个接受名为 *比较操作符* 的函数对象，另一个使用 `operator<`。比较操作符是一个函数对象，可以使用两个对象进行比较。它返回
    `true` 如果第一个参数是 *小于* 第二个参数；否则返回 `false`。`x < y` 的排序解释是 `x` 排在 `y` 前面。本节中解释的所有算法都位于
    `<algorithm>` 头文件中。
- en: '**NOTE**'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Notice that operator< is a valid comparison operator.*'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意，operator< 是一个有效的比较操作符。*'
- en: 'Comparison operators must be transitive. This means that for any elements `a`,
    `b`, and `c` the comparison operator `comp` must preserve the following relationship:
    if `comp(a, b)` and `comp(b, c)`, then `comp(a, c)`. This should make sense: if
    `a` is ordered before `b` and `b` is ordered before `c`, then `a` must be ordered
    before `c`.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 比较操作符必须是传递的。这意味着对于任何元素 `a`、`b` 和 `c`，比较操作符 `comp` 必须保持以下关系：如果 `comp(a, b)` 和
    `comp(b, c)`，那么 `comp(a, c)`。这应该是合理的：如果 `a` 排在 `b` 前面，且 `b` 排在 `c` 前面，那么 `a` 必须排在
    `c` 前面。
- en: '***sort***'
  id: totrans-531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***sort***'
- en: The `sort` algorithm sorts a sequence (unstably).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 算法对序列进行排序（不稳定）。'
- en: '**NOTE**'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A stable sort retains the relative, pre-sort ordering of equal elements, whereas
    an unstable sort might reorder them.*'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '*稳定排序会保留相等元素的相对顺序，而不稳定排序可能会重新排序它们。*'
- en: The algorithm sorts the target sequence in place.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 算法就地对目标序列进行排序。
- en: '[PRE68]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**Arguments**'
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `std::execution` 执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `RandomAccessIterator`s, `rnd_begin` and `rnd_end`, representing the
    target sequence
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对 `RandomAccessIterator`，`rnd_begin` 和 `rnd_end`，表示目标序列
- en: An optional comparison operator, `comp`
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较操作符，`comp`
- en: '**Complexity**'
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Quasilinear** O(N log N) where N = `distance(rnd_begin, rnd_end)`'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**准线性** O(N log N)，其中 N = `distance(rnd_begin, rnd_end)`'
- en: '**Additional Requirements**'
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements of the target sequence must be swappable, move constructible, and
    move assignable.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可交换的、可移动构造的和可移动赋值的。
- en: '**Example**'
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE69]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You first construct a `string` containing the word `spoilage` ➊. Next, you invoke
    `sort` with this `string` as the target sequence ➋. The result is that `goat_``grass`
    now contains the word `aegilops` (a genus of invasive weeds) ➌.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先构造一个包含单词 `spoilage` 的 `string` ➊。接着，你用这个 `string` 作为目标序列调用 `sort` ➋。结果是 `goat_``grass`
    现在包含了单词 `aegilops`（一种侵入性杂草的属名） ➌。
- en: '***stable_sort***'
  id: totrans-548
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***stable_sort***'
- en: The `stable_sort` algorithm sorts a sequence stably.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`stable_sort` 算法对序列进行稳定排序。'
- en: The algorithm sorts the target sequence in place. Equal elements retain their
    original ordering.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 算法就地对目标序列进行排序。相等元素保持其原始顺序。
- en: '[PRE70]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '**Arguments**'
  id: totrans-552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `std::execution` 执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `RandomAccessIterator`s, `rnd_begin` and `rnd_end`, representing the
    target sequence
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对 `RandomAccessIterator`，`rnd_begin` 和 `rnd_end`，表示目标序列
- en: An optional comparison operator, `comp`
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较操作符，`comp`
- en: '**Complexity**'
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Polylog-linear** O(N log² N) where N = `distance(rnd_begin, rnd_end)`. If
    additional memory is available, complexity reduces to quasilinear.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**多对数线性** O(N log² N)，其中 N = `distance(rnd_begin, rnd_end)`。如果有额外内存可用，复杂度将减少到准线性。'
- en: '**Additional Requirements**'
  id: totrans-558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements of the target sequence must be swappable, move constructible, and
    move assignable.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可交换的、可移动构造的和可移动赋值的。
- en: '**Example**'
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE71]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This example sorts a `string` using the *ascenders* and *descenders*. In typography,
    an ascender is a letter with a portion that extends above what is known as the
    mean line of a font. A descender is a letter with a portion that extends below
    what is known as the baseline. Letters commonly typed with descenders are *g*,
    *j*, *p*, *q*, and *y*. Letters commonly typed with ascenders are *b*, *d*, *f*,
    *h*, *k*, *l*, and *t*. This example seeks a `stable_sort` so that all letters
    with ascenders appear before all other letters and letters with descenders appear
    after all other letters. Letters with neither an ascender nor a descender lie
    in the middle. As a `stable_sort`, the relative ordering of letters with common
    ascender/descender categorization must not change.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用*升部字母*和*降部字母*对`string`进行排序。在排版学中，升部字母是指其一部分延伸到字体的平均线以上的字母。降部字母是指其一部分延伸到基线以下的字母。常见的降部字母有*g*、*j*、*p*、*q*和*y*。常见的升部字母有*b*、*d*、*f*、*h*、*k*、*l*和*t*。这个例子使用`stable_sort`，使得所有升部字母排在所有其他字母之前，所有降部字母排在所有其他字母之后。既不属于升部字母也不属于降部字母的字母则排在中间。作为一个`stable_sort`，具有相同升部/降部分类的字母的相对顺序不能发生变化。
- en: 'You first define an `enum class` called `CharCategory` that takes on three
    possible values: `Ascender`, `Normal`, or `Descender` ➊. Next, you define a function
    that categorizes a given char into a `CharCategory` ➋. (Recall from “Switch Statements”
    on [page 50](ch02.xhtml#page_50) that labels “fall through” if you don’t include
    a `break`.) You also define an `ascension_compare` function that converts two
    given `char` objects into `CharCategory` objects and compares them with `operator<`
    ➌. Because `enum class` objects convert implicitly to `int` objects and because
    you define `CharCategory` with its values in the intended order, this will sort
    letters with ascenders ahead of normal letters ahead of letters with descenders.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先定义了一个`enum class`，名为`CharCategory`，它有三个可能的值：`Ascender`、`Normal`或`Descender`
    ➊。接下来，你定义了一个函数，用来将给定的字符分类到`CharCategory`中 ➋。（回想一下在[第50页](ch02.xhtml#page_50)的“Switch语句”部分，若不包含`break`，标签会“穿透”。）你还定义了一个`ascension_compare`函数，用于将两个给定的`char`对象转换为`CharCategory`对象，并通过`operator<`进行比较
    ➌。由于`enum class`对象会隐式转换为`int`对象，并且你按预期的顺序定义了`CharCategory`，因此这将使得升部字母排在正常字母前面，正常字母排在降部字母前面。
- en: Within the test case, you initialize a `string` containing the word `outgrin`
    ➍. Next, you invoke `stable_sort` with this `string` as the target sequence and
    `ascension_compare` as the comparison operator ➎. The result is that `word` now
    contains `touring` ➏. Notice that `t`, the only ascender, appears before all the
    normal characters (which are in the same order as in `outgrin`), which appear
    before `g`, the only descender.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试用例中，你初始化了一个包含单词`outgrin`的`string` ➍。接下来，你调用`stable_sort`，以该`string`作为目标序列，`ascension_compare`作为比较运算符
    ➎。结果是，`word`现在包含了`touring` ➏。注意，`t`，唯一的升部字母，出现在所有正常字符之前（这些字符的顺序和`outgrin`中的顺序相同），而这些正常字符又出现在`g`之前，`g`是唯一的降部字母。
- en: '***partial_sort***'
  id: totrans-565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***partial_sort***'
- en: The `partial_sort` algorithm sorts a sequence into two groups.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial_sort`算法将一个序列排序为两组。'
- en: If modifying, the algorithm sorts the first `(rnd_middle – rnd_first)` elements
    in the target sequence so all elements in `rnd_begin` to `rnd_middle` are less
    than the rest of the elements. If copying, the algorithm places the first `min(distance(ipt_begin,
    ipt_end), distance(rnd_begin, rnd_end))` sorted elements into the destination
    sequence, and it returns an iterator pointing to the end of the destination sequence.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是修改，算法会对目标序列中的前`(rnd_middle – rnd_first)`个元素进行排序，使得`rnd_begin`到`rnd_middle`中的所有元素都小于其余元素。如果是复制，算法会将前`min(distance(ipt_begin,
    ipt_end), distance(rnd_begin, rnd_end))`个已排序的元素放入目标序列，并返回一个指向目标序列末尾的迭代器。
- en: Basically, a partial sort allows you to find the first few elements of a sorted
    sequence without having to sort the entire sequence. For example, if you had the
    sequence D C B A, you could partial sort the first two elements and obtain the
    result A B D C. The first two elements are the same as if you’d sorted the entire
    sequence, but the remaining elements aren’t.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，部分排序允许你在不排序整个序列的情况下，找到排序序列中的前几个元素。例如，如果你有一个序列D C B A，你可以对前两个元素进行部分排序，得到结果A
    B D C。前两个元素和对整个序列进行排序的结果相同，但其余元素则没有进行排序。
- en: '[PRE72]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**Arguments**'
  id: totrans-570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: If modifying, a trio of `RandomAccessIterator`s, `rnd_begin`, `rnd_middle`,
    and `rnd_end`, representing the target sequence
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是修改，表示目标序列的三元组`rnd_begin`、`rnd_middle`和`rnd_end`的`RandomAccessIterator`
- en: If copying, a pair `ipt_begin` and `ipt_end` representing the target sequence
    and a pair `rnd_begin` and `rnd_end` representing the destination sequence
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是复制，表示目标序列的`ipt_begin`和`ipt_end`一对，以及表示目标序列的`rnd_begin`和`rnd_end`一对
- en: An optional comparison operator, `comp`
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较运算符，`comp`
- en: '**Complexity**'
  id: totrans-575
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Quasilinear** O(N log N) where N = `distance(rnd_begin, rnd_end) * log(distance(rnd_begin,
    rnd_middle)` or `distance(rnd_begin, rnd_end) * log(min(distance(rnd_begin, rnd_end),
    distance(ipt_begin, ipt_end))` for the copy variant'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**准线性** O(N log N)，其中N = `distance(rnd_begin, rnd_end) * log(distance(rnd_begin,
    rnd_middle)` 或 `distance(rnd_begin, rnd_end) * log(min(distance(rnd_begin, rnd_end),
    distance(ipt_begin, ipt_end))` 用于复制变体'
- en: '**Additional Requirements**'
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements of the target sequence must be swappable, move constructible, and
    move assignable.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可交换的、可移动构造的，并且可移动赋值的。
- en: '**Examples**'
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE73]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You first initialize a `string` containing the word `nectarous` ➊. Next, you
    invoke `partial_sort` with this `string` as the target sequence and the fifth
    letter (`a`) as the second argument to `partial_sort` ➋. The result is that the
    sequence now contains the word `acentrous` ➌. Notice that the first four letters
    of `acentrous` are sorted and that they’re less than the remaining characters
    in the sequence.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你初始化一个包含单词`nectarous`的`string` ➊。接着，你用这个`string`作为目标序列，和第五个字母（`a`）作为`partial_sort`的第二个参数调用`partial_sort`
    ➋。结果是，序列现在包含单词`acentrous` ➌。注意，`acentrous`的前四个字母已经排序，并且它们小于序列中的剩余字符。
- en: In the second example, you initialize a `string` containing the word `pretanning`
    ➍, which you use as the target sequence for `partial_sort` ➎. In this example,
    you specify the fourth character (`t`) as the second argument to `partial_sort`,
    and you use the `ascension_compare` function from the `stable_sort` example as
    the comparison operator. The result is that the sequence now contains the word
    `trepanning` ➏. Notice that the first three letters are sorted according to `ascension_compare`
    and none of the remaining characters in the second argument to `partial_sort`
    to `z` is less than the first three characters.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，你初始化一个包含单词`pretanning`的`string` ➍，并将其用作`partial_sort`的目标序列 ➎。在这个示例中，你指定第四个字符（`t`）作为`partial_sort`的第二个参数，并使用`stable_sort`示例中的`ascension_compare`函数作为比较运算符。结果是，序列现在包含单词`trepanning`
    ➏。注意，前面三个字母是按`ascension_compare`排序的，并且`partial_sort`的第二个参数中的剩余字符都不小于前三个字符。
- en: '**NOTE**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Technically, the REQUIRE statements in the preceding example might fail on
    some standard library implementations. Because std::partial_sort isn’t guaranteed
    to be stable, results may vary.*'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，前面的示例中的REQUIRE语句可能会在某些标准库实现中失败。因为`std::partial_sort`并不保证稳定性，结果可能会有所不同。*'
- en: '***is_sorted***'
  id: totrans-585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***is_sorted***'
- en: The `is_sorted` algorithm determines whether a sequence is sorted.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_sorted`算法用于判断序列是否已排序。'
- en: The algorithm returns true if the target sequence is sorted according to `operator<`
    or `comp`, if given. The `is_sorted_until` algorithm returns an iterator pointing
    to the first unsorted element or `rnd_end` if the target sequence is sorted.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标序列按照`operator<`或（如果给定）`comp`排序，则该算法返回`true`。`is_sorted_until`算法返回指向第一个未排序元素的迭代器，或者如果目标序列已排序，则返回`rnd_end`。
- en: '[PRE74]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '**Arguments**'
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `RandomAccessIterator`s, `rnd_begin` and `rnd_end`, representing the
    target sequence
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`RandomAccessIterator`，`rnd_begin`和`rnd_end`，表示目标序列
- en: An optional comparison operator, `comp`
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较运算符，`comp`
- en: '**Complexity**'
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm compares `distance(rnd_begin, rnd_end)` times.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法比较`distance(rnd_begin, rnd_end)`次。'
- en: '**Examples**'
  id: totrans-595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE75]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You first construct a `string` containing the word `billowy` ➊. Next, you invoke
    `is_sort` with this `string` as the target sequence, which returns `true` ➋.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你构造一个包含单词`billowy`的`string` ➊。接着，你用这个`string`作为目标序列调用`is_sort`，它返回`true`
    ➋。
- en: In the second example, you construct a `string` containing the word `floppy`
    ➌. You then invoke `is_sorted_until` with this `string` as the target sequence,
    which returns `rnd_end` because the sequence is sorted ➍.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，你构造一个包含单词`floppy`的`string` ➌。然后，你用这个`string`作为目标序列调用`is_sorted_until`，它返回`rnd_end`，因为该序列已排序
    ➍。
- en: '***nth_element***'
  id: totrans-599
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***nth_element***'
- en: The `nth_element` algorithm places a particular element in a sequence into its
    correct sorted position.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`nth_element`算法将序列中的特定元素放到其正确的排序位置。'
- en: 'This partial sorting algorithm modifies the target sequence in the following
    way: the element in the position pointed to by `rnd_nth` is in that position as
    if the whole range were sorted. All elements from `rnd_begin` to `rnd_nth-1` will
    be less than `rnd_nth`. If `rnd_nth == rnd_end`, the function performs no operation.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分排序算法以以下方式修改目标序列：`rnd_nth`指向的位置就像整个范围已排序一样。所有从`rnd_begin`到`rnd_nth-1`的位置的元素都小于`rnd_nth`。如果`rnd_nth
    == rnd_end`，则函数不执行任何操作。
- en: '[PRE76]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '**Arguments**'
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::``seq`)'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A trio of `RandomAccessIterator`s, `rnd_begin`, `rnd_nth`, and `rnd_end`, representing
    the target sequence
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组三个`RandomAccessIterator`，`rnd_begin`、`rnd_nth`和`rnd_end`，表示目标序列
- en: An optional comparison operator, `comp`
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较运算符，`comp`
- en: '**Complexity**'
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** The algorithm compares `distance(rnd_begin, rnd_end)` times.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 该算法比较`distance(rnd_begin, rnd_end)`次。'
- en: '**Additional Requirements**'
  id: totrans-609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements of the target sequence must be swappable, move constructible, and
    move assignable.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可交换的、可移动构造的和可移动赋值的。
- en: '**Example**'
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE77]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You first construct a `vector` of `int` objects containing the number sequence
    1 to 10 inclusive ➊. Next, you invoke `nth_element` with this `vector` as the
    target sequence ➋. You then initialize a lambda named `less_than_6th_elem`, which
    compares an `int` with the sixth element of `numbers` with `operator<` ➌. This
    allows you to check that all elements before the sixth element are less than the
    sixth element ➍. The sixth element is 6 ➎.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先构造一个包含数字序列1到10的`int`对象的`vector` ➊。然后，你使用这个`vector`作为目标序列，调用`nth_element`
    ➋。接着，你初始化一个名为`less_than_6th_elem`的lambda，它使用`operator<`比较一个`int`与`numbers`中的第六个元素
    ➌。这使得你可以检查所有第六个元素之前的元素是否都小于第六个元素 ➍。第六个元素是6 ➎。
- en: '**Binary Search**'
  id: totrans-614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二分查找**'
- en: '*Binary search algorithms* assume that a target sequence is already sorted.
    These algorithms have desirable complexity characteristics compared with generic
    search over an unspecified sequence. Each algorithm explained in this section
    is in the `<algorithm>` header.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '*二分查找算法*假设目标序列已经排序。与在未指定序列上进行通用查找相比，这些算法具有理想的复杂度特性。本节中解释的每个算法都位于`<algorithm>`头文件中。'
- en: '***lower_bound***'
  id: totrans-616
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***lower_bound***'
- en: The `lower_bound` algorithm finds a partition in a sorted sequence.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower_bound`算法在已排序的序列中找到一个分区。'
- en: The algorithm returns an iterator corresponding to the element `result`, which
    partitions the sequence so the elements before `result` are less than `value`,
    whereas `result` and all elements after it aren’t less than `value`.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法返回一个迭代器，指向元素`result`，它将序列划分，使得`result`之前的元素都小于`value`，而`result`及其后的所有元素不小于`value`。
- en: '[PRE78]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '**Arguments**'
  id: totrans-620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`，`fwd_begin`和`fwd_end`，表示目标序列
- en: A `value` to partition the target sequence with
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于划分目标序列的`value`
- en: An optional comparison operator, `comp`
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较运算符，`comp`
- en: '**Complexity**'
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Logarithmic** If you provide a random iterator, `O(log N)` where `N = distance
    (fwd_begin, fwd_end`); otherwise, `O(N)`'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '**对数** 如果提供了一个随机迭代器，复杂度为`O(log N)`，其中`N = distance(fwd_begin, fwd_end)`；否则，复杂度为`O(N)`'
- en: '**Additional Requirements**'
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The target sequence must be sorted according to `operator<` or `comp` if provided.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列必须根据`operator<`或提供的`comp`进行排序。
- en: '**Example**'
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE79]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You first construct a `vector` of `int` objects ➊. Next, you invoke `lower_bound`
    with this `vector` as the target sequence and a `value` of `5` ➋. The result is
    the third element, `5` ➌. The elements `2` and `4` are less than `5`, whereas
    the elements `5`, `6`, `6`, and `9` are not.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先构造一个`int`对象的`vector` ➊。然后，你使用这个`vector`作为目标序列，并提供`value`为`5`，调用`lower_bound`
    ➋。结果是第三个元素，`5` ➌。元素`2`和`4`小于`5`，而元素`5`、`6`、`6`和`9`不小于`5`。
- en: '***upper_bound***'
  id: totrans-631
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***upper_bound***'
- en: The `upper_bound` algorithm finds a partition in a sorted sequence.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper_bound`算法在已排序的序列中找到一个分区。'
- en: The algorithm returns an iterator corresponding to the element `result`, which
    is the first element in the target sequence greater than `value`.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法返回一个迭代器，指向元素`result`，它是目标序列中大于`value`的第一个元素。
- en: '[PRE80]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '**Arguments**'
  id: totrans-635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`，`fwd_begin`和`fwd_end`，表示目标序列
- en: A `value` to partition the target sequence with
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于划分目标序列的`value`
- en: An optional comparison operator, `comp`
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较运算符，`comp`
- en: '**Complexity**'
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Logarithmic** If you provide a random iterator, `O(log N)` where `N = distance
    (fwd_begin, fwd_end`); otherwise, `O(N)`'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**对数级** 如果提供一个随机迭代器，`O(log N)`，其中`N = distance (fwd_begin, fwd_end)`；否则，`O(N)`'
- en: '**Additional Requirements**'
  id: totrans-641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The target sequence must be sorted according to `operator<` or `comp` if provided.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列必须按照`operator<`或提供的`comp`进行排序。
- en: '**Example**'
  id: totrans-643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE81]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You first construct a `vector` of `int` objects ➊. Next, you invoke `upper_bound`
    with this `vector` as the target sequence and a `value` of `5` ➋. The result is
    the fourth element, `6`, which is the first element in the target sequence greater
    than `value` ➌.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 首先构造一个`int`类型的`vector`对象 ➊。接着，调用`upper_bound`，将这个`vector`作为目标序列，`value`为`5`
    ➋。结果是第四个元素`6`，它是目标序列中大于`value`的第一个元素 ➌。
- en: '***equal_range***'
  id: totrans-646
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***equal_range***'
- en: The `equal_range` algorithm finds a range of certain elements in a sorted sequence.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal_range`算法在排序序列中查找一系列特定的元素。'
- en: The algorithm returns a `std::pair` of iterators corresponding to the half-open
    range equal to `value`.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 算法返回一个`std::pair`的迭代器，表示等于`value`的半开区间。
- en: '[PRE82]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '**Arguments**'
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`，`fwd_begin`和`fwd_end`，表示目标序列
- en: A `value` to seek
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查找的`value`
- en: An optional comparison operator, `comp`
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较运算符，`comp`
- en: '**Complexity**'
  id: totrans-654
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Logarithmic** If you provide a random iterator, `O(log N)` where `N = distance
    (fwd_begin, fwd_end)`; otherwise, `O(N)`'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '**对数级** 如果提供一个随机迭代器，`O(log N)`，其中`N = distance (fwd_begin, fwd_end)`；否则，`O(N)`'
- en: '**Additional Requirements**'
  id: totrans-656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The target sequence must be sorted according to `operator<` or `comp` if provided.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列必须按照`operator<`或提供的`comp`进行排序。
- en: '**Example**'
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE83]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You first construct a `vector` of `int` objects ➊. Next, you invoke `equal_range`
    with this `vector` as the target sequence and a `value` of `6` ➋. The result is
    an iterator pair representing the matching range. The begin iterator points to
    the fourth element ➌, and the second iterator points to the sixth element ➍.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 首先构造一个`int`类型的`vector`对象 ➊。接着，调用`equal_range`，将这个`vector`作为目标序列，`value`为`6`
    ➋。结果是一个表示匹配范围的迭代器对。第一个迭代器指向第四个元素 ➌，第二个迭代器指向第六个元素 ➍。
- en: '***binary_search***'
  id: totrans-661
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***binary_search***'
- en: The `binary_search` algorithm finds a particular element in a sorted sequence.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary_search`算法在排序序列中查找特定元素。'
- en: The algorithm returns `true` if the range contains `value`. Specifically, it
    returns `true` if the target sequence contains an element `x` such that neither
    `x < value` nor `value < x`. If `comp` is provided, it returns `true` if the target
    sequence contains an element `x` such that neither `comp(x, value)` nor `comp(value,
    x)`.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果范围包含`value`，算法返回`true`。具体来说，如果目标序列包含元素`x`，使得`x < value`和`value < x`都不成立，则返回`true`。如果提供了`comp`，则当目标序列包含元素`x`，且`comp(x,
    value)`和`comp(value, x)`都不成立时，返回`true`。
- en: '[PRE84]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '**Arguments**'
  id: totrans-665
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`，`fwd_begin`和`fwd_end`，表示目标序列
- en: A `value` to seek
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查找的`value`
- en: An optional comparison operator, `comp`
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较运算符，`comp`
- en: '**Complexity**'
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Logarithmic** If you provide a random iterator, `O(log N)` where `N = distance
    (fwd_begin, fwd_end)`; otherwise, `O(N)`'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '**对数级** 如果提供一个随机迭代器，`O(log N)`，其中`N = distance (fwd_begin, fwd_end)`；否则，`O(N)`'
- en: '**Additional Requirements**'
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The target sequence must be sorted according to `operator<` or `comp` if provided.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列必须按照`operator<`或提供的`comp`进行排序。
- en: '**Example**'
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE85]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You first construct a `vector` of `int` objects ➊. Next, you invoke `binary_search`
    with this `vector` as the target sequence and a value of `6`. Because the sequence
    contains 6, `binary_search` returns `true` ➋. When you invoke `binary_search`
    with `7`, it returns `false` because the target sequence doesn’t contain `7` ➌.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 首先构造一个`int`类型的`vector`对象 ➊。接着，调用`binary_search`，将这个`vector`作为目标序列，值为`6`。由于序列中包含6，`binary_search`返回`true`
    ➋。当你调用`binary_search`并传入`7`时，它返回`false`，因为目标序列中不包含`7` ➌。
- en: '**Partitioning Algorithms**'
  id: totrans-676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**划分算法**'
- en: A *partitioned sequence* contains two contiguous, distinct groups of elements.
    These groups don’t mix, and the first element of the second distinct group is
    called the *partition point*. The stdlib contains algorithms to partition sequences,
    determine whether a sequence is partitioned, and find partition points. Each algorithm
    explained in this section is in the `<algorithm>` header.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*分区序列*包含两个连续的、不同的元素组。这些组不会混合，第二个不同组的第一个元素称为*分区点*。标准库包含用于分区序列、确定序列是否已分区以及查找分区点的算法。本节中解释的每个算法都在`<algorithm>`头文件中。
- en: '***is_partitioned***'
  id: totrans-678
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***is_partitioned***'
- en: The `is_partitioned` algorithm determines whether a sequence is partitioned.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_partitioned`算法用于确定一个序列是否已分区。'
- en: '**NOTE**'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A sequence is partitioned if all elements with some attribute appear before
    the elements that don’t.*'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果所有具有某些属性的元素都出现在没有这些属性的元素之前，则序列被认为是分区的。*'
- en: The algorithm returns `true` if every element in the target sequence for which
    `pred` evaluates to `true` appears before the other elements.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标序列中所有对`pred`评估为`true`的元素都出现在其他元素之前，则算法返回`true`。
- en: '[PRE86]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '**Arguments**'
  id: totrans-684
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin`和`ipt_end`，表示目标序列
- en: A predicate, `pred`, that determines group membership
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个谓词，`pred`，用于确定组成员资格
- en: '**Complexity**'
  id: totrans-688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** At most `distance(ipt_begin, ipt_end)` evaluations of `pred`'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 最多需要对`pred`进行`distance(ipt_begin, ipt_end)`次评估'
- en: '**Examples**'
  id: totrans-690
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE87]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You first construct a lambda called `is_odd`, which returns `true` if the given
    number is odd ➊. Next, you construct a `vector` of `int` objects ➋ and invoke
    `is_partitioned` with this `vector` as the target sequence and `is_odd` as the
    predicate. Because the sequence contains all its odd numbers placed before its
    even numbers, `is_partitioned` returns `true` ➌.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先构造一个名为`is_odd`的lambda，如果给定的数字是奇数，则返回`true` ➊。接着，你构造一个`int`对象的`vector` ➋，并使用这个`vector`作为目标序列，`is_odd`作为谓词调用`is_partitioned`。因为序列中的所有奇数都排在偶数前面，所以`is_partitioned`返回`true`
    ➌。
- en: You then construct another `vector` of `int` objects ➍ and again invoke `is_partitioned`
    with this `vector` as the target sequence and `is_odd` as the predicate. Because
    the sequence doesn’t contain all its odd numbers placed before its even numbers
    (4 is even and before the second 9), `is_partitioned` returns `false` ➎.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你构造另一个`int`对象的`vector` ➍，并再次使用这个`vector`作为目标序列，`is_odd`作为谓词调用`is_partitioned`。因为该序列并没有把所有的奇数放在偶数前面（4是偶数，且排在第二个9之前），所以`is_partitioned`返回`false`
    ➎。
- en: '***partition***'
  id: totrans-694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***partition***'
- en: The `partition` algorithm partitions a sequence.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition`算法用于对序列进行分区。'
- en: The algorithm mutates the target sequence so it’s partitioned according to `pred`.
    It returns the partition point. The elements’ original ordering isn’t necessarily
    preserved.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法会修改目标序列，使其根据`pred`进行分区。它返回分区点。元素的原始顺序不一定会被保留。
- en: '[PRE88]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '**Arguments**'
  id: totrans-698
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认：`std::execution::seq`）
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`，`fwd_begin`和`fwd_end`，表示目标序列
- en: A predicate, `pred`, that determines group membership
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个谓词，`pred`，用于确定组成员资格
- en: '**Complexity**'
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** At most `distance(fwd_begin, fwd_end)` evaluations of `pred`'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 最多需要对`pred`进行`distance(fwd_begin, fwd_end)`次评估'
- en: '**Additional Requirements**'
  id: totrans-704
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The target sequence’s elements must be swappable.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可交换的。
- en: '**Example**'
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE89]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: You first construct a lambda called `is_odd`, which returns `true` if the given
    number is `odd` ➊. Next, you construct a `vector` of `int` objects ➋ and invoke
    `partition` with this `vector` as the target sequence and `is_odd` as the predicate.
    You assign the resulting partition point into `partition_point` ➌.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先构造一个名为`is_odd`的lambda，如果给定的数字是`odd`（奇数）则返回`true` ➊。接着，你构造一个`int`对象的`vector`
    ➋，并使用这个`vector`作为目标序列，`is_odd`作为谓词调用`partition`。你将结果分区点赋值给`partition_point` ➌。
- en: When you invoke `is_partitioned` on the target sequence with `is_odd` as the
    predicate, it returns `true` ➍. Per the specification of the algorithm, *you cannot
    rely on the ordering within the groups*, but the `partition_point` will always
    be the fourth element, because the target sequence contains three odd numbers
    ➎.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在目标序列上调用`is_partitioned`，并以`is_odd`作为谓词时，它返回`true` ➍。根据算法的规范，*你不能依赖于组内的顺序*，但是`partition_point`将始终是第四个元素，因为目标序列包含三个奇数
    ➎。
- en: '***partition_copy***'
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***partition_copy***'
- en: The `partition_copy` algorithm partitions a sequence.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition_copy`算法对一个序列进行分区。'
- en: The algorithm partitions the target sequence by evaluating `pred` on each element.
    All true elements copy into `opt_true`, and all false elements copy into `opt_false`.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通过在每个元素上评估`pred`来对目标序列进行分区。所有`true`元素复制到`opt_true`中，所有`false`元素复制到`opt_false`中。
- en: '[PRE90]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**Arguments**'
  id: totrans-714
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `InputIterator` objects, `ipt_begin` and `ipt_end`, representing the
    target sequence
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`InputIterator`对象，`ipt_begin`和`ipt_end`，表示目标序列
- en: An `OutputIterator`, `opt_true`, to receive copies of `true` elements
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`OutputIterator`，`opt_true`，用于接收`true`元素的副本
- en: An `OutputIterator`, `opt_false`, to receive copies of `false` elements
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`OutputIterator`，`opt_false`，用于接收`false`元素的副本
- en: A predicate, `pred`, that determines group membership
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个谓词，`pred`，用于确定组成员资格
- en: '**Complexity**'
  id: totrans-720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** Exactly `distance(ipt_begin, ipt_end)` evaluations of `pred`'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 精确地进行`distance(ipt_begin, ipt_end)`次`pred`评估'
- en: '**Additional Requirements**'
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The target sequence’s elements must be copy assignable.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可复制赋值的。
- en: The input and output ranges must not overlap.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出范围不能重叠。
- en: '**Example**'
  id: totrans-725
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE91]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You first construct a lambda called `is_odd`, which returns `true` if the given
    number is `odd` ➊. Next, you construct a `vector` of `int` objects containing
    the `numbers` from 1 to 5 and two empty `vector` objects called `odds` and `evens`
    ➋. Next, you invoke `partition_copy` with `numbers` as the target sequence, a
    `back_inserter` to `odds` as the output for true elements, a `back_inserter` to
    `evens` as the output for false elements, and `is_odd` as the predicate ➌. The
    result is that all of the elements in `odds` are odd ➍ and none of the elements
    in `evens` are odd ➎.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 首先构造一个名为`is_odd`的lambda，如果给定的数字是`odd`（奇数），则返回`true` ➊。接下来，构造一个包含从1到5的`int`对象的`vector`，以及两个空的`vector`对象，分别名为`odds`和`evens`
    ➋。然后，使用`partition_copy`，将`numbers`作为目标序列，一个`back_inserter`插入到`odds`作为`true`元素的输出，一个`back_inserter`插入到`evens`作为`false`元素的输出，`is_odd`作为谓词
    ➌。结果是，所有`odds`中的元素都是奇数 ➍，而`evens`中的元素没有奇数 ➎。
- en: '***stable_partition***'
  id: totrans-728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***stable_partition***'
- en: The `stable_partition` algorithm partitions a sequence stably.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '`stable_partition`算法稳定地对序列进行分区。'
- en: '**NOTE**'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A stable partition might take more computation than an unstable partition,
    so the user is given the choice.*'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '*稳定分区可能比不稳定分区需要更多的计算，因此用户可以选择。*'
- en: The algorithm mutates the target sequence so it’s partitioned according to `pred`.
    It returns the partition point. The elements’ original ordering is preserved.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法会改变目标序列，使其根据`pred`进行分区，并返回分区点。元素的原始顺序将被保留。
- en: '[PRE92]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '**Arguments**'
  id: totrans-734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `BidirectionalIterator`s, `bid_begin` and `bid_end`, representing
    the target sequence
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`BidirectionalIterator`，`bid_begin`和`bid_end`，表示目标序列
- en: A predicate, `pred`, that determines group membership
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个谓词，`pred`，用于确定组成员资格
- en: '**Complexity**'
  id: totrans-738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Quasilinear** `O(N log N)` swaps where `N = distance(bid_begin, bid_end)`,
    or `O(N)` swaps if sufficient memory is available.'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '**准线性** `O(N log N)`次交换，其中`N = distance(bid_begin, bid_end)`，或者如果有足够的内存，`O(N)`次交换。'
- en: '**Additional Requirements**'
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The target sequence’s elements must be swappable, move constructible, and move
    assignable.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可交换的、可移动构造的，并且可以进行移动赋值。
- en: '**Example**'
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE93]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You first construct a lambda called `is_odd`, which returns `true` if the given
    number is `odd` ➊. Next, you construct a `vector` of `int` objects ➋ and invoke
    `stable_partition` with this `vector` as the target sequence and `is_odd` as the
    predicate ➌. The result is that the `vector` contains the elements 1, 3, 5, 2,
    4 because this is the only way to partition these numbers while preserving their
    original within-group order ➍.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你构造一个名为`is_odd`的lambda，它返回`true`，如果给定的数字是`odd` ➊。接下来，你构造一个`int`类型的`vector`对象
    ➋，并使用`stable_partition`，以这个`vector`作为目标序列，`is_odd`作为谓词 ➌。结果是`vector`包含元素1、3、5、2、4，因为这是唯一能够在保持原始组内顺序的情况下划分这些数字的方法
    ➍。
- en: '**Merging Algorithms**'
  id: totrans-745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**合并算法**'
- en: '*Merging algorithms* merge two sorted target sequences such that the resulting
    sequence contains copies of both target sequences and is also sorted. Each algorithm
    explained in this section is in the `<algorithm>` header.'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '*合并算法*将两个已排序的目标序列合并，使得结果序列包含两个目标序列的副本，并且也是排序的。本节中解释的每个算法都位于`<algorithm>`头文件中。'
- en: '***merge***'
  id: totrans-747
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***合并***'
- en: The `merge` algorithm merges two sorted sequences.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`算法合并两个已排序的序列。'
- en: The algorithm copies both target sequences into the destination sequence. The
    destination sequence is sorted according to `operator<` or `comp` if provided.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法将两个目标序列复制到目标序列中。如果提供了`operator<`或`comp`，目标序列将根据这些进行排序。
- en: '[PRE94]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '**Arguments**'
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: Two pairs of `InputIterator`s, `ipt_begin` and `ipt_end`, representing the target
    sequences
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两对`InputIterator`，`ipt_begin`和`ipt_end`，表示目标序列
- en: An `OutputIterator`, `opt_result`, representing the destination sequence
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`OutputIterator`，`opt_result`，表示目标序列
- en: A predicate, `pred`, that determines group membership
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个谓词，`pred`，用于确定组成员资格
- en: '**Complexity**'
  id: totrans-756
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** At most `N-1` comparisons where `N = distance(ipt_begin1, ipt_end1)
    + distance(ipt_begin2, ipt_end2)`'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 最多进行`N-1`次比较，其中`N = distance(ipt_begin1, ipt_end1) + distance(ipt_begin2,
    ipt_end2)`'
- en: '**Additional Requirements**'
  id: totrans-758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The target sequences must be sorted according to `operator<` or `comp` if provided.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`operator<`或`comp`，则目标序列必须根据这些进行排序。
- en: '**Example**'
  id: totrans-760
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE95]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You construct three `vector` objects: two containing sorted `int` objects and
    another that is empty ➊. Next, you merge the non-empty `vector` and use the empty
    `vector` as the destination sequence via a `back_inserter` ➋. The `result` contains
    copies of all the elements from the original sequences, and it too is sorted ➌.'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造三个`vector`对象：两个包含已排序的`int`对象，另一个为空➊。接下来，你将非空的`vector`与空的`vector`合并，并使用空的`vector`作为目标序列，利用`back_inserter`
    ➋。`result`包含了原始序列中所有元素的副本，并且它本身也已排序 ➌。
- en: '**Extreme-Value Algorithms**'
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**极值算法**'
- en: Several algorithms, called *extreme-value algorithms*, determine minimum and
    maximum elements or place limits on the minimum or maximum value of an element.
    Each algorithm explained in this section is in the `<algorithm>` header.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 一些被称为*极值算法*的算法，用于确定最小值和最大值元素，或者限制元素的最小值或最大值。本节中解释的每个算法都位于`<algorithm>`头文件中。
- en: '***min and max***'
  id: totrans-765
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最小值和最大值***'
- en: The `min` or `max` algorithm determines a sequence’s extrema.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '`min`或`max`算法用于确定序列的极值。'
- en: The algorithms use `operator<` or `comp` and return the minimum (`min`) or maximum
    (`max`) object. The `minmax` algorithm returns both as a `std::pair` with `first`
    as the minimum and `second` as the maximum.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法使用`operator<`或`comp`，并返回最小值（`min`）或最大值（`max`）对象。`minmax`算法同时返回这两个值，作为一个`std::pair`，其中`first`为最小值，`second`为最大值。
- en: '[PRE96]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '**Arguments**'
  id: totrans-769
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: Two objects, `obj1` and `obj2`, or
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象，`obj1`和`obj2`，或者
- en: An initializer list, `init_list`, representing the objects to compare
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始化列表，`init_list`，表示要比较的对象
- en: An optional comparison function, `comp`
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较函数，`comp`
- en: '**Complexity**'
  id: totrans-773
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Constant or Linear** For the overloads taking `obj1` and `obj2`, exactly
    one comparison. For the initializer list, at most `N-1` comparisons where `N`
    is the length of the initializer list. In the case of `minmax`, given an initializer
    list, this grows to `3/2 N`.'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '**常数或线性** 对于需要`obj1`和`obj2`的重载，恰好有一个比较。对于初始化列表，最多进行`N-1`次比较，其中`N`是初始化列表的长度。对于`minmax`，给定初始化列表，比较次数将增长到`3/2
    N`。'
- en: '**Additional Requirements**'
  id: totrans-775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements must be copy constructible and comparable using the given comparison.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 元素必须是可复制构造的，并且可以使用给定的比较方法进行比较。
- en: '**Examples**'
  id: totrans-777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE97]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You first initialize a lambda called `length_compare`, which uses `operator<`
    to compare the lengths of two inputs ➊. Next, you use `min` to determine whether
    *undiscriminativeness* or *vermin* has lesser length ➋, and you use `max` to determine
    whether *maxim* or *ultramaximal* has greater length ➌. Finally, you use `minmax`
    to determine which of *minimaxes* and *maximin* has minimum and maximum length
    ➍. The result is a pair ➎➏.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化一个名为`length_compare`的lambda，它使用`operator<`来比较两个输入的长度 ➊。接着，你使用`min`来确定*undiscriminativeness*和*vermin*哪个长度较小
    ➋，并使用`max`来确定*maxim*和*ultramaximal*哪个长度较大 ➌。最后，你使用`minmax`来确定*minimaxes*和*maximin*哪个具有最小和最大长度
    ➍。结果是一个对 ➎➏。
- en: '***min_element and max_element***'
  id: totrans-780
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***min_element和max_element***'
- en: The `min_element` or `max_element` algorithm determines a sequence’s extrema.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '`min_element`或`max_element`算法确定一个序列的极值。'
- en: The algorithms use `operator<` or `comp` and return an iterator pointing to
    the minimum (`min_element`) or maximum (`max_element`) object. The `minimax_element`
    algorithm returns both as a `std::pair` with `first` as the minimum and `second`
    as the maximum.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法使用`operator<`或`comp`，并返回指向最小值（`min_element`）或最大值（`max_element`）的迭代器。`minimax_element`算法同时返回最小值和最大值，作为一个`std::pair`，`first`表示最小值，`second`表示最大值。
- en: '[PRE98]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '**Arguments**'
  id: totrans-784
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认值：`std::execution::seq`）
- en: A pair of `ForwardIterator`s, `fwd_begin` and `fwd_end`, representing the target
    sequence
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对`ForwardIterator`，`fwd_begin`和`fwd_end`，表示目标序列
- en: An optional comparison function, `comp`
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较函数，`comp`
- en: '**Complexity**'
  id: totrans-788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** For `max` and `min`, at most `N-1` comparisons where `N=distance(fwd_begin,
    fwd_end)`; for `minmax`, `3/2 N`'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** 对于`max`和`min`，最多进行`N-1`次比较，其中`N=distance(fwd_begin, fwd_end)`；对于`minmax`，则为`3/2
    N`'
- en: '**Additional Requirements**'
  id: totrans-790
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The elements must be comparable using the given operation.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 元素必须能够使用给定的操作进行比较。
- en: '**Examples**'
  id: totrans-792
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE99]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: You first initialize a lambda called `length_compare`, which uses `operator<`
    to compare the lengths of two inputs ➊. Next, you initialize a `vector` of `string`
    objects called `words` containing four words ➋. You use `min_element` to determine
    the smallest of these words by passing it as the target sequence and `length_compare`
    as the comparison function (`deed`) ➌, and you use `max_element` to determine
    the largest (`malayalam`) ➍. Finally, you use `minmax_element`, which returns
    both as a `std::pair` ➎. The `first` element refers to the shortest `word` ➏,
    and `second` refers to the longest ➐.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化一个名为`length_compare`的lambda，它使用`operator<`来比较两个输入的长度 ➊。接着，你初始化一个包含四个单词的`string`对象`vector`，名为`words`
    ➋。你使用`min_element`来确定这些单词中最小的那个，通过将它作为目标序列，并将`length_compare`作为比较函数（`deed`） ➌，然后使用`max_element`来确定最大的单词（`malayalam`）
    ➍。最后，你使用`minmax_element`，它返回最小值和最大值，作为一个`std::pair` ➎。`first`元素表示最短的`word` ➏，`second`元素表示最长的`word`
    ➐。
- en: '***clamp***'
  id: totrans-795
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***clamp***'
- en: The `clamp` algorithm bounds a value.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '`clamp`算法对值进行约束。'
- en: The algorithm uses `operator<` or `comp` to determine whether `obj` is inside
    the bounds from `low` to `high`. If it is, the algorithm simply returns `obj`;
    otherwise, if `obj` is less than `low`, it returns `low`. If `obj` is greater
    than `high`, it returns `high`.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法使用`operator<`或`comp`来判断`obj`是否在`low`到`high`的范围内。如果在范围内，算法直接返回`obj`；否则，如果`obj`小于`low`，则返回`low`；如果`obj`大于`high`，则返回`high`。
- en: '[PRE100]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '**Arguments**'
  id: totrans-799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: An object, `obj`
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象，`obj`
- en: A `low` and `high` object
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`low`和`high`对象
- en: An optional comparison function, `comp`
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的比较函数，`comp`
- en: '**Complexity**'
  id: totrans-803
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Constant** At most two comparisons'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '**常数** 最多进行两次比较'
- en: '**Additional Requirements**'
  id: totrans-805
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The objects must be comparable using the given operation.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象必须能够使用给定的操作进行比较。
- en: '**Examples**'
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE101]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In the first example, you clamp `9000` to the interval from 0 to 100 inclusive.
    Because 9,000 > 100, the result is `100` ➊. In the second example, you clamp `-123`
    to the same interval. Because −123 < 0, the result is `0` ➋. Finally, you clamp
    `3.14` and because it’s within the interval, the result is `3.14` ➌.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，你将`9000`限制在从0到100的区间内。因为9000 > 100，所以结果是`100` ➊。在第二个示例中，你将`-123`限制在同一区间内。因为−123
    < 0，所以结果是`0` ➋。最后，你将`3.14`限制在区间内，由于它在区间内，因此结果是`3.14` ➌。
- en: '**Numeric Operations**'
  id: totrans-810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数值操作**'
- en: The `<numeric>` header was discussed in [Chapter 12](ch12.xhtml#ch12) when you
    learned about its mathematical types and functions. It also provides algorithms
    well suited to numeric operations. This section introduces many of them. Each
    algorithm explained in this section is in the `<numeric>` header.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '`<numeric>` 头文件在 [第12章](ch12.xhtml#ch12) 中讨论过，你在那时学习了它的数学类型和函数。它还提供了非常适合数值操作的算法。本节介绍了其中的许多算法。本节中解释的每个算法都在
    `<numeric>` 头文件中。'
- en: '***Useful Operators***'
  id: totrans-812
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***常用操作符***'
- en: 'Some stdlib numeric operations permit you to pass an operator to customize
    behavior. For convenience, the `<functional>` header provides the following class
    templates that expose various binary arithmetic operations through `operator(T
    x, T y)`:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准库的数值操作允许你传递操作符以自定义行为。为方便起见，`<functional>` 头文件提供了以下类模板，通过 `operator(T x,
    T y)` 暴露各种二元算术操作：
- en: '`plus<T>` implements addition `x + y`.'
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plus<T>` 实现加法 `x + y`。'
- en: '`minus<T>` implements subtraction `x - y`.'
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minus<T>` 实现减法 `x - y`。'
- en: '`multiplies<T>` implements multiplication `x * y`.'
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiplies<T>` 实现乘法 `x * y`。'
- en: '`divides<T>` implements division `x / y`.'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`divides<T>` 实现除法 `x / y`。'
- en: '`modulus<T>` implements addition `x % y`.'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modulus<T>` 实现模运算 `x % y`。'
- en: 'For example, you could add two numbers using the `plus` template, like this:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用 `plus` 模板来加两个数字，像这样：
- en: '[PRE102]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: You first instantiate a `plus` called `adder` ➊, and then you invoke it with
    the values `1` and `2`, which yields `3` ➋. You can also skip the variable entirely
    and simply use a newly constructed `plus` directly to achieve the same result
    ➌.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你实例化一个名为 `adder` 的 `plus` ➊，然后用 `1` 和 `2` 调用它，结果是 `3` ➋。你也可以完全省略变量，直接使用新构造的
    `plus` 来实现相同的结果 ➌。
- en: '**NOTE**'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You generally wouldn’t use these operator types unless you were using generic
    code that required them.*'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '*通常，除非你正在使用需要这些操作符类型的泛型代码，否则不会使用它们。*'
- en: '***iota***'
  id: totrans-824
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***iota***'
- en: The `iota` algorithm fills a sequence with incremental values.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '`iota` 算法将序列填充为递增的值。'
- en: The algorithm assigns incremental values beginning with `start` to the target
    sequence.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 算法从 `start` 开始，依次将递增值赋给目标序列。
- en: '[PRE103]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '**Arguments**'
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: A pair of iterators, `fwd_begin` and `fwd_end`, representing the target sequence
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对迭代器 `fwd_begin` 和 `fwd_end`，表示目标序列
- en: A `start` value
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `start` 值
- en: '**Complexity**'
  id: totrans-831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** `N` increments and assignments, where `N=distance(fwd_begin, fwd_end)`'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** `N` 次增量和赋值，其中 `N=distance(fwd_begin, fwd_end)`'
- en: '**Additional Requirements**'
  id: totrans-833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The objects must be assignable to `start`.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 对象必须能够赋值给 `start`。
- en: '**Example**'
  id: totrans-835
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE104]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: You first initialize an `array` of `int` objects with length `3` ➊. Next, you
    invoke `iota` with the `array` as the target sequence and `1` as the `start` value
    ➋. The result is that `array` contains the elements 1, 2, and 3 ➌.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你初始化一个长度为 `3` 的 `int` 对象数组 ➊。接着，你调用 `iota`，将 `array` 作为目标序列，`1` 作为 `start`
    值 ➋。结果是 `array` 包含元素 1、2 和 3 ➌。
- en: '***accumulate***'
  id: totrans-838
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***累加***'
- en: The `accumulate` algorithm folds a sequence (in order).
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate` 算法按顺序折叠一个序列。'
- en: '**NOTE**'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Folding a sequence means to apply a particular operation over the elements
    of a sequence while passing the cumulative result along to the next operation.*'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '*折叠一个序列意味着对序列的元素应用特定操作，同时将累积结果传递给下一个操作。*'
- en: The algorithm applies `op` to `start` and the target sequence’s first element.
    It takes the result and the target sequence’s next element and again applies `op`,
    proceeding in this fashion until it visits each element in the target sequence.
    Loosely, this algorithm adds the target sequence elements and the `start` value,
    and it returns the result.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法将 `op` 应用于 `start` 和目标序列的第一个元素。然后它将结果与目标序列的下一个元素再次应用 `op`，以此类推，直到遍历目标序列中的每个元素。大致来说，这个算法将目标序列的元素和
    `start` 值相加，并返回结果。
- en: '[PRE105]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '**Arguments**'
  id: totrans-844
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: A pair of iterators, `ipt_begin` and `ipt_end`, representing the target sequence
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对迭代器 `ipt_begin` 和 `ipt_end`，表示目标序列
- en: A `start` value
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `start` 值
- en: An optional binary operator, `op`, that defaults to `plus`
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元操作符 `op`，默认为 `plus`
- en: '**Complexity**'
  id: totrans-848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** `N` applications of `op`, where `N=distance(ipt_begin, ipt_end)`'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** `N` 次应用 `op`，其中 `N=distance(ipt_begin, ipt_end)`'
- en: '**Additional Requirements**'
  id: totrans-850
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: The target sequence’s elements must be copyable.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 目标序列的元素必须是可复制的。
- en: '**Examples**'
  id: totrans-852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE106]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You first initialize a `vector` of `int` objects with length `3` ➊. Next, you
    invoke `accumulate` with the `vector` as the target sequence and `-1` as the `start`
    value ➋. The result is −1 + 1 + 2 + 3 = 5 ➌.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化一个长度为`3`的`vector`类型的`int`对象 ➊。接着，你使用`vector`作为目标序列，并将`-1`作为`start`值调用`accumulate`
    ➋。结果是 −1 + 1 + 2 + 3 = 5 ➌。
- en: In the second example, you use the same target sequence but a start value of
    `2` and the `multiplies` operator instead ➍. The result is 2 * 1 * 2 * 3 = 12
    ➎.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，你使用相同的目标序列，但`start`值为`2`，操作符改为`multiplies`。结果是 2 * 1 * 2 * 3 = 12 ➎。
- en: '***reduce***'
  id: totrans-856
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***reduce***'
- en: The `reduce` algorithm folds a sequence (not necessarily in order).
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`算法对一个序列进行折叠（不一定按顺序）。'
- en: The algorithm is identical to `accumulate` except it accepts an optional `execution`
    and doesn’t guarantee the order of operator applications.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法与`accumulate`相同，只是它接受一个可选的`execution`并且不保证操作符应用的顺序。
- en: '[PRE107]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '**Arguments**'
  id: totrans-860
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: 'An optional `std::execution` execution policy, `ep` (default: `std::execution::seq`)'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`std::execution`执行策略，`ep`（默认为`std::execution::seq`）
- en: A pair of iterators, `ipt_begin` and `ipt_end`, representing the target sequence
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对迭代器，`ipt_begin`和`ipt_end`，表示目标序列
- en: A `start` value
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`start`值
- en: An optional binary operator, `op`, that defaults to `plus`
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元操作符，`op`，默认为`plus`
- en: '**Complexity**'
  id: totrans-865
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** `N` applications of `op`, where `N=distance(ipt_begin, ipt_end)`'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** `N` 次`op`应用，其中`N=distance(ipt_begin, ipt_end)`'
- en: '**Additional Requirements**'
  id: totrans-867
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: Elements must be movable if you omit `ep`.
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略了`ep`，元素必须是可移动的。
- en: Elements must copyable if you provide `ep`.
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了`ep`，元素必须是可复制的。
- en: '**Examples**'
  id: totrans-870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE108]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: You first initialize a `vector` of `int` objects with length `3` ➊. Next, you
    invoke `reduce` with the `vector` as the target sequence and `-1` as the `start`
    value ➋. The result is −1 + 1 + 2 + 3 = 5 ➌.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化一个长度为`3`的`vector`类型的`int`对象 ➊。接着，你使用`vector`作为目标序列，并将`-1`作为`start`值调用`reduce`
    ➋。结果是 −1 + 1 + 2 + 3 = 5 ➌。
- en: In the second example, you use the same target sequence but a start value of
    `2` and the `multiplies` operator instead ➍. The result is 2 * 1 * 2 * 3 = 12
    ➎.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，你使用相同的目标序列，但`start`值为`2`，操作符改为`multiplies`。结果是 2 * 1 * 2 * 3 = 12 ➎。
- en: '***inner_product***'
  id: totrans-874
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***inner_product***'
- en: The `inner_product` algorithm computes the inner product of two sequences.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '`inner_product`算法计算两个序列的内积。'
- en: '**NOTE**'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An inner product (or dot product) is a scalar value associated with a pair
    of sequences.*'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '*内积（或点积）是与一对序列相关的标量值。*'
- en: The algorithm applies `op2` to each pair of corresponding elements in the target
    sequence and sums them together with `start` using `op1`.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法将`op2`应用于目标序列中每一对对应元素，并使用`op1`将它们与`start`相加。
- en: '[PRE109]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '**Arguments**'
  id: totrans-880
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: A pair of iterators, `ipt_begin1` and `ipt_end1`, representing target sequence
    1
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对迭代器，`ipt_begin1`和`ipt_end1`，表示目标序列1
- en: An iterator, `ipt_begin2`, representing target sequence 2
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个迭代器，`ipt_begin2`，表示目标序列2
- en: A `start` value
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`start`值
- en: Two optional binary operators, `op1` and `op2`, that default to `plus` and `multiply`
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个可选的二元操作符，`op1`和`op2`，默认为`plus`和`multiply`
- en: '**Complexity**'
  id: totrans-885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** `N` applications of `op1` and `op2`, where `N=distance(ipt_begin1,
    ipt_end1)`'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** `N` 次`op1`和`op2`应用，其中`N=distance(ipt_begin1, ipt_end1)`'
- en: '**Additional Requirements**'
  id: totrans-887
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: Elements must be copyable.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 元素必须是可复制的。
- en: '**Example**'
  id: totrans-889
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE110]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: You first initialize two `vector`s of `int` objects ➊ ➋. Next, you invoke `inner_product`
    with the two `vector` objects as the target sequences and `10` as the `start`
    value ➌. The result is 10 + 1 * 1 + 2 * 0 + 3 * 1 + 4 * 0 + 4 * 1 = 13 ➍.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化两个`vector`类型的`int`对象 ➊ ➋。接着，你使用这两个`vector`对象作为目标序列，并将`10`作为`start`值调用`inner_product`
    ➌。结果是 10 + 1 * 1 + 2 * 0 + 3 * 1 + 4 * 0 + 4 * 1 = 13 ➍。
- en: '***adjacent_difference***'
  id: totrans-892
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***adjacent_difference***'
- en: The `adjacent_difference` algorithm generates adjacent differences.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '`adjacent_difference`算法生成相邻元素的差值。'
- en: '**NOTE**'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An adjacent difference is the result of applying some operation to each pair
    of neighboring elements.*'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '*相邻差值是对每一对邻近元素应用某个操作的结果。*'
- en: The algorithm sets the first element of the destination sequence equal to the
    first element of the target sequence. For each subsequent element, it applies
    `op` to the prior element and the current element and writes the return value
    into `result`. The algorithm returns the end of the destination sequence.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法将目标序列的第一个元素设置为目的序列的第一个元素。对于每个后续元素，它将`op`应用于前一个元素和当前元素，并将返回值写入`result`。该算法返回目的序列的结尾。
- en: '[PRE111]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '**Arguments**'
  id: totrans-898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: A pair of iterators, `ipt_begin` and `ipt_end`, representing target sequence
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对迭代器，`ipt_begin` 和 `ipt_end`，表示目标序列。
- en: An iterator, `result`, representing the destination sequence
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个迭代器，`result`，表示目标序列。
- en: An optional binary operator, `op`, that defaults to `minus`
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元操作符，`op`，默认为 `minus`。
- en: '**Complexity**'
  id: totrans-902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** `N-1` applications of `op`, where `N=distance(ipt_begin, ipt_end)`'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** `N-1` 次 `op` 应用，其中 `N=distance(ipt_begin, ipt_end)`'
- en: '**Additional Requirements**'
  id: totrans-904
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加要求**'
- en: Elements must be movable if you omit `ep`.
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略 `ep`，元素必须是可移动的。
- en: Elements must copyable if you provide `ep`.
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你提供了 `ep`，元素必须是可复制的。
- en: '**Example**'
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE112]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'You first two initialize a `vector` of `int` objects, one containing the first
    six numbers of the Fibonacci sequence and another that is empty ➊. Next, you invoke
    `adjacent_difference` with the two `vector` objects as the target sequences ➋.
    The result is as expected: the first element equals the first element of the Fibonacci
    sequence, and the following elements are the adjacent differences (1 – 1 = 0),
    (2 – 1 = 1), (3 – 2 = 1), (5 – 3 = 2), (8 – 5 = 3) ➌.'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化一个 `int` 类型的 `vector` 对象，一个包含斐波那契数列的前六个数字，另一个为空 ➊。接下来，你调用 `adjacent_difference`，将两个
    `vector` 对象作为目标序列 ➋。结果如预期所示：第一个元素等于斐波那契数列的第一个元素，后续元素是相邻差（1 – 1 = 0），（2 – 1 = 1），（3
    – 2 = 1），（5 – 3 = 2），（8 – 5 = 3） ➌。
- en: '***partial_sum***'
  id: totrans-910
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***partial_sum***'
- en: The `partial_sum` algorithm generates partial sums.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial_sum` 算法生成部分和。'
- en: The algorithm sets an accumulator equal to the first element of the target sequence.
    For each subsequent element of the target sequence, the algorithm adds that element
    to the accumulator and then writes the accumulator into the destination sequence.
    The algorithm returns the end of the destination sequence.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法将累加器设置为目标序列的第一个元素。对于目标序列中的每个后续元素，算法将该元素添加到累加器中，然后将累加器写入目标序列。该算法返回目标序列的末尾。
- en: '[PRE113]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '**Arguments**'
  id: totrans-914
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**参数**'
- en: A pair of iterators, `ipt_begin` and `ipt_end`, representing the target sequence
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对迭代器，`ipt_begin` 和 `ipt_end`，表示目标序列。
- en: An iterator, `result`, representing the destination sequence
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个迭代器，`result`，表示目标序列。
- en: An optional binary operator, `op`, that defaults to `plus`
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的二元操作符，`op`，默认为 `plus`。
- en: '**Complexity**'
  id: totrans-918
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复杂度**'
- en: '**Linear** `N-1` applications of `op`, where `N=distance(ipt_begin, ipt_end)`'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性** `N-1` 次 `op` 应用，其中 `N=distance(ipt_begin, ipt_end)`'
- en: '**Example**'
  id: totrans-920
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE114]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: You first initialize two `vector` of `int` objects, one called `num` containing
    the first four counting and an empty one called `result` ➊. Next, you invoke `partial_sum`
    with `num` as the target sequence and `result` as the destination ➋. The first
    element equals the first element of the target sequence, and the following elements
    are the partial sums (1 + 2 = 3), (3 + 3 = 6), (6 + 4 = 10) ➌.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化两个 `int` 类型的 `vector` 对象，一个名为 `num` 包含前四个计数值，另一个名为 `result` 是空的 ➊。接下来，你调用
    `partial_sum`，以 `num` 作为目标序列，`result` 作为目的地 ➋。第一个元素等于目标序列的第一个元素，后续元素是部分和（1 + 2
    = 3），（3 + 3 = 6），（6 + 4 = 10） ➌。
- en: '***Other Algorithms***'
  id: totrans-923
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他算法***'
- en: To keep a long chapter from getting much longer, many algorithms are omitted.
    This section provides a survey of them.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止一章内容过长，许多算法被省略。本节对它们进行了概述。
- en: '**(Max) Heap Operations**'
  id: totrans-925
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**（最大）堆操作**'
- en: A range of length *N* is a max heap if for all 0 < *i* < *N*, the ![Image](../images/fig635_1.jpg)-th
    element (rounded down) doesn’t compare less than the *i*-th element. These structures
    have strong performance properties in situations where maximum element lookup
    and insertions must be fast.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为 *N* 的范围是最大堆，如果对于所有 0 < *i* < *N*，! [Image](../images/fig635_1.jpg) 处的元素（向下取整）不会小于
    *i* 处的元素。这些结构在需要快速查找最大元素和插入元素的情况下具有较强的性能特点。
- en: The `<algorithm>` header contains functions that are useful for handling such
    ranges, such as those in [Table 18-1](ch18.xhtml#ch18tab01). See [alg.heap.operations]
    for details.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '`<algorithm>` 头文件包含了许多有助于处理此类范围的函数，例如 [表 18-1](ch18.xhtml#ch18tab01) 中的那些。详情请参见
    [alg.heap.operations]。'
- en: '**Table 18-1:** Heap-Related Algorithms in the `<algorithm>` Header'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-1：** `<algorithm>` 头文件中的堆相关算法'
- en: '| **Algorithm** | **Description** |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `is_heap` | Checks whether a range is a max heap |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '| `is_heap` | 检查一个范围是否是最大堆 |'
- en: '| `is_heap_until` | Finds the largest subrange that is a max heap |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
  zh: '| `is_heap_until` | 查找最大堆的最大子范围 |'
- en: '| `make_heap` | Creates a max heap |'
  id: totrans-933
  prefs: []
  type: TYPE_TB
  zh: '| `make_heap` | 创建一个最大堆 |'
- en: '| `push_heap` | Adds an element |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
  zh: '| `push_heap` | 添加一个元素 |'
- en: '| `pop_heap` | Removes the largest element |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '| `pop_heap` | 移除最大元素 |'
- en: '| `sort_heap` | Transforms a max heap into a sorted range |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '| `sort_heap` | 将最大堆转换为已排序范围 |'
- en: '**Set Operations on Sorted Ranges**'
  id: totrans-937
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**对已排序范围的集合操作**'
- en: The `<algorithm>` header contains functions that perform set operations on sorted
    ranges, such as those in [Table 18-2](ch18.xhtml#ch18tab02). See [alg.set.operations]
    for details.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '`<algorithm>` 头文件包含对已排序范围进行集合操作的函数，如[表 18-2](ch18.xhtml#ch18tab02)所示。详情请参见[alg.set.operations]。'
- en: '**Table 18-2:** Set-Related Algorithms in the `<algorithm>` Header'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-2：** `<algorithm>` 头文件中的集合相关算法'
- en: '| **Algorithm** | **Description** |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `includes` | Returns `true` if one range is a subset of another range |'
  id: totrans-942
  prefs: []
  type: TYPE_TB
  zh: '| `includes` | 如果一个范围是另一个范围的子集，则返回`true` |'
- en: '| `set_difference` | Computes the difference between two sets |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '| `set_difference` | 计算两个集合的差集 |'
- en: '| `set_intersection` | Computes the intersection of two sets |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '| `set_intersection` | 计算两个集合的交集 |'
- en: '| `set_symmetric_difference` | Computes the symmetric difference between two
    sets |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
  zh: '| `set_symmetric_difference` | 计算两个集合的对称差集 |'
- en: '| `set_union` | Computes the union of two sets |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '| `set_union` | 计算两个集合的并集 |'
- en: '**Other Numeric Algorithms**'
  id: totrans-947
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**其他数值算法**'
- en: The `<numeric>` header contains several more functions in addition to those
    introduced in the “Numeric Operations” section. [Table 18-3](ch18.xhtml#ch18tab03)
    lists them. See [numeric.ops] for details.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '`<numeric>` 头文件包含了除“数值运算”部分介绍的函数之外的多个其他函数。[表 18-3](ch18.xhtml#ch18tab03)列出了它们。详情请参见[numeric.ops]。'
- en: '**Table 18-3:** Additional Numerical Algorithms in the `<numeric>` Header'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-3：** `<numeric>` 头文件中的附加数值算法'
- en: '| **Algorithm** | **Description** |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `exclusive_scan` | Like `partial_sum` but excludes the `i`-th element from
    the `i`-th sum |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '| `exclusive_scan` | 类似于`partial_sum`，但将第`i`个元素排除在第`i`个和之外 |'
- en: '| `inclusive_scan` | Like `partial_sum` but executes out of order and requires
    an associative operation |'
  id: totrans-953
  prefs: []
  type: TYPE_TB
  zh: '| `inclusive_scan` | 类似于`partial_sum`，但不按顺序执行，并且需要关联操作 |'
- en: '| `transform_reduce` | Applies a function object; then reduces out of order
    |'
  id: totrans-954
  prefs: []
  type: TYPE_TB
  zh: '| `transform_reduce` | 应用一个函数对象；然后进行不按顺序的归约 |'
- en: '| `transform_exclusive_scan` | Applies a function object; then calculates an
    exclusive scan |'
  id: totrans-955
  prefs: []
  type: TYPE_TB
  zh: '| `transform_exclusive_scan` | 应用一个函数对象；然后计算排他性扫描 |'
- en: '| `transform_inclusive_scan` | Applies a function object; then calculates an
    inclusive scan |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
  zh: '| `transform_inclusive_scan` | 应用一个函数对象；然后计算包含性扫描 |'
- en: '**Memory Operations**'
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内存操作**'
- en: The `<memory>` header contains a number of low-level functions for handling
    uninitialized memory. [Table 18-4](ch18.xhtml#ch18tab04) lists them. See [memory.syn]
    for details.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '`<memory>` 头文件包含了多个低级别的函数，用于处理未初始化的内存。[表 18-4](ch18.xhtml#ch18tab04)列出了它们。详情请参见[memory.syn]。'
- en: '**Table 18-4:** Operations for Uninitialized Memory in the `<memory>` Header'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-4：** `<memory>` 头文件中用于未初始化内存的操作'
- en: '| **Algorithm** | **Description** |'
  id: totrans-960
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-961
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `uninitialized_copy``uninitialized_copy_n``uninitialized_fill``uninitialized_fill_n`
    | Copy objects into uninitialized memory |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '| `uninitialized_copy``uninitialized_copy_n``uninitialized_fill``uninitialized_fill_n`
    | 将对象复制到未初始化的内存中 |'
- en: '| `uninitialized_move``uninitialized_move_n` | Move objects into uninitialized
    memory |'
  id: totrans-963
  prefs: []
  type: TYPE_TB
  zh: '| `uninitialized_move``uninitialized_move_n` | 将对象移动到未初始化的内存中 |'
- en: '| `uninitialized_default_construct``uninitialized_default_construct_n``uninitialized_value_construct``uninitialized_value_construct_n`
    | Construct objects in uninitialized memory |'
  id: totrans-964
  prefs: []
  type: TYPE_TB
  zh: '| `uninitialized_default_construct``uninitialized_default_construct_n``uninitialized_value_construct``uninitialized_value_construct_n`
    | 在未初始化的内存中构造对象 |'
- en: '| `destroy_at``destroy``destroy_n` | Destroy objects |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
  zh: '| `destroy_at``destroy``destroy_n` | 销毁对象 |'
- en: '**Boost Algorithm**'
  id: totrans-966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Boost Algorithm**'
- en: Boost Algorithm is a large algorithm library that overlaps partially with the
    standard library. For space reasons, [Table 18-5](ch18.xhtml#ch18tab05) lists
    only a quick reference to those algorithms not already contained in the standard
    library. Refer to the Boost Algorithm documentation for further information.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Algorithm 是一个庞大的算法库，部分与标准库重叠。由于篇幅限制，[表 18-5](ch18.xhtml#ch18tab05)仅列出了标准库中未包含的算法的快速参考。有关更多信息，请参阅
    Boost Algorithm 文档。
- en: '**Table 18-5:** Additional Algorithms Available in Boost Algorithm'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-5：** Boost Algorithm 中的附加算法'
- en: '| **Algorithm** | **Description** |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-970
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boyer_moore``boyer_moore_horspool``knuth_morris_pratt` | Fast algorithms
    for searching sequences of values |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '| `boyer_moore``boyer_moore_horspool``knuth_morris_pratt` | 用于搜索值序列的快速算法 |'
- en: '| `hex``unhex` | Writes/reads hexadecimal characters |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
  zh: '| `hex``unhex` | 写入/读取十六进制字符 |'
- en: '| `gather` | Takes a sequence and moves elements satisfying a predicate into
    a given position |'
  id: totrans-973
  prefs: []
  type: TYPE_TB
  zh: '| `gather` | 接受一个序列并将满足谓词的元素移动到给定位置 |'
- en: '| `find_not` | Finds the first element in a sequence not equal to a value |'
  id: totrans-974
  prefs: []
  type: TYPE_TB
  zh: '| `find_not` | 查找序列中第一个不等于某个值的元素 |'
- en: '| `find_backward` | Like `find` but works backward |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
  zh: '| `find_backward` | 类似于 `find`，但从后向前查找 |'
- en: '| `is_partitioned_until` | Returns the end iterator for the largest partitioned
    subsequence that begins with the target sequence’s first element |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '| `is_partitioned_until` | 返回从目标序列的第一个元素开始的最大分区子序列的结束迭代器 |'
- en: '| `apply_permutation``apply_reverse_permutation` | Takes an item sequence and
    an order sequence and reshuffles the item sequence according to the order sequence
    |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
  zh: '| `apply_permutation``apply_reverse_permutation` | 接受一个项目序列和一个顺序序列，并根据顺序序列重新排列项目序列
    |'
- en: '| `is_palindrome` | Returns `true` if a sequence is a palindrome |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
  zh: '| `is_palindrome` | 如果序列是回文，则返回 `true` |'
- en: '**A NOTE ON RANGES**'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于范围的说明**'
- en: '[Chapter 8](ch08.xhtml) introduced range expressions as part of the range-based
    `for` loop. Recall from this discussion that a range is a concept that exposes
    `begin` and `end` methods that return iterators. Because you can place requirements
    on iterators to support certain operations, you can place transitive requirements
    on ranges so they provide certain iterators. Each algorithm has certain operational
    requirements, and these are reflected in the sorts of iterators they require.
    Because you can encapsulate an algorithm’s input sequence requirements in terms
    of ranges, you must understand the various range types to understand each algorithm’s
    constraints.'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.xhtml)介绍了作为基于范围的 `for` 循环的一部分的范围表达式。回顾这一讨论，范围是一个概念，它公开 `begin` 和
    `end` 方法来返回迭代器。由于你可以对迭代器施加要求以支持某些操作，因此你可以对范围施加传递性要求，使其提供某些迭代器。每个算法都有特定的操作要求，这些要求反映在它们所需的迭代器类型中。由于你可以用范围来封装算法输入序列的要求，因此你必须理解各种范围类型，以理解每个算法的约束。'
- en: Like concepts, ranges are not yet formally part of C++. Although you’ll still
    get tremendous benefit from understanding the relationship among ranges, iterators,
    and algorithms, there are two drawbacks. First, algorithms still require iterators
    as input arguments, so even if a range is at hand, you’ll need to extract iterators
    manually (for example, with `begin` and `end`). Second, as with other function
    templates, you’ll sometimes get spectacularly poor error messages when you violate
    an algorithm’s operational requirements.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 和概念一样，范围尚未正式成为 C++ 的一部分。尽管理解范围、迭代器和算法之间的关系仍然会带来巨大的好处，但也有两个缺点。首先，算法仍然需要迭代器作为输入参数，因此即使有了范围，你仍然需要手动提取迭代器（例如，使用
    `begin` 和 `end`）。其次，像其他函数模板一样，当你违反算法的操作要求时，可能会得到极其糟糕的错误信息。
- en: Work is underway to introduce ranges into the language formally. In fact, concepts
    and ranges will likely enter the C++ Standard simultaneously because they dovetail
    so nicely.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 正在进行将范围正式引入语言的工作。事实上，概念和范围很可能会同时进入 C++ 标准，因为它们的结合非常自然。
- en: If you want to experiment with one possible implementation of ranges, refer
    to Boost Range.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试实现一个可能的范围操作，请参考 Boost Range。
- en: '**FURTHER READING**'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO 国际标准 ISO/IEC (2017) — 编程语言 C++*（国际标准化组织；瑞士日内瓦；*[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*）'
- en: '*The C++ Standard Library: A Tutorial and Reference*, 2nd Edition, by Nicolai
    Josuttis (Addison-Wesley Professional, 2012)'
  id: totrans-986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C++标准库：教程与参考》*，第2版，尼科莱·约苏蒂斯著（Addison-Wesley Professional, 2012）'
- en: “Algorithmic Complexity” by Victor Adamchik ([*https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html*](https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html))
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维克托·亚当奇克的《算法复杂性》([*https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html*](https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html))
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Boost C++库》*，第2版，博里斯·谢林著（XML Press, 2014）'
