- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Analyzing Social Networks to Prevent Security Incidents
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分析社交网络以防止安全事件
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In the last three chapters on graph theory, we’ve built graphs from a snapshot
    of a network at a particular moment in time; that is, we’ve worked from fixed,
    historical data. But finding and responding to events in the past always leaves
    the white hats one step behind the black hats. If we want to know more about what
    happened before or after the time captured in the data, we need new analytic techniques.
    The future requires *predictive analytics*, a branch of mathematics that aims
    to statistically determine the probability of future or past events given some
    set of known observations. The goal is to stop the security incident before it
    ever gets started. To achieve this, though, we need a way to predict how things
    will change over time. We’ll use a specific algorithm, the Monte Carlo simulation,
    to model network activity that hasn’t occurred yet. While this chapter presents
    the topic in the context of social network analysis, Monte Carlo simulations are
    suited to a wide variety of topics and network types. For example, I’ve used Monte
    Carlo simulations to predict which machine an adversary would attack next.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的三章图论内容中，我们根据网络在特定时刻的快照构建了图；也就是说，我们使用的是固定的历史数据。但是，回顾过去并响应事件总是让白帽子比黑帽子慢一步。如果我们想了解数据捕获的时间之前或之后发生了什么，我们需要新的分析技术。未来需要*预测分析*，这是一门数学分支，旨在根据一组已知的观察数据统计地确定未来或过去事件的可能性。目标是阻止安全事件在发生之前就被解决。然而，要实现这一点，我们需要一种方法来预测事物随时间的变化。我们将使用一种特定的算法——蒙特卡罗模拟，来模拟尚未发生的网络活动。虽然本章在社交网络分析的背景下介绍了这一主题，但蒙特卡罗模拟适用于各种不同的主题和网络类型。例如，我曾使用蒙特卡罗模拟预测对手接下来会攻击哪台机器。
- en: 'Here, we’ll attempt to predict the answers to the following questions about
    a social network:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将尝试预测以下关于社交网络的问题的答案：
- en: How far is information likely to spread from a given node?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息从给定节点传播的距离有多远？
- en: Which nodes are being influenced by other nodes?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些节点正在受到其他节点的影响？
- en: What links could be severed to disrupt the flow of information between two nodes?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些连接可能会被切断，从而中断两个节点之间的信息流动？
- en: From a security perspective, these questions assess the resilience of a social
    network in the face of adversarial behavior. They ask, “How easy would it be to
    break up an association of people?” Companies ask these questions about themselves
    to determine if they could withstand losing key employees, facilities, or vendors.
    Law enforcement asks them when they assess a criminal syndicate.^([1](b01.xhtml#c06-endnote-001))
    Criminals also ask these questions about an organization when they want to select
    the targets for spear phishing and other social engineering attacks.^([2](b01.xhtml#c06-endnote-002))
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度看，这些问题评估社交网络在面对对抗行为时的韧性。它们问：“打破人们之间的关联有多容易？”公司问这些问题是为了确定他们是否能承受失去关键员工、设施或供应商的打击。执法部门在评估犯罪集团时也会问这些问题。^([1](b01.xhtml#c06-endnote-001))
    犯罪分子也会在选择网络钓鱼和其他社会工程攻击目标时问这些问题。^([2](b01.xhtml#c06-endnote-002))
- en: We’ll begin this chapter by looking at how to define and construct a Monte Carlo
    simulation. We’ll discuss how different levels of randomness can be applied to
    replace unknowns. Then we’ll use the Monte Carlo simulation we’ve built to predict
    the way a piece of information might move through the social network from [Chapter
    5](c05.xhtml), given previous observations. Finally, in the proof of concept for
    this chapter, we’ll see how to modify our simulation to account for adversarial
    behavior. By the end of this chapter, you’ll be able to use your knowledge of
    graph theory and apply Monte Carlo simulations to predict the outcome of different
    scenarios on your own social networks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从定义和构建蒙特卡罗模拟开始。我们将讨论如何应用不同级别的随机性来替代未知数。然后，我们将利用我们构建的蒙特卡罗模拟，预测信息如何在社交网络中传播，从[第5章](c05.xhtml)的先前观察数据出发。最后，在本章的概念验证中，我们将看到如何修改我们的模拟，以考虑对抗行为。在本章结束时，你将能够运用图论知识，并将蒙特卡罗模拟应用于预测自己社交网络中不同情境的结果。
- en: Using Monte Carlo Simulations to Predict Attacks
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用蒙特卡罗模拟预测攻击
- en: For the rest of this chapter to make sense, we need a little bit more theory
    on top of the graph theory we’ve already covered. Specifically, I’ve been throwing
    around the word *simulation* without really defining it. Generally speaking, a
    simulation is a controlled imitation of a real-world process. Simulations rely
    on models to describe the key characteristics and behaviors present in the simulated
    environment. The simulation code acts as the manager of the model, choosing various
    actions and applying them to evolve the model at each step. Modern models and
    simulations are most often designed using a combination of programming languages
    like C and Python, where C is used for critical functions and user-friendly Python
    syntax is used for the rest. Luckily, all the underlying C code has already been
    handled for us, so we can focus on the Python interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让本章其余部分有意义，我们需要在已经涵盖的图论基础上增加一些理论内容。具体来说，我一直在提到*模拟*这个词，但并没有真正定义它。一般来说，模拟是对现实世界过程的受控仿真。模拟依赖于模型来描述模拟环境中存在的关键特征和行为。模拟代码充当模型的管理者，选择各种操作并在每一步应用它们以推动模型的发展。现代模型和模拟通常使用C和Python等编程语言的组合来设计，其中C用于关键功能，而用户友好的Python语法则用于其余部分。幸运的是，所有底层的C代码已经为我们处理好了，所以我们可以专注于Python接口。
- en: In theory, any phenomenon that can be reduced to data and equations can be simulated
    on a computer. In practice, however, simulation is difficult because most real-world
    processes are subject to a practically infinite number of influences, and it’s
    impossible to account for them all.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，任何可以简化为数据和方程的现象都可以在计算机上进行模拟。然而，在实践中，模拟是困难的，因为大多数现实世界的过程都受到几乎无限多种因素的影响，而这些因素是无法全部考虑到的。
- en: A Monte Carlo simulation is a way of quickly gathering statistics about some
    seemingly random (or at least hard to predict) variable, given a set of constraints.
    Unlike other forecasting methods, which work with a set of fixed input values,
    a Monte Carlo simulation predicts a set of outcomes based on an estimated range
    of values. You’ve probably seen the results of a Monte Carlo simulation in the
    form of a storm path map (sometimes called a *spaghetti model*). Monte Carlo simulations
    are most useful when the probability of varying outcomes can’t be determined because
    of random variable interference. A Monte Carlo simulation focuses on repeating
    the test with random samples to achieve certain results. It also helps to explain
    the impact of risk and uncertainty in prediction and forecasting models because
    the values for the random variables are chosen using the distribution of previously
    recorded values. The larger the variance in the random value, the more variance
    in the different results of the simulation. In principle, Monte Carlo methods
    can be used to investigate any problem with a probabilistic interpretation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡罗模拟是一种在给定约束条件下，快速收集有关某些看似随机（或者至少难以预测）变量统计数据的方法。与其他预测方法不同，蒙特卡罗模拟基于一组预估的值范围来预测一组结果，而不是依赖固定的输入值。你可能见过蒙特卡罗模拟的结果，这种结果常以风暴路径图的形式展示（有时被称为*意大利面模型*）。蒙特卡罗模拟在由于随机变量干扰无法确定不同结果的概率时最为有用。蒙特卡罗模拟通过对随机样本进行多次测试，来实现特定结果。它还有助于解释风险和不确定性在预测和预报模型中的影响，因为随机变量的值是通过以前记录的值的分布来选择的。随机值的方差越大，模拟中不同结果的方差也就越大。原则上，蒙特卡罗方法可以用于研究任何具有概率解释的问题。
- en: In a security context, I’ve used Monte Carlo simulations to predict and interrupt
    attacks. To do so, I programmed some rules that mimicked the previous decisions
    of the attacker and ran thousands of simulations to predict where the attacker
    would end up. My team created a network graph (similar to the one from the previous
    chapter) in which we weighed the ease of access along with the machine’s attractiveness
    to the attacker (in terms of data or lateral movement). We then ran simulations
    with the attacker starting from random machines we knew had been exploited and
    using a stochastic process to determine if the attacker could successfully move
    from one machine to another.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全环境中，我使用了蒙特卡罗模拟来预测并阻止攻击。为了实现这一点，我编写了一些规则，模拟了攻击者之前的决策，并运行了成千上万次的模拟来预测攻击者将会在哪里结束。我的团队创建了一个网络图（类似于上一章中的那个），在其中我们综合考虑了访问难度和机器对攻击者的吸引力（从数据或横向移动的角度来看）。然后，我们进行了模拟，攻击者从我们知道已被攻击的随机机器开始，使用随机过程来判断攻击者是否能够成功地从一台机器移动到另一台。
- en: 'We had additional rules to define how the attacker selected machines and so
    forth, but the question we were trying to answer was simple: After six days of
    active exploitation, which machines had the highest probability of being infected?
    In math terms, the law of large numbers tells us that integrals described by the
    expected value of some random variable can be approximated by taking the empirical
    mean (sometimes called the *sample mean*) of independent samples of the variable.
    In lay terms, the machines with the highest probability in our network simulation
    tests were likely those with the actual highest probability. And there’s our definition
    for “predicting” the future: we can state, with some degree of confidence, the
    statistical probability of each outcome. Unfortunately, that means things won’t
    always turn out as predicted.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有额外的规则来定义攻击者如何选择机器等，但我们试图回答的问题很简单：经过六天的积极利用，哪些机器被感染的概率最高？用数学术语来说，大数法则告诉我们，通过对某些随机变量的期望值进行积分，可以通过取该变量的独立样本的经验均值（有时叫做*样本均值*）来进行近似。通俗来说，我们网络仿真测试中被感染概率最高的机器，很可能就是那些实际感染概率最高的机器。这就是我们对“预测”未来的定义：我们可以在一定程度上有信心地陈述每种结果的统计概率。不幸的是，这意味着事情并不总是会按照预测的结果发生。
- en: Modeling changes requires that we first have a way to describe what can and
    can’t happen. We’ll use a mathematical construct known as a finite state machine
    to handle this task. We then need to create a fake world for our simulation to
    inhabit. NetworkX will fill this role by providing the graph of our social network.
    Finally, we need some way of recording the different events so that we can analyze
    them. This is where the Monte Carlo algorithm really starts to take shape. Let’s
    start by defining each piece, and then we can tie it all together with some different
    simulations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 建模变化要求我们首先有一种方法来描述什么可以发生，什么不能发生。我们将使用一种叫做有限状态机的数学构造来处理这个任务。接着，我们需要为我们的仿真创建一个虚拟世界。NetworkX
    将通过提供我们的社交网络图来扮演这个角色。最后，我们需要某种方法来记录不同的事件，以便进行分析。这就是蒙特卡洛算法真正开始发挥作用的地方。让我们从定义每个部分开始，然后通过一些不同的仿真将它们结合起来。
- en: Finite State Machines
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有限状态机
- en: A *finite state machine* (*FSM* or simply *state machine*) is a hypothetical
    machine that can be in exactly one of a finite number of states at a given moment
    in time, where a *state* is a unique configuration of variables. If you think
    of a board with three switches on it, each possible switch configuration represents
    a possible state for the board. It’s called a *finite* state machine because you
    can count the number of possible states. In the example switchboard, if each switch
    can be in one of two possible positions, there’s a total of eight possible configurations,
    or states, the switchboard could be in. If you think of these switches like bits
    in binary, you could represent the values between 000 and 111, or 0 through 7
    in base 10\. The state machine can change from one state to another in response
    to some external *input*, or decision (such as flipping one of the switches on
    the board). Changes from one state to another are called *transitions*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*有限状态机*（*FSM* 或简称 *状态机*）是一个假设的机器，在任何给定时刻只能处于有限数量的状态中的一个，其中一个*状态*是变量的独特配置。如果你想象一块有三个开关的电路板，每种可能的开关配置就代表电路板的一个可能状态。它之所以叫做*有限*状态机，是因为你可以计算出可能的状态数目。在这个示例的开关板中，如果每个开关可以处于两个可能的位置，那么总共有八种可能的配置，或者说状态，开关板可以处于其中。如果你把这些开关看作是二进制中的位，你可以表示从
    000 到 111 的值，或者从 0 到 7 的十进制值。状态机可以响应某些外部*输入*或决策（例如翻动电路板上的一个开关）从一个状态转换到另一个状态。状态之间的变化叫做*过渡*。'
- en: Formally, a state machine *M* is defined by a quintuple *M* = (Ξ, *S*, *S*[0],
    δ) comprising a finite number of possible inputs (Ξ, the *input alphabet*), a
    set of all possible states (*S*), an initialization state (*S*[0]) where *S*[0]
    ∈ *S*, and finally the conditions for each valid transition between states, δ.
    We can represent a state machine as a directed graph wherein each node is a potential
    state of the machine, and each edge is the required input to transition from state
    *u* to state *v*. [Figure 6-1](#figure6-1) shows a simple FSM graph with five
    states and four transition inputs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地，一个状态机 *M* 由五元组 *M* = (Ξ, *S*, *S*[0], δ) 定义，其中包含有限个可能的输入（Ξ，*输入字母表*）、所有可能状态的集合（*S*）、初始化状态（*S*[0]），其中
    *S*[0] ∈ *S*，以及每个有效状态转换之间的条件 δ。我们可以将状态机表示为一个有向图，其中每个节点是机器的潜在状态，每条边是从状态 *u* 到状态
    *v* 所需的输入。[图6-1](#figure6-1) 显示了一个简单的有限状态机图，包含五个状态和四个转换输入。
- en: '![](image_fi/502567c06/f06001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/f06001.png)'
- en: 'Figure 6-1: A simple finite state machine'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：一个简单的有限状态机
- en: 'Looking at this graph, you might be confused; after all, I just said there
    were four transitions, but there are nine edges here (the bidirectional edges
    between *S*[0] and *S*[1] and *S*[3] and *S*[4] count as two each). This is because
    the same input may be used in multiple transitions. The inputs Ξ[3] and Ξ[2] in
    [Figure 6-1](#figure6-1) are both examples of this: Ξ[2] is used to transition
    between *S*[0] and *S*[1] as well as between *S*[4] and *S*[2], while Ξ[3] can
    be used to transition from *S3 to *S*[1] or from *S*[1] to *S*[2]. Think of the
    input Ξ[2] as an action, like flipping a particular switch. Depending on what
    state you’re in currently, the action of flipping the switch may take you to a
    different state. If you’re in *S*[0] and flip the switch, you end up in *S*[1].
    If you’re in *S*[4] and flip the switch, you’ll end up in *S*[2]. The input hasn’t
    changed—it’s still Ξ[2]—which illustrates an important relationship between inputs
    and states. The same input may result in arriving at a different state, depending
    on the current state.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个图，你可能会感到困惑；毕竟，我刚才说过有四个转换，但这里有九条边（*S*[0] 和 *S*[1] 之间以及 *S*[3] 和 *S*[4] 之间的双向边算作两条）。这是因为相同的输入可能在多个转换中使用。[图6-1](#figure6-1)
    中的输入 Ξ[3] 和 Ξ[2] 就是这种情况的例子：Ξ[2] 被用来在 *S*[0] 和 *S*[1] 之间转换，也在 *S*[4] 和 *S*[2] 之间转换，而
    Ξ[3] 可以用来从 *S*[3] 转换到 *S*[1]，或者从 *S*[1] 转换到 *S*[2]。把输入 Ξ[2] 想象成一个动作，比如翻动一个特定的开关。根据你当前所处的状态，翻动开关的动作可能会把你带到不同的状态。如果你在
    *S*[0] 中翻动开关，你会到达 *S*[1]。如果你在 *S*[4] 中翻动开关，你会到达 *S*[2]。输入没有改变——它仍然是 Ξ[2]——这说明了输入和状态之间的一个重要关系：相同的输入可能会导致到达不同的状态，具体取决于当前的状态。
- en: '*FSMs are either *deterministic*, meaning each transition has a single guaranteed
    outcome, or *stochastic*, meaning the outcome of an input is influenced by randomness
    and not guaranteed to produce the same result every time. To illustrate the difference
    between the two types of FSMs, imagine picking up a pencil. In a deterministic
    world, attempting to pick up the pencil will always result in successfully picking
    up the pencil—or transitioning to the state where you have the pencil, in FSM
    parlance. In a stochastic world, you may fail to pick up the pencil with some
    probability 0 < *p* < 1\. If you fail to pick up the pencil, you transition to
    a different state than if you’d succeeded. Perhaps you dropped the pencil on the
    floor and you’re now in that state instead. This is a very simplistic example,
    but the point is that stochastic FSMs allow randomness to influence the results.
    This is powerful for generalizing the description of complex interactions because
    you don’t have to understand the mechanisms at work, you only need to measure
    the statistical distribution of possible outcomes and you can approximate the
    same phenomenon.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*有限状态机（FSM）可以是*确定性的*，意味着每个转换都有一个单一的保证结果，或者是*随机的*，意味着输入的结果受随机性影响，并且不保证每次都会产生相同的结果。为了说明这两种类型的有限状态机之间的区别，想象一下捡起一支铅笔。在一个确定性的世界中，试图捡起铅笔总是会成功——或者在有限状态机的术语中，就是转换到你拥有铅笔的状态。而在一个随机的世界中，捡起铅笔可能会有一定的失败概率
    0 < *p* < 1。如果你未能捡起铅笔，你将进入与成功时不同的状态。也许你把铅笔掉到地板上，现在你处于那个状态。这是一个非常简单的例子，但关键是随机有限状态机允许随机性影响结果。这对于概括复杂交互的描述非常有用，因为你不需要理解背后的机制，你只需要衡量可能结果的统计分布，就能近似同样的现象。'
- en: 'You’ll often see a mix of deterministic and stochastic inputs in the same FSM.
    For example, in the FSM from [Figure 6-1](#figure6-1), Ξ[4] is deterministic.
    If you’re at *S*[2], the input Ξ[4] is guaranteed to transition you to *S*[3]
    and there’s no other possible outcome. On the other hand, Ξ[1] is stochastic:
    if you’re at *S*[4] and select action Ξ[1], you might end up at *S*[1] or at *S*[3].
    If no probabilities are given for these outcomes, it’s assumed to be uniformly
    random. If probabilities are given, the probability distribution is used in a
    weighted-random selection function. NetworkX has parameters for labeling the edges,
    which can be useful when showing the probabilities or, as I’ve done here, the
    transition names. You can see examples of this code in the accompanying Jupyter
    notebook. For more detailed examples of using FSMs, I highly recommend checking
    Wolfram Alpha.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常看到在同一个有限状态机（FSM）中混合使用确定性和随机输入。例如，在[图 6-1](#figure6-1)中的FSM中，Ξ[4]是确定性的。如果你处于*S*[2]状态，输入Ξ[4]会保证将你转换到*S*[3]状态，没有其他可能的结果。另一方面，Ξ[1]是随机的：如果你处于*S*[4]状态并选择了动作Ξ[1]，你可能会到达*S*[1]或*S*[3]。如果没有给出这些结果的概率，通常认为它是均匀随机的。如果给出了概率，则使用概率分布在加权随机选择函数中进行选择。NetworkX有用于标记边的参数，这在显示概率时很有用，或者正如我在这里做的那样，显示转换名称。你可以在附带的Jupyter
    notebook中看到这些代码的示例。关于使用FSM的更详细示例，我强烈推荐查看Wolfram Alpha。
- en: Now that you understand FSM structure a bit better, let’s move on to how we
    can leverage it using an algorithmic gem known as random walks. Random walks allow
    us to repeatedly choose random inputs for our FSM to automate the simulation of
    these choices based on the rules we define.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对FSM结构有了更好的理解，我们继续探讨如何利用它，借助一种名为随机游走的算法宝石。随机游走允许我们反复为FSM选择随机输入，以基于我们定义的规则自动化这些选择的模拟。
- en: Network Modeling with Random Walks
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络建模与随机游走
- en: In math terms, a *random walk* is a series of randomly chosen steps (or transitions)
    within a system that result in a random final state after some number of steps.
    I like the analogy of a tourist wandering in an unfamiliar city. They may walk
    up the street a bit, decide to turn left, go a few blocks, and then decide to
    turn around and go back the other way. These walks are erratic and unpredictable
    by definition. Versions of the random walk model have been applied to research
    topics from economics to neurology, and now information security!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用数学术语来说，*随机游走*是一系列在系统内随机选择的步骤（或转换），在经过若干步之后会导致一个随机的最终状态。我喜欢用游客在陌生城市中漫游的比喻。他们可能会走上一段街道，决定转左，再走几个街区，然后决定转身回头。按照定义，这些游走是无规律且不可预测的。随机游走模型的不同版本已经被应用于从经济学到神经学的研究课题，现在也用于信息安全！
- en: 'We’re going to apply this methodology to model how people pass information
    to one another and ultimately utilize the network. We can then use this information
    to explore what might happen if we change some of the parameters (such as an attacker
    taking over one or more lines of communication) without risking actual disruption
    to the network. Randomly selecting a series of transitions within a state machine
    over *n* steps (*T*(*n*)) updates the state of the system with the result of the
    input. The subsequent decision must be based on the new state, and all actions
    may not be valid in all states. The set of valid transitions from a given state
    is denoted Ξ[(][*S*][)]. At each step a transition is selected from Ξ[(][*S*][)]
    and appended to *T*(*n*). We can write this as:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用这种方法来建模人们如何相互传递信息并最终利用网络。然后，我们可以利用这些信息来探索如果改变一些参数（例如攻击者接管一个或多个通信线路）时会发生什么，而无需冒着实际干扰网络的风险。在状态机中随机选择一系列转换，经过*n*步（*T*(*n*)）后，系统的状态会根据输入结果更新。随后的决策必须基于新状态，并且在所有状态下并非所有动作都是有效的。从给定状态的有效转换集合用Ξ[(][*S*][)]表示。在每一步中，从Ξ[(][*S*][)]中选择一个转换并将其附加到*T*(*n*)中。我们可以将其表示为：
- en: '![](image_fi/502567c06/m06001.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06001.png)'
- en: The state is updated and the process is repeated until all *n* steps have been
    taken, or no valid state transitions are left. The resulting *terminal state*
    is the product of applying the random walk defined in *T*(*n*) to the state machine
    *M* (*M* × *T*(*n*) *= S(Tn*)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 状态被更新后，过程会重复，直到所有*n*步都已完成，或者没有剩余的有效状态转换。最终的*终态*是将*T*(*n*)中定义的随机游走应用于状态机*M* (*M*
    × *T*(*n*) = *S*(Tn*))的结果。
- en: As a concrete example, let’s define a simple state machine. Imagine you’re standing
    in the center of a large empty room. This is the initial state, *S*[0]. On the
    floor is a 7×7 grid of squares, and positions in the room can be expressed as
    location tuples (*x*, *y*) on the Cartesian plane (your position is *S*[0] = (4,
    4)). You can move forward, backward, left, or right one square with each step.
    Given an arbitrary set of instructions, you may end up standing on any square
    in the room; therefore, each square can be viewed as a potential state in *S*.
    The inputs [*forward*, *backward*, *left*, *right*] form the input alphabet Ξ.
    The two diagrams in [Figure 6-2](#figure6-2) show the same uniformly random walk
    for *n* = 10 in two dimensions on the left and three dimensions on the right.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，假设我们定义一个简单的状态机。想象你站在一个大空房间的中心，这是初始状态，*S*[0]。地板上有一个7×7的方格，房间中的位置可以表示为笛卡尔平面上的位置元组（*x*，*y*）（你的位置是*S*[0]
    = (4, 4)）。你可以每次移动一步，向前、向后、向左或向右。给定一组任意的指令，你可能会站在房间的任何方格上；因此，每个方格可以视为*S*中的一个潜在状态。输入[*前进*，*后退*，*左*，*右*]构成了输入字母表Ξ。图[6-2](#figure6-2)中的两个图展示了相同的均匀随机漫步，左边是二维，右边是三维，步数为*n*
    = 10。
- en: '![](image_fi/502567c06/f06002.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/f06002.png)'
- en: 'Figure 6-2: A 2D and 3D random walk example'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：二维和三维随机漫步示例
- en: In the 3D example, the third dimension is time (you wouldn’t actually start
    to levitate as you moved around the room).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D示例中，第三个维度是时间（你在房间里移动时实际上不会开始悬浮）。
- en: 'In contrast to a uniformly random walk, where each input is equally likely,
    in a *biased random walk* (or just *biased walk*), one or more of the inputs is
    likely to occur more than the rest. In a biased walk, we extend Ξ to a set of
    tuples: (*input*, *probability*).^([3](b01.xhtml#c06-endnote-003)) At each step
    we select one of the inputs from the list using a weighted random selection function—that
    is, one that respects the probability distribution we pass to it. We’ll construct
    a version of this later, but for now the key takeaway is that biased walks allow
    you to add any a priori information you have about behavior probabilities to your
    modeling. For example, if you know there’s a malicious actor who’s looking for
    financial information, you may choose to bias your model of their behavior toward
    nodes in the network that have access to such information.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与均匀随机漫步不同，其中每个输入的发生概率相等，在*偏置随机漫步*（或仅称为*偏置漫步*）中，一个或多个输入的发生概率可能会高于其他输入。在偏置漫步中，我们将Ξ扩展为一组元组：(*输入*，*概率*)。^([3](b01.xhtml#c06-endnote-003))在每一步中，我们从列表中选择一个输入，使用加权随机选择函数，也就是遵循我们传递给它的概率分布的函数。我们稍后会构建一个这个的版本，但现在的关键是，偏置漫步允许你将关于行为概率的任何先验信息添加到你的模型中。例如，如果你知道有一个恶意行为者在寻找财务信息，你可能会选择将模型的行为偏向于那些有权限访问该类信息的网络节点。
- en: Up until now we’ve covered what a state machine is and how we can use one to
    simulate a series of choices. Because a random walk represents a single set of
    choices made within a stochastic FSM, you could rerun the simulation and the results
    would likely be different. Even with a biased random walk, the results on each
    iteration may be a little more predictable but still not the same. If the result
    were always the same, the system would be deterministic and no fun to analyze.
    It’s the differences between simulation results that we’re interested in analyzing.
    Repeated stochastic simulation is the defining characteristic of a Monte Carlo
    simulation, so in the next section, we’ll complete our algorithm by defining how
    we want to run each test and collect the results in a meaningful way. Once we
    have the final piece to the puzzle, we’ll start using our Monte Carlo simulation
    to predict some possible future states for our social network.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了什么是状态机，以及如何使用状态机来模拟一系列的选择。由于随机漫步代表在随机状态机（FSM）中做出的一组选择，你可以重新运行模拟，结果可能会有所不同。即使是偏置随机漫步，每次迭代的结果也许会更加可预测，但仍然不完全相同。如果结果总是相同的，那么系统将是确定性的，分析起来也不会有趣。我们感兴趣的是分析模拟结果之间的差异。重复的随机模拟是蒙特卡洛模拟的定义特征，因此在下一节中，我们将通过定义如何运行每个测试并以有意义的方式收集结果，来完成我们的算法。一旦我们获得了拼图的最后一块，我们将开始使用蒙特卡洛模拟预测社交网络的一些可能的未来状态。
- en: Monte Carlo Simulation
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟
- en: We can illustrate the relationship between random walks and Monte Carlo simulations
    with the simple example of flipping a coin. If we flip a coin and it lands on
    heads, what have we learned about the coin? Well, we’ve learned that with an extremely
    small sample size of 1, the coin lands on heads. Now, how useful do you think
    this information is for making predictions about the result of future coin flips?
    Could you predict if this is a fair coin or a trick coin? The answer is no, you
    couldn’t. This single result is not very useful—not yet, anyway. To get a clearer
    picture, we’d need to repeat this test a reasonably large number of times and
    record each outcome. Suppose we flip the coin 99 more times and it always lands
    on heads. This is way outside the expected result of roughly 50 percent, so we
    could state the coin is definitely not fair.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单的掷硬币例子来说明随机游走与蒙特卡洛模拟之间的关系。如果我们掷一枚硬币，并且它落在正面，那么我们从硬币上学到了什么呢？嗯，我们知道在样本量极小（仅为1）的情况下，硬币会落在正面。那么，你认为这些信息对于预测未来掷硬币结果有多大帮助呢？你能否预测这是公平的硬币还是有陷阱的硬币？答案是不能。这个单一结果并不特别有用——至少现在还不。为了得到更清晰的图景，我们需要将这个测试重复进行较多次，并记录每次的结果。假设我们再掷99次硬币，结果每次都落在正面。那么这个结果远远超出了大约50%的预期，我们就可以断定这枚硬币肯定不公平。
- en: This situation is similar to the relationship between random walks and Monte
    Carlo simulations. Monte Carlo simulations are a subset of *repeated-sampling
    algorithms, which repeat a test some large number of times to gather statistical
    distributions. What makes a Monte Carlo simulation different from other repeated
    sampling algorithms is that it uses repeated random walks to simplify simulating
    complex interactions within a state machine over time. The random walk through
    the FSM acts like a single test—a coin flip, a space walk, or some other singular
    occurrence. The Monte Carlo algorithm then adds a layer to repeat this test over
    and over to collect the large sample size needed to make accurate predictions
    about future outcomes.*
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况类似于随机游走和蒙特卡洛模拟之间的关系。蒙特卡洛模拟是*重复采样算法*的一个子集，它通过多次重复测试来收集统计分布。蒙特卡洛模拟与其他重复采样算法的不同之处在于，它通过重复随机游走来简化在状态机中模拟复杂的交互过程。FSM中的随机游走就像一个单一的测试——一次掷硬币、一场太空漫步或其他某种单一事件。然后，蒙特卡洛算法会在此基础上增加一层，将这个测试重复进行多次，以收集大量样本数据，从而对未来结果做出准确预测。
- en: '*One predominant use for Monte Carlo simulations is in the field of General
    Game Playing (GGP). The goal for GGP researchers is to find a generalized algorithm
    that can play any arbitrary but well-defined game. Think about a system like Deep
    Blue or the more recent Alpha Go, but designed to play chess and *Go*, as well
    as backgammon, tic-tac-toe, *Risk*, *Battleship*, and so on. This realm of study
    extends to single-player games (so-called puzzle games) like *Tower of Hanoi*
    as well. The automated system, called the *player*, needs to decide on the next
    valid move from a list of potential moves. This process is known as *goal-oriented
    planning*. In a state machine with a large number of potential states (chess matches,
    for example), it’s prohibitive to exhaustively search the options to conclusion.
    Instead, a player needs a strategy to quickly weigh possible options to identify
    advantageous ones. Monte Carlo simulations are one option that researchers have
    used with some success^([4](b01.xhtml#c06-endnote-004)) by reducing each game
    to a limited-length random walk through potential game states, then repeatedly
    testing the outcome of these walks for some goal condition.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*蒙特卡洛模拟的一个主要应用是在通用博弈游戏（GGP）领域。GGP研究者的目标是找到一种通用算法，能够玩任何任意但定义明确的游戏。想想像深蓝（Deep
    Blue）或更近期的Alpha Go这样的系统，但它被设计用来玩国际象棋和*围棋*，以及西洋跳棋、井字游戏、*风险*、*战舰*等其他游戏。这个研究领域也扩展到单人游戏（即所谓的益智游戏），例如*河内塔*。这个自动化系统被称为*玩家*，需要从一系列潜在动作中决定下一个有效的动作。这个过程被称为*目标导向规划*。在具有大量潜在状态的状态机中（例如国际象棋比赛），全面搜索所有选项并得出结论是不可行的。因此，玩家需要一种策略，快速权衡可能的选项，以识别有利的选择。蒙特卡洛模拟是研究人员成功应用的一种方法^([4](b01.xhtml#c06-endnote-004))，它通过将每场游戏简化为一个有限长度的随机游走，穿越潜在的游戏状态，然后反复测试这些游走的结果，以达到某个目标条件。*'
- en: 'As I’ve mentioned, security often comes down to one researcher’s offensive
    knowledge against another’s defensive knowledge. Game theory would label this
    a zero-sum multiplayer scenario. The term *zero-sum* refers to the case that,
    for one player to win points, the other player must lose an equal amount of points.
    Simply put: if you win, I must lose, and vice versa. Chess is the most famous
    example of zero-sum games, but we also see these conditions in a lot of adversarial
    interactions like security. For me to bypass your security, your security must
    get bypassed. For your security controls to block me, my attacks must fail. There
    are already schools like Stanford University that teach game theory as a way for
    humans to analyze their security posture. There are also researchers using game
    theory to model attack and defense scenarios.^([5](b01.xhtml#c06-endnote-005))
    It seems to me that programmatically applying game theory within information security
    research is a natural progression from the tools available today, and the simplest
    place to start that process is with Monte Carlo simulations.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，安全性往往归结为一个研究人员的进攻知识与另一个研究人员的防守知识之间的对抗。博弈论将这种情况称为零和多人博弈。*零和*指的是一种情况，即为了让一个玩家赢得积分，另一个玩家必须失去等量的积分。简单来说：如果你赢了，我就必须输，反之亦然。国际象棋是零和博弈最著名的例子，但我们也可以在许多对抗性互动中看到这些条件，比如安全性问题。为了绕过你的安全防护，你的安全防护必须被突破。为了阻止我，你的安全控制必须失败。像斯坦福大学这样的学府已经开设博弈论课程，帮助人们分析他们的安全态势。也有研究人员使用博弈论来模拟攻击与防守场景。^([5](b01.xhtml#c06-endnote-005))
    在我看来，将博弈论程序化地应用于信息安全研究是从现有工具自然发展而来的，而开始这一过程的最简单方式就是使用蒙特卡罗仿真。
- en: Of course, this simplicity can come at a cost. Monte Carlo simulations can miss
    obvious advantageous decisions due to the random nature of selection. You can
    tune the accuracy of the model a bit by adjusting the number of random walks,
    as well as the maximum length of each random walk. [Figure 6-3](#figure6-3) shows
    an example Monte Carlo simulation of random walks like the one in [Figure 6-2](#figure6-2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种简化可能会带来一些代价。由于选择的随机性质，蒙特卡罗仿真可能会错过明显的有利决策。你可以通过调整随机游走的次数，以及每次随机游走的最大长度，来略微调节模型的准确性。[图
    6-3](#figure6-3)展示了一个蒙特卡罗仿真示例，类似于[图 6-2](#figure6-2)中的随机游走。
- en: '![](image_fi/502567c06/f06003.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/f06003.png)'
- en: 'Figure 6-3: A random walk Monte Carlo simulation'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：随机游走蒙特卡罗仿真
- en: Each walk is shaded differently so you can tell where they overlap. They all
    start from the same location but then take unpredictable paths.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每次游走的路径会有不同的阴影色调，这样你就可以看出它们的重叠部分。它们都从同一个位置开始，但随后会沿着不可预测的路径走。
- en: 'The Monte Carlo simulation we’ll look at is an algorithm that relies on *k*
    random walks of length *n*, through a state machine *M*, to obtain the result
    list ζ*R*. The result is a list of terminal states from each random walk performed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的蒙特卡罗仿真是一种依赖于 *k* 次长度为 *n* 的随机游走算法，通过状态机 *M* 来获得结果列表 ζ*R*。结果是每次随机游走得到的终态列表：
- en: '![](image_fi/502567c06/m06002.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06002.png)'
- en: 'For convenience, I also output the path traversed by each random walk:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我还输出了每个随机游走所经过的路径：
- en: '![](image_fi/502567c06/m06003.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06003.png)'
- en: Choosing values for *n* and *k* is an equal mix of domain knowledge, statistical
    theory, and art. For *n*, we need to choose a value large enough to allow our
    model to reach interesting outcome states without creating a bunch of repetitive
    data. For state machines with a large number of potential transitions and states,
    you may need to pick a value for *n* that balances long enough paths with a reasonable
    program runtime. Our state machine has a small number of potential transitions
    and will tend to reach a terminal state fairly quickly, so a small value between
    10 and 20 steps will suffice.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 *n* 和 *k* 的值既需要领域知识，也需要统计理论和艺术的结合。对于 *n*，我们需要选择一个足够大的值，使得我们的模型能够到达有趣的结果状态，而不会产生大量重复数据。对于有大量潜在转移和状态的状态机，你可能需要选择一个
    *n* 值，平衡足够长的路径与合理的程序运行时间。我们的状态机有少量的潜在转移，并且通常会很快到达终态，所以 10 到 20 步之间的小值就足够了。
- en: Choosing a good value for *k* is largely related to the number of potential
    states in the machine. You want to run the simulation as many times as it takes
    to collect statistical data to support a claim about the outcome, so the more
    possible outcomes there are, the more times you’ll want to run the simulation.
    When you move a project like this into production, you can use statistical methods
    to calculate the exact sample size required to justify an empirical claim, called
    *sample size determination*. Here, our simulation has a relatively small number
    of terminal states and we’re only trying to prove out the system, so somewhere
    between 10 and 25 runs will suffice for testing purposes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个好的*k*值与机器中潜在状态的数量密切相关。你希望尽可能多次运行模拟，以收集支持结果主张的统计数据，因此可能的结果越多，你就越希望多次运行模拟。当你将这样的项目投入生产时，可以使用统计方法来计算确切的样本量，以证明实证主张，这叫做*样本量确定*。在这里，我们的模拟只有相对较少的终端状态，并且我们只是尝试证明系统的有效性，因此，进行10到25次运行就足够进行测试。
- en: Simulating Social Networks
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社交网络模拟
- en: To answer our research questions about a social network, we’re going to write
    our own *Matrix*-like world, where simulated users live out their digital lives
    according to the rules of the system we put in place. The rules we choose represent
    all the decisions a user can make in our simulated world. I base the rules I use
    on the observations already present in the data (for example, which users have
    communicated in the past, and on what topics), as well as a simplified version
    of some link prediction theory published in 2009.^([6](b01.xhtml#c06-endnote-006))
    *Link prediction theory* attempts to describe how edges in a graph have formed
    previously and use that information to predict how they’ll form in the future.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答关于社交网络的研究问题，我们将编写我们自己的*Matrix*式世界，其中模拟的用户将根据我们设定的系统规则生活。我们选择的规则代表了用户在模拟世界中可以做出的所有决策。我所使用的规则基于数据中已经存在的观察结果（例如，哪些用户曾经沟通过，沟通的主题是什么），以及2009年发布的某些链接预测理论的简化版本。^([6](b01.xhtml#c06-endnote-006))
    *链接预测理论* 试图描述图中的边缘是如何以前形成的，并利用这些信息来预测未来如何形成。
- en: Our goal in designing the rules for the FSM is to accurately simulate which
    users might form connections, dissolve their association with other users, or
    pass information along to their connections. We’ll then look at how we can enhance
    the simulation by adding an adversary who is working to disrupt the network. This
    allows us to move into the realm of “what if” simulations. What if the head of
    HR suddenly leaves the company? What if the router in the office crashes? You’ll
    start seeing chances to apply simulations everywhere. After reading through this
    implementation, think about the rules and assumptions we’ve built up and how you
    might improve the simulation with more realistic constraints and behaviors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计有限状态机（FSM）规则的目标是准确模拟哪些用户可能会建立连接、解除与其他用户的关联，或将信息传递给他们的连接。接下来，我们将研究如何通过增加一个旨在破坏网络的对立者来增强模拟。这使我们进入了“如果”的模拟领域。如果人力资源部门的负责人突然离开公司会怎么样？如果办公室的路由器崩溃了呢？你会开始看到到处都可以应用模拟的机会。阅读完这个实现后，思考一下我们建立的规则和假设，以及如何通过更加现实的约束和行为来改进模拟。
- en: Modeling User Interaction
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户互动建模
- en: To answer the question “How far is information likely to spread from a given
    node?” we can simulate a message *q* propagating through the network by being
    transmitted from one user to another, and determine how many users are likely
    to receive the message. We’ll model the user interactions by generating biased
    random walks for the message to move from node to node. Assume, for the moment,
    that only one copy of the message can exist at a time. (See “[Modeling Information
    Flow](#h2-502567c06-0006)” for handling multiple copies of a message.) Think of
    this like a budget report making its way around an office. As each employee reads
    the report, they decide whether to forward it on to one of their coworkers. Because
    the report is sensitive, no one is allowed to make copies, so only one person
    can be holding the information at any given time. By selecting a starting node
    and allowing the message to propagate probabilistically, we can simulate possible
    paths the report is likely to follow, then count the unique nodes that eventually
    received the message. The average count of unique nodes after all the walks have
    been completed can be seen as the number of nodes likely to receive the information
    originating from the selected starting node.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答“信息从某个节点传播的范围有多远？”这个问题，我们可以模拟一个消息*q*在网络中通过从一个用户传递到另一个用户的方式传播，并确定可能接收到该消息的用户数量。我们将通过为消息生成偏置的随机游走来模拟用户之间的交互，从而让消息在节点间传播。假设，目前为止一次只有一份消息副本存在。（处理消息的多个副本请参见“[信息流建模](#h2-502567c06-0006)”）可以将其想象为一份预算报告在办公室内流转。每个员工阅读报告后，决定是否将其转发给某个同事。由于报告内容敏感，没人被允许复印，因此任何时刻只有一个人可以持有该信息。通过选择一个起始节点并允许消息按概率传播，我们可以模拟报告可能遵循的路径，然后统计最终接收到报告的独特节点数量。所有游走完成后，接收到信息的独特节点的平均数量可以看作是从选定的起始节点开始，信息可能传播到的节点数量。
- en: For a Monte Carlo simulation, you must define the state machine that will act
    as the core of the system. The social network graph nodes (the users) represent
    states the message can occupy in the FSM. Edges indicate potential transitions
    between states (which is based on past communications between users). In the beginning
    of our simulations these will remain static, and we’ll be examining the network
    as it exists at the current point in time. (In the proof of concept for this chapter,
    the edges will change to simulate users making and severing connections within
    the network.) Finally, the input alphabet, which defines valid actions for the
    available transitions, models interactions between nodes (for example, one user
    passing the message to another). Defining inputs and transitions for the FSM is
    similar to defining what are valid choices and when. For the first question, which
    deals with information transmitted between nodes, the input alphabet is [*Send*,
    *Pass*], representing the two actions a user may take when they receive a piece
    of information.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于蒙特卡洛模拟，你必须定义作为系统核心的状态机。社交网络图中的节点（即用户）代表消息在有限状态机（FSM）中可能占据的状态。边表示状态之间的潜在转移（基于用户之间的过去通信）。在我们模拟的开始，这些边将保持静态，我们将检查当前时刻网络的状态。（在本章的概念验证中，边会发生变化，以模拟用户在网络中建立和断开连接。）最后，输入字母表定义了有效的过渡操作，模拟节点之间的交互（例如，一个用户将消息传递给另一个用户）。定义FSM的输入和转移类似于定义有效的选择以及选择的时机。针对第一个问题，即节点之间传递的信息，输入字母表是[*发送*,
    *传递*]，表示用户在接收到信息后可能采取的两种操作。
- en: To start, we’ll define the initial state *S*[0] as the node with the highest
    out-degree holding the message, so the simulation has the best chance of reaching
    a large number of unique nodes on different simulations. Later, we’ll measure
    the effect of starting from different nodes. The node holding the message at any
    given moment is *u*(*q*).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将初始状态*S*[0]定义为持有消息的出度最高的节点，这样模拟就能在不同的模拟中最大程度地覆盖更多独特的节点。稍后，我们会衡量从不同节点开始的效果。在任何给定时刻，持有消息的节点是*u*(*q*)。
- en: 'At each step in a random walk, the node *u*(*q*) uniformly selects one of two
    possible inputs Ξ = [*Send*, *Pass*]. The a priori probability of an input being
    selected is:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机游走的每一步中，节点*u*(*q*)会均匀地从两个可能的输入 Ξ = [*发送*, *传递*] 中选择一个。选择输入的先验概率为：
- en: '![](image_fi/502567c06/m06004.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06004.png)'
- en: '*Pr* (Ξ[*(Send)*]) denotes the probability of *Send*. If *u*(*q*) chooses *Send*,
    *q* is passed to a uniformly selected neighbor of *u*(*q*) (I still denote the
    neighbors of a node as Γ[*(u)*]). If *Pass* is chosen, *u*(*q*) does nothing for
    that step.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pr* (Ξ[*(Send)*])表示*Send*的概率。如果*u*(*q*)选择*Send*，则*q*将被传递给*u*(*q*)的一个均匀随机选择的邻居（我仍然将一个节点的邻居表示为Γ[*(u)*]）。如果选择*Pass*，则*u*(*q*)在该步骤中不做任何操作。'
- en: 'The a priori probability of a given neighbor *v* being selected is:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 给定邻居*v*被选中的先验概率是：
- en: '![](image_fi/502567c06/m06005.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06005.png)'
- en: 'Here v ∈ Γ(u(q ) ). Simply put, this means the starting probability for each
    neighbor is equal. The larger the number of neighbors a node has, the lower the
    probability of any one neighbor receiving the message next. For example, if *u*(*q*)
    has three neighbors (|Γ(u(q))| = 3), then ![m06006r](image_fi/502567c06/m06006r.png).
    You could also write this as a conditional probability (*Pr*(*A*|*B*)):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '这里v ∈ Γ(u(q))。简单来说，这意味着每个邻居的起始概率是相等的。一个节点的邻居越多，任何一个邻居接收消息的概率就越低。例如，如果*u*(*q*)有三个邻居（|Γ(u(q))|
    = 3），那么![m06006r](image_fi/502567c06/m06006r.png)。你也可以将其写成条件概率（*Pr*(*A*|*B*)):'
- en: '![](image_fi/502567c06/m06007.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06007.png)'
- en: The formula states that the probability of a particular neighbor receiving the
    message, given the input is *Send*, is 0.33, or 33 percent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该公式表示，在输入为*Send*的情况下，某个特定邻居接收到消息的概率为0.33，即33%。
- en: 'The overall probability of a message propagating without presuming that *Send*
    is the selected input is defined in the numerator of the previous equation. Intuitively,
    you can think of this as the probability of each event occurring in isolation.
    More properly, the independent probability of a message propagating forward to
    a given neighbor of *u*(*q*) (assuming three neighbors) is:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设不考虑*Send*为选定输入的情况下，消息传播的总体概率定义在前一个公式的分子中。直观地，你可以将其视为每个事件单独发生的概率。更准确地说，消息传播到给定邻居的独立概率（假设有三个邻居）是：
- en: Pr (u(q) → v ) = Pr ( Ξ( Send ) ∧ v(q) ) = 0.5 × 0.33 = 0.165
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Pr (u(q) → v ) = Pr ( Ξ( Send ) ∧ v(q) ) = 0.5 × 0.33 = 0.165
- en: Before we generate random walks, we need to set up the simulation, as shown
    in [Listing 6-1](#listing6-1).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成随机游走之前，我们需要设置仿真环境，如[Listing 6-1](#listing6-1)所示。
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: The initialization code for the Monte Carlo simulation'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-1：蒙特卡洛仿真初始化代码
- en: The code relies on the graph *G* being populated using the method back in Listings
    5-2 and 5-4. Assuming the graph *G* has already been populated, we start with
    the input alphabet `XI`, which represents *Send* as expected and *Pass* using
    `None` ❶; the number of simulations, `k` ❷; and the number of steps in each simulation,
    `n`. To set the start state `S0` ❸, we select the node with the highest out-degree.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码依赖于图*G*已使用Listings 5-2和5-4中的方法进行填充。假设图*G*已经填充完成，我们从输入字母表`XI`开始，其中*Send*使用`None`表示
    ❶，仿真次数`k` ❷，以及每次仿真的步数`n`。为了设置起始状态`S0` ❸，我们选择出度最高的节点。
- en: Continuing from [Listing 6-1](#listing6-1), [Listing 6-2](#listing6-2) shows
    a deterministic, uniformly random implementation of the message-passing Monte
    Carlo simulation algorithm.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 延续[Listing 6-1](#listing6-1)，[Listing 6-2](#listing6-2)展示了一个确定性的、均匀随机的消息传递蒙特卡洛仿真算法实现。
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: A deterministic message-passing Monte Carlo simulation'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-2：确定性消息传递蒙特卡洛仿真
- en: First, we initialize the results list `R` ❶, and then we use nested `for` loops
    24 to perform `k` random walks with up to `n` steps in each.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化结果列表`R` ❶，然后使用嵌套的`for`循环24执行`k`次随机游走，每次游走最多执行`n`步。
- en: Each walk begins with the message at the node `S0` ❸. At each step, we gather
    the neighbors for the currently selected node ❺. If exactly one neighbor exists,
    this neighbor is automatically selected. However, if more than one neighbor exists
    ❻, we select one uniformly at random using the `choice` function, then update
    the `message_at` variable. If the message ever reaches a node with no out-degree
    ❼, we record the node as the result and conclude the walk with `break`. At the
    end of each walk, we append the terminating node `Tn` to the results list ❽.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每次游走从节点`S0` ❸开始。在每一步，我们收集当前选定节点的邻居 ❺。如果只有一个邻居，则自动选择该邻居。然而，如果存在多个邻居 ❻，我们使用`choice`函数从中均匀地随机选择一个邻居，然后更新`message_at`变量。如果消息最终到达一个没有出度的节点
    ❼，我们将该节点记录为结果，并用`break`结束游走。在每次游走结束时，我们将终止节点`Tn`添加到结果列表 ❽。
- en: We summarize the likely *information flow distance*, or *IFD* (![m06008](image_fi/502567c06/m06008.png)),
    as the mean number of unique nodes (disregarding the starting node) in each path
    ❾, then normalize the IFD by the total number of nodes in `G` (again, disregarding
    the starting node) ❿ and print it out to the screen. The `unique` function simply
    takes the path and reduces it to only unique entries. (You can see how I implemented
    it in the 2nd cell of the *MonteCarloSimulations.ipynb* notebook in the chapter’s
    supplemental materials. You can also choose to use one of the library’s versions
    of the code, such as NumPy’s `unique`.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将可能的*信息流距离*（或*IFD*）![m06008](image_fi/502567c06/m06008.png)总结为每条路径中独特节点的平均数量（不考虑起始节点）❾，然后通过`G`中的节点总数（同样不考虑起始节点）❿来标准化IFD，并将其输出到屏幕上。`unique`函数简单地将路径减少为仅包含唯一条目的列表。（你可以在本章补充材料的*MonteCarloSimulations.ipynb*笔记本中的第二个单元格中查看我是如何实现的。你也可以选择使用库中某个版本的代码，例如NumPy的`unique`。）
- en: If you run the code in [Listing 6-2](#listing6-2) a few times, you’ll notice
    the output isn’t consistent. While *S*[*0*] is deterministic, the route from there
    is stochastic. You could edit this model to be entirely deterministic by replacing
    the `vq = choice(gamma_uq)` call with a deterministic selection method, such as
    always passing *q* to the neighbor of *u*(*q*) with the highest out-degree. This
    would be a good option to model a specific behavior pattern that’s known in advance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行[Listing 6-2](#listing6-2)中的代码几次，你会注意到输出结果不一致。虽然*S*[*0*]是确定性的，但从那里开始的路径是随机的。你可以通过将`vq
    = choice(gamma_uq)`调用替换为一个确定性选择方法（例如，总是将*q*传递给邻居节点*u*（*q*）的出度最高的节点），使得这个模型完全确定性。这将是模拟已知的特定行为模式的一个好选项。
- en: 'To implement the simulation with a biased walk instead of a uniformly random
    walk, you can add another element to `XI` that is the same as one already present.
    By doing so, you change the relative probabilities of each input variable being
    selected. For example, adding another `"send"` to the list will weight *Send*
    to twice as likely as *Pass*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个带有偏置行走的模拟，而不是均匀随机行走，你可以向`XI`中添加另一个已经存在的元素。通过这样做，你改变了每个输入变量被选择的相对概率。例如，向列表中添加另一个`"send"`将使*Send*的概率是*Pass*的两倍：
- en: '![](image_fi/502567c06/m06009.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06009.png)'
- en: 'For more fine-tuned control over the probability (bias) of each input, switch
    out the simple `choice` function for one that can process a dictionary of `{action:
    probability}` definitions. (See the proof of concept at the end of the chapter
    for an example.)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '为了对每个输入的概率（偏置）进行更精细的控制，可以将简单的`choice`函数替换为一个可以处理`{action: probability}`定义字典的函数。（请参见本章末尾的概念验证部分以获取示例。）'
- en: Congratulations, you’ve now defined your first predictive model using Monte
    Carlo simulations! This is a simplistic model where we rely on uniform selection
    for randomness and some basic actions, like send and pass, to describe what might
    occur to some arbitrary message on our network. Try starting the message from
    different users and see how it impacts the number of steps the message travels
    and where it ends up. We refer to this as a *naive model*, because we didn’t include
    any specific information about the history of the network, message contents, or
    user preferences. We assume each node is equally likely to send any message to
    any other node it can contact. While simplifying assumptions like this make the
    code easier to write and interpret, they do so at the expense of accuracy. In
    the next section, we’ll extend our model to incorporate more details about the
    message and users to more accurately predict the probable flow of information
    given what we’ve already witnessed about data flow in the network.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经使用蒙特卡洛模拟定义了第一个预测模型！这是一个简化的模型，我们依赖均匀选择来生成随机性，并使用一些基本动作，如发送和传递，来描述网络中某个任意消息可能发生的情况。尝试从不同的用户那里启动消息，看看它如何影响消息的传递步骤数以及最终的位置。我们称之为*简单模型*，因为我们没有包含有关网络历史、消息内容或用户偏好的任何具体信息。我们假设每个节点都有相同的概率将任何消息发送给它能联系到的任何其他节点。虽然像这样的简化假设使代码更容易编写和解释，但它们以牺牲准确性为代价。在下一节中，我们将扩展模型，加入更多关于消息和用户的细节，以更准确地预测我们已经观察到的数据流在网络中的可能流动。
- en: Modeling Topic-Based Influence
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于主题的影响建模
- en: To answer the question “Which nodes are being influenced by other nodes?” we’ll
    extend the investigation of topic-based influence from [Chapter 5](c05.xhtml).
    Recall that we previously weighed each user’s potential interest in a topic by
    measuring their interaction with other messages containing the same topic, using
    the Hyperlink-Induced Topic Search algorithm (HITS). If we reframe our current
    model with respect to a given message topic, like the environment, we can incorporate
    hub and authority information into our state machine model to control the information
    exchange probability. In this case, we’ll use a user’s HITS score to determine
    the probability of a message being reblogged based on the message’s content, instead
    of just blindly assuming all messages have the same probability for all users
    all the time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答“哪些节点受到其他节点的影响？”这个问题，我们将扩展[第5章](c05.xhtml)中基于话题的影响调查。回想一下，我们之前通过测量用户与包含相同话题的其他消息的互动，使用超链接引导话题搜索算法（HITS）来衡量每个用户对某一话题的潜在兴趣。如果我们将当前模型以某个特定消息话题（如环境）为基础进行重新构建，我们可以将中心节点和权威信息融入到我们的状态机模型中，从而控制信息交换的概率。在这种情况下，我们将使用用户的HITS分数来确定消息被转发的概率，这个概率是基于消息内容的，而不是简单地假设所有消息对于所有用户的转发概率都是相同的。
- en: Modeling message propagation in this fashion assumes that a user is more likely
    to reblog a message similar to a message they have reblogged previously. Users
    who have reblogged posts involving a given topic get a higher authority score
    for that topic than those who haven’t, which translates to a higher probability
    of receiving a message about that topic. If you think about the content you see
    on people’s social network feeds, you’ll probably see a fairly common theme among
    the information they share and reshare (this is one of those assumptions you may
    want to challenge later). Some people choose to share business news; others, arts
    and entertainment; and still others, security.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式建模消息传播假设用户更有可能转发他们之前已转发过的类似消息。已经转发过涉及特定话题的帖子用户，比没有转发过的用户拥有更高的该话题权威分数，这意味着他们更有可能收到关于该话题的消息。如果你考虑一下在社交网络上看到的内容，你可能会发现人们分享和重新分享的信息中有一个相当常见的主题（这是你可能想稍后挑战的假设之一）。有些人选择分享商业新闻；有些人分享艺术和娱乐；还有些人分享安全相关的内容。
- en: Let’s update the previous implementation to compare the spread of different
    message types (*qx*) so we can examine the interests of different users and predict
    what messages they’re most likely to reblog in the future. If you were designing
    a viral message attack for this network, it would make sense for you to examine
    different topics and choose the one with the highest probability of propagating
    farthest through the network. From a defensive perspective, you can flip this
    analysis and track a malicious message back to the probable source. We’ll be keeping
    the same definition of influence between users (so a user reblogging a message
    is influenced by that message to some degree), but instead of using the *Send*
    action, our nodes will be selecting messages to reblog. Nothing about the action
    changes, so I’ve opted to keep the name, but renaming it might help to keep the
    direction of influence clear in your model.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新之前的实现，比较不同消息类型（*qx*）的传播方式，这样我们就可以检查不同用户的兴趣，并预测他们未来最有可能转发哪些消息。如果你在为这个网络设计病毒性消息攻击，分析不同的话题并选择传播最远的那个是有意义的。从防御的角度来看，你可以反向分析这条消息，并追踪恶意消息的可能来源。我们将保持用户之间的影响力定义不变（也就是说，用户转发一条消息时，受到了该消息的某种程度影响），但我们的节点将选择要转发的消息，而不是使用*发送*操作。操作的方式没有改变，因此我选择保持名称，但重新命名可能有助于在你的模型中保持影响方向的清晰。
- en: '[Listing 6-3](#listing6-3) shows the code to run a topic-based message-passing
    Monte Carlo simulation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单6-3](#listing6-3)展示了运行基于话题的消息传递蒙特卡洛模拟的代码：'
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-3: A topic-based message-passing Monte Carlo simulation'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-3：基于话题的消息传递蒙特卡洛模拟
- en: 'This code prints a tuple of `(S0, {node: termination_count})`, using the same
    values for `k` and `n` defined in [Listing 6-1](#listing6-1), as well as the `term_subgraph`
    function ❶, which is based on code you’ll see later in [Listing 6-5](#listing6-5).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码打印一个元组`(S0, {node: termination_count})`，使用与[清单6-1](#listing6-1)中定义的相同的`k`和`n`值，以及基于[清单6-5](#listing6-5)中代码的`term_subgraph`函数❶。'
- en: 'In this simulation, *S*[0] ❷ is the node with the highest hub score for the
    selected topic (*S*[0] = *max*(*hub*(*qx*)(*G*))), and *Pr* (Ξ[*(Send)*]) is the
    hub score of *u*(*q*) for the message type *x*: *Pr* (Ξ[*(Send)*]) = *hub*[*(qx)*](*u*).
    The `hub_send` function (defined in the *graph_funcs.py* file, provided in the
    book’s supplementary materials) takes the hub score of `uq` and returns whether
    `uq` passes the message on ❸. The `hub_send` function is based on another function,
    `weighted_choice`, which is also included in the *graph_funcs.py* file. There
    are still only two possible actions in Ξ, so the probability of *Pass* is equal
    to 1 minus the probability of *Send*: *Pr* (Ξ[*(Pass)*]) = 1 – *Pr* (Ξ[*(Send)*]).
    The probability for selecting a given neighbor is the normalized authority score
    for that neighbor, given the message type *qx* (*Pr*(*v*(*qx*)) = *auth*(*qx*)(*v*)).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模拟中，*S*[0] ❷ 是所选主题的最大中心度节点（*S*[0] = *max*(*hub*(*qx*)(*G*)))，而*Pr* (Ξ[*(Send)*])
    是消息类型 *x* 对应的*u*(*q*)的中心度分数：*Pr* (Ξ[*(Send)*]) = *hub*[*(qx)*](*u*)。`hub_send`函数（在*graph_funcs.py*文件中定义，随书附带）接受`uq`的中心度分数并返回`uq`是否转发该消息❸。`hub_send`函数基于另一个函数`weighted_choice`，该函数也包含在*graph_funcs.py*文件中。在Ξ中仍然只有两种可能的动作，因此*Pass*的概率等于
    1 减去*Send*的概率：*Pr* (Ξ[*(Pass)*]) = 1 – *Pr* (Ξ[*(Send)*])。选择给定邻居的概率是该邻居的归一化权威分数，基于消息类型*qx*（*Pr*(*v*(*qx*))
    = *auth*(*qx*)(*v*)）。
- en: If the message is sent, we select the neighbor using the `scored_neighbor_select`
    function (also defined in the *graph_funcs.py* file and based on the `weighted_choice`
    function) ❹. If a neighbor is returned, we add the edge between the sender and
    recipient to the path `Tn` and update the message location ❺; otherwise, we terminate
    the simulation with the `break` statement.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息已发送，我们使用`scored_neighbor_select`函数（同样在*graph_funcs.py*文件中定义，并基于`weighted_choice`函数）选择邻居❹。如果返回了邻居，我们将在路径`Tn`中添加发送者和接收者之间的边，并更新消息的位置❺；否则，我们通过`break`语句终止模拟。
- en: 'If we assume a message ending at a node imparts some influence, we can count
    how many times a message ends at a particular user and claim that the node with
    the highest count is most likely to be influenced by the given message type from
    the given user. This intuitively means that the user would likely end up reblogging
    the message at some point. All roads lead home, so to speak. To find this node,
    we loop over the ending locations and tally the results to build the `{node: termination_count}`
    dictionary ❻, then print the results. This constitutes one run of the Monte Carlo
    simulation.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们假设一条消息在一个节点结束会产生一些影响，我们可以计算消息结束在特定用户处的次数，并认为具有最高计数的节点最有可能受到给定用户发出的消息类型的影响。这直观地意味着该用户可能最终会在某个时刻转发这条消息。可以说，所有的路都通向家。为了找到这个节点，我们遍历结束位置并统计结果，构建`{node:
    termination_count}`字典❻，然后打印结果。这构成了蒙特卡洛模拟的一个运行。'
- en: We want to collect several runs and average the results for the most accurate
    predictions, so we wrap the code in a function definition called `run_sim_2`,
    which will take in the topic list and the Mastodon post data as parameters. (You
    can see the `run_sim_2` function in the 4th cell of the *MonteCarloSimulation.ipynb*
    notebook.) Finally, we return the source node and the dictionary containing the
    users at whom the message terminated, so we can collect the results until we’re
    ready to analyze them. Let’s call this newly defined function in a loop to collect
    a reasonable sample size. [Listing 6-4](#listing6-4) shows how to collect the
    samples and average them for the final output.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望收集多个运行结果并对其进行平均，以获得最准确的预测，因此我们将代码封装在一个名为`run_sim_2`的函数定义中，该函数将接收主题列表和 Mastodon
    帖子数据作为参数。（你可以在*MonteCarloSimulation.ipynb*笔记本的第 4 个单元格中看到`run_sim_2`函数。）最后，我们返回源节点和包含消息终止用户的字典，以便我们可以收集结果，直到准备好进行分析。让我们在循环中调用这个新定义的函数来收集合理的样本大小。[列表
    6-4](#listing6-4)展示了如何收集样本并对其进行平均，以便得到最终输出。
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: Averaging the Monte Carlo simulation results'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-4：平均蒙特卡洛模拟结果
- en: 'Here are the results from averaging 10 runs of the simulation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对模拟 10 次运行结果的平均值：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using these results, we could claim that the user `gutierrezjamie` is most likely
    to influence `hartmanmatthew` on the topic of environment. What’s important here
    isn’t the numbers themselves but the relative sizes of the numbers, so you might
    also conclude that `shannon42` is three times more likely than `grosslinda` to
    end up reblogging the message. Of course, this is just the result of one small
    group of simulations. Ten simulations on a topic as complex as information flow
    and influence is hardly definitive. To strengthen this claim of influence, repeat
    the simulations some large number of times by increasing *k* (using the statistical
    method mentioned earlier) and average those results. In general, the more possible
    outcomes for the simulation, the more times it should be run. There’s a point
    of diminishing returns to this, though. You’ll want to experiment with different
    simulation counts and lengths by updating the values for *k* and *n*, respectively.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些结果，我们可以断言用户`gutierrezjamie`最有可能在环境话题上影响`hartmanmatthew`。这里重要的不是数字本身，而是数字的相对大小，因此你也可能得出结论，`shannon42`比`grosslinda`更可能三倍转发该信息。当然，这只是一次小规模模拟的结果。在像信息流和影响力这样复杂的话题上进行十次模拟显然不足以得出定论。为了增强影响力的论断，通过增加*k*（使用之前提到的统计方法）并对结果进行平均，重复多次模拟。通常，模拟的可能结果越多，应该运行的次数也越多。不过，这里也有收益递减的规律。你需要通过分别更新*k*和*n*的值，来实验不同的模拟次数和时长。
- en: The last part of the code we’re going to examine is the `term_subgraph` function,
    which we called in [Listing 6-3](#listing6-3). The function in [Listing 6-5](#listing6-5)
    takes in a term of interest and searches the underlying data to find all relevant
    posts.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的代码的最后部分是`term_subgraph`函数，它在[列表 6-3](#listing6-3)中被调用。[列表 6-5](#listing6-5)中的函数接受一个感兴趣的术语，并搜索底层数据以找到所有相关帖子。
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-5: Defining the subgraph based on terms'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-5: 基于术语定义子图'
- en: The function takes in the term we’re interested in searching for and the `post_df`
    `DataFrame` object we defined previously. Using the `str.contains` function, we
    filter the data down to only rows whose text column contains the search term.
    We then collect the replies to these posts by searching the `in_reply_to_id` column
    for any relevant post IDs, storing them in a `DataFrame` called `dat_replies`.
    Next, we define the `DiGraph` object that will hold the resulting graph data and
    store it in a variable named `hG`. We loop over the `dat_replies` index list,
    and, for each entry, we look up the row associated with the index. We use the
    row’s `in_reply_to_screen_name` and `user_screen_name` to create an edge in the
    graph, showing the direction of influence on the topic of interest. Once we’ve
    completed the loop, we return the completed subgraph.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受我们感兴趣的搜索词和我们之前定义的`post_df` `DataFrame`对象。使用`str.contains`函数，我们将数据筛选为仅包含搜索词的文本列的行。然后，我们通过搜索`in_reply_to_id`列中的相关帖子ID，收集这些帖子的回复，并将其存储在名为`dat_replies`的`DataFrame`中。接下来，我们定义一个`DiGraph`对象来保存生成的图数据，并将其存储在名为`hG`的变量中。我们遍历`dat_replies`的索引列表，对于每个条目，查找与该索引关联的行。我们使用该行的`in_reply_to_screen_name`和`user_screen_name`来创建图中的边，展示在感兴趣话题上的影响方向。一旦循环完成，我们返回已完成的子图。
- en: Now that we’ve defined all the basic code we’ll need, we can start to improve
    upon our simple model. In the next section, we’ll cover how to make our message
    behave more realistically through resource allocation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有基本代码，我们可以开始改进我们的简单模型。在下一部分，我们将介绍如何通过资源分配使我们的消息行为更加现实。
- en: Modeling Information Flow
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建模信息流
- en: 'So far, our simulation treats the message like a single object moving from
    node to node, like a package being delivered to an address. But what about the
    cases where a message may be transferred to multiple users simultaneously? Our
    model is fine for single copies of messages, but it’d be nice if we could find
    a way to model the information more intuitively as flowing through the network
    instead. Think about it like this: you don’t send one birthday party invitation
    and ask each invitee to pass the message on to the next person on the list; you
    send multiple invitations to the people you want to attend. Each invitee may then
    invite another person to go to the party with them, so the message spreads even
    further along the network simultaneously. To model this type of information flow,
    we need to improve our state machine to treat the message as if multiple copies
    exist.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的模拟将消息视作一个从节点到节点移动的单一对象，就像一个包裹被送到一个地址一样。但如果消息可以同时传递给多个用户呢？我们的模型对于单个副本的消息是适用的，但如果我们能够找到一种方法，更直观地将信息流动通过网络建模就更好了。想想看：你不会只发送一个生日派对邀请函并要求每个被邀请者把消息传递给列表上的下一个人；你会将多个邀请函发送给你希望出席的人。每个被邀请者可能会邀请另一个人一同前往派对，这样消息就会同时沿着网络进一步传播。为了建模这种类型的信息流动，我们需要改进我们的状态机，使其处理多个副本的消息。
- en: To simulate the case where more than one copy of *q* can exist, we can reformulate
    message passing as a question of resource flow within the network. By doing so,
    we can figure out how much information two people have communicated in the past
    and use that as an indicator of how much they may communicate in the future. *Resource
    allocation (RA)* is a model that was first posed to describe the nonlinear correlation
    between airport connectivity and travel capacity.^([7](b01.xhtml#c06-endnote-007))
    We’ll be using the same principle as a way to quantify the quality of information
    exchange as the message spreads through the network.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟多个 *q* 副本可以存在的情况，我们可以将消息传递重新表述为网络中资源流动的问题。通过这样做，我们可以弄清楚两个人在过去交流了多少信息，并用这个作为他们未来可能交流的一个指标。*资源分配
    (RA)* 是一个最初提出用来描述机场连接性与旅行能力之间非线性关系的模型。^([7](b01.xhtml#c06-endnote-007)) 我们将使用相同的原理来量化信息交换的质量，随着消息在网络中的传播。
- en: 'Generally speaking, RA describes the potential flow of resources between two
    nodes (*u*, *v*) where *v* is not a neighbor of *u*, but they’re connected by
    a directed path (*v* ∉ *Γ*[(][*u*][)] ∧ ρ(*u*→*v*) ∈ *E*). Supposing a node *u*
    in a directed graph has one unit of resources to distribute evenly among all its
    direct neighbors, the resources allocated to any member of the network is the
    sum of the resources at the end of each path between *u* and *v*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，RA 描述了两个节点 (*u*, *v*) 之间潜在的资源流动，其中 *v* 不是 *u* 的邻居，但它们通过一个有向路径相连 (*v* ∉
    *Γ*[(][*u*][)] ∧ ρ(*u*→*v*) ∈ *E*)。假设有一个有向图中的节点 *u* 拥有一个单位的资源，并将这些资源均匀分配给所有的直接邻居，那么分配给网络中任何成员的资源就是
    *u* 和 *v* 之间每条路径末端资源的总和：
- en: '![](image_fi/502567c06/m06010.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06010.png)'
- en: You can think of this value as the importance of node *v* in the case of distribution
    for node *u*. If |ρ(*u*, *v*)| > 2, this process is repeated for all nodes between,
    until some amount of resource reaches *v*. Therefore, you might instead wish to
    think of this value as the amount of resources *u* provides to *v* through the
    distribution network.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个值看作是在节点 *u* 的分配情况下，节点 *v* 的重要性。如果 |ρ(*u*, *v*)| > 2，那么这个过程会对所有节点进行重复，直到有一定数量的资源到达
    *v*。因此，你可以将这个值看作是 *u* 通过分配网络提供给 *v* 的资源量。
- en: As a concrete example, suppose you’re investigating a criminal organization
    that sells counterfeit goods it purchases from a forger. The boss of this hypothetical
    organization buys 100 boxes of knock-off handbags (the initial amount of resources
    at *S*[0]). He then distributes the merchandise to his top 4 lieutenants by dividing
    the 100 boxes into 25 boxes for each. Finally, each lieutenant divides their 25
    boxes among their street corner shops. If each lieutenant has connections to 5
    storefronts, each store would get 5 boxes. If the crime boss were to lose one
    of these stores, the loss would account for only 5 percent of his inventory. This
    is a very simplistic model that assumes each node and path can evenly carry the
    resource in question. However, that’s not always the case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，假设你正在调查一个犯罪组织，该组织销售从伪造者那里购买的假冒商品。这个假设中的组织老板购买了100箱仿冒手袋（即*S*[0]的初始资源量）。然后，他将这些商品分配给他的四个高级手下，每人分得25箱。最后，每个手下将他们的25箱商品分配给他们街角的商店。如果每个手下与5个店面有联系，那么每个店面将收到5箱商品。如果犯罪老板失去其中一个店面，损失将仅占他库存的5%。这是一个非常简化的模型，假设每个节点和路径可以均匀地传递相关资源。然而，实际情况并不总是如此。
- en: Formally, the ![m06011](image_fi/502567c06/m06011.png) portion of the previous
    formula is known as the *flow function*, which models a specific type of behavior
    for passing or receiving resources. Using this flow function, the resource gets
    divided evenly among all the neighbors of the node *u*, the same as the boxes
    of counterfeit goods. There are a few different flow functions built into NetworkX.
    Unfortunately, they’re not implemented for directed graphs as defined here. As
    you shift from research to applications, you’ll often be responsible for extending
    your code libraries with missing definitions like this. The *graph_funcs.py* file
    includes the code for directed resource allocation, so you can use it to experiment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式上讲，前面公式中的![m06011](image_fi/502567c06/m06011.png)部分被称为*流函数*，它模拟了传递或接收资源的特定行为类型。使用这个流函数，资源会均匀地分配给节点*u*的所有邻居，就像假冒商品的箱子一样。NetworkX内置了几种不同的流函数。遗憾的是，它们并没有为这里定义的有向图实现。当你从研究转向应用时，你通常需要负责扩展代码库，填补像这样的缺失定义。*graph_funcs.py*文件包含了有向资源分配的代码，所以你可以使用它来进行实验。
- en: By combining the historical analysis of the HITS algorithm with the simultaneous
    flow of resource allocation, we can create a respectable model, capable of simulating
    user behavior based on previous observations. You should be able to build on this
    framework of state machines and Monte Carlo simulation to model all sorts of interesting
    phenomena, not just in social networks but throughout the topic of information
    security as a whole.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将HITS算法的历史分析与资源分配的同步流结合起来，我们可以创建一个有价值的模型，能够基于之前的观察模拟用户行为。你应该能够在这个状态机和蒙特卡洛仿真框架上进行扩展，模拟各种有趣的现象，不仅仅是在社交网络中，而是涵盖整个信息安全主题。
- en: In the next section, we’ll move on to a proof-of-concept application that will
    take us deeper into applied game theory and Monte Carlo simulation by simulating
    an adversarial face-off on our social network platform. Let’s get ready to rumble!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进入一个概念验证应用，它将带我们更深入地了解应用博弈论和蒙特卡洛仿真，通过模拟在我们的社交网络平台上的对抗性对决。准备好迎接挑战吧！
- en: 'The Proof of Concept: Disrupting the Flow of Information'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念验证：干扰信息流
- en: ''
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final question for this chapter—“What links could be severed to disrupt
    the flow of information between two nodes?”—is a very interesting security topic.
    There are many scenarios in which disrupting the flow of information to a particular
    subset of nodes could be catastrophic. Imagine a hospital tied to a single source
    of electricity. To disconnect any outlet in the hospital from electricity, you’d
    only need to sever the single link between the hospital and its power source.
    This is a *single point of failure*, and to avoid it hospitals deploy multipoint
    connections to the power grid and install backup generators for more severe disruptions.
    Many home networks suffer from this design flaw as well. To sever all the connected
    devices behind the router, you simply need to sever the connection forward of
    the router. In social networks, like businesses, failure points like these occur
    regularly. Companies often have people known as “linchpin employees”^([8](b01.xhtml#c06-endnote-008))
    who fill roles no other employees can, or possess arcane knowledge the company
    needs to operate. Linchpin employees inspired the proof of concept for this chapter:
    Monte Carlo simulations to model the potential to disrupt information flow within
    an evolving social network.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终问题——“可以切断哪些连接以破坏两个节点之间的信息流？”——是一个非常有趣的安全话题。有许多场景，其中破坏信息流向特定节点子集的流动可能会带来灾难性的后果。想象一下，一个医院依赖单一的电力来源。要切断医院的任何电源插座，你只需切断医院与电源之间的唯一连接。这是一个*单点故障*，为了避免这种情况，医院会部署多点连接到电网，并安装备用发电机以应对更严重的中断。许多家庭网络也存在这种设计缺陷。要切断路由器后面所有连接的设备，只需要切断路由器前端的连接。在社交网络中，就像在企业中一样，类似的故障点经常发生。公司常常有被称为“关键员工”^([8](b01.xhtml#c06-endnote-008))的人，他们承担着其他员工无法胜任的角色，或拥有公司运营所需的深奥知识。关键员工启发了本章概念验证的证明：通过蒙特卡洛模拟来建模在一个发展中的社交网络中破坏信息流动的潜力。
- en: For the rest of this chapter, we’ll be building a simulation where our social
    network is under attack from a nefarious outsider. We’ll use some of the same
    analysis techniques that gave birth to the modern internet to see how difficult
    it would be to disrupt our social network. Sometimes it’s fun to be the bad guy!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余部分，我们将构建一个模拟，假设我们的社交网络正受到一个邪恶外部敌人的攻击。我们将使用一些现代互联网诞生时所用的分析技术，看看破坏我们的社交网络会有多困难。有时候，扮演坏人也挺有趣的！
- en: Modeling an Evolving Network
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建模一个演化中的网络
- en: 'In a static network, you could find the set of edges that, when removed, would
    separate two nodes (you’ll see a method for producing this list in a moment),
    but that doesn’t account for network adaptations, like cross-training another
    employee in the linchpin employee’s arcane knowledge to alleviate a single point
    of failure. To model an evolving network, we’ll mimic a two-player, turn-based
    game scenario, wherein one player tries to get a message through from a starting
    user to an end user as their adversary tries to stop the message from reaching
    the end. To make the game more complex, the network itself evolves on each turn
    as users reblog messages from other users or disconnect from people who were previous
    connections. Player 1 acts on the part of the network and all its users, while
    player 2 acts as the adversarial force. Player 1’s goal is to send a message *u*
    from a source node (*u*A) to a sink node (*v*[Ω]). Player 2 seeks to keep this
    message from reaching the sink node by selectively removing paths from the network.
    The game play is broken up into three phases: network adaptations, message movement,
    and finally adversarial movement (in that order).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态网络中，你可以找到一组边，当这些边被移除时，会将两个节点分开（你稍后将看到一种生成该列表的方法），但这并未考虑到网络的适应性，例如将另一名员工进行跨职能培训，让他掌握关键员工的深奥知识，从而缓解单点故障。为了模拟一个演化中的网络，我们将模拟一个两人轮流制的游戏场景，其中一名玩家试图将信息从起始用户传递到终端用户，而其对手则试图阻止该信息到达终端。为了使游戏更复杂，网络本身会在每一轮变化，因为用户会转发其他用户的信息或断开与曾经连接的人的联系。玩家1在网络及其所有用户中行动，而玩家2则充当对抗力量。玩家1的目标是将信息*u*从源节点(*u*A)发送到汇节点(*v*[Ω])。玩家2的目标是通过选择性地移除网络中的路径，阻止该信息到达汇节点。游戏分为三个阶段：网络适应、信息移动，最后是对抗性移动（按此顺序）。
- en: 'The game is over if *q* reaches *v*[Ω], or when no path exists to complete
    the transmission:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*q*到达*v*[Ω]，或者当没有路径可以完成传输时，游戏结束：
- en: '![](image_fi/502567c06/m06012.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06012.png)'
- en: This equation can be translated into the convenient helper function in [Listing
    6-6](#listing6-6).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程可以转化为方便的辅助函数，见[示例 6-6](#listing6-6)。
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-6: Checking for terminal conditions'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-6：检查终止条件
- en: This function takes in the graph object, the ID of the node currently holding
    the message, and the ID of the goal node. If these two nodes aren’t the same and
    there’s a path between them ❶, the game isn’t over, so the code returns `None`
    (as in no winner). If the two nodes aren’t equal and there’s no path between the
    current node and the goal node ❸, player 2 has succeeded in isolating the message,
    and the function returns `-1`. If the two IDs match ❷, the message has reached
    the goal node, so the function returns `1`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受图对象、当前持有消息的节点ID和目标节点的ID。如果这两个节点不同且它们之间有路径 ❶，游戏没有结束，因此代码返回`None`（即没有赢家）。如果两个节点不相同且当前节点与目标节点之间没有路径
    ❸，则玩家2已成功隔离消息，函数返回`-1`。如果这两个ID匹配 ❷，则消息已到达目标节点，函数返回`1`。
- en: Moving the Message Through the Network
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过网络传递消息
- en: The second helper function, `weighted_choice`, shown in [Listing 6-7](#listing6-7),
    will be used for weighted random selection of the next node to a receive the message.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个辅助函数`weighted_choice`，如[示例 6-7](#listing6-7)所示，将用于加权随机选择下一个接收消息的节点。
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-7: Weighted random selection function for biased walks'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-7：用于偏向行走的加权随机选择函数
- en: 'The input parameter `scores` is a dictionary of `{item: weight}`, giving each
    item that may be selected and its weight. (The weights do not need to sum to 1;
    only the relative size of the values matters.) The `totals` list partitions the
    real number space between 0 and the sum of the weights (![m06013](image_fi/502567c06/m06013.png))
    into bins proportional in size to the weight of the item they represent, by adding
    each item to a `running_total`, then recording the running total after each item
    is added ❶. The sum of all the weights then scales a random value ❷ to fall into
    one of the bins, and the bin determines which item is selected ❸. Items with larger
    weights map to larger bins, meaning the items are more likely to be selected,
    hence “weighted random selection.”'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '输入参数`scores`是一个字典，格式为`{item: weight}`，为每个可能被选择的项目分配一个权重。 （权重不需要加总为1；只有值的相对大小才重要。）`totals`列表将实数空间在0和权重总和之间分割
    (![m06013](image_fi/502567c06/m06013.png))，其分割的大小与所代表项目的权重成正比，通过将每个项目加到`running_total`中，并在每个项目添加后记录运行总和
    ❶。所有权重的总和然后会缩放一个随机值 ❷，使其落入某个分区，而该分区决定了选择哪个项目 ❸。权重较大的项目映射到较大的分区，这意味着这些项目更有可能被选择，因此这就是“加权随机选择”。'
- en: 'As a concrete example, take an input dictionary `{"A":1,"B":2,"C":3}`. After
    the first loop executes, the `totals` list contains `[1,3,6]` and the `running_total`
    is `6`. The random real value `rnd` (between 0 and 1) is selected using the `random`
    function, then multiplied by `running_total` ❷ to produce the percentage of the
    weight randomly selected. The random value `1.0` means the maximum weight, in
    this case:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个具体例子为例，输入字典为`{"A":1,"B":2,"C":3}`。在第一次循环执行后，`totals`列表包含`[1,3,6]`，而`running_total`为`6`。随机实数值`rnd`（介于0和1之间）通过`random`函数选择，然后乘以`running_total`
    ❷以产生随机选择的权重百分比。随机值`1.0`表示最大权重，在此情况下为：
- en: '![](image_fi/502567c06/m06014.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06014.png)'
- en: We can verify that the break points accurately reflect our input weights by
    calculating the amount of space on the number line assigned to the key, called
    its *key space*. These should equate to 1 / 6 = 0.166, 2 / 6 = 0.333, and 3 /
    6 = 0.5 for keys `A`, `B`, and `C`, respectively. We find the key space by subtracting
    the key’s lower selection boundary from its upper selection boundary. To select
    key `A`, `rnd` must be lower than or equal to approximately 0.166 (0.166 × 6 =
    0.996). To select key `B`, `rnd` needs to be between 0.166 and 0.5 (0.5 × 6 =
    3), which means the key space for `B` is (0.5 – 0.166 = 0.333). We can divide
    `B`’s key space by `A`’s to get a relative size comparison (0.333 / 0.166 = 2.006),
    which means the key space for `B` is twice the size of the one for `A`, just as
    we requested. Finally, `rnd` needs to be greater than 0.5 and less than or equal
    to 1.0 for key `C` to be selected. The key space for `C` is (1 – 0.5 = 0.5). You
    can continue the key space logic to prove that the space provided to `C` is three
    times the space provided for `A` (0.5 / 0.166 = 3.0) and one and a half times
    larger than the key space for `B` (0.5 / 0.333 = 1.5). I hope this helps to illustrate
    how the values in our input dictionary control the size of the key space created
    during the random selection process. We’ll be relying heavily on the `weighted_choice`
    function during our proof, so it’s worth taking the time to understand it in detail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过计算分配给键的数轴空间来验证断点是否准确反映我们的输入权重，这个空间称为其*key space*。这些应等于 1 / 6 = 0.166，2
    / 6 = 0.333 和 3 / 6 = 0.5，分别对应于键 `A`、`B` 和 `C`。我们通过将键的下选择边界减去其上选择边界来找到键空间。为了选择键
    `A`，`rnd` 必须小于或等于大约 0.166（0.166 × 6 = 0.996）。为了选择键 `B`，`rnd` 需要介于 0.166 和 0.5
    之间（0.5 × 6 = 3），这意味着键 `B` 的键空间为 (0.5 – 0.166 = 0.333)。我们可以将 `B` 的键空间除以 `A` 的键空间，以获得相对大小比较（0.333
    / 0.166 = 2.006），这意味着键 `B` 的键空间是键 `A` 的两倍，正如我们要求的那样。最后，`rnd` 必须大于 0.5 且小于或等于 1.0
    才能选择键 `C`。键 `C` 的键空间为 (1 – 0.5 = 0.5)。你可以继续这个键空间的逻辑，证明分配给 `C` 的空间是分配给 `A` 的三倍（0.5
    / 0.166 = 3.0），并且是分配给 `B` 的键空间的 1.5 倍（0.5 / 0.333 = 1.5）。希望这有助于说明我们的输入字典中的值如何控制在随机选择过程中创建的键空间的大小。我们将在证明过程中大量依赖
    `weighted_choice` 函数，因此花时间详细理解它是值得的。
- en: Measuring the Amount of Information Flow
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量信息流量
- en: Some connections between nodes in a network may be capable of carrying more
    information than others. In a social network, for example, some members may be
    more effective at spreading information, like a linchpin employee at a company.
    The amount of information flow between two nodes in a social network isn’t straightforward
    to measure, and depends on your research question. For the purposes of our simulation
    game, the edge capacity is the number of characters in a given post (maximum 500,
    at the time of writing).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中某些节点之间的连接可能能够承载比其他连接更多的信息。例如，在社交网络中，某些成员可能更有效地传播信息，就像公司中的关键员工一样。在社交网络中，两个节点之间的信息流量并不是简单地可以测量的，它取决于你的研究问题。在我们的模拟游戏中，边的容量是指给定帖子中的字符数（最大500个字符，在写作时为止）。
- en: By adding an attribute named *capacity*, which represents the maximum amount
    of information that can be transmitted along the particular edge in one unit of
    time, to the edges in *E*, we can compare the effect of removing different subsets
    of edges on the overall flow and capacitance of the network using the *max-flow,
    min-cut theorem*.^([9](b01.xhtml#c06-endnote-009)) We’ll take a deeper look at
    this theorem when we improve player 2, but for the moment just know that it allows
    us to model a resource that gets spread out across a network, rather than moving
    from point to point as we’ve seen previously.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向*E*中的边添加一个名为*capacity*的属性，该属性表示在单位时间内通过特定边传输的最大信息量，我们可以使用*最大流，最小割定理*来比较删除不同子集边对网络整体流量和电容的影响。^([9](b01.xhtml#c06-endnote-009))
    我们将在改进玩家2时深入了解这个定理，但目前只需知道，它使我们能够模拟一个资源在网络中扩散的过程，而不是像之前看到的那样从一个点移动到另一个点。
- en: Now is a good time to step back and remember why this matters to us. Our ultimate
    goal is to test how difficult it would be for an adversary to significantly disrupt
    the communication of the network. The max-flow, min-cut theorem gives us the information
    needed to test if two nodes can still communicate (because there’s still a path
    between the two nodes). It also helps us determine what cuts are more or less
    advantageous for the adversary, as well as giving them a way to quickly judge
    their options. An attacker who knows the max-flow, min-cut theory will likely
    have a much higher chance at sabotaging the network than one who attacks random
    communication channels. We’ll examine this hypothesis by implementing two versions
    of the adversary in the following game and comparing the damage they can achieve.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候退后一步，记住这一切对我们来说的重要性了。我们的最终目标是测试敌人破坏网络通信的难易程度。最大流、最小割定理为我们提供了测试两个节点是否仍能通信所需的信息（因为两个节点之间仍然有一条路径）。它还帮助我们确定哪些割对敌人来说更有利或不利，同时为敌人提供了一种快速判断其选项的方法。了解最大流、最小割理论的攻击者，可能比攻击随机通信通道的攻击者更有可能破坏网络。我们将在接下来的游戏中通过实现两个版本的敌人来检验这一假设，并比较他们能造成的破坏。
- en: How the Game Works
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏如何运作
- en: The game is actually very simple. The objective for player 1, the white hat,
    is to get a message from a node on one side of the network to a node on the other
    side. To achieve this they have the entire network at their disposal. On each
    turn, they will move the message around the network trying to reach the sink node.
    They win if the message successfully traverses the network from the source node
    to the sink node. On the other side of the virtual table is player 2, the black
    hat. Their job is stop that message, at any cost. On each turn, they’ll select
    an edge to remove from the network. Player 2 wins if they successfully disconnect
    the network so that there’s no way the message can reach the sink node.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏其实非常简单。玩家1（白帽）的目标是将消息从网络一侧的节点传送到网络另一侧的节点。为此，他们可以使用整个网络。在每回合中，他们会在网络中移动消息，试图到达接收节点。如果消息成功从源节点传输到接收节点，他们就赢了。虚拟桌子另一边是玩家2（黑帽）。他们的任务是以任何代价阻止这个消息。在每回合中，他们将选择从网络中删除一条边。玩家2赢得胜利的条件是他们成功地切断网络，使得消息无法到达接收节点。
- en: Evolving the Network
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络演变
- en: 'Social networks rarely have a static topography: the links and membership are
    changing even as you try to measure them. The network adaptation phase models
    the evolving topography by allowing edges to be created or removed probabilistically.
    This means that new routes may open up suddenly and old paths may disappear on
    their own. Neither player can fully trust the network to do what they expect it
    to. I chose to implement this as part of player 1’s turn since they’re the network
    administrator in this scenario. On each turn, player 1 chooses an input action
    from the input alphabet for every node that’s not holding the message (∀*u*^((¬)^(*q*)^)
    ∈*V wrs*(Ξ), where *wrs*(Ξ) is the weighted random selection function defined
    previously). [Listing 6-8](#listing6-8) shows the weighted input alphabet, which
    includes the creation and dissolution of edges with `connect` and `disconnect`,
    or the option to `pass` as before.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络很少有静态的拓扑结构：即使在你尝试测量它们时，链接和成员身份也在不断变化。网络适应阶段通过允许边的创建或删除来模拟拓扑的演变。这意味着新的路径可能会突然打开，旧的路径可能会自行消失。双方玩家都无法完全信任网络按预期运作。我选择将这一部分作为玩家1的回合来实现，因为在这种情况下他们是网络管理员。在每回合中，玩家1会从输入字母表中选择一个输入动作，针对每个没有持有消息的节点（∀*u*^((¬)^(*q*)^)
    ∈*V wrs*(Ξ)，其中 *wrs*(Ξ) 是前面定义的加权随机选择函数）。[Listing 6-8](#listing6-8) 显示了加权输入字母表，包括使用
    `connect` 和 `disconnect` 来创建和解除边，或者像之前一样选择 `pass`。
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-8: Weighted inputs for nodes without the message'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-8：没有消息的节点的加权输入
- en: The weights in `XI` describe the tendency of the network over time. These values
    create a scenario where the network is likely to grow over time since `connect`
    and `pass` both have an individual weight of 40 percent (2 / 5 = 0.4), a combined
    80 percent of the selection space, while `disconnect` has only 20 percent. If
    `connect` is chosen, the node forms a new edge with (meaning it receives a reply
    from) another node in the graph, which means we need a way to select the user
    they connect to. I’ve chosen to implement this based on *preferential attachment*,
    the idea that users with many connections are more likely to form new connections
    than those with fewer connections. In our network, this means that nodes that
    receive replies from many other users (large out-degrees) are more likely to receive
    a reply from users who reply to many users (high in-degrees). (Even if the current
    node doesn’t tend to receive many replies, it’s still more likely to get a reply
    from a more active user.)^([10](b01.xhtml#c06-endnote-010))
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`XI`中的权重描述了网络随时间的趋势。这些值创造了一个网络随时间增长的情形，因为`connect`和`pass`的每个单独权重为40%（2 / 5
    = 0.4），合计80%的选择空间，而`disconnect`只有20%。如果选择`connect`，节点将与另一个节点建立新边（即它收到来自另一个节点的回复），这意味着我们需要一种方法来选择它们连接的用户。我选择基于*优先连接*来实现这一点，优先连接的概念是，具有更多连接的用户比那些连接较少的用户更可能建立新连接。在我们的网络中，这意味着接收到来自许多其他用户回复的节点（具有较大的外度）更可能收到那些回复许多用户的用户的回复（具有较高的入度）。(即使当前节点不倾向于接收很多回复，它仍然更可能从一个更活跃的用户那里获得回复。)^([10](b01.xhtml#c06-endnote-010))'
- en: 'Formally, the *undirected preferential attachment (UPA)* score for two nodes
    (*u*, *v*) is the product of the length of their neighbors:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，两个节点（*u*，*v*）的*无向优先连接（UPA）*分数是它们邻居长度的乘积：
- en: UPA( u, v ) = |Γ( u )| × |Γ( v )|
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: UPA( u, v ) = |Γ( u )| × |Γ( v )|
- en: 'To account for the directionality of our network graph, we can define *directed
    preferential attachment (DPA)* using outgoing neighbors of *u* and incoming neighbors
    of *v*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了考虑我们网络图的方向性，我们可以使用*有向优先连接（DPA）*定义*u*的出邻居和*v*的入邻居：
- en: DPA( u → v ) = |Γ( u → )| × |Γ( v ←)|
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: DPA( u → v ) = |Γ( u → )| × |Γ( v ←)|
- en: '[Listing 6-9](#listing6-9) shows the weighted random connection function, which
    will be called from the player 1 logic shown in [Listing 6-12](#listing6-12).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 6-9](#listing6-9)展示了加权随机连接函数，该函数将从[Listing 6-12](#listing6-12)中显示的玩家1逻辑中调用。'
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-9: A directed preferential attachment weighted random selection'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-9: 一个有向优先连接加权随机选择'
- en: 'The function `wrs_connect` takes the graph and the connecting node as input
    and loops over each ID in the graph ❶ to calculate the DPA score ❷ between the
    input node and each other node (skipping the input node with `continue`). The
    `weighted_choice` function uses the `scores` dictionary to pick a node to connect
    to ❸:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`wrs_connect`以图和连接的节点作为输入，并遍历图中的每个ID ❶来计算输入节点与每个其他节点之间的DPA分数 ❷（跳过输入节点使用`continue`）。`weighted_choice`函数使用`scores`字典来选择一个节点进行连接
    ❸：
- en: vconn = wrs( [ DPA( u( ¬ q ), ¬ u )] ∀ ¬ u ∈ V )
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: vconn = wrs( [ DPA( u( ¬ q ), ¬ u )] ∀ ¬ u ∈ V )
- en: If `disconnect` is chosen, the user disassociates from another user who sends
    them the least information (as measured by the definition of capacity given previously).
    The `capacity` attribute of each edge in `G.in_edges` is used in the weighted
    random selection process to choose a neighbor to disassociate from. [Listing 6-10](#listing6-10)
    shows the code to calculate the capacity and selection weight for a given node.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择`disconnect`，用户将与发送给他们最少信息的另一个用户断开联系（根据前面定义的容量来衡量）。`G.in_edges`中每个边的`capacity`属性在加权随机选择过程中用于选择一个邻居来断开联系。[Listing
    6-10](#listing6-10)展示了计算给定节点的容量和选择权重的代码。
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-10: Capacity weighting for a node'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-10: 节点的容量加权'
- en: 'We start by looping over the neighbor data from the set of inbound edges for
    the node ❶ and collecting these into the `n_capacity` dictionary. If we hadn’t
    condensed the multiple edges previously (by using a `DiGraph` instead of a `MultiDiGraph`),
    we’d need to sum up the capacity of each in-edge incident to the node first:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先遍历节点的入边集合中的邻居数据 ❶，并将其收集到`n_capacity`字典中。如果我们没有提前将多个边合并（通过使用`DiGraph`而不是`MultiDiGraph`），我们需要先对每个入边的容量进行求和：
- en: '![](image_fi/502567c06/m06015.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06015.png)'
- en: We weight edges with lower *N*[*capacity*] entries more heavily in the selection
    process, then invert the capacities by subtracting them from a modifier *Q* =
    1 + *max*(*N*[*capacity*] ) ❷, which results in the weighting formula ![m06016](image_fi/502567c06/m06016.png)
    ❸.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在选择过程中对容量较低的 *N*[*capacity*] 边赋予更高的权重，然后通过从修正值 *Q* = 1 + *max*(*N*[*capacity*]
    ) ❷ 中减去这些容量来反转容量，从而得到加权公式 ![m06016](image_fi/502567c06/m06016.png) ❸。
- en: For example, if *max*(*N*[*capacity*]) = 10 ⇔ *Q* = 11, an edge with ![m06017](image_fi/502567c06/m06017.png)
    will get a weight of `1` (![m06018](image_fi/502567c06/m06018.png)), while an
    edge with ![m06019](image_fi/502567c06/m06019.png) will get a weight of `10` (![m06020](image_fi/502567c06/m06020.png)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 *max*(*N*[*capacity*]) = 10 ⇔ *Q* = 11，则带有 ![m06017](image_fi/502567c06/m06017.png)
    的边将获得权重 `1` (![m06018](image_fi/502567c06/m06018.png))，而带有 ![m06019](image_fi/502567c06/m06019.png)
    的边将获得权重 `10` (![m06020](image_fi/502567c06/m06020.png))。
- en: We’ll set the return value for a given node to the tuple (*N*[*capacity*] ,
    *N*[*weight*] ). Both `n_capacity` and `n_weight` are dictionaries keyed off of
    the neighboring node’s ID. The `wrs_disconnect` function in [Listing 6-11](#listing6-11)
    uses the `n_weight` dictionary to select the least informative neighbor to disconnect
    `u` from.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为给定节点设置返回值为元组 (*N*[*capacity*] , *N*[*weight*] )。`n_capacity` 和 `n_weight`
    都是以邻接节点 ID 为键的字典。[Listing 6-11](#listing6-11) 中的 `wrs_disconnect` 函数使用 `n_weight`
    字典来选择最不重要的邻居来断开与 `u` 的连接。
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-11: A weighted random disconnection function'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-11: 一个加权随机断开函数'
- en: If there are no inbound edges for the node `u` (meaning it has no in-degree
    neighbors to disconnect from) the function returns `None` ❶, resulting in the
    same outcome as `pass`. If more than one edge is found, the capacity scores for
    all the inbound neighbors are calculated using the function from [Listing 6-10](#listing6-10)
    ❷. The key returned from this function is the neighbor to disassociate from (*v*[*disconn*]
    = *wrs*(*N*[*weight*] )) ❸. The edge (*u*^((¬)^(*q*)^) ← *v*[*disconn*] ) is then
    removed from the graph in the player 1 logic in [Listing 6-12](#listing6-12).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点 `u` 没有入边（意味着它没有入度邻居可以断开连接），则函数返回 `None` ❶，结果与 `pass` 相同。如果找到多个边，则使用 [Listing
    6-10](#listing6-10) 中的函数 ❷ 计算所有入邻居的容量分数。此函数返回的键是要断开连接的邻居 (*v*[*disconn*] = *wrs*(*N*[*weight*]
    )) ❸。然后，在 [Listing 6-12](#listing6-12) 中的玩家 1 逻辑中，边 (*u*^((¬)^(*q*)^) ← *v*[*disconn*]
    ) 被移除。
- en: Moving the Message
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移动信息
- en: After the network evolution phase, the game moves into the message movement
    phase, where the only possible input is `send`. If an edge exists between the
    node currently holding the message, *u*(*q*), and the goal node, *v*[Ω], the message
    passes along that edge and player 1 wins the game. Otherwise, the paths between
    *u*(*q*) and *v*[Ω] are calculated, and the message is passed to the next node
    along one of these paths, selected uniformly at random.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络演化阶段之后，游戏进入信息传递阶段，此时唯一可能的输入是`send`。如果当前持有信息的节点 *u*(*q*) 与目标节点 *v*[Ω] 之间存在边，则信息沿着该边传递，玩家
    1 获得胜利。否则，计算 *u*(*q*) 和 *v*[Ω] 之间的路径，并将信息沿这些路径中的一条传递到下一个节点，路径的选择是随机的。
- en: The code in [Listing 6-12](#listing6-12) handles player 1’s turn, which includes
    both the network adaptations and message movement phases. The function `player_one_turn`
    takes the graph, the node holding the message, and the goal node as parameters
    and returns the node that receives the message and the new state of the graph.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 6-12](#listing6-12) 中的代码处理玩家 1 的回合，包括网络适应和信息传递两个阶段。函数 `player_one_turn`
    以图、持有信息的节点和目标节点作为参数，返回接收信息的节点以及图的更新状态。'
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 6-12: The logic defining player 1’s turn'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-12: 定义玩家 1 回合逻辑'
- en: If an edge exists between `uq` and the goal node `omega` ❶, we pass the message
    to `omega`. This will end the turn (and game) with a victory for player 1! Otherwise,
    we calculate the average capacity of the graph ❷, which will be used as the capacity
    of any new edges added during network adaptation. This allows the average to change
    from turn to turn, depending on which edges (if any) were removed during the previous
    network adaptation phase.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `uq` 和目标节点 `omega` 之间存在边 ❶，我们将信息传递给 `omega`。这将结束回合（并且游戏结束），玩家 1 获胜！否则，我们计算图的平均容量
    ❷，该值将作为网络适应过程中添加的新边的容量。这使得平均值在每一回合之间变化，取决于上一个网络适应阶段是否删除了边（如果有的话）。
- en: To perform network adaption and message passing, we loop over each node in the
    graph ❸. For *u*(*q*), we attempt to find valid paths between it and the goal
    node ❹ (the message movement phase). If this attempt fails with an `nx.exception.NetworkXNoPath`,
    the function returns and the round ends with a victory for player 2, since the
    message can’t reach the destination. Otherwise, we randomly select a path using
    the `choice` function ❺ and pass the message to the first node in this path.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行网络适应和消息传递，我们对图中的每个节点进行遍历 ❸。对于*u*（*q*），我们尝试找到它与目标节点之间的有效路径 ❹（消息传递阶段）。如果此尝试失败并出现`nx.exception.NetworkXNoPath`，函数将返回，回合结束，玩家2获胜，因为消息无法到达目标节点。否则，我们使用`choice`函数随机选择一条路径
    ❺，并将消息传递到路径中的第一个节点。
- en: For all other nodes, we select an action using the weighted random function
    and the `XI` dictionary defined in [Listing 6-8](#listing6-8) ❻. If `pass` is
    chosen, the code jumps to the next node using the `continue` keyword ❼. If `connect`
    is returned, we use the `wrs_connect` function shown in [Listing 6-9](#listing6-9)
    to form a new edge ❽. Otherwise, `disconnect` was chosen, so we use the `wrs_disconnect`
    function from [Listing 6-11](#listing6-11) to remove an edge from the graph ❾.
    Finally, we return the receiving node and the updated graph ❿.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他节点，我们使用加权随机函数和[Listing 6-8](#listing6-8) ❻中定义的`XI`字典选择一个操作。如果选择`pass`，代码会使用`continue`关键字跳到下一个节点
    ❼。如果返回`connect`，我们使用[Listing 6-9](#listing6-9)中的`wrs_connect`函数形成一条新边 ❽。否则，选择了`disconnect`，我们使用[Listing
    6-11](#listing6-11)中的`wrs_disconnect`函数从图中移除一条边 ❾。最后，我们返回接收节点和更新后的图 ❿。
- en: Disrupting the Network
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 破坏网络
- en: 'Player 2 then gets to select an edge to remove from the network to try to disrupt
    the flow of the message. One of the strengths of Monte Carlo simulation is in
    its ability to compare different strategies over time. To illustrate this, let’s
    compare two strategies for player 2 to achieve their goal. In the first strategy
    ([Listing 6-13](#listing6-13)), player 2 selects an edge from *E* uniformly at
    random:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后玩家2选择从网络中移除一条边，试图破坏消息的流动。蒙特卡罗仿真的一个优点是能够随着时间的推移比较不同的策略。为了说明这一点，我们将比较两种策略，看看玩家2如何实现他们的目标。在第一种策略中（[Listing
    6-13](#listing6-13)），玩家2从*E*中均匀地随机选择一条边：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-13: The player 2 random implementation'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-13: 玩家2的随机实现'
- en: This will act as a good baseline, since it most closely resembles a truly random
    walk. The code randomly selects ❶ and then removes ❷ an edge from the graph; we
    then return the updated graph ❸.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将作为一个良好的基准，因为它最接近真正的随机行走。代码随机选择 ❶，然后移除 ❷ 图中的一条边；接着我们返回更新后的图 ❸。
- en: The results of such a strategy can be seen as a null control, as if an adversary
    just blindly started removing things with no real concept of what they were impacting.
    We’ll look at the second strategy, where player 2 selects their moves to inflict
    the most damage using the flow information of the network, after we demonstrate
    the simulation using this simple strategy and gather our baseline network performance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略的结果可以看作是一个零控制，就好像对手只是盲目地开始移除东西，完全不知道他们所影响的内容。在我们使用这种简单策略演示仿真并收集基准网络性能之后，我们将查看第二种策略，其中玩家2根据网络的流动信息选择其操作，以造成最大的破坏。
- en: Once player 2 has finished selecting the edge to disrupt, the round is complete.
    If neither player has won, the next round starts and gameplay continues in this
    fashion until one of the players succeeds in reaching their objective.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家2完成选择破坏的边，回合就结束了。如果没有玩家获胜，下一回合开始，游戏继续进行，直到其中一位玩家成功达到目标。
- en: In the next section, we’ll cover how to select the start and end nodes. In much
    larger networks (like the ones you’re likely to see in the wild), having methods
    for automating tasks like finding data will save you a lot of manual exploration
    before running your first simulation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何选择起始节点和结束节点。在更大的网络中（比如你在实际应用中可能会遇到的网络），拥有自动化任务的方法，例如寻找数据，将在运行你的第一个仿真之前节省大量的手动探索时间。
- en: The Game Objective
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏目标
- en: Before we tie this all together into a functional simulation, let’s look at
    the `shortest_path_scores` helper function, shown in [Listing 6-14](#listing6-14),
    which returns a list of average path lengths for all pairs of nodes that are not
    directly connected.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有这些内容结合成一个功能完整的仿真之前，让我们先来看一下`shortest_path_scores`辅助函数，见[Listing 6-14](#listing6-14)，它返回所有不直接连接的节点对的平均路径长度列表。
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-14: Creating an average-length score for weighted selection'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-14: 为加权选择创建平均长度得分'
- en: The `for` loop ❶ calls the NetworkX function `nx.non_edges` to get a list of
    all possible node combinations not directly connected by an edge, checks that
    the two nodes *u* and *v* are different, and checks that one or more paths exist
    between the nodes. If any condition fails, we skip that pair of nodes with the
    `continue` keyword. Otherwise, we use the `nx.all_shortest_paths` function to
    make a list of all potential paths between the source and sink nodes at the start
    of the game ❷, then calculate the average path length ❸ and append it to the `pairs`
    list. Once all the pairs have been processed, we sort the results in descending
    order, based on the average path length first, then the ID of the node *u*, and
    finally the ID of the node *v* ❹.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环❶调用NetworkX函数`nx.non_edges`获取所有可能的节点组合，这些组合没有直接连接的边，检查两个节点 *u* 和 *v*
    是否不同，并且检查它们之间是否存在一条或多条路径。如果任一条件不满足，我们将跳过该节点对，使用`continue`关键字。否则，我们使用`nx.all_shortest_paths`函数列出游戏开始时源节点和汇节点之间的所有潜在路径❷，然后计算平均路径长度❸，并将其附加到`pairs`列表中。一旦所有节点对处理完成，我们根据平均路径长度对结果进行降序排序，若平均路径长度相同，则根据节点
    *u* 的 ID 排序，最后按节点 *v* 的 ID 排序❹。'
- en: In [Listing 6-15](#listing6-15) we’ll combine these scores with the `weighted_choice`
    function to randomly select the source and sink pair while favoring pairs that
    have more, or longer, paths than those with fewer, shorter ones. I chose this
    method so the simulation has enough routes to make it interesting. You may choose
    the source and sink nodes based on other parameters in your simulation. You might
    even extend your simulation to test all possible combinations of source and sink
    node.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 6-15](#listing6-15)中，我们将这些得分与`weighted_choice`函数结合，随机选择源节点和汇节点对，同时偏向那些具有更多路径或较长路径的节点对，而不是具有较少或较短路径的节点对。我选择这种方法是为了确保模拟有足够的路线来保持游戏的趣味性。你可以根据模拟中的其他参数选择源节点和汇节点，甚至可以扩展模拟，测试所有可能的源节点和汇节点组合。
- en: The Game Simulation
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏模拟
- en: Finally, it’s time to tie all these functions together into a single cohesive
    game with the code in [Listing 6-15](#listing6-15). We’ll run the game simulation
    25 times, each with a different pair of source and sink nodes. Each run will generate
    *k* random walks, representing one game between player 1 and player 2 per walk,
    and tally the number of wins for each player. The average of the *k* scores is
    the score for the run overall. Using different source and sink nodes, instead
    of running the same scenario over and over, will give us a better sense of the
    network as a whole. The code in [Listing 6-15](#listing6-15) assumes you’ve already
    built the graph (using code similar to [Listing 6-3](#listing6-3)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，到了将所有这些函数结合成一个完整游戏的时候，代码见[清单 6-15](#listing6-15)。我们将运行游戏模拟 25 次，每次使用一对不同的源节点和汇节点。每次运行将生成
    *k* 次随机游走，每次游走代表玩家 1 和玩家 2 之间的一局游戏，并统计每个玩家的获胜次数。*k* 次得分的平均值即为该轮游戏的总得分。使用不同的源节点和汇节点，而不是一遍又一遍地运行相同的场景，将使我们对整个网络有更好的理解。代码[清单
    6-15](#listing6-15)假设你已经构建了图（使用类似[清单 6-3](#listing6-3)的代码）。
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 6-15: The main game simulation function'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-15：主要的游戏模拟函数
- en: Before running the group of simulations, we get the list of average path lengths
    between nodes with `shortest_path_scores` ([Listing 6-14](#listing6-14)) ❶, convert
    the average path lengths returned into a list of `path_weights` (meaning nodes
    with longer average shorter path lengths get weighted higher), and select a pair
    of nodes (which is the key returned from `path_weights`) ❷. If that pair of nodes
    and associated paths have already been used in a simulation (tracked by the `played`
    list), we select another. From the selected pair and path, we set the source and
    sink nodes, `alpha` and `omega`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行模拟组之前，我们首先使用`shortest_path_scores`（[清单 6-14](#listing6-14)）❶获取节点之间的平均路径长度列表，接着将返回的平均路径长度转换为`path_weights`列表（即平均路径长度较长的节点获得更高的权重），然后选择一对节点（该对节点即为`path_weights`返回的键值）❷。如果该对节点及其相关路径已经在模拟中使用过（由`played`列表追踪），我们将选择另一个节点对。从选中的节点对及路径中，我们确定源节点和汇节点，即`alpha`和`omega`。
- en: Once we’ve found a valid source and sink pair, we perform the *k* random walks.
    Each iteration of the `for` loop ❸ constitutes one complete game, played on a
    copy of the graph (`newG`) to maintain the original topology between matches.
    Each *n*-step random walk ❹ generates up to *n* turns for both players 68 and
    checks the win condition at each phase 57. The result of each game is appended
    to `game_res`. Each iteration of this loop counts as one complete turn cycle within
    a game.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了有效的源节点和汇节点对，就执行*k*次随机游走。`for`循环的每次迭代❸构成一次完整的游戏，在图的副本(`newG`)上进行，以保持比赛之间的原始拓扑结构。每次*n*步随机游走❹为两位玩家生成最多*n*轮，并在每个阶段57检查胜利条件。每局游戏的结果都会添加到`game_res`中。这个循环的每次迭代都算作游戏中的一次完整回合。
- en: Once the *k* walks are complete, we tally the wins (1 point for a win by player
    1 and –1 point for a win by player 2) ❾ by summing `game_res`, then take the average
    `tally` as the overall score for the *k* walks.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*k*次游走完成，我们通过求和`game_res`来统计胜利（玩家1胜利得1分，玩家2胜利得–1分）❾，然后取平均值`tally`作为*k*次游走的总得分。
- en: 'Run the code in [Listing 6-15](#listing6-15) to see the result of 25 simulations.
    The averages produced by each test (the outermost `for` loop) may vary wildly,
    as you can see from this snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行[Listing 6-15](#listing6-15)中的代码以查看25次模拟的结果。每次测试（最外层的`for`循环）产生的平均值可能会有很大差异，正如你从这个代码片段中可以看到的那样：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A score of `0.0` means both players won the same number of matches. Positive
    averages indicate player 1 won more often than player 2\. The closer to `+1` this
    gets, the more heavily the matches favored player 1\. The opposite is true as
    the score moves below 0\. An average score of `-1` indicates player 2 won every
    match.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`0.0`的得分意味着两位玩家赢得的比赛数相同。正数平均值表示玩家1比玩家2赢得更多。这个值越接近`+1`，比赛就越倾向于玩家1。相反，当得分低于0时，情况则相反。`-1`的平均得分表示玩家2赢得了每一场比赛。'
- en: The final step is to summarize the result from all the tests. We can do so by
    summing the individual averages and then dividing by the number of tests. We’ll
    call this the *population mean*. The benefit of the population mean is twofold.
    First, it summarizes all the tests into a single number you can interpret, rather
    than a list of test results. Second, the population mean should be relatively
    stable compared to the values observed between individual run results. If we rerun
    the code, we’ll get different individual test results. The population mean should
    be relatively stable, though.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是总结所有测试的结果。我们可以通过将各个平均值相加，然后除以测试的数量来完成。我们将其称为*总体均值*。总体均值的好处有两个。首先，它将所有测试总结为一个可以解读的数字，而不是一系列测试结果。其次，总体均值应该相对稳定，相较于个别运行结果中观察到的值。如果我们重新运行代码，可能会得到不同的单个测试结果。不过，总体均值应该保持相对稳定。
- en: When analyzing the model three times, I got the population averages 0.2160,
    0.2320, and 0.1808\. Of course in statistics we deal with uncertainty, so a better
    measure of the population mean is the numeric range we believe the actual population
    mean will fall between, given some desired level of confidence. To do this, we
    use the `scipy.stats.t.interval` function and pass in the results from our simulations
    and our desired confidence interval (called the *alpha parameter*) as a float.
    The result is a tuple containing the lower and upper bounds within which we can
    predict the true population mean will fall. For example, I ran the simulation
    6,250 times and I can say with 95 percent confidence the true population mean
    for the simulation (as it’s currently configured) will be between 0.1078 and 0.2225,
    which means there is a slight advantage to player 1\. The current design seems
    to slightly favor the defender because of its growth and the lack of intelligence
    from the adversary.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析模型三次时，我得到了总体平均值0.2160、0.2320和0.1808。当然，在统计学中我们会处理不确定性，因此一个更好的总体均值衡量标准是我们认为实际总体均值将落在的数字范围，这取决于我们期望的置信度水平。为了做到这一点，我们使用`scipy.stats.t.interval`函数，传入我们的模拟结果和期望的置信区间（称为*alpha参数*），并将其作为浮动值传入。结果是一个元组，包含我们预测实际总体均值会落在其中的上下限。例如，我运行了6,250次模拟，我可以有95%的信心认为当前配置下的模拟的真实总体均值将在0.1078和0.2225之间，这意味着玩家1有轻微的优势。当前设计似乎稍微偏向防守方，因为其增长和对手缺乏智能。
- en: Now that we’ve established a baseline performance for our network, let’s see
    if we can improve the adversary’s chances by letting them observe the network
    and pick which routes to sever. We can then compare the results of the two simulations
    (in terms of predicted population means) and see if our changes significantly
    impact player 2’s chance at disrupting the network.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的网络建立了基准性能，让我们看看是否可以通过让对手观察网络并选择要切断的路线来提高他们的机会。然后我们可以比较两个模拟的结果（以预测的总体均值为标准），看看我们的改变是否显著影响了玩家
    2 破坏网络的机会。
- en: Improvements to Player 2
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对玩家 2 的改进
- en: Let’s see what happens if we give player 2 a little more intelligence. In this
    version, player 2 uses the updated graph and current message position to remove
    an edge that’s important to the path between the message position and the goal
    (a relatively intuitive strategy for human players).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果给玩家 2 更多的智能会发生什么。在这个版本中，玩家 2 使用更新后的图和当前消息位置，移除一条对消息位置和目标之间路径重要的边（这对人类玩家来说是一个相对直观的策略）。
- en: To codify this strategy, player 2 will use the max-flow, min-cut theorem. A
    max-flow, min-cut analysis was one of the driving forces behind the creation of
    the modern TCP/IP internet. The protocol breaks messages into little chunks called
    *packets* and then chooses different routes for different parts of the transmission
    based on response times and carrying capacity. The basic idea of the design is
    that someone would have to take out a large percentage of the network before they
    could disconnect two distant nodes from each other. The list of nodes that would
    need to be removed is known as the *cutset*. The adversary in our simulation game
    will take advantage of the cutset information to carry out the exact type of attack
    Paul Baran, the inventor of packet-switching networks, was concerned with in his
    research ([https://www.rand.org/about/history/baran.list.html](https://www.rand.org/about/history/baran.list.html))—that
    is, the selective targeting and removal of communication channels to disrupt the
    network.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这一策略编码化，玩家 2 将使用最大流最小割定理。最大流最小割分析是现代 TCP/IP 网络创建的推动力之一。该协议将消息分割成称为 *数据包*
    的小块，然后根据响应时间和承载能力为不同部分的传输选择不同的路线。该设计的基本思想是，必须拆除网络中很大一部分，才能将两个远程节点相互断开。需要移除的节点列表被称为
    *割集*。我们模拟游戏中的对手将利用割集信息执行保罗·巴兰（Paul Baran）在其研究中关注的那种攻击（[https://www.rand.org/about/history/baran.list.html](https://www.rand.org/about/history/baran.list.html)）——也就是选择性地针对并移除通信通道以破坏网络。
- en: 'In short, the max-flow, min-cut theorem tells us two key pieces of information.
    First, the max-flow portion describes the maximum amount of resources that can
    flow along all paths between two nodes (*u*, *v*). The min-cut section describes
    the minimum number of edges someone would need to remove from the network to sever
    all paths between the two nodes. More formally: given two nodes (*u, v*), the
    max-flow, min-cut theorem tells you the total capacity for the fewest set of edges
    you need to remove so there’s no path between the two nodes (the cutset). A cut
    is a graph partitioning *G*(*S*, *T*) such that *u* is in *S* and *v* is in *T*.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，最大流最小割定理告诉我们两个关键信息。首先，最大流部分描述了在两个节点（*u*，*v*）之间所有路径上可以流动的最大资源量。最小割部分描述了从网络中移除最少数量的边，以切断两个节点之间的所有路径。更正式地说：给定两个节点（*u*，*v*），最大流最小割定理告诉你需要移除的最少边集合的总容量，以使得两个节点之间没有路径（割集）。一个割是一个图的划分
    *G*（*S*，*T*），使得 *u* 在 *S* 中，*v* 在 *T* 中。
- en: 'The *capacity constraint* defined in the max-flow, min-cut theorem limits the
    volume flowing through each edge, per simulation step, to less than or equal to
    the maximum capacity of the edge:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最大流最小割定理中定义的 *容量约束* 限制了每条边在每个模拟步骤中的流量，流量必须小于或等于该边的最大容量：
- en: (u → v) flow ≤ (u → v) capacity
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: （u → v）流量 ≤ （u → v）容量
- en: 'The *conservation constraint* of the theorem states the amount that flows into
    each node is equal to the amount flowing out:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 定理的 *保守约束* 说明流入每个节点的量等于流出该节点的量：
- en: '![](image_fi/502567c06/m06021.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06021.png)'
- en: 'Once again, this can be restated more simply: every node sends out all the
    resources it receives; it doesn’t keep any for itself. This constraint applies
    to all nodes except *u*α and *v*[Ω] . In terms of our simulation, this means that
    any user who reblogs the message receives as much information as the post contains,
    and if someone then reblogs the message from them, that person also receives the
    same amount of information. The source and sink nodes are treated specially due
    to their position in the flow. The source node is like a faucet capable of adding
    a certain amount of resource to the network, so nothing flows into the source,
    only out. In our graph this is synonymous with a user who is likely to receive
    a lot of reblogs, but isn’t likely to reblog a lot themselves (nodes with high
    out-degree and low in-degree). Conversely, the sink node is like a sponge that
    absorbs some amount of information from the network without passing any on. Whatever
    information hits the sink node is absorbed there.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次简化来说：每个节点都会发送它收到的所有资源；它不会为自己保留任何资源。这个约束适用于所有节点，除了 *u*α 和 *v*[Ω]。就我们的模拟而言，这意味着任何转发消息的用户都能接收到该帖子包含的所有信息，而如果有人从他们那里转发消息，那个人也会接收到相同的信息量。源节点和汇节点由于它们在流中的位置，需特殊处理。源节点就像一个水龙头，能够向网络添加一定量的资源，因此没有资源流入源节点，只有流出。在我们的图中，这与一个可能收到大量转发但不太可能自己转发的人（具有高出度和低入度的节点）同义。相反，汇节点就像一个海绵，吸收从网络传来的信息而不传递出去。任何到达汇节点的信息都会被吸收。
- en: The `nx.minimum_cut` function in [Listing 6-16](#listing6-16) uses the max-flow,
    min-cut theorem to determine the minimum cut value between two nodes (*u*, *v*)
    and the partition created by the cut, returned as a tuple (`cut_value`, `partition`).
    The `partition` is a tuple of (`reachable`, `unreachable`) nodes that indicates
    which nodes would be reachable and unreachable from *u*. Recall from the previous
    definition that a cut partitions the graph so that the two nodes are in separate,
    disconnected components if the cutset is removed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-16](#listing6-16) 中的 `nx.minimum_cut` 函数使用最大流最小割定理来确定两个节点（*u*，*v*）之间的最小割值，以及由割产生的分割，结果以元组（`cut_value`，`partition`）的形式返回。`partition`
    是一个元组（`reachable`，`unreachable`）表示从 *u* 可以到达和不能到达的节点。回顾之前的定义，割将图划分为两个部分，如果移除 `cutset`，这两个节点就会在不同的、断开的组件中。'
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 6-16: Updating player 2 with more intelligence'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-16：通过增加智能来更新玩家 2
- en: We start by computing the `cutset` between *u*(*q*) and *v*[Ω] ❶. To convert
    the `partition` tuple into the `cutset`, we loop over the pairs of neighbors in
    the `reachable` set ❷. For each node in the set, we loop over all their neighbors
    in the graph. If one of their neighbors is found in the `unreachable` set, then
    the edge(s) between the node in the `reachable` set and the node in the `unreachable`
    set belong to the cutset. Once we’ve processed all the nodes this way, we’ll have
    the list of all edges required to disconnect the two nodes. If there’s only one
    edge in the set, player 2 chooses this edge for removal ❹. Otherwise, player 2
    chooses an edge from the `cutset` uniformly at random, again relying on the `choice`
    function ❸.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算 *u*（*q*）和 *v*[Ω] 之间的 `cutset` ❶。为了将 `partition` 元组转换为 `cutset`，我们遍历 `reachable`
    集合中的邻居对 ❷。对于集合中的每个节点，我们遍历它们在图中的所有邻居。如果它们的邻居在 `unreachable` 集合中找到，那么 `reachable`
    集合中的节点与 `unreachable` 集合中的节点之间的边属于 `cutset`。当我们通过这种方式处理完所有节点后，就能得到所有断开两个节点所需的边。如果集合中只有一条边，玩家
    2 选择这条边进行移除 ❹。否则，玩家 2 从 `cutset` 中随机选择一条边，同样依赖于 `choice` 函数 ❸。
- en: 'This output shows the result of rerunning the simulation with the new strategy
    for player 2:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出展示了重新运行模拟并采用新策略对玩家 2 的结果：
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After analyzing the modified player 2 in 6,250 simulations, I got a population
    mean of –0.8144 and can say with 95 percent confidence that the population mean
    for simulations with the modified player 2 is between –0.9484 and –0.6803\. When
    you run the code on your machine, you might see slightly different results (remember,
    we’re dealing with a lot of randomness), but the overall trend should remain consistent.
    It seems that this simple strategy changes the simulation to heavily favor player
    2, even with the network growth still favoring player 1.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析了修改后的玩家 2 在 6,250 次模拟中的表现后，我得到的总体均值为 -0.8144，并且可以 95% 确信，修改后的玩家 2 在模拟中的总体均值介于
    -0.9484 和 -0.6803 之间。当你在自己的机器上运行代码时，可能会看到稍有不同的结果（记住，我们在处理很多随机性），但整体趋势应该保持一致。看起来这个简单的策略将模拟的结果大大倾向于玩家
    2，即使网络增长仍然倾向于玩家 1。
- en: 'There’s always a chance we’re erroneously claiming that we’ve improved player
    2’s chances. Since we can’t simulate every possible outcome, we can never be 100
    percent sure our population means are accurate. How, then, can we be sure this
    result isn’t due to some random fluke? The truth is, we can be sure only up to
    a certain point. We have to accept that we can’t know for certain. This brings
    up an important point: we need to think about how much risk we’re willing to accept
    of coming to an incorrect conclusion. When you perform an analysis in the wild,
    there are often real-world consequences for acting on incorrect conclusions. You
    should pick a confidence level that complements the amount of risk in the event
    that you’re wrong. The higher the risk, the higher confidence you should require.
    Once you’ve chosen your desired level of confidence, you can convert it into your
    t-test threshold by subtracting the desired confidence level from 100\. For example,
    I want to be very certain our result is not a fluke, so I’ll set the confidence
    level to 99 percent, which means we’re willing to accept a 1 percent probability
    of coming to an incorrect conclusion. We can now use this threshold to test our
    claim that we’ve improved player 2’s chance of winning.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是有可能错误地声称我们改善了玩家2的获胜机会。由于我们无法模拟每个可能的结果，我们永远无法百分之百确定我们的总体均值是否准确。那么，我们如何确保这个结果不是某种随机偶然现象呢？事实是，我们只能在一定范围内确保这一点。我们必须接受我们无法确切知道的现实。这就提出了一个重要问题：我们需要思考我们愿意接受多少风险，以避免得出错误结论。当你在实际环境中进行分析时，错误结论的后果往往是现实的。你应该选择一个与风险相匹配的置信水平，以防万一你错了。风险越高，你需要的置信度就应该越高。一旦你选择了期望的置信水平，你可以通过从100减去所需的置信水平来将其转换为t检验的阈值。例如，我希望非常确定我们的结果不是偶然的，因此我将置信水平设置为99%，这意味着我们愿意接受1%的概率得出错误结论。我们现在可以使用这个阈值来检验我们是否提高了玩家2的获胜机会。
- en: More formally, we can state the hypothesis that changing player 2’s logic has
    created a significant reduction in the population mean (*h*[1] = μ[0] > μ[1]).
    The null hypothesis, then, is that the random sample’s mean will be equal to or
    less than that of the modified player (*h*[1] = μ[0] ≥ μ[1]). We can compare the
    population mean of this set of results using a statistical method known as the
    *two-sample t-test*. This t-test quantifies the difference between the arithmetic
    means of the two samples. A common application is to test if a new process or
    treatment is superior to a current process or treatment. In our case, we’ll use
    it to determine if the difference between the two population means is significant
    enough to claim that our changed strategy for player 2 has in fact improved their
    chance of winning.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地，我们可以陈述假设，改变玩家2的逻辑显著降低了总体均值（*h*[1] = μ[0] > μ[1]）。那么零假设是，随机样本的均值将等于或小于修改后的玩家均值（*h*[1]
    = μ[0] ≥ μ[1]）。我们可以使用一种叫做*双样本t检验*的统计方法来比较这组结果的总体均值。这个t检验量化了两个样本的算术均值之间的差异。一个常见的应用是检验一个新过程或治疗方法是否优于现有的过程或治疗方法。在我们的案例中，我们将使用它来确定两个总体均值之间的差异是否足够显著，以声称我们为玩家2所做的改变确实提高了他们的获胜机会。
- en: The proof of concept uses the `scipy.stats.ttest_ind` function to run this test.
    The result is an object with an attribute named `pvalue`. The p-value quantifies
    the probability of observing a value as or more extreme than the tested value,
    assuming the null hypothesis is true. We compare this number against our threshold
    of 1 percent to determine if we’re confident enough in the result to reject the
    null hypothesis. In this case I’ve run the test over a dozen times and every time
    the improved player 2 score is significantly low enough to support the claim that
    we are 99 percent sure the change we made to player 2 improved their chance of
    winning. We can visualize the two probability distributions as in [Figure 6-4](#figure6-4)
    to see just how big of an impact the change has had.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该概念验证使用了`scipy.stats.ttest_ind`函数来运行此检验。结果是一个具有名为`pvalue`属性的对象。p值量化了在零假设为真的情况下，观察到与测试值相同或更极端值的概率。我们将这个数字与1%的阈值进行比较，以确定我们是否对结果有足够的信心来拒绝零假设。在这种情况下，我已运行了十几次测试，每次玩家2的得分显著低于支持我们99%确定的结论，即我们对玩家2的改变提高了他们的获胜机会。我们可以如图[6-4](#figure6-4)所示，直观地展示两个概率分布，以了解这一变化带来了多大的影响。
- en: '![](image_fi/502567c06/f06004.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/f06004.png)'
- en: 'Figure 6-4: Comparing probability distributions'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：比较概率分布
- en: This graph shows the likelihood of all possible test outcomes for both the random
    and improved player 2 models. The light gray dotted line represents the baseline
    performance of the random player model. The dark gray continuous line is the performance
    of the improved player model. The large peak and steep drop-off around –0.8 shows
    that the improved player performed more consistently and could win most series
    by a large margin. In fact, it would be incredibly unlikely for any series of
    tests to average as high as –0.25 using the improved player 2 code. We can interpret
    this as an indication that the ability to selectively remove edges has the potential
    to highly disrupt the information flow within this network.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表展示了随机玩家模型和改进后的玩家 2 模型的所有可能测试结果的概率。浅灰色虚线代表随机玩家模型的基准表现。深灰色实线则是改进后的玩家模型的表现。大峰值和急剧下降出现在–0.8附近，表明改进后的玩家表现更为一致，并且可以以较大差距赢得大部分比赛。事实上，使用改进后的玩家
    2 代码，任何一系列测试的平均值达到–0.25的可能性极低。我们可以将其解释为，选择性地移除边缘有潜力大幅干扰该网络中的信息流动。
- en: You can run the proof of concept using the command `python mcs_multiplayer.py`
    in the *Chapter 6* directory in the book’s supplemental materials. On each execution,
    the code runs a group of simulations for both player 2 types, then calculates
    the population means and compares them using the one-tailed t-test. It will output
    a line telling us whether or not we can reject the null hypothesis, and finally
    it generates a graph like the one in [Figure 6-4](#figure6-4) for analysis. As
    an exercise, try adjusting the weights in `XI` to more heavily favor new connections
    and see if this impacts the result to player 1’s benefit. What other changes could
    you make to player 1 to improve their ability to defend the network?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用命令`python mcs_multiplayer.py`在书籍附带材料的*第6章*目录中运行概念验证。每次执行时，代码会运行一组针对两种玩家类型的模拟，然后计算人口均值并通过单尾t检验进行比较。它将输出一行，告诉我们是否可以拒绝原假设，最后它会生成一个类似于[图6-4](#figure6-4)的图表进行分析。作为一个练习，尝试调整`XI`中的权重，更多地偏向新连接，看看这是否会影响结果并对玩家
    1 有利。你还能对玩家 1 做哪些其他改动，以提高他们防御网络的能力？
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The concepts introduced in this chapter—Monte Carlo simulations, finite state
    machines, random walks, weighted choice—combined with the foundational graph theory
    from the last three chapters make up an extremely flexible set of tools that go
    far beyond social network analysis. By defining finite state machines for simulations,
    analyzing repeated simulations to determine the likelihood of a particular outcome,
    modifying simulations to get different results and insights, and modeling how
    graphs may evolve over time, you can quantitatively assess security risks by modeling
    potential changes to the environment.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的概念——蒙特卡罗模拟、有限状态机、随机游走、加权选择——结合过去三章的基础图论，构成了一套极其灵活的工具，远远超出了社交网络分析的范畴。通过为模拟定义有限状态机、分析重复模拟以确定特定结果的可能性、修改模拟以获得不同的结果和见解，以及建模图形如何随着时间演变，你可以通过模拟环境潜在变化来定量评估安全风险。
- en: One scenario where I constantly find myself applying Monte Carlo simulations
    is in crowd flow dynamics. Predicting how people will move through an area, where
    they’ll gather, and how they might change that movement in response to different
    types of obstructions is one of the keys to planning effective physical security
    controls. We’ll discuss this a bit more in the context of the art gallery problem
    in [Part III](p03.xhtml), but you may already have some idea of how you could
    approach this task using what we’ve covered here.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我在群体流动动态中经常应用蒙特卡罗模拟。预测人们如何在区域内移动，他们会在哪里聚集，以及他们如何响应不同类型的障碍物而改变这些移动方式，是规划有效物理安全控制的关键之一。我们将在[第三部分](p03.xhtml)的艺术画廊问题中进一步讨论这一点，但你或许已经有了一些如何利用我们所学内容来解决这一任务的想法。
- en: This is just the beginning of Monte Carlo simulations, though. By changing the
    logic at each simulation step, you can model all kinds of unique behaviors in
    the network. Designing an appropriate simulation is as much an art as it is a
    science, so don’t be afraid to branch out and explore some wild simulation ideas.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅仅是蒙特卡罗模拟的开始。通过改变每个模拟步骤中的逻辑，你可以模拟网络中的各种独特行为。设计一个合适的模拟既是一门艺术，也是一门科学，所以不要害怕拓展思路，探索一些大胆的模拟想法。
- en: To help you as you go forth, the Jupyter notebook that accompanies this chapter
    has code to display random walks in 2D and 3D, which you can use to visualize
    the simulations you develop. Often, seeing the results distributed visually can
    lead to interesting discoveries (like paths that always cross a single point).
    By combining the random walk display code with the animation code from the supplemental
    materials, you can even create a video of the simulation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你继续前进，本章附带的Jupyter笔记本包含了用于显示二维和三维随机游走的代码，你可以使用这些代码来可视化你开发的模拟。通常，看到结果的可视化分布可以带来有趣的发现（例如，路径总是穿过某一个点）。通过将随机游走显示代码与补充材料中的动画代码结合，你甚至可以创建模拟的视频。
- en: As you explore the related literature, you’ll find numerous advanced discussions
    of how to select a “best move” within the Monte Carlo simulation. As you saw in
    the proof of concept, small changes to parameters can have a drastic impact on
    the result. It’s important to be aware of the rationale and implications of each
    change to the model so that you can formulate more accurate assessments and draw
    well-founded conclusions about the networks you simulate.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在你探索相关文献时，你会发现关于如何在蒙特卡罗模拟中选择“最佳移动”的众多高级讨论。正如你在概念验证中所看到的，参数的微小变化可能对结果产生重大影响。了解每个模型变化的原因和影响非常重要，这样你才能制定更准确的评估，并对你模拟的网络得出有根据的结论。
- en: You can learn more about GGP theory and algorithms from Stanford University’s
    online course ([http://ggp.stanford.edu](http://ggp.stanford.edu)). Several of
    these models lend themselves well to various information security tasks, such
    as risk analysis, budget planning, and incident response. If you’d like to learn
    more about information flow, check out the research paper “An Information Flow
    Model for Conflict and Fission in Small Groups,”^([11](b01.xhtml#c06-endnote-011))
    which describes a formal process for measuring information flow and detecting
    unbalanced sentiment in a social network.**
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过斯坦福大学的在线课程了解更多关于GGP理论和算法的内容（[http://ggp.stanford.edu](http://ggp.stanford.edu)）。这些模型中的几个非常适用于各种信息安全任务，如风险分析、预算规划和事件响应。如果你想了解更多关于信息流的内容，可以查看研究论文《小组中的冲突与分裂的信息流模型》，^([11](b01.xhtml#c06-endnote-011))
    该文描述了一个用于测量信息流并检测社交网络中情绪不平衡的正式过程。**
