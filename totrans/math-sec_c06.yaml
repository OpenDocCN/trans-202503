- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Analyzing Social Networks to Prevent Security Incidents
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分析社交网络以防止安全事件
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In the last three chapters on graph theory, we’ve built graphs from a snapshot
    of a network at a particular moment in time; that is, we’ve worked from fixed,
    historical data. But finding and responding to events in the past always leaves
    the white hats one step behind the black hats. If we want to know more about what
    happened before or after the time captured in the data, we need new analytic techniques.
    The future requires *predictive analytics*, a branch of mathematics that aims
    to statistically determine the probability of future or past events given some
    set of known observations. The goal is to stop the security incident before it
    ever gets started. To achieve this, though, we need a way to predict how things
    will change over time. We’ll use a specific algorithm, the Monte Carlo simulation,
    to model network activity that hasn’t occurred yet. While this chapter presents
    the topic in the context of social network analysis, Monte Carlo simulations are
    suited to a wide variety of topics and network types. For example, I’ve used Monte
    Carlo simulations to predict which machine an adversary would attack next.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的三章图论内容中，我们根据网络在特定时刻的快照构建了图；也就是说，我们使用的是固定的历史数据。但是，回顾过去并响应事件总是让白帽子比黑帽子慢一步。如果我们想了解数据捕获的时间之前或之后发生了什么，我们需要新的分析技术。未来需要*预测分析*，这是一门数学分支，旨在根据一组已知的观察数据统计地确定未来或过去事件的可能性。目标是阻止安全事件在发生之前就被解决。然而，要实现这一点，我们需要一种方法来预测事物随时间的变化。我们将使用一种特定的算法——蒙特卡罗模拟，来模拟尚未发生的网络活动。虽然本章在社交网络分析的背景下介绍了这一主题，但蒙特卡罗模拟适用于各种不同的主题和网络类型。例如，我曾使用蒙特卡罗模拟预测对手接下来会攻击哪台机器。
- en: 'Here, we’ll attempt to predict the answers to the following questions about
    a social network:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将尝试预测以下关于社交网络的问题的答案：
- en: How far is information likely to spread from a given node?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息从给定节点传播的距离有多远？
- en: Which nodes are being influenced by other nodes?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些节点正在受到其他节点的影响？
- en: What links could be severed to disrupt the flow of information between two nodes?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些连接可能会被切断，从而中断两个节点之间的信息流动？
- en: From a security perspective, these questions assess the resilience of a social
    network in the face of adversarial behavior. They ask, “How easy would it be to
    break up an association of people?” Companies ask these questions about themselves
    to determine if they could withstand losing key employees, facilities, or vendors.
    Law enforcement asks them when they assess a criminal syndicate.^([1](b01.xhtml#c06-endnote-001))
    Criminals also ask these questions about an organization when they want to select
    the targets for spear phishing and other social engineering attacks.^([2](b01.xhtml#c06-endnote-002))
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度看，这些问题评估社交网络在面对对抗行为时的韧性。它们问：“打破人们之间的关联有多容易？”公司问这些问题是为了确定他们是否能承受失去关键员工、设施或供应商的打击。执法部门在评估犯罪集团时也会问这些问题。^([1](b01.xhtml#c06-endnote-001))
    犯罪分子也会在选择网络钓鱼和其他社会工程攻击目标时问这些问题。^([2](b01.xhtml#c06-endnote-002))
- en: We’ll begin this chapter by looking at how to define and construct a Monte Carlo
    simulation. We’ll discuss how different levels of randomness can be applied to
    replace unknowns. Then we’ll use the Monte Carlo simulation we’ve built to predict
    the way a piece of information might move through the social network from [Chapter
    5](c05.xhtml), given previous observations. Finally, in the proof of concept for
    this chapter, we’ll see how to modify our simulation to account for adversarial
    behavior. By the end of this chapter, you’ll be able to use your knowledge of
    graph theory and apply Monte Carlo simulations to predict the outcome of different
    scenarios on your own social networks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从定义和构建蒙特卡罗模拟开始。我们将讨论如何应用不同级别的随机性来替代未知数。然后，我们将利用我们构建的蒙特卡罗模拟，预测信息如何在社交网络中传播，从[第5章](c05.xhtml)的先前观察数据出发。最后，在本章的概念验证中，我们将看到如何修改我们的模拟，以考虑对抗行为。在本章结束时，你将能够运用图论知识，并将蒙特卡罗模拟应用于预测自己社交网络中不同情境的结果。
- en: Using Monte Carlo Simulations to Predict Attacks
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用蒙特卡罗模拟预测攻击
- en: For the rest of this chapter to make sense, we need a little bit more theory
    on top of the graph theory we’ve already covered. Specifically, I’ve been throwing
    around the word *simulation* without really defining it. Generally speaking, a
    simulation is a controlled imitation of a real-world process. Simulations rely
    on models to describe the key characteristics and behaviors present in the simulated
    environment. The simulation code acts as the manager of the model, choosing various
    actions and applying them to evolve the model at each step. Modern models and
    simulations are most often designed using a combination of programming languages
    like C and Python, where C is used for critical functions and user-friendly Python
    syntax is used for the rest. Luckily, all the underlying C code has already been
    handled for us, so we can focus on the Python interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让本章其余部分有意义，我们需要在已经涵盖的图论基础上增加一些理论内容。具体来说，我一直在提到*模拟*这个词，但并没有真正定义它。一般来说，模拟是对现实世界过程的受控仿真。模拟依赖于模型来描述模拟环境中存在的关键特征和行为。模拟代码充当模型的管理者，选择各种操作并在每一步应用它们以推动模型的发展。现代模型和模拟通常使用C和Python等编程语言的组合来设计，其中C用于关键功能，而用户友好的Python语法则用于其余部分。幸运的是，所有底层的C代码已经为我们处理好了，所以我们可以专注于Python接口。
- en: In theory, any phenomenon that can be reduced to data and equations can be simulated
    on a computer. In practice, however, simulation is difficult because most real-world
    processes are subject to a practically infinite number of influences, and it’s
    impossible to account for them all.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，任何可以简化为数据和方程的现象都可以在计算机上进行模拟。然而，在实践中，模拟是困难的，因为大多数现实世界的过程都受到几乎无限多种因素的影响，而这些因素是无法全部考虑到的。
- en: A Monte Carlo simulation is a way of quickly gathering statistics about some
    seemingly random (or at least hard to predict) variable, given a set of constraints.
    Unlike other forecasting methods, which work with a set of fixed input values,
    a Monte Carlo simulation predicts a set of outcomes based on an estimated range
    of values. You’ve probably seen the results of a Monte Carlo simulation in the
    form of a storm path map (sometimes called a *spaghetti model*). Monte Carlo simulations
    are most useful when the probability of varying outcomes can’t be determined because
    of random variable interference. A Monte Carlo simulation focuses on repeating
    the test with random samples to achieve certain results. It also helps to explain
    the impact of risk and uncertainty in prediction and forecasting models because
    the values for the random variables are chosen using the distribution of previously
    recorded values. The larger the variance in the random value, the more variance
    in the different results of the simulation. In principle, Monte Carlo methods
    can be used to investigate any problem with a probabilistic interpretation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡罗模拟是一种在给定约束条件下，快速收集有关某些看似随机（或者至少难以预测）变量统计数据的方法。与其他预测方法不同，蒙特卡罗模拟基于一组预估的值范围来预测一组结果，而不是依赖固定的输入值。你可能见过蒙特卡罗模拟的结果，这种结果常以风暴路径图的形式展示（有时被称为*意大利面模型*）。蒙特卡罗模拟在由于随机变量干扰无法确定不同结果的概率时最为有用。蒙特卡罗模拟通过对随机样本进行多次测试，来实现特定结果。它还有助于解释风险和不确定性在预测和预报模型中的影响，因为随机变量的值是通过以前记录的值的分布来选择的。随机值的方差越大，模拟中不同结果的方差也就越大。原则上，蒙特卡罗方法可以用于研究任何具有概率解释的问题。
- en: In a security context, I’ve used Monte Carlo simulations to predict and interrupt
    attacks. To do so, I programmed some rules that mimicked the previous decisions
    of the attacker and ran thousands of simulations to predict where the attacker
    would end up. My team created a network graph (similar to the one from the previous
    chapter) in which we weighed the ease of access along with the machine’s attractiveness
    to the attacker (in terms of data or lateral movement). We then ran simulations
    with the attacker starting from random machines we knew had been exploited and
    using a stochastic process to determine if the attacker could successfully move
    from one machine to another.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全环境中，我使用了蒙特卡罗模拟来预测并阻止攻击。为了实现这一点，我编写了一些规则，模拟了攻击者之前的决策，并运行了成千上万次的模拟来预测攻击者将会在哪里结束。我的团队创建了一个网络图（类似于上一章中的那个），在其中我们综合考虑了访问难度和机器对攻击者的吸引力（从数据或横向移动的角度来看）。然后，我们进行了模拟，攻击者从我们知道已被攻击的随机机器开始，使用随机过程来判断攻击者是否能够成功地从一台机器移动到另一台。
- en: 'We had additional rules to define how the attacker selected machines and so
    forth, but the question we were trying to answer was simple: After six days of
    active exploitation, which machines had the highest probability of being infected?
    In math terms, the law of large numbers tells us that integrals described by the
    expected value of some random variable can be approximated by taking the empirical
    mean (sometimes called the *sample mean*) of independent samples of the variable.
    In lay terms, the machines with the highest probability in our network simulation
    tests were likely those with the actual highest probability. And there’s our definition
    for “predicting” the future: we can state, with some degree of confidence, the
    statistical probability of each outcome. Unfortunately, that means things won’t
    always turn out as predicted.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有额外的规则来定义攻击者如何选择机器等，但我们试图回答的问题很简单：经过六天的积极利用，哪些机器被感染的概率最高？用数学术语来说，大数法则告诉我们，通过对某些随机变量的期望值进行积分，可以通过取该变量的独立样本的经验均值（有时叫做*样本均值*）来进行近似。通俗来说，我们网络仿真测试中被感染概率最高的机器，很可能就是那些实际感染概率最高的机器。这就是我们对“预测”未来的定义：我们可以在一定程度上有信心地陈述每种结果的统计概率。不幸的是，这意味着事情并不总是会按照预测的结果发生。
- en: Modeling changes requires that we first have a way to describe what can and
    can’t happen. We’ll use a mathematical construct known as a finite state machine
    to handle this task. We then need to create a fake world for our simulation to
    inhabit. NetworkX will fill this role by providing the graph of our social network.
    Finally, we need some way of recording the different events so that we can analyze
    them. This is where the Monte Carlo algorithm really starts to take shape. Let’s
    start by defining each piece, and then we can tie it all together with some different
    simulations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 建模变化要求我们首先有一种方法来描述什么可以发生，什么不能发生。我们将使用一种叫做有限状态机的数学构造来处理这个任务。接着，我们需要为我们的仿真创建一个虚拟世界。NetworkX
    将通过提供我们的社交网络图来扮演这个角色。最后，我们需要某种方法来记录不同的事件，以便进行分析。这就是蒙特卡洛算法真正开始发挥作用的地方。让我们从定义每个部分开始，然后通过一些不同的仿真将它们结合起来。
- en: Finite State Machines
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有限状态机
- en: A *finite state machine* (*FSM* or simply *state machine*) is a hypothetical
    machine that can be in exactly one of a finite number of states at a given moment
    in time, where a *state* is a unique configuration of variables. If you think
    of a board with three switches on it, each possible switch configuration represents
    a possible state for the board. It’s called a *finite* state machine because you
    can count the number of possible states. In the example switchboard, if each switch
    can be in one of two possible positions, there’s a total of eight possible configurations,
    or states, the switchboard could be in. If you think of these switches like bits
    in binary, you could represent the values between 000 and 111, or 0 through 7
    in base 10\. The state machine can change from one state to another in response
    to some external *input*, or decision (such as flipping one of the switches on
    the board). Changes from one state to another are called *transitions*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*有限状态机*（*FSM* 或简称 *状态机*）是一个假设的机器，在任何给定时刻只能处于有限数量的状态中的一个，其中一个*状态*是变量的独特配置。如果你想象一块有三个开关的电路板，每种可能的开关配置就代表电路板的一个可能状态。它之所以叫做*有限*状态机，是因为你可以计算出可能的状态数目。在这个示例的开关板中，如果每个开关可以处于两个可能的位置，那么总共有八种可能的配置，或者说状态，开关板可以处于其中。如果你把这些开关看作是二进制中的位，你可以表示从
    000 到 111 的值，或者从 0 到 7 的十进制值。状态机可以响应某些外部*输入*或决策（例如翻动电路板上的一个开关）从一个状态转换到另一个状态。状态之间的变化叫做*过渡*。'
- en: Formally, a state machine *M* is defined by a quintuple *M* = (Ξ, *S*, *S*[0],
    δ) comprising a finite number of possible inputs (Ξ, the *input alphabet*), a
    set of all possible states (*S*), an initialization state (*S*[0]) where *S*[0]
    ∈ *S*, and finally the conditions for each valid transition between states, δ.
    We can represent a state machine as a directed graph wherein each node is a potential
    state of the machine, and each edge is the required input to transition from state
    *u* to state *v*. [Figure 6-1](#figure6-1) shows a simple FSM graph with five
    states and four transition inputs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地，一个状态机 *M* 由五元组 *M* = (Ξ, *S*, *S*[0], δ) 定义，其中包含有限个可能的输入（Ξ，*输入字母表*）、所有可能状态的集合（*S*）、初始化状态（*S*[0]），其中
    *S*[0] ∈ *S*，以及每个有效状态转换之间的条件 δ。我们可以将状态机表示为一个有向图，其中每个节点是机器的潜在状态，每条边是从状态 *u* 到状态
    *v* 所需的输入。[图6-1](#figure6-1) 显示了一个简单的有限状态机图，包含五个状态和四个转换输入。
- en: '![](image_fi/502567c06/f06001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/f06001.png)'
- en: 'Figure 6-1: A simple finite state machine'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：一个简单的有限状态机
- en: 'Looking at this graph, you might be confused; after all, I just said there
    were four transitions, but there are nine edges here (the bidirectional edges
    between *S*[0] and *S*[1] and *S*[3] and *S*[4] count as two each). This is because
    the same input may be used in multiple transitions. The inputs Ξ[3] and Ξ[2] in
    [Figure 6-1](#figure6-1) are both examples of this: Ξ[2] is used to transition
    between *S*[0] and *S*[1] as well as between *S*[4] and *S*[2], while Ξ[3] can
    be used to transition from *S3 to *S*[1] or from *S*[1] to *S*[2]. Think of the
    input Ξ[2] as an action, like flipping a particular switch. Depending on what
    state you’re in currently, the action of flipping the switch may take you to a
    different state. If you’re in *S*[0] and flip the switch, you end up in *S*[1].
    If you’re in *S*[4] and flip the switch, you’ll end up in *S*[2]. The input hasn’t
    changed—it’s still Ξ[2]—which illustrates an important relationship between inputs
    and states. The same input may result in arriving at a different state, depending
    on the current state.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个图，你可能会感到困惑；毕竟，我刚才说过有四个转换，但这里有九条边（*S*[0] 和 *S*[1] 之间以及 *S*[3] 和 *S*[4] 之间的双向边算作两条）。这是因为相同的输入可能在多个转换中使用。[图6-1](#figure6-1)
    中的输入 Ξ[3] 和 Ξ[2] 就是这种情况的例子：Ξ[2] 被用来在 *S*[0] 和 *S*[1] 之间转换，也在 *S*[4] 和 *S*[2] 之间转换，而
    Ξ[3] 可以用来从 *S*[3] 转换到 *S*[1]，或者从 *S*[1] 转换到 *S*[2]。把输入 Ξ[2] 想象成一个动作，比如翻动一个特定的开关。根据你当前所处的状态，翻动开关的动作可能会把你带到不同的状态。如果你在
    *S*[0] 中翻动开关，你会到达 *S*[1]。如果你在 *S*[4] 中翻动开关，你会到达 *S*[2]。输入没有改变——它仍然是 Ξ[2]——这说明了输入和状态之间的一个重要关系：相同的输入可能会导致到达不同的状态，具体取决于当前的状态。
- en: '*FSMs are either *deterministic*, meaning each transition has a single guaranteed
    outcome, or *stochastic*, meaning the outcome of an input is influenced by randomness
    and not guaranteed to produce the same result every time. To illustrate the difference
    between the two types of FSMs, imagine picking up a pencil. In a deterministic
    world, attempting to pick up the pencil will always result in successfully picking
    up the pencil—or transitioning to the state where you have the pencil, in FSM
    parlance. In a stochastic world, you may fail to pick up the pencil with some
    probability 0 < *p* < 1\. If you fail to pick up the pencil, you transition to
    a different state than if you’d succeeded. Perhaps you dropped the pencil on the
    floor and you’re now in that state instead. This is a very simplistic example,
    but the point is that stochastic FSMs allow randomness to influence the results.
    This is powerful for generalizing the description of complex interactions because
    you don’t have to understand the mechanisms at work, you only need to measure
    the statistical distribution of possible outcomes and you can approximate the
    same phenomenon.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*有限状态机（FSM）可以是*确定性的*，意味着每个转换都有一个单一的保证结果，或者是*随机的*，意味着输入的结果受随机性影响，并且不保证每次都会产生相同的结果。为了说明这两种类型的有限状态机之间的区别，想象一下捡起一支铅笔。在一个确定性的世界中，试图捡起铅笔总是会成功——或者在有限状态机的术语中，就是转换到你拥有铅笔的状态。而在一个随机的世界中，捡起铅笔可能会有一定的失败概率
    0 < *p* < 1。如果你未能捡起铅笔，你将进入与成功时不同的状态。也许你把铅笔掉到地板上，现在你处于那个状态。这是一个非常简单的例子，但关键是随机有限状态机允许随机性影响结果。这对于概括复杂交互的描述非常有用，因为你不需要理解背后的机制，你只需要衡量可能结果的统计分布，就能近似同样的现象。'
- en: 'You’ll often see a mix of deterministic and stochastic inputs in the same FSM.
    For example, in the FSM from [Figure 6-1](#figure6-1), Ξ[4] is deterministic.
    If you’re at *S*[2], the input Ξ[4] is guaranteed to transition you to *S*[3]
    and there’s no other possible outcome. On the other hand, Ξ[1] is stochastic:
    if you’re at *S*[4] and select action Ξ[1], you might end up at *S*[1] or at *S*[3].
    If no probabilities are given for these outcomes, it’s assumed to be uniformly
    random. If probabilities are given, the probability distribution is used in a
    weighted-random selection function. NetworkX has parameters for labeling the edges,
    which can be useful when showing the probabilities or, as I’ve done here, the
    transition names. You can see examples of this code in the accompanying Jupyter
    notebook. For more detailed examples of using FSMs, I highly recommend checking
    Wolfram Alpha.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常看到在同一个有限状态机（FSM）中混合使用确定性和随机输入。例如，在[图 6-1](#figure6-1)中的FSM中，Ξ[4]是确定性的。如果你处于*S*[2]状态，输入Ξ[4]会保证将你转换到*S*[3]状态，没有其他可能的结果。另一方面，Ξ[1]是随机的：如果你处于*S*[4]状态并选择了动作Ξ[1]，你可能会到达*S*[1]或*S*[3]。如果没有给出这些结果的概率，通常认为它是均匀随机的。如果给出了概率，则使用概率分布在加权随机选择函数中进行选择。NetworkX有用于标记边的参数，这在显示概率时很有用，或者正如我在这里做的那样，显示转换名称。你可以在附带的Jupyter
    notebook中看到这些代码的示例。关于使用FSM的更详细示例，我强烈推荐查看Wolfram Alpha。
- en: Now that you understand FSM structure a bit better, let’s move on to how we
    can leverage it using an algorithmic gem known as random walks. Random walks allow
    us to repeatedly choose random inputs for our FSM to automate the simulation of
    these choices based on the rules we define.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对FSM结构有了更好的理解，我们继续探讨如何利用它，借助一种名为随机游走的算法宝石。随机游走允许我们反复为FSM选择随机输入，以基于我们定义的规则自动化这些选择的模拟。
- en: Network Modeling with Random Walks
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络建模与随机游走
- en: In math terms, a *random walk* is a series of randomly chosen steps (or transitions)
    within a system that result in a random final state after some number of steps.
    I like the analogy of a tourist wandering in an unfamiliar city. They may walk
    up the street a bit, decide to turn left, go a few blocks, and then decide to
    turn around and go back the other way. These walks are erratic and unpredictable
    by definition. Versions of the random walk model have been applied to research
    topics from economics to neurology, and now information security!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用数学术语来说，*随机游走*是一系列在系统内随机选择的步骤（或转换），在经过若干步之后会导致一个随机的最终状态。我喜欢用游客在陌生城市中漫游的比喻。他们可能会走上一段街道，决定转左，再走几个街区，然后决定转身回头。按照定义，这些游走是无规律且不可预测的。随机游走模型的不同版本已经被应用于从经济学到神经学的研究课题，现在也用于信息安全！
- en: 'We’re going to apply this methodology to model how people pass information
    to one another and ultimately utilize the network. We can then use this information
    to explore what might happen if we change some of the parameters (such as an attacker
    taking over one or more lines of communication) without risking actual disruption
    to the network. Randomly selecting a series of transitions within a state machine
    over *n* steps (*T*(*n*)) updates the state of the system with the result of the
    input. The subsequent decision must be based on the new state, and all actions
    may not be valid in all states. The set of valid transitions from a given state
    is denoted Ξ[(][*S*][)]. At each step a transition is selected from Ξ[(][*S*][)]
    and appended to *T*(*n*). We can write this as:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用这种方法来建模人们如何相互传递信息并最终利用网络。然后，我们可以利用这些信息来探索如果改变一些参数（例如攻击者接管一个或多个通信线路）时会发生什么，而无需冒着实际干扰网络的风险。在状态机中随机选择一系列转换，经过*n*步（*T*(*n*)）后，系统的状态会根据输入结果更新。随后的决策必须基于新状态，并且在所有状态下并非所有动作都是有效的。从给定状态的有效转换集合用Ξ[(][*S*][)]表示。在每一步中，从Ξ[(][*S*][)]中选择一个转换并将其附加到*T*(*n*)中。我们可以将其表示为：
- en: '![](image_fi/502567c06/m06001.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06001.png)'
- en: The state is updated and the process is repeated until all *n* steps have been
    taken, or no valid state transitions are left. The resulting *terminal state*
    is the product of applying the random walk defined in *T*(*n*) to the state machine
    *M* (*M* × *T*(*n*) *= S(Tn*)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 状态被更新后，过程会重复，直到所有*n*步都已完成，或者没有剩余的有效状态转换。最终的*终态*是将*T*(*n*)中定义的随机游走应用于状态机*M* (*M*
    × *T*(*n*) = *S*(Tn*))的结果。
- en: As a concrete example, let’s define a simple state machine. Imagine you’re standing
    in the center of a large empty room. This is the initial state, *S*[0]. On the
    floor is a 7×7 grid of squares, and positions in the room can be expressed as
    location tuples (*x*, *y*) on the Cartesian plane (your position is *S*[0] = (4,
    4)). You can move forward, backward, left, or right one square with each step.
    Given an arbitrary set of instructions, you may end up standing on any square
    in the room; therefore, each square can be viewed as a potential state in *S*.
    The inputs [*forward*, *backward*, *left*, *right*] form the input alphabet Ξ.
    The two diagrams in [Figure 6-2](#figure6-2) show the same uniformly random walk
    for *n* = 10 in two dimensions on the left and three dimensions on the right.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，假设我们定义一个简单的状态机。想象你站在一个大空房间的中心，这是初始状态，*S*[0]。地板上有一个7×7的方格，房间中的位置可以表示为笛卡尔平面上的位置元组（*x*，*y*）（你的位置是*S*[0]
    = (4, 4)）。你可以每次移动一步，向前、向后、向左或向右。给定一组任意的指令，你可能会站在房间的任何方格上；因此，每个方格可以视为*S*中的一个潜在状态。输入[*前进*，*后退*，*左*，*右*]构成了输入字母表Ξ。图[6-2](#figure6-2)中的两个图展示了相同的均匀随机漫步，左边是二维，右边是三维，步数为*n*
    = 10。
- en: '![](image_fi/502567c06/f06002.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/f06002.png)'
- en: 'Figure 6-2: A 2D and 3D random walk example'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：二维和三维随机漫步示例
- en: In the 3D example, the third dimension is time (you wouldn’t actually start
    to levitate as you moved around the room).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D示例中，第三个维度是时间（你在房间里移动时实际上不会开始悬浮）。
- en: 'In contrast to a uniformly random walk, where each input is equally likely,
    in a *biased random walk* (or just *biased walk*), one or more of the inputs is
    likely to occur more than the rest. In a biased walk, we extend Ξ to a set of
    tuples: (*input*, *probability*).^([3](b01.xhtml#c06-endnote-003)) At each step
    we select one of the inputs from the list using a weighted random selection function—that
    is, one that respects the probability distribution we pass to it. We’ll construct
    a version of this later, but for now the key takeaway is that biased walks allow
    you to add any a priori information you have about behavior probabilities to your
    modeling. For example, if you know there’s a malicious actor who’s looking for
    financial information, you may choose to bias your model of their behavior toward
    nodes in the network that have access to such information.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与均匀随机漫步不同，其中每个输入的发生概率相等，在*偏置随机漫步*（或仅称为*偏置漫步*）中，一个或多个输入的发生概率可能会高于其他输入。在偏置漫步中，我们将Ξ扩展为一组元组：(*输入*，*概率*)。^([3](b01.xhtml#c06-endnote-003))在每一步中，我们从列表中选择一个输入，使用加权随机选择函数，也就是遵循我们传递给它的概率分布的函数。我们稍后会构建一个这个的版本，但现在的关键是，偏置漫步允许你将关于行为概率的任何先验信息添加到你的模型中。例如，如果你知道有一个恶意行为者在寻找财务信息，你可能会选择将模型的行为偏向于那些有权限访问该类信息的网络节点。
- en: Up until now we’ve covered what a state machine is and how we can use one to
    simulate a series of choices. Because a random walk represents a single set of
    choices made within a stochastic FSM, you could rerun the simulation and the results
    would likely be different. Even with a biased random walk, the results on each
    iteration may be a little more predictable but still not the same. If the result
    were always the same, the system would be deterministic and no fun to analyze.
    It’s the differences between simulation results that we’re interested in analyzing.
    Repeated stochastic simulation is the defining characteristic of a Monte Carlo
    simulation, so in the next section, we’ll complete our algorithm by defining how
    we want to run each test and collect the results in a meaningful way. Once we
    have the final piece to the puzzle, we’ll start using our Monte Carlo simulation
    to predict some possible future states for our social network.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了什么是状态机，以及如何使用状态机来模拟一系列的选择。由于随机漫步代表在随机状态机（FSM）中做出的一组选择，你可以重新运行模拟，结果可能会有所不同。即使是偏置随机漫步，每次迭代的结果也许会更加可预测，但仍然不完全相同。如果结果总是相同的，那么系统将是确定性的，分析起来也不会有趣。我们感兴趣的是分析模拟结果之间的差异。重复的随机模拟是蒙特卡洛模拟的定义特征，因此在下一节中，我们将通过定义如何运行每个测试并以有意义的方式收集结果，来完成我们的算法。一旦我们获得了拼图的最后一块，我们将开始使用蒙特卡洛模拟预测社交网络的一些可能的未来状态。
- en: Monte Carlo Simulation
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟
- en: We can illustrate the relationship between random walks and Monte Carlo simulations
    with the simple example of flipping a coin. If we flip a coin and it lands on
    heads, what have we learned about the coin? Well, we’ve learned that with an extremely
    small sample size of 1, the coin lands on heads. Now, how useful do you think
    this information is for making predictions about the result of future coin flips?
    Could you predict if this is a fair coin or a trick coin? The answer is no, you
    couldn’t. This single result is not very useful—not yet, anyway. To get a clearer
    picture, we’d need to repeat this test a reasonably large number of times and
    record each outcome. Suppose we flip the coin 99 more times and it always lands
    on heads. This is way outside the expected result of roughly 50 percent, so we
    could state the coin is definitely not fair.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单的掷硬币例子来说明随机游走与蒙特卡洛模拟之间的关系。如果我们掷一枚硬币，并且它落在正面，那么我们从硬币上学到了什么呢？嗯，我们知道在样本量极小（仅为1）的情况下，硬币会落在正面。那么，你认为这些信息对于预测未来掷硬币结果有多大帮助呢？你能否预测这是公平的硬币还是有陷阱的硬币？答案是不能。这个单一结果并不特别有用——至少现在还不。为了得到更清晰的图景，我们需要将这个测试重复进行较多次，并记录每次的结果。假设我们再掷99次硬币，结果每次都落在正面。那么这个结果远远超出了大约50%的预期，我们就可以断定这枚硬币肯定不公平。
- en: This situation is similar to the relationship between random walks and Monte
    Carlo simulations. Monte Carlo simulations are a subset of *repeated-sampling
    algorithms, which repeat a test some large number of times to gather statistical
    distributions. What makes a Monte Carlo simulation different from other repeated
    sampling algorithms is that it uses repeated random walks to simplify simulating
    complex interactions within a state machine over time. The random walk through
    the FSM acts like a single test—a coin flip, a space walk, or some other singular
    occurrence. The Monte Carlo algorithm then adds a layer to repeat this test over
    and over to collect the large sample size needed to make accurate predictions
    about future outcomes.*
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况类似于随机游走和蒙特卡洛模拟之间的关系。蒙特卡洛模拟是*重复采样算法*的一个子集，它通过多次重复测试来收集统计分布。蒙特卡洛模拟与其他重复采样算法的不同之处在于，它通过重复随机游走来简化在状态机中模拟复杂的交互过程。FSM中的随机游走就像一个单一的测试——一次掷硬币、一场太空漫步或其他某种单一事件。然后，蒙特卡洛算法会在此基础上增加一层，将这个测试重复进行多次，以收集大量样本数据，从而对未来结果做出准确预测。
- en: '*One predominant use for Monte Carlo simulations is in the field of General
    Game Playing (GGP). The goal for GGP researchers is to find a generalized algorithm
    that can play any arbitrary but well-defined game. Think about a system like Deep
    Blue or the more recent Alpha Go, but designed to play chess and *Go*, as well
    as backgammon, tic-tac-toe, *Risk*, *Battleship*, and so on. This realm of study
    extends to single-player games (so-called puzzle games) like *Tower of Hanoi*
    as well. The automated system, called the *player*, needs to decide on the next
    valid move from a list of potential moves. This process is known as *goal-oriented
    planning*. In a state machine with a large number of potential states (chess matches,
    for example), it’s prohibitive to exhaustively search the options to conclusion.
    Instead, a player needs a strategy to quickly weigh possible options to identify
    advantageous ones. Monte Carlo simulations are one option that researchers have
    used with some success^([4](b01.xhtml#c06-endnote-004)) by reducing each game
    to a limited-length random walk through potential game states, then repeatedly
    testing the outcome of these walks for some goal condition.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*蒙特卡洛模拟的一个主要应用是在通用博弈游戏（GGP）领域。GGP研究者的目标是找到一种通用算法，能够玩任何任意但定义明确的游戏。想想像深蓝（Deep
    Blue）或更近期的Alpha Go这样的系统，但它被设计用来玩国际象棋和*围棋*，以及西洋跳棋、井字游戏、*风险*、*战舰*等其他游戏。这个研究领域也扩展到单人游戏（即所谓的益智游戏），例如*河内塔*。这个自动化系统被称为*玩家*，需要从一系列潜在动作中决定下一个有效的动作。这个过程被称为*目标导向规划*。在具有大量潜在状态的状态机中（例如国际象棋比赛），全面搜索所有选项并得出结论是不可行的。因此，玩家需要一种策略，快速权衡可能的选项，以识别有利的选择。蒙特卡洛模拟是研究人员成功应用的一种方法^([4](b01.xhtml#c06-endnote-004))，它通过将每场游戏简化为一个有限长度的随机游走，穿越潜在的游戏状态，然后反复测试这些游走的结果，以达到某个目标条件。*'
- en: 'As I’ve mentioned, security often comes down to one researcher’s offensive
    knowledge against another’s defensive knowledge. Game theory would label this
    a zero-sum multiplayer scenario. The term *zero-sum* refers to the case that,
    for one player to win points, the other player must lose an equal amount of points.
    Simply put: if you win, I must lose, and vice versa. Chess is the most famous
    example of zero-sum games, but we also see these conditions in a lot of adversarial
    interactions like security. For me to bypass your security, your security must
    get bypassed. For your security controls to block me, my attacks must fail. There
    are already schools like Stanford University that teach game theory as a way for
    humans to analyze their security posture. There are also researchers using game
    theory to model attack and defense scenarios.^([5](b01.xhtml#c06-endnote-005))
    It seems to me that programmatically applying game theory within information security
    research is a natural progression from the tools available today, and the simplest
    place to start that process is with Monte Carlo simulations.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，安全性往往归结为一个研究人员的进攻知识与另一个研究人员的防守知识之间的对抗。博弈论将这种情况称为零和多人博弈。*零和*指的是一种情况，即为了让一个玩家赢得积分，另一个玩家必须失去等量的积分。简单来说：如果你赢了，我就必须输，反之亦然。国际象棋是零和博弈最著名的例子，但我们也可以在许多对抗性互动中看到这些条件，比如安全性问题。为了绕过你的安全防护，你的安全防护必须被突破。为了阻止我，你的安全控制必须失败。像斯坦福大学这样的学府已经开设博弈论课程，帮助人们分析他们的安全态势。也有研究人员使用博弈论来模拟攻击与防守场景。^([5](b01.xhtml#c06-endnote-005))
    在我看来，将博弈论程序化地应用于信息安全研究是从现有工具自然发展而来的，而开始这一过程的最简单方式就是使用蒙特卡罗仿真。
- en: Of course, this simplicity can come at a cost. Monte Carlo simulations can miss
    obvious advantageous decisions due to the random nature of selection. You can
    tune the accuracy of the model a bit by adjusting the number of random walks,
    as well as the maximum length of each random walk. [Figure 6-3](#figure6-3) shows
    an example Monte Carlo simulation of random walks like the one in [Figure 6-2](#figure6-2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种简化可能会带来一些代价。由于选择的随机性质，蒙特卡罗仿真可能会错过明显的有利决策。你可以通过调整随机游走的次数，以及每次随机游走的最大长度，来略微调节模型的准确性。[图
    6-3](#figure6-3)展示了一个蒙特卡罗仿真示例，类似于[图 6-2](#figure6-2)中的随机游走。
- en: '![](image_fi/502567c06/f06003.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/f06003.png)'
- en: 'Figure 6-3: A random walk Monte Carlo simulation'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：随机游走蒙特卡罗仿真
- en: Each walk is shaded differently so you can tell where they overlap. They all
    start from the same location but then take unpredictable paths.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每次游走的路径会有不同的阴影色调，这样你就可以看出它们的重叠部分。它们都从同一个位置开始，但随后会沿着不可预测的路径走。
- en: 'The Monte Carlo simulation we’ll look at is an algorithm that relies on *k*
    random walks of length *n*, through a state machine *M*, to obtain the result
    list ζ*R*. The result is a list of terminal states from each random walk performed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的蒙特卡罗仿真是一种依赖于 *k* 次长度为 *n* 的随机游走算法，通过状态机 *M* 来获得结果列表 ζ*R*。结果是每次随机游走得到的终态列表：
- en: '![](image_fi/502567c06/m06002.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06002.png)'
- en: 'For convenience, I also output the path traversed by each random walk:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我还输出了每个随机游走所经过的路径：
- en: '![](image_fi/502567c06/m06003.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06003.png)'
- en: Choosing values for *n* and *k* is an equal mix of domain knowledge, statistical
    theory, and art. For *n*, we need to choose a value large enough to allow our
    model to reach interesting outcome states without creating a bunch of repetitive
    data. For state machines with a large number of potential transitions and states,
    you may need to pick a value for *n* that balances long enough paths with a reasonable
    program runtime. Our state machine has a small number of potential transitions
    and will tend to reach a terminal state fairly quickly, so a small value between
    10 and 20 steps will suffice.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 *n* 和 *k* 的值既需要领域知识，也需要统计理论和艺术的结合。对于 *n*，我们需要选择一个足够大的值，使得我们的模型能够到达有趣的结果状态，而不会产生大量重复数据。对于有大量潜在转移和状态的状态机，你可能需要选择一个
    *n* 值，平衡足够长的路径与合理的程序运行时间。我们的状态机有少量的潜在转移，并且通常会很快到达终态，所以 10 到 20 步之间的小值就足够了。
- en: Choosing a good value for *k* is largely related to the number of potential
    states in the machine. You want to run the simulation as many times as it takes
    to collect statistical data to support a claim about the outcome, so the more
    possible outcomes there are, the more times you’ll want to run the simulation.
    When you move a project like this into production, you can use statistical methods
    to calculate the exact sample size required to justify an empirical claim, called
    *sample size determination*. Here, our simulation has a relatively small number
    of terminal states and we’re only trying to prove out the system, so somewhere
    between 10 and 25 runs will suffice for testing purposes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个好的*k*值与机器中潜在状态的数量密切相关。你希望尽可能多次运行模拟，以收集支持结果主张的统计数据，因此可能的结果越多，你就越希望多次运行模拟。当你将这样的项目投入生产时，可以使用统计方法来计算确切的样本量，以证明实证主张，这叫做*样本量确定*。在这里，我们的模拟只有相对较少的终端状态，并且我们只是尝试证明系统的有效性，因此，进行10到25次运行就足够进行测试。
- en: Simulating Social Networks
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社交网络模拟
- en: To answer our research questions about a social network, we’re going to write
    our own *Matrix*-like world, where simulated users live out their digital lives
    according to the rules of the system we put in place. The rules we choose represent
    all the decisions a user can make in our simulated world. I base the rules I use
    on the observations already present in the data (for example, which users have
    communicated in the past, and on what topics), as well as a simplified version
    of some link prediction theory published in 2009.^([6](b01.xhtml#c06-endnote-006))
    *Link prediction theory* attempts to describe how edges in a graph have formed
    previously and use that information to predict how they’ll form in the future.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答关于社交网络的研究问题，我们将编写我们自己的*Matrix*式世界，其中模拟的用户将根据我们设定的系统规则生活。我们选择的规则代表了用户在模拟世界中可以做出的所有决策。我所使用的规则基于数据中已经存在的观察结果（例如，哪些用户曾经沟通过，沟通的主题是什么），以及2009年发布的某些链接预测理论的简化版本。^([6](b01.xhtml#c06-endnote-006))
    *链接预测理论* 试图描述图中的边缘是如何以前形成的，并利用这些信息来预测未来如何形成。
- en: Our goal in designing the rules for the FSM is to accurately simulate which
    users might form connections, dissolve their association with other users, or
    pass information along to their connections. We’ll then look at how we can enhance
    the simulation by adding an adversary who is working to disrupt the network. This
    allows us to move into the realm of “what if” simulations. What if the head of
    HR suddenly leaves the company? What if the router in the office crashes? You’ll
    start seeing chances to apply simulations everywhere. After reading through this
    implementation, think about the rules and assumptions we’ve built up and how you
    might improve the simulation with more realistic constraints and behaviors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计有限状态机（FSM）规则的目标是准确模拟哪些用户可能会建立连接、解除与其他用户的关联，或将信息传递给他们的连接。接下来，我们将研究如何通过增加一个旨在破坏网络的对立者来增强模拟。这使我们进入了“如果”的模拟领域。如果人力资源部门的负责人突然离开公司会怎么样？如果办公室的路由器崩溃了呢？你会开始看到到处都可以应用模拟的机会。阅读完这个实现后，思考一下我们建立的规则和假设，以及如何通过更加现实的约束和行为来改进模拟。
- en: Modeling User Interaction
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户互动建模
- en: To answer the question “How far is information likely to spread from a given
    node?” we can simulate a message *q* propagating through the network by being
    transmitted from one user to another, and determine how many users are likely
    to receive the message. We’ll model the user interactions by generating biased
    random walks for the message to move from node to node. Assume, for the moment,
    that only one copy of the message can exist at a time. (See “[Modeling Information
    Flow](#h2-502567c06-0006)” for handling multiple copies of a message.) Think of
    this like a budget report making its way around an office. As each employee reads
    the report, they decide whether to forward it on to one of their coworkers. Because
    the report is sensitive, no one is allowed to make copies, so only one person
    can be holding the information at any given time. By selecting a starting node
    and allowing the message to propagate probabilistically, we can simulate possible
    paths the report is likely to follow, then count the unique nodes that eventually
    received the message. The average count of unique nodes after all the walks have
    been completed can be seen as the number of nodes likely to receive the information
    originating from the selected starting node.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答“信息从某个节点传播的范围有多远？”这个问题，我们可以模拟一个消息*q*在网络中通过从一个用户传递到另一个用户的方式传播，并确定可能接收到该消息的用户数量。我们将通过为消息生成偏置的随机游走来模拟用户之间的交互，从而让消息在节点间传播。假设，目前为止一次只有一份消息副本存在。（处理消息的多个副本请参见“[信息流建模](#h2-502567c06-0006)”）可以将其想象为一份预算报告在办公室内流转。每个员工阅读报告后，决定是否将其转发给某个同事。由于报告内容敏感，没人被允许复印，因此任何时刻只有一个人可以持有该信息。通过选择一个起始节点并允许消息按概率传播，我们可以模拟报告可能遵循的路径，然后统计最终接收到报告的独特节点数量。所有游走完成后，接收到信息的独特节点的平均数量可以看作是从选定的起始节点开始，信息可能传播到的节点数量。
- en: For a Monte Carlo simulation, you must define the state machine that will act
    as the core of the system. The social network graph nodes (the users) represent
    states the message can occupy in the FSM. Edges indicate potential transitions
    between states (which is based on past communications between users). In the beginning
    of our simulations these will remain static, and we’ll be examining the network
    as it exists at the current point in time. (In the proof of concept for this chapter,
    the edges will change to simulate users making and severing connections within
    the network.) Finally, the input alphabet, which defines valid actions for the
    available transitions, models interactions between nodes (for example, one user
    passing the message to another). Defining inputs and transitions for the FSM is
    similar to defining what are valid choices and when. For the first question, which
    deals with information transmitted between nodes, the input alphabet is [*Send*,
    *Pass*], representing the two actions a user may take when they receive a piece
    of information.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于蒙特卡洛模拟，你必须定义作为系统核心的状态机。社交网络图中的节点（即用户）代表消息在有限状态机（FSM）中可能占据的状态。边表示状态之间的潜在转移（基于用户之间的过去通信）。在我们模拟的开始，这些边将保持静态，我们将检查当前时刻网络的状态。（在本章的概念验证中，边会发生变化，以模拟用户在网络中建立和断开连接。）最后，输入字母表定义了有效的过渡操作，模拟节点之间的交互（例如，一个用户将消息传递给另一个用户）。定义FSM的输入和转移类似于定义有效的选择以及选择的时机。针对第一个问题，即节点之间传递的信息，输入字母表是[*发送*,
    *传递*]，表示用户在接收到信息后可能采取的两种操作。
- en: To start, we’ll define the initial state *S*[0] as the node with the highest
    out-degree holding the message, so the simulation has the best chance of reaching
    a large number of unique nodes on different simulations. Later, we’ll measure
    the effect of starting from different nodes. The node holding the message at any
    given moment is *u*(*q*).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将初始状态*S*[0]定义为持有消息的出度最高的节点，这样模拟就能在不同的模拟中最大程度地覆盖更多独特的节点。稍后，我们会衡量从不同节点开始的效果。在任何给定时刻，持有消息的节点是*u*(*q*)。
- en: 'At each step in a random walk, the node *u*(*q*) uniformly selects one of two
    possible inputs Ξ = [*Send*, *Pass*]. The a priori probability of an input being
    selected is:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机游走的每一步中，节点*u*(*q*)会均匀地从两个可能的输入 Ξ = [*发送*, *传递*] 中选择一个。选择输入的先验概率为：
- en: '![](image_fi/502567c06/m06004.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06004.png)'
- en: '*Pr* (Ξ[*(Send)*]) denotes the probability of *Send*. If *u*(*q*) chooses *Send*,
    *q* is passed to a uniformly selected neighbor of *u*(*q*) (I still denote the
    neighbors of a node as Γ[*(u)*]). If *Pass* is chosen, *u*(*q*) does nothing for
    that step.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pr* (Ξ[*(Send)*])表示*Send*的概率。如果*u*(*q*)选择*Send*，则*q*将被传递给*u*(*q*)的一个均匀随机选择的邻居（我仍然将一个节点的邻居表示为Γ[*(u)*]）。如果选择*Pass*，则*u*(*q*)在该步骤中不做任何操作。'
- en: 'The a priori probability of a given neighbor *v* being selected is:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 给定邻居*v*被选中的先验概率是：
- en: '![](image_fi/502567c06/m06005.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06005.png)'
- en: 'Here v ∈ Γ(u(q ) ). Simply put, this means the starting probability for each
    neighbor is equal. The larger the number of neighbors a node has, the lower the
    probability of any one neighbor receiving the message next. For example, if *u*(*q*)
    has three neighbors (|Γ(u(q))| = 3), then ![m06006r](image_fi/502567c06/m06006r.png).
    You could also write this as a conditional probability (*Pr*(*A*|*B*)):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '这里v ∈ Γ(u(q))。简单来说，这意味着每个邻居的起始概率是相等的。一个节点的邻居越多，任何一个邻居接收消息的概率就越低。例如，如果*u*(*q*)有三个邻居（|Γ(u(q))|
    = 3），那么![m06006r](image_fi/502567c06/m06006r.png)。你也可以将其写成条件概率（*Pr*(*A*|*B*)):'
- en: '![](image_fi/502567c06/m06007.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06007.png)'
- en: The formula states that the probability of a particular neighbor receiving the
    message, given the input is *Send*, is 0.33, or 33 percent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该公式表示，在输入为*Send*的情况下，某个特定邻居接收到消息的概率为0.33，即33%。
- en: 'The overall probability of a message propagating without presuming that *Send*
    is the selected input is defined in the numerator of the previous equation. Intuitively,
    you can think of this as the probability of each event occurring in isolation.
    More properly, the independent probability of a message propagating forward to
    a given neighbor of *u*(*q*) (assuming three neighbors) is:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设不考虑*Send*为选定输入的情况下，消息传播的总体概率定义在前一个公式的分子中。直观地，你可以将其视为每个事件单独发生的概率。更准确地说，消息传播到给定邻居的独立概率（假设有三个邻居）是：
- en: Pr (u(q) → v ) = Pr ( Ξ( Send ) ∧ v(q) ) = 0.5 × 0.33 = 0.165
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Pr (u(q) → v ) = Pr ( Ξ( Send ) ∧ v(q) ) = 0.5 × 0.33 = 0.165
- en: Before we generate random walks, we need to set up the simulation, as shown
    in [Listing 6-1](#listing6-1).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成随机游走之前，我们需要设置仿真环境，如[Listing 6-1](#listing6-1)所示。
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: The initialization code for the Monte Carlo simulation'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-1：蒙特卡洛仿真初始化代码
- en: The code relies on the graph *G* being populated using the method back in Listings
    5-2 and 5-4. Assuming the graph *G* has already been populated, we start with
    the input alphabet `XI`, which represents *Send* as expected and *Pass* using
    `None` ❶; the number of simulations, `k` ❷; and the number of steps in each simulation,
    `n`. To set the start state `S0` ❸, we select the node with the highest out-degree.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码依赖于图*G*已使用Listings 5-2和5-4中的方法进行填充。假设图*G*已经填充完成，我们从输入字母表`XI`开始，其中*Send*使用`None`表示
    ❶，仿真次数`k` ❷，以及每次仿真的步数`n`。为了设置起始状态`S0` ❸，我们选择出度最高的节点。
- en: Continuing from [Listing 6-1](#listing6-1), [Listing 6-2](#listing6-2) shows
    a deterministic, uniformly random implementation of the message-passing Monte
    Carlo simulation algorithm.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 延续[Listing 6-1](#listing6-1)，[Listing 6-2](#listing6-2)展示了一个确定性的、均匀随机的消息传递蒙特卡洛仿真算法实现。
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: A deterministic message-passing Monte Carlo simulation'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-2：确定性消息传递蒙特卡洛仿真
- en: First, we initialize the results list `R` ❶, and then we use nested `for` loops
    24 to perform `k` random walks with up to `n` steps in each.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化结果列表`R` ❶，然后使用嵌套的`for`循环24执行`k`次随机游走，每次游走最多执行`n`步。
- en: Each walk begins with the message at the node `S0` ❸. At each step, we gather
    the neighbors for the currently selected node ❺. If exactly one neighbor exists,
    this neighbor is automatically selected. However, if more than one neighbor exists
    ❻, we select one uniformly at random using the `choice` function, then update
    the `message_at` variable. If the message ever reaches a node with no out-degree
    ❼, we record the node as the result and conclude the walk with `break`. At the
    end of each walk, we append the terminating node `Tn` to the results list ❽.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每次游走从节点`S0` ❸开始。在每一步，我们收集当前选定节点的邻居 ❺。如果只有一个邻居，则自动选择该邻居。然而，如果存在多个邻居 ❻，我们使用`choice`函数从中均匀地随机选择一个邻居，然后更新`message_at`变量。如果消息最终到达一个没有出度的节点
    ❼，我们将该节点记录为结果，并用`break`结束游走。在每次游走结束时，我们将终止节点`Tn`添加到结果列表 ❽。
- en: We summarize the likely *information flow distance*, or *IFD* (![m06008](image_fi/502567c06/m06008.png)),
    as the mean number of unique nodes (disregarding the starting node) in each path
    ❾, then normalize the IFD by the total number of nodes in `G` (again, disregarding
    the starting node) ❿ and print it out to the screen. The `unique` function simply
    takes the path and reduces it to only unique entries. (You can see how I implemented
    it in the 2nd cell of the *MonteCarloSimulations.ipynb* notebook in the chapter’s
    supplemental materials. You can also choose to use one of the library’s versions
    of the code, such as NumPy’s `unique`.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将可能的*信息流距离*（或*IFD*）![m06008](image_fi/502567c06/m06008.png)总结为每条路径中独特节点的平均数量（不考虑起始节点）❾，然后通过`G`中的节点总数（同样不考虑起始节点）❿来标准化IFD，并将其输出到屏幕上。`unique`函数简单地将路径减少为仅包含唯一条目的列表。（你可以在本章补充材料的*MonteCarloSimulations.ipynb*笔记本中的第二个单元格中查看我是如何实现的。你也可以选择使用库中某个版本的代码，例如NumPy的`unique`。）
- en: If you run the code in [Listing 6-2](#listing6-2) a few times, you’ll notice
    the output isn’t consistent. While *S*[*0*] is deterministic, the route from there
    is stochastic. You could edit this model to be entirely deterministic by replacing
    the `vq = choice(gamma_uq)` call with a deterministic selection method, such as
    always passing *q* to the neighbor of *u*(*q*) with the highest out-degree. This
    would be a good option to model a specific behavior pattern that’s known in advance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行[Listing 6-2](#listing6-2)中的代码几次，你会注意到输出结果不一致。虽然*S*[*0*]是确定性的，但从那里开始的路径是随机的。你可以通过将`vq
    = choice(gamma_uq)`调用替换为一个确定性选择方法（例如，总是将*q*传递给邻居节点*u*（*q*）的出度最高的节点），使得这个模型完全确定性。这将是模拟已知的特定行为模式的一个好选项。
- en: 'To implement the simulation with a biased walk instead of a uniformly random
    walk, you can add another element to `XI` that is the same as one already present.
    By doing so, you change the relative probabilities of each input variable being
    selected. For example, adding another `"send"` to the list will weight *Send*
    to twice as likely as *Pass*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个带有偏置行走的模拟，而不是均匀随机行走，你可以向`XI`中添加另一个已经存在的元素。通过这样做，你改变了每个输入变量被选择的相对概率。例如，向列表中添加另一个`"send"`将使*Send*的概率是*Pass*的两倍：
- en: '![](image_fi/502567c06/m06009.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06009.png)'
- en: 'For more fine-tuned control over the probability (bias) of each input, switch
    out the simple `choice` function for one that can process a dictionary of `{action:
    probability}` definitions. (See the proof of concept at the end of the chapter
    for an example.)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '为了对每个输入的概率（偏置）进行更精细的控制，可以将简单的`choice`函数替换为一个可以处理`{action: probability}`定义字典的函数。（请参见本章末尾的概念验证部分以获取示例。）'
- en: Congratulations, you’ve now defined your first predictive model using Monte
    Carlo simulations! This is a simplistic model where we rely on uniform selection
    for randomness and some basic actions, like send and pass, to describe what might
    occur to some arbitrary message on our network. Try starting the message from
    different users and see how it impacts the number of steps the message travels
    and where it ends up. We refer to this as a *naive model*, because we didn’t include
    any specific information about the history of the network, message contents, or
    user preferences. We assume each node is equally likely to send any message to
    any other node it can contact. While simplifying assumptions like this make the
    code easier to write and interpret, they do so at the expense of accuracy. In
    the next section, we’ll extend our model to incorporate more details about the
    message and users to more accurately predict the probable flow of information
    given what we’ve already witnessed about data flow in the network.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经使用蒙特卡洛模拟定义了第一个预测模型！这是一个简化的模型，我们依赖均匀选择来生成随机性，并使用一些基本动作，如发送和传递，来描述网络中某个任意消息可能发生的情况。尝试从不同的用户那里启动消息，看看它如何影响消息的传递步骤数以及最终的位置。我们称之为*简单模型*，因为我们没有包含有关网络历史、消息内容或用户偏好的任何具体信息。我们假设每个节点都有相同的概率将任何消息发送给它能联系到的任何其他节点。虽然像这样的简化假设使代码更容易编写和解释，但它们以牺牲准确性为代价。在下一节中，我们将扩展模型，加入更多关于消息和用户的细节，以更准确地预测我们已经观察到的数据流在网络中的可能流动。
- en: Modeling Topic-Based Influence
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于主题的影响建模
- en: To answer the question “Which nodes are being influenced by other nodes?” we’ll
    extend the investigation of topic-based influence from [Chapter 5](c05.xhtml).
    Recall that we previously weighed each user’s potential interest in a topic by
    measuring their interaction with other messages containing the same topic, using
    the Hyperlink-Induced Topic Search algorithm (HITS). If we reframe our current
    model with respect to a given message topic, like the environment, we can incorporate
    hub and authority information into our state machine model to control the information
    exchange probability. In this case, we’ll use a user’s HITS score to determine
    the probability of a message being reblogged based on the message’s content, instead
    of just blindly assuming all messages have the same probability for all users
    all the time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答“哪些节点受到其他节点的影响？”这个问题，我们将扩展[第5章](c05.xhtml)中基于话题的影响调查。回想一下，我们之前通过测量用户与包含相同话题的其他消息的互动，使用超链接引导话题搜索算法（HITS）来衡量每个用户对某一话题的潜在兴趣。如果我们将当前模型以某个特定消息话题（如环境）为基础进行重新构建，我们可以将中心节点和权威信息融入到我们的状态机模型中，从而控制信息交换的概率。在这种情况下，我们将使用用户的HITS分数来确定消息被转发的概率，这个概率是基于消息内容的，而不是简单地假设所有消息对于所有用户的转发概率都是相同的。
- en: Modeling message propagation in this fashion assumes that a user is more likely
    to reblog a message similar to a message they have reblogged previously. Users
    who have reblogged posts involving a given topic get a higher authority score
    for that topic than those who haven’t, which translates to a higher probability
    of receiving a message about that topic. If you think about the content you see
    on people’s social network feeds, you’ll probably see a fairly common theme among
    the information they share and reshare (this is one of those assumptions you may
    want to challenge later). Some people choose to share business news; others, arts
    and entertainment; and still others, security.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式建模消息传播假设用户更有可能转发他们之前已转发过的类似消息。已经转发过涉及特定话题的帖子用户，比没有转发过的用户拥有更高的该话题权威分数，这意味着他们更有可能收到关于该话题的消息。如果你考虑一下在社交网络上看到的内容，你可能会发现人们分享和重新分享的信息中有一个相当常见的主题（这是你可能想稍后挑战的假设之一）。有些人选择分享商业新闻；有些人分享艺术和娱乐；还有些人分享安全相关的内容。
- en: Let’s update the previous implementation to compare the spread of different
    message types (*qx*) so we can examine the interests of different users and predict
    what messages they’re most likely to reblog in the future. If you were designing
    a viral message attack for this network, it would make sense for you to examine
    different topics and choose the one with the highest probability of propagating
    farthest through the network. From a defensive perspective, you can flip this
    analysis and track a malicious message back to the probable source. We’ll be keeping
    the same definition of influence between users (so a user reblogging a message
    is influenced by that message to some degree), but instead of using the *Send*
    action, our nodes will be selecting messages to reblog. Nothing about the action
    changes, so I’ve opted to keep the name, but renaming it might help to keep the
    direction of influence clear in your model.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新之前的实现，比较不同消息类型（*qx*）的传播方式，这样我们就可以检查不同用户的兴趣，并预测他们未来最有可能转发哪些消息。如果你在为这个网络设计病毒性消息攻击，分析不同的话题并选择传播最远的那个是有意义的。从防御的角度来看，你可以反向分析这条消息，并追踪恶意消息的可能来源。我们将保持用户之间的影响力定义不变（也就是说，用户转发一条消息时，受到了该消息的某种程度影响），但我们的节点将选择要转发的消息，而不是使用*发送*操作。操作的方式没有改变，因此我选择保持名称，但重新命名可能有助于在你的模型中保持影响方向的清晰。
- en: '[Listing 6-3](#listing6-3) shows the code to run a topic-based message-passing
    Monte Carlo simulation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单6-3](#listing6-3)展示了运行基于话题的消息传递蒙特卡洛模拟的代码：'
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-3: A topic-based message-passing Monte Carlo simulation'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-3：基于话题的消息传递蒙特卡洛模拟
- en: 'This code prints a tuple of `(S0, {node: termination_count})`, using the same
    values for `k` and `n` defined in [Listing 6-1](#listing6-1), as well as the `term_subgraph`
    function ❶, which is based on code you’ll see later in [Listing 6-5](#listing6-5).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码打印一个元组`(S0, {node: termination_count})`，使用与[清单6-1](#listing6-1)中定义的相同的`k`和`n`值，以及基于[清单6-5](#listing6-5)中代码的`term_subgraph`函数❶。'
- en: 'In this simulation, *S*[0] ❷ is the node with the highest hub score for the
    selected topic (*S*[0] = *max*(*hub*(*qx*)(*G*))), and *Pr* (Ξ[*(Send)*]) is the
    hub score of *u*(*q*) for the message type *x*: *Pr* (Ξ[*(Send)*]) = *hub*[*(qx)*](*u*).
    The `hub_send` function (defined in the *graph_funcs.py* file, provided in the
    book’s supplementary materials) takes the hub score of `uq` and returns whether
    `uq` passes the message on ❸. The `hub_send` function is based on another function,
    `weighted_choice`, which is also included in the *graph_funcs.py* file. There
    are still only two possible actions in Ξ, so the probability of *Pass* is equal
    to 1 minus the probability of *Send*: *Pr* (Ξ[*(Pass)*]) = 1 – *Pr* (Ξ[*(Send)*]).
    The probability for selecting a given neighbor is the normalized authority score
    for that neighbor, given the message type *qx* (*Pr*(*v*(*qx*)) = *auth*(*qx*)(*v*)).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模拟中，*S*[0] ❷ 是所选主题的最大中心度节点（*S*[0] = *max*(*hub*(*qx*)(*G*)))，而*Pr* (Ξ[*(Send)*])
    是消息类型 *x* 对应的*u*(*q*)的中心度分数：*Pr* (Ξ[*(Send)*]) = *hub*[*(qx)*](*u*)。`hub_send`函数（在*graph_funcs.py*文件中定义，随书附带）接受`uq`的中心度分数并返回`uq`是否转发该消息❸。`hub_send`函数基于另一个函数`weighted_choice`，该函数也包含在*graph_funcs.py*文件中。在Ξ中仍然只有两种可能的动作，因此*Pass*的概率等于
    1 减去*Send*的概率：*Pr* (Ξ[*(Pass)*]) = 1 – *Pr* (Ξ[*(Send)*])。选择给定邻居的概率是该邻居的归一化权威分数，基于消息类型*qx*（*Pr*(*v*(*qx*))
    = *auth*(*qx*)(*v*)）。
- en: If the message is sent, we select the neighbor using the `scored_neighbor_select`
    function (also defined in the *graph_funcs.py* file and based on the `weighted_choice`
    function) ❹. If a neighbor is returned, we add the edge between the sender and
    recipient to the path `Tn` and update the message location ❺; otherwise, we terminate
    the simulation with the `break` statement.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息已发送，我们使用`scored_neighbor_select`函数（同样在*graph_funcs.py*文件中定义，并基于`weighted_choice`函数）选择邻居❹。如果返回了邻居，我们将在路径`Tn`中添加发送者和接收者之间的边，并更新消息的位置❺；否则，我们通过`break`语句终止模拟。
- en: 'If we assume a message ending at a node imparts some influence, we can count
    how many times a message ends at a particular user and claim that the node with
    the highest count is most likely to be influenced by the given message type from
    the given user. This intuitively means that the user would likely end up reblogging
    the message at some point. All roads lead home, so to speak. To find this node,
    we loop over the ending locations and tally the results to build the `{node: termination_count}`
    dictionary ❻, then print the results. This constitutes one run of the Monte Carlo
    simulation.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们假设一条消息在一个节点结束会产生一些影响，我们可以计算消息结束在特定用户处的次数，并认为具有最高计数的节点最有可能受到给定用户发出的消息类型的影响。这直观地意味着该用户可能最终会在某个时刻转发这条消息。可以说，所有的路都通向家。为了找到这个节点，我们遍历结束位置并统计结果，构建`{node:
    termination_count}`字典❻，然后打印结果。这构成了蒙特卡洛模拟的一个运行。'
- en: We want to collect several runs and average the results for the most accurate
    predictions, so we wrap the code in a function definition called `run_sim_2`,
    which will take in the topic list and the Mastodon post data as parameters. (You
    can see the `run_sim_2` function in the 4th cell of the *MonteCarloSimulation.ipynb*
    notebook.) Finally, we return the source node and the dictionary containing the
    users at whom the message terminated, so we can collect the results until we’re
    ready to analyze them. Let’s call this newly defined function in a loop to collect
    a reasonable sample size. [Listing 6-4](#listing6-4) shows how to collect the
    samples and average them for the final output.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望收集多个运行结果并对其进行平均，以获得最准确的预测，因此我们将代码封装在一个名为`run_sim_2`的函数定义中，该函数将接收主题列表和 Mastodon
    帖子数据作为参数。（你可以在*MonteCarloSimulation.ipynb*笔记本的第 4 个单元格中看到`run_sim_2`函数。）最后，我们返回源节点和包含消息终止用户的字典，以便我们可以收集结果，直到准备好进行分析。让我们在循环中调用这个新定义的函数来收集合理的样本大小。[列表
    6-4](#listing6-4)展示了如何收集样本并对其进行平均，以便得到最终输出。
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: Averaging the Monte Carlo simulation results'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-4：平均蒙特卡洛模拟结果
- en: 'Here are the results from averaging 10 runs of the simulation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对模拟 10 次运行结果的平均值：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using these results, we could claim that the user `gutierrezjamie` is most likely
    to influence `hartmanmatthew` on the topic of environment. What’s important here
    isn’t the numbers themselves but the relative sizes of the numbers, so you might
    also conclude that `shannon42` is three times more likely than `grosslinda` to
    end up reblogging the message. Of course, this is just the result of one small
    group of simulations. Ten simulations on a topic as complex as information flow
    and influence is hardly definitive. To strengthen this claim of influence, repeat
    the simulations some large number of times by increasing *k* (using the statistical
    method mentioned earlier) and average those results. In general, the more possible
    outcomes for the simulation, the more times it should be run. There’s a point
    of diminishing returns to this, though. You’ll want to experiment with different
    simulation counts and lengths by updating the values for *k* and *n*, respectively.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些结果，我们可以断言用户`gutierrezjamie`最有可能在环境话题上影响`hartmanmatthew`。这里重要的不是数字本身，而是数字的相对大小，因此你也可能得出结论，`shannon42`比`grosslinda`更可能三倍转发该信息。当然，这只是一次小规模模拟的结果。在像信息流和影响力这样复杂的话题上进行十次模拟显然不足以得出定论。为了增强影响力的论断，通过增加*k*（使用之前提到的统计方法）并对结果进行平均，重复多次模拟。通常，模拟的可能结果越多，应该运行的次数也越多。不过，这里也有收益递减的规律。你需要通过分别更新*k*和*n*的值，来实验不同的模拟次数和时长。
- en: The last part of the code we’re going to examine is the `term_subgraph` function,
    which we called in [Listing 6-3](#listing6-3). The function in [Listing 6-5](#listing6-5)
    takes in a term of interest and searches the underlying data to find all relevant
    posts.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的代码的最后部分是`term_subgraph`函数，它在[列表 6-3](#listing6-3)中被调用。[列表 6-5](#listing6-5)中的函数接受一个感兴趣的术语，并搜索底层数据以找到所有相关帖子。
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-5: Defining the subgraph based on terms'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-5: 基于术语定义子图'
- en: The function takes in the term we’re interested in searching for and the `post_df`
    `DataFrame` object we defined previously. Using the `str.contains` function, we
    filter the data down to only rows whose text column contains the search term.
    We then collect the replies to these posts by searching the `in_reply_to_id` column
    for any relevant post IDs, storing them in a `DataFrame` called `dat_replies`.
    Next, we define the `DiGraph` object that will hold the resulting graph data and
    store it in a variable named `hG`. We loop over the `dat_replies` index list,
    and, for each entry, we look up the row associated with the index. We use the
    row’s `in_reply_to_screen_name` and `user_screen_name` to create an edge in the
    graph, showing the direction of influence on the topic of interest. Once we’ve
    completed the loop, we return the completed subgraph.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受我们感兴趣的搜索词和我们之前定义的`post_df` `DataFrame`对象。使用`str.contains`函数，我们将数据筛选为仅包含搜索词的文本列的行。然后，我们通过搜索`in_reply_to_id`列中的相关帖子ID，收集这些帖子的回复，并将其存储在名为`dat_replies`的`DataFrame`中。接下来，我们定义一个`DiGraph`对象来保存生成的图数据，并将其存储在名为`hG`的变量中。我们遍历`dat_replies`的索引列表，对于每个条目，查找与该索引关联的行。我们使用该行的`in_reply_to_screen_name`和`user_screen_name`来创建图中的边，展示在感兴趣话题上的影响方向。一旦循环完成，我们返回已完成的子图。
- en: Now that we’ve defined all the basic code we’ll need, we can start to improve
    upon our simple model. In the next section, we’ll cover how to make our message
    behave more realistically through resource allocation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有基本代码，我们可以开始改进我们的简单模型。在下一部分，我们将介绍如何通过资源分配使我们的消息行为更加现实。
- en: Modeling Information Flow
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建模信息流
- en: 'So far, our simulation treats the message like a single object moving from
    node to node, like a package being delivered to an address. But what about the
    cases where a message may be transferred to multiple users simultaneously? Our
    model is fine for single copies of messages, but it’d be nice if we could find
    a way to model the information more intuitively as flowing through the network
    instead. Think about it like this: you don’t send one birthday party invitation
    and ask each invitee to pass the message on to the next person on the list; you
    send multiple invitations to the people you want to attend. Each invitee may then
    invite another person to go to the party with them, so the message spreads even
    further along the network simultaneously. To model this type of information flow,
    we need to improve our state machine to treat the message as if multiple copies
    exist.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的模拟将消息视作一个从节点到节点移动的单一对象，就像一个包裹被送到一个地址一样。但如果消息可以同时传递给多个用户呢？我们的模型对于单个副本的消息是适用的，但如果我们能够找到一种方法，更直观地将信息流动通过网络建模就更好了。想想看：你不会只发送一个生日派对邀请函并要求每个被邀请者把消息传递给列表上的下一个人；你会将多个邀请函发送给你希望出席的人。每个被邀请者可能会邀请另一个人一同前往派对，这样消息就会同时沿着网络进一步传播。为了建模这种类型的信息流动，我们需要改进我们的状态机，使其处理多个副本的消息。
- en: To simulate the case where more than one copy of *q* can exist, we can reformulate
    message passing as a question of resource flow within the network. By doing so,
    we can figure out how much information two people have communicated in the past
    and use that as an indicator of how much they may communicate in the future. *Resource
    allocation (RA)* is a model that was first posed to describe the nonlinear correlation
    between airport connectivity and travel capacity.^([7](b01.xhtml#c06-endnote-007))
    We’ll be using the same principle as a way to quantify the quality of information
    exchange as the message spreads through the network.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟多个 *q* 副本可以存在的情况，我们可以将消息传递重新表述为网络中资源流动的问题。通过这样做，我们可以弄清楚两个人在过去交流了多少信息，并用这个作为他们未来可能交流的一个指标。*资源分配
    (RA)* 是一个最初提出用来描述机场连接性与旅行能力之间非线性关系的模型。^([7](b01.xhtml#c06-endnote-007)) 我们将使用相同的原理来量化信息交换的质量，随着消息在网络中的传播。
- en: 'Generally speaking, RA describes the potential flow of resources between two
    nodes (*u*, *v*) where *v* is not a neighbor of *u*, but they’re connected by
    a directed path (*v* ∉ *Γ*[(][*u*][)] ∧ ρ(*u*→*v*) ∈ *E*). Supposing a node *u*
    in a directed graph has one unit of resources to distribute evenly among all its
    direct neighbors, the resources allocated to any member of the network is the
    sum of the resources at the end of each path between *u* and *v*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，RA 描述了两个节点 (*u*, *v*) 之间潜在的资源流动，其中 *v* 不是 *u* 的邻居，但它们通过一个有向路径相连 (*v* ∉
    *Γ*[(][*u*][)] ∧ ρ(*u*→*v*) ∈ *E*)。假设有一个有向图中的节点 *u* 拥有一个单位的资源，并将这些资源均匀分配给所有的直接邻居，那么分配给网络中任何成员的资源就是
    *u* 和 *v* 之间每条路径末端资源的总和：
- en: '![](image_fi/502567c06/m06010.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06010.png)'
- en: You can think of this value as the importance of node *v* in the case of distribution
    for node *u*. If |ρ(*u*, *v*)| > 2, this process is repeated for all nodes between,
    until some amount of resource reaches *v*. Therefore, you might instead wish to
    think of this value as the amount of resources *u* provides to *v* through the
    distribution network.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个值看作是在节点 *u* 的分配情况下，节点 *v* 的重要性。如果 |ρ(*u*, *v*)| > 2，那么这个过程会对所有节点进行重复，直到有一定数量的资源到达
    *v*。因此，你可以将这个值看作是 *u* 通过分配网络提供给 *v* 的资源量。
- en: As a concrete example, suppose you’re investigating a criminal organization
    that sells counterfeit goods it purchases from a forger. The boss of this hypothetical
    organization buys 100 boxes of knock-off handbags (the initial amount of resources
    at *S*[0]). He then distributes the merchandise to his top 4 lieutenants by dividing
    the 100 boxes into 25 boxes for each. Finally, each lieutenant divides their 25
    boxes among their street corner shops. If each lieutenant has connections to 5
    storefronts, each store would get 5 boxes. If the crime boss were to lose one
    of these stores, the loss would account for only 5 percent of his inventory. This
    is a very simplistic model that assumes each node and path can evenly carry the
    resource in question. However, that’s not always the case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，假设你正在调查一个犯罪组织，该组织销售从伪造者那里购买的假冒商品。这个假设中的组织老板购买了100箱仿冒手袋（即*S*[0]的初始资源量）。然后，他将这些商品分配给他的四个高级手下，每人分得25箱。最后，每个手下将他们的25箱商品分配给他们街角的商店。如果每个手下与5个店面有联系，那么每个店面将收到5箱商品。如果犯罪老板失去其中一个店面，损失将仅占他库存的5%。这是一个非常简化的模型，假设每个节点和路径可以均匀地传递相关资源。然而，实际情况并不总是如此。
- en: Formally, the ![m06011](image_fi/502567c06/m06011.png) portion of the previous
    formula is known as the *flow function*, which models a specific type of behavior
    for passing or receiving resources. Using this flow function, the resource gets
    divided evenly among all the neighbors of the node *u*, the same as the boxes
    of counterfeit goods. There are a few different flow functions built into NetworkX.
    Unfortunately, they’re not implemented for directed graphs as defined here. As
    you shift from research to applications, you’ll often be responsible for extending
    your code libraries with missing definitions like this. The *graph_funcs.py* file
    includes the code for directed resource allocation, so you can use it to experiment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式上讲，前面公式中的![m06011](image_fi/502567c06/m06011.png)部分被称为*流函数*，它模拟了传递或接收资源的特定行为类型。使用这个流函数，资源会均匀地分配给节点*u*的所有邻居，就像假冒商品的箱子一样。NetworkX内置了几种不同的流函数。遗憾的是，它们并没有为这里定义的有向图实现。当你从研究转向应用时，你通常需要负责扩展代码库，填补像这样的缺失定义。*graph_funcs.py*文件包含了有向资源分配的代码，所以你可以使用它来进行实验。
- en: By combining the historical analysis of the HITS algorithm with the simultaneous
    flow of resource allocation, we can create a respectable model, capable of simulating
    user behavior based on previous observations. You should be able to build on this
    framework of state machines and Monte Carlo simulation to model all sorts of interesting
    phenomena, not just in social networks but throughout the topic of information
    security as a whole.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将HITS算法的历史分析与资源分配的同步流结合起来，我们可以创建一个有价值的模型，能够基于之前的观察模拟用户行为。你应该能够在这个状态机和蒙特卡洛仿真框架上进行扩展，模拟各种有趣的现象，不仅仅是在社交网络中，而是涵盖整个信息安全主题。
- en: In the next section, we’ll move on to a proof-of-concept application that will
    take us deeper into applied game theory and Monte Carlo simulation by simulating
    an adversarial face-off on our social network platform. Let’s get ready to rumble!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进入一个概念验证应用，它将带我们更深入地了解应用博弈论和蒙特卡洛仿真，通过模拟在我们的社交网络平台上的对抗性对决。准备好迎接挑战吧！
- en: 'The Proof of Concept: Disrupting the Flow of Information'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念验证：干扰信息流
- en: ''
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final question for this chapter—“What links could be severed to disrupt
    the flow of information between two nodes?”—is a very interesting security topic.
    There are many scenarios in which disrupting the flow of information to a particular
    subset of nodes could be catastrophic. Imagine a hospital tied to a single source
    of electricity. To disconnect any outlet in the hospital from electricity, you’d
    only need to sever the single link between the hospital and its power source.
    This is a *single point of failure*, and to avoid it hospitals deploy multipoint
    connections to the power grid and install backup generators for more severe disruptions.
    Many home networks suffer from this design flaw as well. To sever all the connected
    devices behind the router, you simply need to sever the connection forward of
    the router. In social networks, like businesses, failure points like these occur
    regularly. Companies often have people known as “linchpin employees”^([8](b01.xhtml#c06-endnote-008))
    who fill roles no other employees can, or possess arcane knowledge the company
    needs to operate. Linchpin employees inspired the proof of concept for this chapter:
    Monte Carlo simulations to model the potential to disrupt information flow within
    an evolving social network.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终问题——“可以切断哪些连接以破坏两个节点之间的信息流？”——是一个非常有趣的安全话题。有许多场景，其中破坏信息流向特定节点子集的流动可能会带来灾难性的后果。想象一下，一个医院依赖单一的电力来源。要切断医院的任何电源插座，你只需切断医院与电源之间的唯一连接。这是一个*单点故障*，为了避免这种情况，医院会部署多点连接到电网，并安装备用发电机以应对更严重的中断。许多家庭网络也存在这种设计缺陷。要切断路由器后面所有连接的设备，只需要切断路由器前端的连接。在社交网络中，就像在企业中一样，类似的故障点经常发生。公司常常有被称为“关键员工”^([8](b01.xhtml#c06-endnote-008))的人，他们承担着其他员工无法胜任的角色，或拥有公司运营所需的深奥知识。关键员工启发了本章概念验证的证明：通过蒙特卡洛模拟来建模在一个发展中的社交网络中破坏信息流动的潜力。
- en: For the rest of this chapter, we’ll be building a simulation where our social
    network is under attack from a nefarious outsider. We’ll use some of the same
    analysis techniques that gave birth to the modern internet to see how difficult
    it would be to disrupt our social network. Sometimes it’s fun to be the bad guy!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余部分，我们将构建一个模拟，假设我们的社交网络正受到一个邪恶外部敌人的攻击。我们将使用一些现代互联网诞生时所用的分析技术，看看破坏我们的社交网络会有多困难。有时候，扮演坏人也挺有趣的！
- en: Modeling an Evolving Network
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建模一个演化中的网络
- en: 'In a static network, you could find the set of edges that, when removed, would
    separate two nodes (you’ll see a method for producing this list in a moment),
    but that doesn’t account for network adaptations, like cross-training another
    employee in the linchpin employee’s arcane knowledge to alleviate a single point
    of failure. To model an evolving network, we’ll mimic a two-player, turn-based
    game scenario, wherein one player tries to get a message through from a starting
    user to an end user as their adversary tries to stop the message from reaching
    the end. To make the game more complex, the network itself evolves on each turn
    as users reblog messages from other users or disconnect from people who were previous
    connections. Player 1 acts on the part of the network and all its users, while
    player 2 acts as the adversarial force. Player 1’s goal is to send a message *u*
    from a source node (*u*A) to a sink node (*v*[Ω]). Player 2 seeks to keep this
    message from reaching the sink node by selectively removing paths from the network.
    The game play is broken up into three phases: network adaptations, message movement,
    and finally adversarial movement (in that order).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态网络中，你可以找到一组边，当这些边被移除时，会将两个节点分开（你稍后将看到一种生成该列表的方法），但这并未考虑到网络的适应性，例如将另一名员工进行跨职能培训，让他掌握关键员工的深奥知识，从而缓解单点故障。为了模拟一个演化中的网络，我们将模拟一个两人轮流制的游戏场景，其中一名玩家试图将信息从起始用户传递到终端用户，而其对手则试图阻止该信息到达终端。为了使游戏更复杂，网络本身会在每一轮变化，因为用户会转发其他用户的信息或断开与曾经连接的人的联系。玩家1在网络及其所有用户中行动，而玩家2则充当对抗力量。玩家1的目标是将信息*u*从源节点(*u*A)发送到汇节点(*v*[Ω])。玩家2的目标是通过选择性地移除网络中的路径，阻止该信息到达汇节点。游戏分为三个阶段：网络适应、信息移动，最后是对抗性移动（按此顺序）。
- en: 'The game is over if *q* reaches *v*[Ω], or when no path exists to complete
    the transmission:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*q*到达*v*[Ω]，或者当没有路径可以完成传输时，游戏结束：
- en: '![](image_fi/502567c06/m06012.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06012.png)'
- en: This equation can be translated into the convenient helper function in [Listing
    6-6](#listing6-6).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程可以转化为方便的辅助函数，见[示例 6-6](#listing6-6)。
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-6: Checking for terminal conditions'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-6：检查终止条件
- en: This function takes in the graph object, the ID of the node currently holding
    the message, and the ID of the goal node. If these two nodes aren’t the same and
    there’s a path between them ❶, the game isn’t over, so the code returns `None`
    (as in no winner). If the two nodes aren’t equal and there’s no path between the
    current node and the goal node ❸, player 2 has succeeded in isolating the message,
    and the function returns `-1`. If the two IDs match ❷, the message has reached
    the goal node, so the function returns `1`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受图对象、当前持有消息的节点ID和目标节点的ID。如果这两个节点不同且它们之间有路径 ❶，游戏没有结束，因此代码返回`None`（即没有赢家）。如果两个节点不相同且当前节点与目标节点之间没有路径
    ❸，则玩家2已成功隔离消息，函数返回`-1`。如果这两个ID匹配 ❷，则消息已到达目标节点，函数返回`1`。
- en: Moving the Message Through the Network
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过网络传递消息
- en: The second helper function, `weighted_choice`, shown in [Listing 6-7](#listing6-7),
    will be used for weighted random selection of the next node to a receive the message.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个辅助函数`weighted_choice`，如[示例 6-7](#listing6-7)所示，将用于加权随机选择下一个接收消息的节点。
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-7: Weighted random selection function for biased walks'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-7：用于偏向行走的加权随机选择函数
- en: 'The input parameter `scores` is a dictionary of `{item: weight}`, giving each
    item that may be selected and its weight. (The weights do not need to sum to 1;
    only the relative size of the values matters.) The `totals` list partitions the
    real number space between 0 and the sum of the weights (![m06013](image_fi/502567c06/m06013.png))
    into bins proportional in size to the weight of the item they represent, by adding
    each item to a `running_total`, then recording the running total after each item
    is added ❶. The sum of all the weights then scales a random value ❷ to fall into
    one of the bins, and the bin determines which item is selected ❸. Items with larger
    weights map to larger bins, meaning the items are more likely to be selected,
    hence “weighted random selection.”'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '输入参数`scores`是一个字典，格式为`{item: weight}`，为每个可能被选择的项目分配一个权重。 （权重不需要加总为1；只有值的相对大小才重要。）`totals`列表将实数空间在0和权重总和之间分割
    (![m06013](image_fi/502567c06/m06013.png))，其分割的大小与所代表项目的权重成正比，通过将每个项目加到`running_total`中，并在每个项目添加后记录运行总和
    ❶。所有权重的总和然后会缩放一个随机值 ❷，使其落入某个分区，而该分区决定了选择哪个项目 ❸。权重较大的项目映射到较大的分区，这意味着这些项目更有可能被选择，因此这就是“加权随机选择”。'
- en: 'As a concrete example, take an input dictionary `{"A":1,"B":2,"C":3}`. After
    the first loop executes, the `totals` list contains `[1,3,6]` and the `running_total`
    is `6`. The random real value `rnd` (between 0 and 1) is selected using the `random`
    function, then multiplied by `running_total` ❷ to produce the percentage of the
    weight randomly selected. The random value `1.0` means the maximum weight, in
    this case:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个具体例子为例，输入字典为`{"A":1,"B":2,"C":3}`。在第一次循环执行后，`totals`列表包含`[1,3,6]`，而`running_total`为`6`。随机实数值`rnd`（介于0和1之间）通过`random`函数选择，然后乘以`running_total`
    ❷以产生随机选择的权重百分比。随机值`1.0`表示最大权重，在此情况下为：
- en: '![](image_fi/502567c06/m06014.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c06/m06014.png)'
- en: We can verify that the break points accurately reflect our input weights by
    calculating the amount of space on the number line assigned to the key, called
    its *key space*. These should equate to 1 / 6 = 0.166, 2 / 6 = 0.333, and 3 /
    6 = 0.5 for keys `A`, `B`, and `C`, respectively. We find the key space by subtracting
    the key’s lower selection boundary from its upper selection boundary. To select
    key `A`, `rnd` must be lower than or equal to approximately 0.166 (0.166 × 6 =
    0.996). To select key `B`, `rnd` needs to be between 0.166 and 0.5 (0.5 × 6 =
    3), which means the key space for `B` is (0.5 – 0.166 = 0.333). We can divide
    `B`’s key space by `A`’s to get a relative size comparison (0.333 / 0.166 = 2.006),
    which means the key space for `B` is twice the size of the one for `A`, just as
    we requested. Finally, `rnd` needs to be greater than 0.5 and less than or equal
    to 1.0 for key `C` to be selected. The key space for `C` is (1 – 0.5 = 0.5). You
    can continue the key space logic to prove that the space provided to `C` is three
    times the space provided for `A` (0.5 / 0.166 = 3.0) and one and a half times
    larger than the key space for `B` (0.5 / 0.333 = 1.5). I hope this helps to illustrate
    how the values in our input dictionary control the size of the key space created
    during the random selection process. We’ll be relying heavily on the `weighted_choice`
    function during our proof, so it’s worth taking the time to understand it in detail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过计算分配给键的数轴空间来验证断点是否准确反映我们的输入权重，这个空间称为其*key space*。这些应等于 1 / 6 = 0.166，2
    / 6 = 0.333 和 3 / 6 = 0.5，分别对应于键 `A`、`B` 和 `C`。我们通过将键的下选择边界减去其上选择边界来找到键空间。为了选择键
    `A`，`rnd` 必须小于或等于大约 0.166（0.166 × 6 = 0.996）。为了选择键 `B`，`rnd` 需要介于 0.166 和 0.5
    之间（0.5 × 6 = 3），这意味着键 `B` 的键空间为 (0.5 – 0.166 = 0.333)。我们可以将 `B` 的键空间除以 `A` 的键空间，以获得相对大小比较（0.333
    / 0.166 = 2.006），这意味着键 `B` 的键空间是键 `A` 的两倍，正如我们要求的那样。最后，`rnd` 必须大于 0.5 且小于或等于 1.0
    才能选择键 `C`。键 `C` 的键空间为 (1 – 0.5 = 0.5)。你可以继续这个键空间的逻辑，证明分配给 `C` 的空间是分配给 `A` 的三倍（0.5
    / 0.166 = 3.0），并且是分配给 `B` 的键空间的 1.5 倍（0.5 / 0.333 = 1.5）。希望这有助于说明我们的输入字典中的值如何控制在随机选择过程中创建的键空间的大小。我们将在证明过程中大量依赖
    `weighted_choice` 函数，因此花时间详细理解它是值得的。
- en: Measuring the Amount of Information Flow
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量信息流量
- en: Some connections between nodes in a network may be capable of carrying more
    information than others. In a social network, for example, some members may be
    more effective at spreading information, like a linchpin employee at a company.
    The amount of information flow between two nodes in a social network isn’t straightforward
    to measure, and depends on your research question. For the purposes of our simulation
    game, the edge capacity is the number of characters in a given post (maximum 500,
    at the time of writing).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中某些节点之间的连接可能能够承载比其他连接更多的信息。例如，在社交网络中，某些成员可能更有效地传播信息，就像公司中的关键员工一样。在社交网络中，两个节点之间的信息流量并不是简单地可以测量的，它取决于你的研究问题。在我们的模拟游戏中，边的容量是指给定帖子中的字符数（最大500个字符，在写作时为止）。
- en: By adding an attribute named *capacity*, which represents the maximum amount
    of information that can be transmitted along the particular edge in one unit of
    time, to the edges in *E*, we can compare the effect of removing different subsets
    of edges on the overall flow and capacitance of the network using the *max-flow,
    min-cut theorem*.^([9](b01.xhtml#c06-endnote-009)) We’ll take a deeper look at
    this theorem when we improve player 2, but for the moment just know that it allows
    us to model a resource that gets spread out across a network, rather than moving
    from point to point as we’ve seen previously.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向*E*中的边添加一个名为*capacity*的属性，该属性表示在单位时间内通过特定边传输的最大信息量，我们可以使用*最大流，最小割定理*来比较删除不同子集边对网络整体流量和电容的影响。^([9](b01.xhtml#c06-endnote-009))
    我们将在改进玩家2时深入了解这个定理，但目前只需知道，它使我们能够模拟一个资源在网络中扩散的过程，而不是像之前看到的那样从一个点移动到另一个点。
- en: Now is a good time to step back and remember why this matters to us. Our ultimate
    goal is to test how difficult it would be for an adversary to significantly disrupt
    the communication of the network. The max-flow, min-cut theorem gives us the information
    needed to test if two nodes can still communicate (because there’s still a path
    between the two nodes). It also helps us determine what cuts are more or less
    advantageous for the adversary, as well as giving them a way to quickly judge
    their options. An attacker who knows the max-flow, min-cut theory will likely
    have a much higher chance at sabotaging the network than one who attacks random
    communication channels. We’ll examine this hypothesis by implementing two versions
    of the adversary in the following game and comparing the damage they can achieve.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候退后一步，记住这一切对我们来说的重要性了。我们的最终目标是测试敌人破坏网络通信的难易程度。最大流、最小割定理为我们提供了测试两个节点是否仍能通信所需的信息（因为两个节点之间仍然有一条路径）。它还帮助我们确定哪些割对敌人来说更有利或不利，同时为敌人提供了一种快速判断其选项的方法。了解最大流、最小割理论的攻击者，可能比攻击随机通信通道的攻击者更有可能破坏网络。我们将在接下来的游戏中通过实现两个版本的敌人来检验这一假设，并比较他们能造成的破坏。
- en: How the Game Works
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏如何运作
- en: The game is actually very simple. The objective for player 1, the white hat,
    is to get a message from a node on one side of the network to a node on the other
    side. To achieve this they have the entire network at their disposal. On each
    turn, they will move the message around the network trying to reach the sink node.
    They win if the message successfully traverses the network from the source node
    to the sink node. On the other side of the virtual table is player 2, the black
    hat. Their job is stop that message, at any cost. On each turn, they’ll select
    an edge to remove from the network. Player 2 wins if they successfully disconnect
    the network so that there’s no way the message can reach the sink node.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏其实非常简单。玩家1（白帽）的目标是将消息从网络一侧的节点传送到网络另一侧的节点。为此，他们可以使用整个网络。在每回合中，他们会在网络中移动消息，试图到达接收节点。如果消息成功从源节点传输到接收节点，他们就赢了。虚拟桌子另一边是玩家2（黑帽）。他们的任务是以任何代价阻止这个消息。在每回合中，他们将选择从网络中删除一条边。玩家2赢得胜利的条件是他们成功地切断网络，使得消息无法到达接收节点。
- en: Evolving the Network
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络演变
- en: 'Social networks rarely have a static topography: the links and membership are
    changing even as you try to measure them. The network adaptation phase models
    the evolving topography by allowing edges to be created or removed probabilistically.
    This means that new routes may open up suddenly and old paths may disappear on
    their own. Neither player can fully trust the network to do what they expect it
    to. I chose to implement this as part of player 1’s turn since they’re the network
    administrator in this scenario. On each turn, player 1 chooses an input action
    from the input alphabet for every node that’s not holding the message (∀*u*^((¬)^(*q*)^)
    ∈*V wrs*(Ξ), where *wrs*(Ξ) is the weighted random selection function defined
    previously). [Listing 6-8](#listing6-8) shows the weighted input alphabet, which
    includes the creation and dissolution of edges with `connect` and `disconnect`,
    or the option to `pass` as before.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络很少有静态的拓扑结构：即使在你尝试测量它们时，链接和成员身份也在不断变化。网络适应阶段通过允许边的创建或删除来模拟拓扑的演变。这意味着新的路径可能会突然打开，旧的路径可能会自行消失。双方玩家都无法完全信任网络按预期运作。我选择将这一部分作为玩家1的回合来实现，因为在这种情况下他们是网络管理员。在每回合中，玩家1会从输入字母表中选择一个输入动作，针对每个没有持有消息的节点（∀*u*^((¬)^(*q*)^)
    ∈*V wrs*(Ξ)，其中 *wrs*(Ξ) 是前面定义的加权随机选择函数）。[Listing 6-8](#listing6-8) 显示了加权输入字母表，包括使用
    `connect` 和 `disconnect` 来创建和解除边，或者像之前一样选择 `pass`。
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-8: Weighted inputs for nodes without the message'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-8：没有消息的节点的加权输入
- en: The weights in `XI` describe the tendency of the network over time. These values
    create a scenario where the network is likely to grow over time since `connect`
    and `pass` both have an individual weight of 40 percent (2 / 5 = 0.4), a combined
    80 percent of the selection space, while `disconnect` has only 20 percent. If
    `connect` is chosen, the node forms a new edge with (meaning it receives a reply
    from) another node in the graph, which means we need a way to select the user
    they connect to. I’ve chosen to implement this based on *preferential attachment*,
    the idea that users with many connections are more likely to form new connections
    than those with fewer connections. In our network, this means that nodes that
    receive replies from many other users (large out-degrees) are more likely to receive
    a reply from users who reply to many users (high in-degrees). (Even if the current
    node doesn’t tend to receive many replies, it’s still more likely to get a reply
    from a more active user.)^([10](b01.xhtml#c06-endnote-010))
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Formally, the *undirected preferential attachment (UPA)* score for two nodes
    (*u*, *v*) is the product of the length of their neighbors:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: UPA( u, v ) = |Γ( u )| × |Γ( v )|
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'To account for the directionality of our network graph, we can define *directed
    preferential attachment (DPA)* using outgoing neighbors of *u* and incoming neighbors
    of *v*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: DPA( u → v ) = |Γ( u → )| × |Γ( v ←)|
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-9](#listing6-9) shows the weighted random connection function, which
    will be called from the player 1 logic shown in [Listing 6-12](#listing6-12).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-9: A directed preferential attachment weighted random selection'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `wrs_connect` takes the graph and the connecting node as input
    and loops over each ID in the graph ❶ to calculate the DPA score ❷ between the
    input node and each other node (skipping the input node with `continue`). The
    `weighted_choice` function uses the `scores` dictionary to pick a node to connect
    to ❸:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: vconn = wrs( [ DPA( u( ¬ q ), ¬ u )] ∀ ¬ u ∈ V )
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: If `disconnect` is chosen, the user disassociates from another user who sends
    them the least information (as measured by the definition of capacity given previously).
    The `capacity` attribute of each edge in `G.in_edges` is used in the weighted
    random selection process to choose a neighbor to disassociate from. [Listing 6-10](#listing6-10)
    shows the code to calculate the capacity and selection weight for a given node.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-10: Capacity weighting for a node'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by looping over the neighbor data from the set of inbound edges for
    the node ❶ and collecting these into the `n_capacity` dictionary. If we hadn’t
    condensed the multiple edges previously (by using a `DiGraph` instead of a `MultiDiGraph`),
    we’d need to sum up the capacity of each in-edge incident to the node first:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c06/m06015.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: We weight edges with lower *N*[*capacity*] entries more heavily in the selection
    process, then invert the capacities by subtracting them from a modifier *Q* =
    1 + *max*(*N*[*capacity*] ) ❷, which results in the weighting formula ![m06016](image_fi/502567c06/m06016.png)
    ❸.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: For example, if *max*(*N*[*capacity*]) = 10 ⇔ *Q* = 11, an edge with ![m06017](image_fi/502567c06/m06017.png)
    will get a weight of `1` (![m06018](image_fi/502567c06/m06018.png)), while an
    edge with ![m06019](image_fi/502567c06/m06019.png) will get a weight of `10` (![m06020](image_fi/502567c06/m06020.png)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: We’ll set the return value for a given node to the tuple (*N*[*capacity*] ,
    *N*[*weight*] ). Both `n_capacity` and `n_weight` are dictionaries keyed off of
    the neighboring node’s ID. The `wrs_disconnect` function in [Listing 6-11](#listing6-11)
    uses the `n_weight` dictionary to select the least informative neighbor to disconnect
    `u` from.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-11: A weighted random disconnection function'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: If there are no inbound edges for the node `u` (meaning it has no in-degree
    neighbors to disconnect from) the function returns `None` ❶, resulting in the
    same outcome as `pass`. If more than one edge is found, the capacity scores for
    all the inbound neighbors are calculated using the function from [Listing 6-10](#listing6-10)
    ❷. The key returned from this function is the neighbor to disassociate from (*v*[*disconn*]
    = *wrs*(*N*[*weight*] )) ❸. The edge (*u*^((¬)^(*q*)^) ← *v*[*disconn*] ) is then
    removed from the graph in the player 1 logic in [Listing 6-12](#listing6-12).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Moving the Message
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the network evolution phase, the game moves into the message movement
    phase, where the only possible input is `send`. If an edge exists between the
    node currently holding the message, *u*(*q*), and the goal node, *v*[Ω], the message
    passes along that edge and player 1 wins the game. Otherwise, the paths between
    *u*(*q*) and *v*[Ω] are calculated, and the message is passed to the next node
    along one of these paths, selected uniformly at random.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 6-12](#listing6-12) handles player 1’s turn, which includes
    both the network adaptations and message movement phases. The function `player_one_turn`
    takes the graph, the node holding the message, and the goal node as parameters
    and returns the node that receives the message and the new state of the graph.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 6-12: The logic defining player 1’s turn'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: If an edge exists between `uq` and the goal node `omega` ❶, we pass the message
    to `omega`. This will end the turn (and game) with a victory for player 1! Otherwise,
    we calculate the average capacity of the graph ❷, which will be used as the capacity
    of any new edges added during network adaptation. This allows the average to change
    from turn to turn, depending on which edges (if any) were removed during the previous
    network adaptation phase.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: To perform network adaption and message passing, we loop over each node in the
    graph ❸. For *u*(*q*), we attempt to find valid paths between it and the goal
    node ❹ (the message movement phase). If this attempt fails with an `nx.exception.NetworkXNoPath`,
    the function returns and the round ends with a victory for player 2, since the
    message can’t reach the destination. Otherwise, we randomly select a path using
    the `choice` function ❺ and pass the message to the first node in this path.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: For all other nodes, we select an action using the weighted random function
    and the `XI` dictionary defined in [Listing 6-8](#listing6-8) ❻. If `pass` is
    chosen, the code jumps to the next node using the `continue` keyword ❼. If `connect`
    is returned, we use the `wrs_connect` function shown in [Listing 6-9](#listing6-9)
    to form a new edge ❽. Otherwise, `disconnect` was chosen, so we use the `wrs_disconnect`
    function from [Listing 6-11](#listing6-11) to remove an edge from the graph ❾.
    Finally, we return the receiving node and the updated graph ❿.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Disrupting the Network
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Player 2 then gets to select an edge to remove from the network to try to disrupt
    the flow of the message. One of the strengths of Monte Carlo simulation is in
    its ability to compare different strategies over time. To illustrate this, let’s
    compare two strategies for player 2 to achieve their goal. In the first strategy
    ([Listing 6-13](#listing6-13)), player 2 selects an edge from *E* uniformly at
    random:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-13: The player 2 random implementation'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: This will act as a good baseline, since it most closely resembles a truly random
    walk. The code randomly selects ❶ and then removes ❷ an edge from the graph; we
    then return the updated graph ❸.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The results of such a strategy can be seen as a null control, as if an adversary
    just blindly started removing things with no real concept of what they were impacting.
    We’ll look at the second strategy, where player 2 selects their moves to inflict
    the most damage using the flow information of the network, after we demonstrate
    the simulation using this simple strategy and gather our baseline network performance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Once player 2 has finished selecting the edge to disrupt, the round is complete.
    If neither player has won, the next round starts and gameplay continues in this
    fashion until one of the players succeeds in reaching their objective.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover how to select the start and end nodes. In much
    larger networks (like the ones you’re likely to see in the wild), having methods
    for automating tasks like finding data will save you a lot of manual exploration
    before running your first simulation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The Game Objective
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we tie this all together into a functional simulation, let’s look at
    the `shortest_path_scores` helper function, shown in [Listing 6-14](#listing6-14),
    which returns a list of average path lengths for all pairs of nodes that are not
    directly connected.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-14: Creating an average-length score for weighted selection'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop ❶ calls the NetworkX function `nx.non_edges` to get a list of
    all possible node combinations not directly connected by an edge, checks that
    the two nodes *u* and *v* are different, and checks that one or more paths exist
    between the nodes. If any condition fails, we skip that pair of nodes with the
    `continue` keyword. Otherwise, we use the `nx.all_shortest_paths` function to
    make a list of all potential paths between the source and sink nodes at the start
    of the game ❷, then calculate the average path length ❸ and append it to the `pairs`
    list. Once all the pairs have been processed, we sort the results in descending
    order, based on the average path length first, then the ID of the node *u*, and
    finally the ID of the node *v* ❹.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 6-15](#listing6-15) we’ll combine these scores with the `weighted_choice`
    function to randomly select the source and sink pair while favoring pairs that
    have more, or longer, paths than those with fewer, shorter ones. I chose this
    method so the simulation has enough routes to make it interesting. You may choose
    the source and sink nodes based on other parameters in your simulation. You might
    even extend your simulation to test all possible combinations of source and sink
    node.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The Game Simulation
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, it’s time to tie all these functions together into a single cohesive
    game with the code in [Listing 6-15](#listing6-15). We’ll run the game simulation
    25 times, each with a different pair of source and sink nodes. Each run will generate
    *k* random walks, representing one game between player 1 and player 2 per walk,
    and tally the number of wins for each player. The average of the *k* scores is
    the score for the run overall. Using different source and sink nodes, instead
    of running the same scenario over and over, will give us a better sense of the
    network as a whole. The code in [Listing 6-15](#listing6-15) assumes you’ve already
    built the graph (using code similar to [Listing 6-3](#listing6-3)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 6-15: The main game simulation function'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Before running the group of simulations, we get the list of average path lengths
    between nodes with `shortest_path_scores` ([Listing 6-14](#listing6-14)) ❶, convert
    the average path lengths returned into a list of `path_weights` (meaning nodes
    with longer average shorter path lengths get weighted higher), and select a pair
    of nodes (which is the key returned from `path_weights`) ❷. If that pair of nodes
    and associated paths have already been used in a simulation (tracked by the `played`
    list), we select another. From the selected pair and path, we set the source and
    sink nodes, `alpha` and `omega`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve found a valid source and sink pair, we perform the *k* random walks.
    Each iteration of the `for` loop ❸ constitutes one complete game, played on a
    copy of the graph (`newG`) to maintain the original topology between matches.
    Each *n*-step random walk ❹ generates up to *n* turns for both players 68 and
    checks the win condition at each phase 57. The result of each game is appended
    to `game_res`. Each iteration of this loop counts as one complete turn cycle within
    a game.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Once the *k* walks are complete, we tally the wins (1 point for a win by player
    1 and –1 point for a win by player 2) ❾ by summing `game_res`, then take the average
    `tally` as the overall score for the *k* walks.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code in [Listing 6-15](#listing6-15) to see the result of 25 simulations.
    The averages produced by each test (the outermost `for` loop) may vary wildly,
    as you can see from this snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A score of `0.0` means both players won the same number of matches. Positive
    averages indicate player 1 won more often than player 2\. The closer to `+1` this
    gets, the more heavily the matches favored player 1\. The opposite is true as
    the score moves below 0\. An average score of `-1` indicates player 2 won every
    match.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to summarize the result from all the tests. We can do so by
    summing the individual averages and then dividing by the number of tests. We’ll
    call this the *population mean*. The benefit of the population mean is twofold.
    First, it summarizes all the tests into a single number you can interpret, rather
    than a list of test results. Second, the population mean should be relatively
    stable compared to the values observed between individual run results. If we rerun
    the code, we’ll get different individual test results. The population mean should
    be relatively stable, though.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing the model three times, I got the population averages 0.2160,
    0.2320, and 0.1808\. Of course in statistics we deal with uncertainty, so a better
    measure of the population mean is the numeric range we believe the actual population
    mean will fall between, given some desired level of confidence. To do this, we
    use the `scipy.stats.t.interval` function and pass in the results from our simulations
    and our desired confidence interval (called the *alpha parameter*) as a float.
    The result is a tuple containing the lower and upper bounds within which we can
    predict the true population mean will fall. For example, I ran the simulation
    6,250 times and I can say with 95 percent confidence the true population mean
    for the simulation (as it’s currently configured) will be between 0.1078 and 0.2225,
    which means there is a slight advantage to player 1\. The current design seems
    to slightly favor the defender because of its growth and the lack of intelligence
    from the adversary.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve established a baseline performance for our network, let’s see
    if we can improve the adversary’s chances by letting them observe the network
    and pick which routes to sever. We can then compare the results of the two simulations
    (in terms of predicted population means) and see if our changes significantly
    impact player 2’s chance at disrupting the network.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Improvements to Player 2
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s see what happens if we give player 2 a little more intelligence. In this
    version, player 2 uses the updated graph and current message position to remove
    an edge that’s important to the path between the message position and the goal
    (a relatively intuitive strategy for human players).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: To codify this strategy, player 2 will use the max-flow, min-cut theorem. A
    max-flow, min-cut analysis was one of the driving forces behind the creation of
    the modern TCP/IP internet. The protocol breaks messages into little chunks called
    *packets* and then chooses different routes for different parts of the transmission
    based on response times and carrying capacity. The basic idea of the design is
    that someone would have to take out a large percentage of the network before they
    could disconnect two distant nodes from each other. The list of nodes that would
    need to be removed is known as the *cutset*. The adversary in our simulation game
    will take advantage of the cutset information to carry out the exact type of attack
    Paul Baran, the inventor of packet-switching networks, was concerned with in his
    research ([https://www.rand.org/about/history/baran.list.html](https://www.rand.org/about/history/baran.list.html))—that
    is, the selective targeting and removal of communication channels to disrupt the
    network.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, the max-flow, min-cut theorem tells us two key pieces of information.
    First, the max-flow portion describes the maximum amount of resources that can
    flow along all paths between two nodes (*u*, *v*). The min-cut section describes
    the minimum number of edges someone would need to remove from the network to sever
    all paths between the two nodes. More formally: given two nodes (*u, v*), the
    max-flow, min-cut theorem tells you the total capacity for the fewest set of edges
    you need to remove so there’s no path between the two nodes (the cutset). A cut
    is a graph partitioning *G*(*S*, *T*) such that *u* is in *S* and *v* is in *T*.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The *capacity constraint* defined in the max-flow, min-cut theorem limits the
    volume flowing through each edge, per simulation step, to less than or equal to
    the maximum capacity of the edge:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: (u → v) flow ≤ (u → v) capacity
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The *conservation constraint* of the theorem states the amount that flows into
    each node is equal to the amount flowing out:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c06/m06021.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: 'Once again, this can be restated more simply: every node sends out all the
    resources it receives; it doesn’t keep any for itself. This constraint applies
    to all nodes except *u*α and *v*[Ω] . In terms of our simulation, this means that
    any user who reblogs the message receives as much information as the post contains,
    and if someone then reblogs the message from them, that person also receives the
    same amount of information. The source and sink nodes are treated specially due
    to their position in the flow. The source node is like a faucet capable of adding
    a certain amount of resource to the network, so nothing flows into the source,
    only out. In our graph this is synonymous with a user who is likely to receive
    a lot of reblogs, but isn’t likely to reblog a lot themselves (nodes with high
    out-degree and low in-degree). Conversely, the sink node is like a sponge that
    absorbs some amount of information from the network without passing any on. Whatever
    information hits the sink node is absorbed there.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The `nx.minimum_cut` function in [Listing 6-16](#listing6-16) uses the max-flow,
    min-cut theorem to determine the minimum cut value between two nodes (*u*, *v*)
    and the partition created by the cut, returned as a tuple (`cut_value`, `partition`).
    The `partition` is a tuple of (`reachable`, `unreachable`) nodes that indicates
    which nodes would be reachable and unreachable from *u*. Recall from the previous
    definition that a cut partitions the graph so that the two nodes are in separate,
    disconnected components if the cutset is removed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 6-16: Updating player 2 with more intelligence'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We start by computing the `cutset` between *u*(*q*) and *v*[Ω] ❶. To convert
    the `partition` tuple into the `cutset`, we loop over the pairs of neighbors in
    the `reachable` set ❷. For each node in the set, we loop over all their neighbors
    in the graph. If one of their neighbors is found in the `unreachable` set, then
    the edge(s) between the node in the `reachable` set and the node in the `unreachable`
    set belong to the cutset. Once we’ve processed all the nodes this way, we’ll have
    the list of all edges required to disconnect the two nodes. If there’s only one
    edge in the set, player 2 chooses this edge for removal ❹. Otherwise, player 2
    chooses an edge from the `cutset` uniformly at random, again relying on the `choice`
    function ❸.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'This output shows the result of rerunning the simulation with the new strategy
    for player 2:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After analyzing the modified player 2 in 6,250 simulations, I got a population
    mean of –0.8144 and can say with 95 percent confidence that the population mean
    for simulations with the modified player 2 is between –0.9484 and –0.6803\. When
    you run the code on your machine, you might see slightly different results (remember,
    we’re dealing with a lot of randomness), but the overall trend should remain consistent.
    It seems that this simple strategy changes the simulation to heavily favor player
    2, even with the network growth still favoring player 1.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s always a chance we’re erroneously claiming that we’ve improved player
    2’s chances. Since we can’t simulate every possible outcome, we can never be 100
    percent sure our population means are accurate. How, then, can we be sure this
    result isn’t due to some random fluke? The truth is, we can be sure only up to
    a certain point. We have to accept that we can’t know for certain. This brings
    up an important point: we need to think about how much risk we’re willing to accept
    of coming to an incorrect conclusion. When you perform an analysis in the wild,
    there are often real-world consequences for acting on incorrect conclusions. You
    should pick a confidence level that complements the amount of risk in the event
    that you’re wrong. The higher the risk, the higher confidence you should require.
    Once you’ve chosen your desired level of confidence, you can convert it into your
    t-test threshold by subtracting the desired confidence level from 100\. For example,
    I want to be very certain our result is not a fluke, so I’ll set the confidence
    level to 99 percent, which means we’re willing to accept a 1 percent probability
    of coming to an incorrect conclusion. We can now use this threshold to test our
    claim that we’ve improved player 2’s chance of winning.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: More formally, we can state the hypothesis that changing player 2’s logic has
    created a significant reduction in the population mean (*h*[1] = μ[0] > μ[1]).
    The null hypothesis, then, is that the random sample’s mean will be equal to or
    less than that of the modified player (*h*[1] = μ[0] ≥ μ[1]). We can compare the
    population mean of this set of results using a statistical method known as the
    *two-sample t-test*. This t-test quantifies the difference between the arithmetic
    means of the two samples. A common application is to test if a new process or
    treatment is superior to a current process or treatment. In our case, we’ll use
    it to determine if the difference between the two population means is significant
    enough to claim that our changed strategy for player 2 has in fact improved their
    chance of winning.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The proof of concept uses the `scipy.stats.ttest_ind` function to run this test.
    The result is an object with an attribute named `pvalue`. The p-value quantifies
    the probability of observing a value as or more extreme than the tested value,
    assuming the null hypothesis is true. We compare this number against our threshold
    of 1 percent to determine if we’re confident enough in the result to reject the
    null hypothesis. In this case I’ve run the test over a dozen times and every time
    the improved player 2 score is significantly low enough to support the claim that
    we are 99 percent sure the change we made to player 2 improved their chance of
    winning. We can visualize the two probability distributions as in [Figure 6-4](#figure6-4)
    to see just how big of an impact the change has had.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c06/f06004.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: Comparing probability distributions'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: This graph shows the likelihood of all possible test outcomes for both the random
    and improved player 2 models. The light gray dotted line represents the baseline
    performance of the random player model. The dark gray continuous line is the performance
    of the improved player model. The large peak and steep drop-off around –0.8 shows
    that the improved player performed more consistently and could win most series
    by a large margin. In fact, it would be incredibly unlikely for any series of
    tests to average as high as –0.25 using the improved player 2 code. We can interpret
    this as an indication that the ability to selectively remove edges has the potential
    to highly disrupt the information flow within this network.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: You can run the proof of concept using the command `python mcs_multiplayer.py`
    in the *Chapter 6* directory in the book’s supplemental materials. On each execution,
    the code runs a group of simulations for both player 2 types, then calculates
    the population means and compares them using the one-tailed t-test. It will output
    a line telling us whether or not we can reject the null hypothesis, and finally
    it generates a graph like the one in [Figure 6-4](#figure6-4) for analysis. As
    an exercise, try adjusting the weights in `XI` to more heavily favor new connections
    and see if this impacts the result to player 1’s benefit. What other changes could
    you make to player 1 to improve their ability to defend the network?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concepts introduced in this chapter—Monte Carlo simulations, finite state
    machines, random walks, weighted choice—combined with the foundational graph theory
    from the last three chapters make up an extremely flexible set of tools that go
    far beyond social network analysis. By defining finite state machines for simulations,
    analyzing repeated simulations to determine the likelihood of a particular outcome,
    modifying simulations to get different results and insights, and modeling how
    graphs may evolve over time, you can quantitatively assess security risks by modeling
    potential changes to the environment.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: One scenario where I constantly find myself applying Monte Carlo simulations
    is in crowd flow dynamics. Predicting how people will move through an area, where
    they’ll gather, and how they might change that movement in response to different
    types of obstructions is one of the keys to planning effective physical security
    controls. We’ll discuss this a bit more in the context of the art gallery problem
    in [Part III](p03.xhtml), but you may already have some idea of how you could
    approach this task using what we’ve covered here.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: This is just the beginning of Monte Carlo simulations, though. By changing the
    logic at each simulation step, you can model all kinds of unique behaviors in
    the network. Designing an appropriate simulation is as much an art as it is a
    science, so don’t be afraid to branch out and explore some wild simulation ideas.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: To help you as you go forth, the Jupyter notebook that accompanies this chapter
    has code to display random walks in 2D and 3D, which you can use to visualize
    the simulations you develop. Often, seeing the results distributed visually can
    lead to interesting discoveries (like paths that always cross a single point).
    By combining the random walk display code with the animation code from the supplemental
    materials, you can even create a video of the simulation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: As you explore the related literature, you’ll find numerous advanced discussions
    of how to select a “best move” within the Monte Carlo simulation. As you saw in
    the proof of concept, small changes to parameters can have a drastic impact on
    the result. It’s important to be aware of the rationale and implications of each
    change to the model so that you can formulate more accurate assessments and draw
    well-founded conclusions about the networks you simulate.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about GGP theory and algorithms from Stanford University’s
    online course ([http://ggp.stanford.edu](http://ggp.stanford.edu)). Several of
    these models lend themselves well to various information security tasks, such
    as risk analysis, budget planning, and incident response. If you’d like to learn
    more about information flow, check out the research paper “An Information Flow
    Model for Conflict and Fission in Small Groups,”^([11](b01.xhtml#c06-endnote-011))
    which describes a formal process for measuring information flow and detecting
    unbalanced sentiment in a social network.**
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
