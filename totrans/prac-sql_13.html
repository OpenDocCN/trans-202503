<html><head></head><body><div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="223" id="Page_223"/>13</span><br/>&#13;
<span class="ChapterTitle">Advanced Query Techniques</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img src="Images/chapterart.png" alt="" width="200" height="200"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Sometimes data analysis requires advanced SQL techniques that go beyond a table join or basic <code>SELECT</code> query. In this chapter, we’ll cover techniques that include writing a query that uses the results of other queries as inputs and reclassifying numerical values into categories before counting them.</p>&#13;
<p>For the exercises, I’ll introduce a dataset of temperatures recorded in select US cities, and we’ll revisit datasets you’ve created in previous chapters. The code for the exercises is available, along with all the book’s resources, at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>. You’ll continue to use the <code>analysis</code> database you’ve already built. Let’s get started.</p>&#13;
<h2 id="h1-501065c13-0001">Using Subqueries</h2>&#13;
<p class="BodyFirst">A <em>subquery</em> is a query nested inside another query. Typically, it performs a calculation or a logical test or generates rows to be passed into the main <span epub:type="pagebreak" title="224" id="Page_224"/>outer query. Subqueries are part of standard ANSI SQL, and the syntax is not unusual: we just enclose a query in parentheses. For example, we can write a subquery that returns multiple rows and treat those results as a table in the <code>FROM</code> clause of the main outer query. Or we can create a <em>scalar subquery</em> that returns a single value and use it as part of an <em>expression</em> to filter rows via <code>WHERE</code>, <code>IN</code>, and <code>HAVING</code> clauses. A <em>correlated subquery</em> is one that depends on a value or table name from the outer query to execute. Conversely, an <em>uncorrelated subquery</em> has no reference to objects in the main query.</p>&#13;
<p>It’s easier to understand these concepts by working with data, so let’s revisit several datasets from earlier chapters, including the census county-level population estimates table <code>us_counties_pop_est_2019</code> and the business patterns table <code>cbp_naics_72_establishments</code>.</p>&#13;
<h3 id="h2-501065c13-0001">Filtering with Subqueries in a WHERE Clause</h3>&#13;
<p class="BodyFirst">A <code>WHERE</code> clause lets you filter query results based on criteria you provide, using an expression such as <code>WHERE quantity &gt; 1000</code>. But this requires that you already know the value to use for comparison. What if you don’t? That’s one way a subquery comes in handy: it lets you write a query that generates one or more values to use as part of an expression in a <code>WHERE</code> clause.</p>&#13;
<h4 id="h3-501065c13-0001">Generating Values for a Query Expression</h4>&#13;
<p class="BodyFirst">Say you wanted to write a query to show which US counties are at or above the 90th percentile, or top 10 percent, for population. Rather than writing two separate queries—one to calculate the 90th percentile and another to find counties with populations at or higher—you can do both at once using a subquery as part of a <code>WHERE</code> clause, as shown in <a href="#listing13-1" id="listinganchor13-1">Listing 13-1</a>.</p>&#13;
<pre><code>SELECT county_name,&#13;
       state_name,&#13;
       pop_est_2019&#13;
FROM us_counties_pop_est_2019&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> WHERE pop_est_2019 &gt;= (&#13;
    SELECT percentile_cont(.9) WITHIN GROUP (ORDER BY pop_est_2019)&#13;
    FROM us_counties_pop_est_2019&#13;
    )&#13;
ORDER BY pop_est_2019 DESC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-1">Listing 13-1</a>: Using a subquery in a <code>WHERE</code> clause</p>&#13;
<p>The <code>WHERE</code> clause <span class="CodeAnnotation" aria-label="annotation1">1</span>, which filters by the total population column <code>pop_est_2019</code>, doesn’t include a value as it normally would. Instead, after the <code>&gt;=</code> comparison operators, we provide a subquery in parentheses. This subquery uses the <code>percentile_cont()</code> function to generate one value: the 90th percentile cutoff point in the <code>pop_est_2019</code> column.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Using <code>percentile_cont()</code> to filter with a subquery works only if you pass in a single input, as shown. If you pass in an array, as in <a href="c06.xhtml#listing6-12" id="listinganchor6-12">Listing 6-12</a> on <span class="xref" itemid="xref_target_page 90">page 90</span>, <code>percentile_cont()</code> returns an array, and the query will fail to evaluate the <code>&gt;=</code> against an array type.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p><span epub:type="pagebreak" title="225" id="Page_225"/>This is an example of an uncorrelated subquery. It does not depend on any values in the outer query, and it will be executed just once to generate the requested value. If you run the subquery portion only, by highlighting it in pgAdmin, it will execute, and you should see a result of <code>213707.3</code>. But you won’t see that number when you run the entire query in <a href="#listing13-1">Listing 13-1</a>, because the subquery result is passed directly to the outer query’s <code>WHERE</code> clause.</p>&#13;
<p>The entire query should return 315 rows, or about 10 percent of the 3,142 rows in <code>us_counties_pop_est_2019</code>.</p>&#13;
<pre><code>      county_name            state_name      pop_est_2019&#13;
----------------------- -------------------- ------------&#13;
Los Angeles County      California               10039107&#13;
Cook County             Illinois                  5150233&#13;
Harris County           Texas                     4713325&#13;
Maricopa County         Arizona                   4485414&#13;
San Diego County        California                3338330&#13;
<var>--snip--</var>&#13;
Cabarrus County         North Carolina             216453&#13;
Yuma County             Arizona                    213787</code></pre>&#13;
<p>The result includes all counties with a population greater than or equal to <code>213707.3</code>, the value the subquery generated.</p>&#13;
<h4 id="h3-501065c13-0002">Using a Subquery to Identify Rows to Delete </h4>&#13;
<p class="BodyFirst">We can use the same subquery in a <code>DELETE</code> statement to specify what to remove from a table. In <a href="#listing13-2" id="listinganchor13-2">Listing 13-2</a>, we make a copy of the census table using the method you learned in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span> and then delete everything from that backup except the 315 counties in the top 10 percent of population.</p>&#13;
<pre><code>CREATE TABLE us_counties_2019_top10 AS&#13;
SELECT * FROM us_counties_pop_est_2019;&#13;
&#13;
DELETE FROM us_counties_2019_top10&#13;
WHERE pop_est_2019 &lt; (&#13;
    SELECT percentile_cont(.9) WITHIN GROUP (ORDER BY pop_est_2019)&#13;
    FROM us_counties_2019_top10&#13;
    );</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-2">Listing 13-2</a>: Using a subquery in a <code>WHERE</code> clause with <code>DELETE</code></p>&#13;
<p>Run the code in <a href="#listing13-2">Listing 13-2</a>, and then execute <code>SELECT count(*) FROM us_counties_2019_top10;</code> to count the remaining rows. The result should be 315 rows, which is the original 3,142 minus the 2,827 below the value identified by the subquery.</p>&#13;
<h3 id="h2-501065c13-0002">Creating Derived Tables with Subqueries</h3>&#13;
<p class="BodyFirst">If your subquery returns rows and columns, you can place it in a <code>FROM</code> clause to create a new table known as a <em>derived table</em> that you can query or join with <span epub:type="pagebreak" title="226" id="Page_226"/>other tables, just as you would a regular table. It’s another example of an uncorrelated subquery.</p>&#13;
<p>Let’s look at a simple example. In <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, you learned the difference between average and median. A median often better indicates a dataset’s central value because a few very large or small values (or outliers) can skew an average. For that reason, I often compare the two. If they’re close, the data more likely falls in a <em>normal distribution</em> (the familiar bell curve), and the average is a good representation of the central value. If the average and median are far apart, some outliers might be having an effect or the distribution is skewed, not normal.</p>&#13;
<p>Finding the average and median population of US counties as well as the difference between them is a two-step process. We need to calculate the average and the median and then subtract the two. We can do both operations in one fell swoop with a subquery in the <code>FROM</code> clause, as shown in <a href="#listing13-3" id="listinganchor13-3">Listing 13-3</a>.</p>&#13;
<pre><code>SELECT round(calcs.average, 0) AS average,&#13;
       calcs.median,&#13;
       round(calcs.average - calcs.median, 0) AS median_average_diff&#13;
FROM (&#13;
   <span class="CodeAnnotationCode" aria-label="annotation1">1</span> SELECT avg(pop_est_2019) AS average,&#13;
            percentile_cont(.5)&#13;
                WITHIN GROUP (ORDER BY pop_est_2019)::numeric AS median&#13;
     FROM us_counties_pop_est_2019&#13;
     )&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> AS calcs;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-3">Listing 13-3</a>: Subquery as a derived table in a <code>FROM</code> clause</p>&#13;
<p>The subquery <span class="CodeAnnotation" aria-label="annotation1">1</span> that produces a derived table is straightforward. We use the <code>avg()</code> and <code>percentile_cont()</code> functions to find the average and median of the census table’s <code>pop_est_2019</code> column and name each column with an alias. Then we name the derived table <code>calcs</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> so we can reference it in the main query.</p>&#13;
<p>In the main query, we subtract the <code>median</code> from the <code>average</code>, both of which are returned by the subquery. The result is rounded and labeled with the alias <code>median_average_diff</code>. Run the query, and the result should be the following:</p>&#13;
<pre><code>average    median     median_average_diff&#13;
-------    -------    -------------------&#13;
 104468      25726                  78742</code></pre>&#13;
<p>The difference between the median and average, 78,742, is nearly three times the size of the median. That indicates we have some high-population counties inflating the average.</p>&#13;
<h3 id="h2-501065c13-0003">Joining Derived Tables</h3>&#13;
<p class="BodyFirst">Joining multiple derived tables lets you perform several preprocessing steps before final calculations in a main query. For example, in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>, we <span epub:type="pagebreak" title="227" id="Page_227"/>calculated the rate of tourism-related businesses per 1,000 population in each county. Let’s say we want to do the same at the state level. Before we can calculate that rate, we need to know the number of tourism businesses in each state and the population of each state. <a href="#listing13-4" id="listinganchor13-4">Listing 13-4</a> shows how to write subqueries for both tasks and join them to calculate the overall rate.</p>&#13;
<pre><code>SELECT census.state_name AS st,&#13;
       census.pop_est_2018,&#13;
       est.establishment_count,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> round((est.establishment_count/census.pop_est_2018::numeric) * 1000, 1)&#13;
           AS estabs_per_thousand&#13;
FROM&#13;
    (&#13;
      <span class="CodeAnnotationCode" aria-label="annotation2">2</span> SELECT st,&#13;
               sum(establishments) AS establishment_count&#13;
        FROM cbp_naics_72_establishments&#13;
        GROUP BY st&#13;
    )&#13;
    AS est&#13;
JOIN&#13;
    (&#13;
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> SELECT state_name,&#13;
               sum(pop_est_2018) AS pop_est_2018&#13;
        FROM us_counties_pop_est_2019&#13;
        GROUP BY state_name&#13;
    )&#13;
    AS census&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> ON est.st = census.state_name&#13;
ORDER BY estabs_per_thousand DESC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-4">Listing 13-4</a>: Joining two derived tables</p>&#13;
<p>You learned how to calculate rates in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>, so the math and syntax in the outer query for finding <code>estabs_per_thousand</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> should be familiar. We divide the number of establishments by the population and then multiply that quotient by a thousand. For the inputs, we use the values generated from two derived tables.</p>&#13;
<p>The first <span class="CodeAnnotation" aria-label="annotation2">2</span> finds the number of establishments in each state using the <code>sum()</code> aggregate function. We give this derived table the alias <code>est</code> for reference in the main part of the query. The second <span class="CodeAnnotation" aria-label="annotation3">3</span> finds the 2018 estimated population by state by using <code>sum()</code> on the <code>pop_est_2018</code> column. We alias this derived table as <code>census</code>.</p>&#13;
<p>Next, we join the derived tables <span class="CodeAnnotation" aria-label="annotation4">4</span> by linking the <code>st</code> column in <code>est</code> to the <code>state_name</code> column in <code>census</code>. We then list the results in descending order based on the rate. Here’s a sample of the 51 rows showing the highest and lowest rates:</p>&#13;
<pre><code>         st          pop_est_2018 establishment_count estabs_per_thousand&#13;
-------------------- ------------ ------------------- -------------------&#13;
District of Columbia       701547                2754                 3.9&#13;
Montana                   1060665                3569                 3.4&#13;
Vermont                    624358                1991                 3.2&#13;
<span epub:type="pagebreak" title="228" id="Page_228"/>Maine                     1339057                4282                 3.2&#13;
Wyoming                    577601                1808                 3.1&#13;
<var>--snip--</var>&#13;
Arizona                   7158024               13288                 1.9&#13;
Alabama                   4887681                9140                 1.9&#13;
Utah                      3153550                6062                 1.9&#13;
Mississippi               2981020                5645                 1.9&#13;
Kentucky                  4461153                8251                 1.8</code></pre>&#13;
<p>At the top is Washington, DC, unsurprising given the tourist activity generated by the museums, monuments, and other attractions in the nation’s capital. Montana may seem like a surprise in second place, but it’s a low-population state with major tourist destinations including Glacier and Yellowstone national parks. Mississippi and Kentucky are among those states with the fewest tourism-related businesses per 1,000 population.</p>&#13;
<h3 id="h2-501065c13-0004">Generating Columns with Subqueries</h3>&#13;
<p class="BodyFirst">You can also place a subquery in the column list after <code>SELECT</code> to generate a value for that column in the query result. The subquery must generate only a single row. For example, the query in <a href="#listing13-5" id="listinganchor13-5">Listing 13-5</a> selects the geography and population information from <code>us_counties_pop_est_2019</code> and then adds an uncorrelated subquery to add the median of all counties to each row in the new column <code>us_median</code>.</p>&#13;
<pre><code>SELECT county_name,&#13;
       state_name AS st,&#13;
       pop_est_2019,&#13;
       (SELECT percentile_cont(.5) WITHIN GROUP (ORDER BY pop_est_2019)&#13;
        FROM us_counties_pop_est_2019) AS us_median&#13;
FROM us_counties_pop_est_2019;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-5">Listing 13-5</a>: Adding a subquery to a column list</p>&#13;
<p>The first rows of the result set should look like this:</p>&#13;
<pre><code>           county_name                     st          pop_est_2019 us_median&#13;
--------------------------------- -------------------- ------------ ---------&#13;
Autauga County                    Alabama                     55869     25726&#13;
Baldwin County                    Alabama                    223234     25726&#13;
Barbour County                    Alabama                     24686     25726&#13;
Bibb County                       Alabama                     22394     25726&#13;
Blount County                     Alabama                     57826     25726&#13;
<var>--snip--</var></code></pre>&#13;
<p>On its own, that repeating <code>us_median</code> value isn’t very helpful. It would be more interesting and useful to generate values that indicate how much each county’s population deviates from the median value. Let’s look at how we can use the same subquery technique to do that. <a href="#listing13-6" id="listinganchor13-6">Listing 13-6</a> builds on <a href="#listing13-5">Listing 13-5</a> by substituting a subquery after <code>SELECT</code> that calculates the difference between the population and the median for each county.</p>&#13;
<pre><code><span epub:type="pagebreak" title="229" id="Page_229"/>SELECT county_name,&#13;
       state_name AS st,&#13;
       pop_est_2019,&#13;
       pop_est_2019 - (SELECT percentile_cont(.5) WITHIN GROUP (ORDER BY pop_est_2019) <span class="CodeAnnotationCode" aria-label="annotation1">1</span>&#13;
                       FROM us_counties_pop_est_2019) AS diff_from_median&#13;
FROM us_counties_pop_est_2019&#13;
WHERE (pop_est_2019 - (SELECT percentile_cont(.5) WITHIN GROUP (ORDER BY pop_est_2019) <span class="CodeAnnotationCode" aria-label="annotation2">2</span>&#13;
                       FROM us_counties_pop_est_2019))&#13;
       BETWEEN -1000 AND 1000;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-6">Listing 13-6</a>: Using a subquery in a calculation</p>&#13;
<p>The subquery <span class="CodeAnnotation" aria-label="annotation1">1</span> is now part of a calculation that subtracts the subquery’s result from <code>pop_est_2019</code>, the total population, giving the column an alias of <code>diff_from_median</code>. To make this query even more useful, we can filter results to show counties whose population is close to the median. To do this, we repeat the calculation with the subquery in the <code>WHERE</code> clause <span class="CodeAnnotation" aria-label="annotation2">2</span> and filter results using the <code>BETWEEN -1000 AND 1000</code> expression.</p>&#13;
<p>The outcome should reveal 78 counties. Here are the first five rows:</p>&#13;
<pre><code>      county_name             st       pop_est_2019 diff_from_median&#13;
----------------------- -------------- ------------ ----------------&#13;
Cherokee County         Alabama               26196              470&#13;
Geneva County           Alabama               26271              545&#13;
Cleburne County         Arkansas              24919             -807&#13;
Johnson County          Arkansas              26578              852&#13;
St. Francis County      Arkansas              24994             -732&#13;
<var>--snip--</var></code></pre>&#13;
<p>Bear in mind that subqueries can add to overall query execution time. In <a href="#listing13-6">Listing 13-6</a>, I removed the subquery from <a href="#listing13-5">Listing 13-5</a> that displays the column <code>us_median</code> to avoid repeating the subquery a third time. With our data set, the impact is minimal; if we were working with millions of rows, winnowing some unneeded subqueries might provide a significant speed boost.</p>&#13;
<h3 id="h2-501065c13-0005">Understanding Subquery Expressions</h3>&#13;
<p class="BodyFirst">You can also use subqueries to filter rows by evaluating whether a condition evaluates as <code>true</code> or <code>false</code>. For this, we can use <em>subquery expressions</em>, which are a combination of a keyword with a subquery and are generally used in <code>WHERE</code> clauses to filter rows based on the existence of values in another table.</p>&#13;
<p>The PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/functions-subquery.html" class="LinkURL">https://www.postgresql.org/docs/current/functions-subquery.html</a> lists available subquery expressions, but here we’ll examine the syntax for two that tend to be used most often: <code>IN</code> and <code>EXISTS</code>. To prep, run the code in <a href="#listing13-7" id="listinganchor13-7">Listing 13-7</a> to create a small table called <code>retirees</code> that we’ll query along with the <code>employees</code> table you built in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>. We’ll imagine that we’ve received this data from a vendor listing people who’ve applied for retirement benefits.</p>&#13;
<pre><code><span epub:type="pagebreak" title="230" id="Page_230"/>CREATE TABLE retirees (&#13;
    id int,&#13;
    first_name text,&#13;
    last_name text&#13;
);&#13;
&#13;
INSERT INTO retirees&#13;
VALUES (2, 'Janet', 'King'),&#13;
       (4, 'Michael', 'Taylor');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-7">Listing 13-7</a>: Creating and filling a <code>retirees</code> table</p>&#13;
<p>Now let’s use this table in some subquery expressions.</p>&#13;
<h4 id="h3-501065c13-0003">Generating Values for the IN Operator</h4>&#13;
<p class="BodyFirst">The subquery expression <code>IN (</code><var>subquery</var><code>)</code> works like the <code>IN</code> operator example in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> except we employ a subquery to provide the list of values to check against rather than manually entering one. In <a href="#listing13-8" id="listinganchor13-8">Listing 13-8</a>, we use an uncorrelated subquery, which will be executed one time, to generate <code>id</code> values from the <code>retirees</code> table. The values it returns become the list for the <code>IN</code> operator in the <code>WHERE</code> clause. This lets us find employees who are also present in the table of retirees.</p>&#13;
<pre><code>SELECT first_name, last_name&#13;
FROM employees&#13;
WHERE emp_id IN (&#13;
    SELECT id&#13;
    FROM retirees)&#13;
ORDER BY emp_id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-8">Listing 13-8</a>: Generating values for the <code>IN</code> operator</p>&#13;
<p>Run the query, and the output shows the two people in <code>employees</code> whose <code>emp_id</code> have a matching <code>id</code> in the <code>retirees</code> table:</p>&#13;
<pre><code>first_name last_name&#13;
---------- ---------&#13;
Janet      King&#13;
Michael    Taylor</code></pre>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Avoid using <code>NOT IN</code>. The presence of <code>NULL</code> values in a subquery result set will cause a query with a <code>NOT IN</code> expression to return no rows. The PostgreSQL wiki recommends using <code>NOT</code><code> </code><code>EXISTS</code> instead, described in the next section.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h4 id="h3-501065c13-0004">Checking Whether Values Exist</h4>&#13;
<p class="BodyFirst">The subquery expression <code>EXISTS (</code><var>subquery</var><code>)</code> returns a value of <code>true</code> if the subquery in parentheses returns at least one row. If it returns no rows, <code>EXISTS</code> evaluates to <code>false</code>.</p>&#13;
<p><span epub:type="pagebreak" title="231" id="Page_231"/>The <code>EXISTS</code> subquery expression in <a href="#listing13-9" id="listinganchor13-9">Listing 13-9</a> shows an example of a correlated subquery—it includes an expression in its <code>WHERE</code> clause that requires data from the outer query. Also, because the subquery is correlated, it will execute once for each row returned by the outer query, each time checking whether there’s an <code>id</code> in <code>retirees</code> that matches <code>emp_id</code> in <code>employees</code>. If there is a match, the <code>EXISTS</code> expression returns <code>true</code>.</p>&#13;
<pre><code>SELECT first_name, last_name&#13;
FROM employees&#13;
WHERE EXISTS (&#13;
    SELECT id&#13;
    FROM retirees&#13;
    WHERE id = employees.emp_id);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-9">Listing 13-9</a>: Using a correlated subquery with <code>WHERE EXISTS</code></p>&#13;
<p>When you run the code, it should return the same result as it did in <a href="#listing13-8">Listing 13-8</a>. Using this approach is particularly helpful if you need to join on more than one column, which you can’t do with the <code>IN</code> expression. You also can add the <code>NOT</code> keyword with <code>EXISTS</code> to perform the opposite function and find rows in the employees table with no corresponding record in <code>retirees</code>, as in <a href="#listing13-10" id="listinganchor13-10">Listing 13-10</a>.</p>&#13;
<pre><code>SELECT first_name, last_name&#13;
FROM employees&#13;
WHERE NOT EXISTS (&#13;
    SELECT id&#13;
    FROM retirees&#13;
    WHERE id = employees.emp_id);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-10">Listing 13-10</a>: Using a correlated subquery with <code>WHERE NOT EXISTS</code></p>&#13;
<p>That should produce these results:</p>&#13;
<pre><code>first_name last_name&#13;
---------- ---------&#13;
Julia      Reyes&#13;
Arthur     Pappas</code></pre>&#13;
<p>The technique of using <code>NOT</code> with <code>EXISTS</code> is helpful for finding missing values or assessing whether a dataset is complete.</p>&#13;
<h3 id="h2-501065c13-0006">Using Subqueries with LATERAL</h3>&#13;
<p class="BodyFirst">Placing the keyword <code>LATERAL</code> before subqueries in a <code>FROM</code> clause adds several bits of functionality that help simplify otherwise complicated queries.</p>&#13;
<h4 id="h3-501065c13-0005">LATERAL with FROM</h4>&#13;
<p class="BodyFirst">First, a subquery preceded by <code>LATERAL</code> can reference tables and other subqueries that appear before it in the <code>FROM</code> clause, which can reduce redundant code by making it easy to reuse calculations.</p>&#13;
<p><span epub:type="pagebreak" title="232" id="Page_232"/><a href="#listing13-11" id="listinganchor13-11">Listing 13-11</a> calculates the change in county population from 2018 to 2019 two ways: raw change in numbers and percent change.</p>&#13;
<pre><code>SELECT county_name,&#13;
       state_name,&#13;
       pop_est_2018,&#13;
       pop_est_2019,&#13;
       raw_chg,&#13;
       round(pct_chg * 100, 2) AS pct_chg&#13;
FROM us_counties_pop_est_2019,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> LATERAL (SELECT pop_est_2019 - pop_est_2018 AS raw_chg) rc,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation2">2</span> LATERAL (SELECT raw_chg / pop_est_2018::numeric AS pct_chg) pc&#13;
ORDER BY pct_chg DESC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-11">Listing 13-11</a>: Using <code>LATERAL</code> subqueries in the <code>FROM</code> clause</p>&#13;
<p>In the <code>FROM</code> clause, after naming the <code>us_counties_pop_est_2019</code> table, we add the first <code>LATERAL</code> subquery <span class="CodeAnnotation" aria-label="annotation1">1</span>. In parentheses, we place a query that subtracts the 2018 population estimate from the 2019 estimate and alias the result as <code>raw_chg</code>. Because a <code>LATERAL</code> subquery can reference a table listed before it in the <code>FROM</code> clause without needing to specify its name, we can omit the <code>us_counties_pop_est_2019</code> table from the subquery. Subqueries in <code>FROM</code> must have an alias, so we label this one <code>rc</code>.</p>&#13;
<p>The second <code>LATERAL</code> subquery <span class="CodeAnnotation" aria-label="annotation2">2</span> calculates the percent change in population from 2018 to 2019. To find percent change, we must know the raw change. Rather than re-calculate it, we can reference the <code>raw_chg</code> value from the previous subquery. That helps make our code shorter and easier to read.</p>&#13;
<p>The query results should look like this:</p>&#13;
<pre><code>  county_name     state_name  pop_est_2018 pop_est_2019 raw_chg pct_chg&#13;
---------------- ------------ ------------ ------------ ------- -------&#13;
Loving County    Texas                 148          169      21   14.19&#13;
McKenzie County  North Dakota        13594        15024    1430   10.52&#13;
Loup County      Nebraska              617          664      47    7.62&#13;
Kaufman County   Texas              128279       136154    7875    6.14&#13;
Williams County  North Dakota        35469        37589    2120    5.98&#13;
<var>--snip--</var></code></pre>&#13;
<h4 id="h3-501065c13-0006">LATERAL with JOIN</h4>&#13;
<p class="BodyFirst">Combining <code>LATERAL</code> with <code>JOIN</code> creates functionality similar to a <em>for loop</em> in a programming language: for each row generated by the query in front of the <code>LATERAL</code> join, a subquery or function after the <code>LATERAL</code> join will be evaluated once.</p>&#13;
<p>We’ll reuse the <code>teachers</code> table from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> and create a new table to record each time a teacher swipes a badge to unlock a lab door. Our task is to find the two most recent times a teacher accessed a lab. <a href="#listing13-12" id="listinganchor13-12">Listing 13-12</a> shows the code.</p>&#13;
<pre><code><span epub:type="pagebreak" title="233" id="Page_233"/><span class="CodeAnnotationHang" aria-label="annotation1">1</span> ALTER TABLE teachers ADD CONSTRAINT id_key PRIMARY KEY (id);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> CREATE TABLE teachers_lab_access (&#13;
    access_id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,&#13;
    access_time timestamp with time zone,&#13;
    lab_name text,&#13;
    teacher_id bigint REFERENCES teachers (id)&#13;
);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> INSERT INTO teachers_lab_access (access_time, lab_name, teacher_id)&#13;
VALUES ('2022-11-30 08:59:00-05', 'Science A', 2),&#13;
       ('2022-12-01 08:58:00-05', 'Chemistry B', 2),&#13;
       ('2022-12-21 09:01:00-05', 'Chemistry A', 2),&#13;
       ('2022-12-02 11:01:00-05', 'Science B', 6),&#13;
       ('2022-12-07 10:02:00-05', 'Science A', 6),&#13;
       ('2022-12-17 16:00:00-05', 'Science B', 6);&#13;
&#13;
SELECT t.first_name, t.last_name, a.access_time, a.lab_name&#13;
FROM teachers t&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> LEFT JOIN LATERAL (SELECT *&#13;
                   FROM teachers_lab_access&#13;
                 <span class="CodeAnnotationCode" aria-label="annotation5">5</span> WHERE teacher_id = t.id&#13;
                   ORDER BY access_time DESC&#13;
                   LIMIT 2)<span class="CodeAnnotationCode" aria-label="annotation6">6</span> a&#13;
<span class="CodeAnnotationHang" aria-label="annotation7">7</span> ON true&#13;
ORDER BY t.id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-12">Listing 13-12</a>: Using a subquery with a <code>LATERAL</code> join</p>&#13;
<p>First, we add a primary key <span class="CodeAnnotation" aria-label="annotation1">1</span> to the <code>teachers</code> table using <code>ALTER TABLE</code> (we didn’t place a constraint on this table in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> because we were just covering the basics about creating tables). Next, we make a simple <code>teachers_lab_access</code> table <span class="CodeAnnotation" aria-label="annotation2">2</span> with columns to record the lab name and access timestamp. The table has a surrogate primary key <code>access_id</code> and a foreign key <code>teacher_id</code> that references <code>id</code> in <code>teachers</code>. Finally, we add six rows to the table using an <code>INSERT</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> statement.</p>&#13;
<p>Now we’re ready to query the data. In our <code>SELECT</code> statement, we join <code>teachers</code> to a subquery using <code>LEFT JOIN</code>. We add the <code>LATERAL</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> keyword, which means for each row returned from <code>teachers</code>, the subquery will execute, returning the two most recent labs accessed by that particular teacher and the times they were accessed. Using <code>LEFT JOIN</code> will return all rows from <code>teachers</code> regardless of whether the subquery finds a matching teacher in <code>teachers_lab_access</code>.</p>&#13;
<p>In the <code>WHERE</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> clause, the subquery references the outer query using the foreign key of <code>teacher_lab_access</code>. This <code>LATERAL</code> join syntax requires that the subquery have an alias <span class="CodeAnnotation" aria-label="annotation6">6</span>, which here is <code>a</code>, and the value <code>true</code> in the <code>ON</code> portion <span class="CodeAnnotation" aria-label="annotation7">7</span> of the <code>JOIN</code> clause. In this case, <code>true</code> lets us create the join without naming specific columns to join upon.</p>&#13;
<p><span epub:type="pagebreak" title="234" id="Page_234"/>Run the query, and the results should look like this:</p>&#13;
<pre><code>first_name last_name      access_time         lab_name&#13;
---------- --------- ----------------------  ------------&#13;
Janet      Smith&#13;
Lee        Reynolds  2022-12-21 09:01:00-05  Chemistry A&#13;
Lee        Reynolds  2022-12-01 08:58:00-05  Chemistry B&#13;
Samuel     Cole&#13;
Samantha   Bush&#13;
Betty      Diaz&#13;
Kathleen   Roush     2022-12-17 16:00:00-05  Science B&#13;
Kathleen   Roush     2022-12-07 10:02:00-05  Science A</code></pre>&#13;
<p>The two teachers with IDs in the access table have their two most recent lab access times shown. Teachers who didn’t access a lab display <code>NULL</code> values; if we want to remove those from the results, we could substitute <code>INNER JOIN</code> (or just <code>JOIN</code>) for <code>LEFT JOIN</code>.</p>&#13;
<p>Next, let’s explore another syntax for working with subqueries.</p>&#13;
<h2 id="h1-501065c13-0002">Using Common Table Expressions</h2>&#13;
<p class="BodyFirst">The <em>common table expression</em> <em>(CTE)</em>, a relatively recent addition to standard SQL, allows you to use one or more <code>SELECT</code> queries to predefine temporary tables that you can reference as often as needed in your main query. CTEs are informally called <code>WITH</code> queries because you define them using a <code>WITH ... AS</code> statement. The following examples show some advantages of using them, including cleaner code and less redundancy.</p>&#13;
<p><a href="#listing13-13" id="listinganchor13-13">Listing 13-13</a> shows a simple CTE based on our census estimates data. The code determines how many counties in each state have 100,000 people or more. Let’s walk through the example.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> WITH large_counties (county_name, state_name, pop_est_2019)&#13;
AS (&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> SELECT county_name, state_name, pop_est_2019&#13;
    FROM us_counties_pop_est_2019&#13;
    WHERE pop_est_2019 &gt;= 100000&#13;
   )&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> SELECT state_name, count(*)&#13;
FROM large_counties&#13;
GROUP BY state_name&#13;
ORDER BY count(*) DESC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-13">Listing 13-13</a>: Using a simple CTE to count large counties</p>&#13;
<p>The <code>WITH ... AS</code> statement <span class="CodeAnnotation" aria-label="annotation1">1</span> defines the temporary table <code>large_counties</code>. After <code>WITH</code>, we name the table and list its column names in parentheses. Unlike column definitions in a <code>CREATE TABLE</code> statement, we don’t need to provide data types, because the temporary table inherits those from the subquery <span class="CodeAnnotation" aria-label="annotation2">2</span>, which is enclosed in parentheses after <code>AS</code>. The subquery must return the same number of columns as defined in the temporary table, but the column names don’t <span epub:type="pagebreak" title="235" id="Page_235"/>need to match. The column list is optional if you’re not renaming columns; I’ve included it here so you can see the syntax.</p>&#13;
<p>The main query <span class="CodeAnnotation" aria-label="annotation3">3</span> counts and groups the rows in <code>large_counties</code> by <code>state_name</code> and then orders by the count in descending order. The top six rows of the results should look like this:</p>&#13;
<pre><code>     state_name      count&#13;
-------------------- -----&#13;
Texas                   40&#13;
Florida                 36&#13;
California              35&#13;
Pennsylvania            31&#13;
New York                28&#13;
North Carolina          28&#13;
<var>--snip--</var></code></pre>&#13;
<p>Texas, Florida, and California are among the states that had the most counties with a 2019 population of 100,000 or more.</p>&#13;
<p><a href="#listing13-14" id="listinganchor13-14">Listing 13-14</a> uses a CTE to rewrite the join of derived tables in <a href="#listing13-4">Listing 13-4</a> (finding the rate of tourism-related businesses per 1,000 population in each state) into a more readable format.</p>&#13;
<pre><code>WITH&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> counties (st, pop_est_2018) AS&#13;
    (SELECT state_name, sum(pop_est_2018)&#13;
     FROM us_counties_pop_est_2019&#13;
     GROUP BY state_name),&#13;
&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> establishments (st, establishment_count) AS&#13;
    (SELECT st, sum(establishments) AS establishment_count&#13;
     FROM cbp_naics_72_establishments&#13;
     GROUP BY st)&#13;
&#13;
SELECT counties.st,&#13;
       pop_est_2018,&#13;
       establishment_count,&#13;
       round((establishments.establishment_count /&#13;
              counties.pop_est_2018::numeric(10,1)) * 1000, 1)&#13;
           AS estabs_per_thousand&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> FROM counties JOIN establishments&#13;
ON counties.st = establishments.st&#13;
ORDER BY estabs_per_thousand DESC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-14">Listing 13-14</a>: Using CTEs in a table join</p>&#13;
<p>Following the <code>WITH</code> keyword, we define two tables using subqueries. The first subquery, <code>counties</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, returns the 2018 population of each state. The second, <code>establishments</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, returns the number of tourism-related businesses per state. With those tables defined, we join them <span class="CodeAnnotation" aria-label="annotation3">3</span> on the <code>st</code> column in each table and calculate the rate per thousand. The results are identical to the joined derived tables in <a href="#listing13-4">Listing 13-4</a>, but <a href="#listing13-14">Listing 13-14</a> is easier to comprehend.</p>&#13;
<p><span epub:type="pagebreak" title="236" id="Page_236"/>As another example, you can use a CTE to simplify queries that have redundant code. For example, in <a href="#listing13-6">Listing 13-6</a>, we used a subquery with the <code>percentile_cont()</code> function in two locations to find median county population. In <a href="#listing13-15" id="listinganchor13-15">Listing 13-15</a>, we can write that subquery just once as a CTE.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> WITH us_median AS&#13;
    (SELECT percentile_cont(.5)&#13;
     WITHIN GROUP (ORDER BY pop_est_2019) AS us_median_pop&#13;
     FROM us_counties_pop_est_2019)&#13;
&#13;
SELECT county_name,&#13;
       state_name AS st,&#13;
       pop_est_2019,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation2">2</span> us_median_pop,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation3">3</span> pop_est_2019 - us_median_pop AS diff_from_median&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> FROM us_counties_pop_est_2019 CROSS JOIN us_median&#13;
<span class="CodeAnnotationHang" aria-label="annotation5">5</span> WHERE (pop_est_2019 - us_median_pop)&#13;
       BETWEEN -1000 AND 1000;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-15">Listing 13-15</a>: Using CTEs to minimize redundant code</p>&#13;
<p>After the <code>WITH</code> keyword, we define <code>us_median</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> as the result of the same subquery used in <a href="#listing13-6">Listing 13-6</a>, which finds the median population using <code>percentile_cont()</code>. Then we reference the <code>us_median_pop</code> column on its own <span class="CodeAnnotation" aria-label="annotation2">2</span>, as part of a calculated column <span class="CodeAnnotation" aria-label="annotation3">3</span>, and in a <code>WHERE</code> clause <span class="CodeAnnotation" aria-label="annotation5">5</span>. To make the value available to every row in the <code>us_counties_pop_est_2019</code> table during <code>SELECT</code>, we use the <code>CROSS JOIN</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> you learned in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>&#13;
<p>This query provides identical results to those in <a href="#listing13-6">Listing 13-6</a>, but we had to write the subquery that finds the median only once. Another bonus is that you can more easily revise the query. For example, to find counties whose population is close to the 90th percentile, you need to substitute <code>.9</code> for <code>.5</code> as input to <code>percentile_cont()</code> in only one place.</p>&#13;
<p>Readable code, less redundancy, and easier modifications are often-cited reasons for using CTEs. Another, beyond the scope of this book, is the ability to add a <code>RECURSIVE</code> keyword that lets a CTE loop through query results within the CTE itself—a task useful when dealing with data organized in a hierarchy. An example is a company’s personnel listing, where you might want to find all the people who report to a particular executive. The recursive CTE will start with the executive and then loop down through rows finding her direct reports and then the people who report to those people. You can learn more about recursive query syntax via the PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/queries-with.html" class="LinkURL">https://www.postgresql.org/docs/current/queries-with.html</a>.</p>&#13;
<h2 id="h1-501065c13-0003">Performing Cross Tabulations</h2>&#13;
<p class="BodyFirst"><em>Cross tabulations</em> provide a simple way to summarize and compare variables by displaying them in a table layout, or matrix. Rows in the matrix represent one variable, columns represent another variable, and each cell where a row and column intersect holds a value, such as a count or percentage.</p>&#13;
<p><span epub:type="pagebreak" title="237" id="Page_237"/>You’ll often see cross tabulations, also called <em>pivot tables</em> or <em>crosstabs</em>, used to report summaries of survey results or to compare pairs of variables. A frequent example happens during elections when candidates’ votes are tallied by geography:</p>&#13;
<pre><code>candidate    ward 1    ward 2    ward 3&#13;
---------    ------    ------    ------&#13;
Collins         602     1,799     2,112&#13;
Banks           599     1,398     1,616&#13;
Rutherford      911       902     1,114</code></pre>&#13;
<p>In this case, the candidates’ names are one variable, the wards (or city districts) are another variable, and the cells at the intersection of the two hold the vote totals for that candidate in that ward. Let’s look at how to generate cross tabulations.</p>&#13;
<h3 id="h2-501065c13-0007">Installing the crosstab() Function</h3>&#13;
<p class="BodyFirst">Standard ANSI SQL doesn’t have a crosstab function, but PostgreSQL does as part of a <em>module</em> you can install easily. Modules are PostgreSQL extras that aren’t part of the core application; they include functions related to security, text search, and more. You can find a list of PostgreSQL modules at <a href="https://www.postgresql.org/docs/current/contrib.html" class="LinkURL">https://www.postgresql.org/docs/current/contrib.html</a>.</p>&#13;
<p>PostgreSQL’s <code>crosstab()</code> function is part of the <code>tablefunc</code> module. To install <code>tablefunc</code>, execute this command in pgAdmin:</p>&#13;
<pre><code>CREATE EXTENSION tablefunc;</code></pre>&#13;
<p>PostgreSQL should return the message <code>CREATE EXTENSION</code>. (If you’re working with another database management system, check its documentation for a similar functionality. For example, Microsoft SQL Server has the <code>PIVOT</code> command.)</p>&#13;
<p>Next, we’ll create a basic crosstab so you can learn the syntax, and then we’ll handle a more complex case.</p>&#13;
<h3 id="h2-501065c13-0008">Tabulating Survey Results</h3>&#13;
<p class="BodyFirst">Let’s say your company needs a fun employee activity so you coordinate an ice cream social at each of your three offices. The trouble is that people are particular about ice cream flavors. To choose flavors people will like in each office, you decide to conduct a survey.</p>&#13;
<p>The CSV file <em>ice_cream_survey.csv</em> contains 200 responses to your survey. You can download this file, along with all the book’s resources, at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>. Each row includes a <code>response_id</code>, <code>office</code>, and <code>flavor</code>. You’ll need to count how many people chose each flavor at each office and share the results in a readable way.</p>&#13;
<p>In your <code>analysis</code> database, use the code in <a href="#listing13-16" id="listinganchor13-16">Listing 13-16</a> to create a table and load the data. Make sure you change the file path to the location on your computer where you saved the CSV file.</p>&#13;
<pre><code><span epub:type="pagebreak" title="238" id="Page_238"/>CREATE TABLE ice_cream_survey (&#13;
    response_id integer PRIMARY KEY,&#13;
    office text,&#13;
    flavor text&#13;
);&#13;
&#13;
COPY ice_cream_survey&#13;
FROM '<var>C:\YourDirectory\</var>ice_cream_survey.csv'&#13;
WITH (FORMAT CSV, HEADER);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-16">Listing 13-16</a>: Creating and filling the <code>ice_cream_survey</code> table</p>&#13;
<p>If you want to inspect the data, run the following to view the first five rows:</p>&#13;
<pre><code>SELECT *&#13;
FROM ice_cream_survey&#13;
ORDER BY response_id&#13;
LIMIT 5;</code></pre>&#13;
<p>The data should look like this:</p>&#13;
<pre><code>response_id    office      flavor&#13;
-----------    --------    ----------&#13;
          1    Uptown      Chocolate&#13;
          2    Midtown     Chocolate&#13;
          3    Downtown    Strawberry&#13;
          4    Uptown      Chocolate&#13;
          5    Midtown     Chocolate</code></pre>&#13;
<p>It looks like chocolate is in the lead! But let’s confirm this choice by using the code in <a href="#listing13-17" id="listinganchor13-17">Listing 13-17</a> to generate a crosstab.</p>&#13;
<pre><code>SELECT *&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> FROM crosstab('SELECT <span class="CodeAnnotationCode" aria-label="annotation2">2</span> office,&#13;
                      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> flavor,&#13;
                      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> count(*)&#13;
               FROM ice_cream_survey&#13;
               GROUP BY office, flavor&#13;
               ORDER BY office',&#13;
&#13;
            <span class="CodeAnnotationCode" aria-label="annotation5">5</span> 'SELECT flavor&#13;
               FROM ice_cream_survey&#13;
               GROUP BY flavor&#13;
               ORDER BY flavor')&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation6">6</span> AS (office text,&#13;
    chocolate bigint,&#13;
    strawberry bigint,&#13;
    vanilla bigint);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-17">Listing 13-17</a>: Generating the ice cream survey crosstab</p>&#13;
<p><span epub:type="pagebreak" title="239" id="Page_239"/>The query begins with a <code>SELECT *</code> statement that selects everything from the contents of the <code>crosstab()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span>. We supply two queries as parameters to the <code>crosstab()</code> function; note that because these queries are parameters, we place them inside single quotes. The first query generates the data for the crosstab and has three required columns. The first column, <code>office</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, supplies the row names for the crosstab. The second column, <code>flavor</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, supplies the category (or column) name to be associated with the value provided in the third column. Those values will display in each cell where a row and a column intersect in the table. In this case, we want the intersecting cells to show a <code>count()</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> of each flavor selected at each office. This first query on its own creates a simple aggregated list.</p>&#13;
<p>The second query parameter <span class="CodeAnnotation" aria-label="annotation5">5</span> produces the category names for the columns. The <code>crosstab()</code> function requires that the second subquery returns only one column, so we use <code>SELECT</code> to retrieve <code>flavor</code> and <code>GROUP BY</code> to return that column’s unique values.</p>&#13;
<p>Then we specify the names and data types of the crosstab’s output columns following the <code>AS</code> keyword <span class="CodeAnnotation" aria-label="annotation6">6</span>. The list must match the row and column names in the order the queries generate them. For example, because the second query that supplies the category columns orders the flavors alphabetically, the output column list must as well.</p>&#13;
<p>When we run the code, our data displays in a clean, readable crosstab:</p>&#13;
<pre><code>office      chocolate    strawberry    vanilla&#13;
--------    ---------    ----------    -------&#13;
Downtown           23            32         19&#13;
Midtown            41                       23&#13;
Uptown             22            17         23</code></pre>&#13;
<p>It’s easy to see at a glance that the Midtown office favors chocolate but has no interest in strawberry, which is represented by a <code>NULL</code> value showing that strawberry received no votes. But strawberry is the top choice Downtown, and the Uptown office is more evenly split among the three flavors.</p>&#13;
<h3 id="h2-501065c13-0009">Tabulating City Temperature Readings</h3>&#13;
<p class="BodyFirst">Let’s create another crosstab, but this time we’ll use real data. The <em>temperature_readings.csv</em> file, also available with all the book’s resources at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>, contains a year’s worth of daily temperature readings from three observation stations around the United States: Chicago, Seattle, and Waikiki, a neighborhood on the south shore of the city of Honolulu. The data come from the US National Oceanic and Atmospheric Administration (NOAA) at <a href="https://www.ncdc.noaa.gov/cdo-web/datatools/findstation/" class="LinkURL">https://www.ncdc.noaa.gov/cdo-web/datatools/findstation/</a>.</p>&#13;
<p>Each row in the CSV file contains four values: the station name, the date, and the day’s maximum and minimum temperatures. All temperatures are in Fahrenheit. For each month in each city, we want to compare climates using the median high temperature. <a href="#listing13-18" id="listinganchor13-18">Listing 13-18</a> has the code to create the <code>temperature_readings</code> table and import the CSV file.</p>&#13;
<pre><code><span epub:type="pagebreak" title="240" id="Page_240"/>CREATE TABLE temperature_readings (&#13;
    station_name text,&#13;
    observation_date date,&#13;
    max_temp integer,&#13;
    min_temp integer,&#13;
    CONSTRAINT temp_key PRIMARY KEY (station_name, observation_date)&#13;
);&#13;
&#13;
COPY temperature_readings&#13;
FROM '<var>C:\YourDirectory\</var>temperature_readings.csv'&#13;
WITH (FORMAT CSV, HEADER);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-18">Listing 13-18</a>: Creating and filling a <code>temperature_readings</code> table</p>&#13;
<p>The table contains the four columns from the CSV file; we add a natural primary key using the station name and observation date. A quick count should return 1,077 rows. Now, let’s see what cross tabulating the data does using <a href="#listing13-19" id="listinganchor13-19">Listing 13-19</a>.</p>&#13;
<pre><code>SELECT *&#13;
FROM crosstab('SELECT&#13;
                <span class="CodeAnnotationCode" aria-label="annotation1">1</span> station_name,&#13;
                <span class="CodeAnnotationCode" aria-label="annotation2">2</span> date_part(''month'', observation_date),&#13;
                <span class="CodeAnnotationCode" aria-label="annotation3">3</span> percentile_cont(.5)&#13;
                      WITHIN GROUP (ORDER BY max_temp)&#13;
               FROM temperature_readings&#13;
               GROUP BY station_name,&#13;
                        date_part(''month'', observation_date)&#13;
               ORDER BY station_name',&#13;
&#13;
              'SELECT month&#13;
               FROM <span class="CodeAnnotationCode" aria-label="annotation4">4</span> generate_series(1,12) month')&#13;
&#13;
AS (station text,&#13;
    jan numeric(3,0),&#13;
    feb numeric(3,0),&#13;
    mar numeric(3,0),&#13;
    apr numeric(3,0),&#13;
    may numeric(3,0),&#13;
    jun numeric(3,0),&#13;
    jul numeric(3,0),&#13;
    aug numeric(3,0),&#13;
    sep numeric(3,0),&#13;
    oct numeric(3,0),&#13;
    nov numeric(3,0),&#13;
    dec numeric(3,0)&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-19">Listing 13-19</a>: Generating the temperature readings crosstab</p>&#13;
<p>The crosstab structure is the same as in <a href="#listing13-18">Listing 13-18</a>. The first subquery inside <code>crosstab()</code> generates the data for the crosstab, finding the median maximum temperature for each month. It supplies three required columns. The first, <code>station_name</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, names the rows. The second column <span epub:type="pagebreak" title="241" id="Page_241"/>uses the <code>date_part()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span> from <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span> to extract the month from <code>observation_date</code>, which provides the crosstab columns. Then we use <code>percentile_cont(.5)</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> to find the 50th percentile, or the median, of the <code>max_temp</code>. We group by station name and month so we have a median <code>max_temp</code> for each month at each station.</p>&#13;
<p>As in <a href="#listing13-18">Listing 13-18</a>, the second subquery produces the set of category names for the columns. I’m using a function called <code>generate_series()</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> in a manner noted in the official PostgreSQL documentation to create a list of numbers from 1 to 12 that match the month numbers <code>date_part()</code> extracts from <code>observation_date</code>.</p>&#13;
<p>Following <code>AS</code>, we provide the names and data types for the crosstab’s output columns. Each is a <code>numeric</code> type, matching the output of the percentile function. The following output is practically poetry:</p>&#13;
<pre><code>station                          jan  feb  mar  apr  may  jun  jul  aug  sep  oct  nov  dec&#13;
------------------------------   ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---&#13;
CHICAGO NORTHERLY ISLAND IL US    34   36   46   50   66   77   81   80   77   65   57   35&#13;
SEATTLE BOEING FIELD WA US        50   54   56   64   66   71   76   77   69   62   55   42&#13;
WAIKIKI 717.2 HI US               83   84   84   86   87   87   88   87   87   86   84   82</code></pre>&#13;
<p>We’ve transformed a raw set of daily readings into a compact table showing the median maximum temperature each month for each station. At a glance, we can see that the temperature in Waikiki is consistently balmy, whereas Chicago’s median high temperatures vary from just above freezing to downright pleasant. Seattle falls between the two.</p>&#13;
<p>Crosstabs do take time to set up, but viewing datasets in a matrix often makes comparisons easier than viewing the same data in a vertical list. Keep in mind that the <code>crosstab()</code> function is resource-intensive, so tread carefully when querying sets that have millions or billions of rows.</p>&#13;
<h2 id="h1-501065c13-0004">Reclassifying Values with CASE</h2>&#13;
<p class="BodyFirst">The ANSI Standard SQL <code>CASE</code> statement is a <em>conditional expression</em>, meaning it lets you add some “if this, then . . .” logic to a query. You can use <code>CASE</code> in multiple ways, but for data analysis, it’s handy for reclassifying values into categories. You can create categories based on ranges in your data and classify values according to those categories.</p>&#13;
<p>The <code>CASE</code> syntax follows this pattern:</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> CASE WHEN <var>condition</var> THEN <var>result</var>&#13;
   <span class="CodeAnnotationCode" aria-label="annotation2">2</span> WHEN <var>another_condition</var> THEN <var>result</var>&#13;
   <span class="CodeAnnotationCode" aria-label="annotation3">3</span> ELSE <var>result</var>&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> END</code></pre>&#13;
<p>We give the <code>CASE</code> keyword <span class="CodeAnnotation" aria-label="annotation1">1</span> and then provide at least one <code>WHEN </code><var>condition</var><code> THEN </code><var>result</var> clause, where <var>condition</var> is any expression the database can evaluate as <code>true</code> or <code>false</code>, such as <code>county = 'Dutchess County'</code> or <code>date &gt; '1995-08-09'</code>. If the condition is <code>true</code>, the <code>CASE</code> statement returns the <var>result</var> and stops checking any <span epub:type="pagebreak" title="242" id="Page_242"/>further conditions. The result can be any valid data type. If the condition is <code>false</code>, the database moves on to evaluate the next condition.</p>&#13;
<p>To evaluate more conditions, we can add optional <code>WHEN ... THEN</code> clauses <span class="CodeAnnotation" aria-label="annotation2">2</span>. We can also provide an optional <code>ELSE</code> clause <span class="CodeAnnotation" aria-label="annotation3">3</span> to return a result in case no condition evaluates as <code>true</code>. Without an <code>ELSE</code> clause, the statement would return a <code>NULL</code> when no conditions are <code>true</code>. The statement finishes with an <code>END</code> keyword <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>&#13;
<p><a href="#listing13-20" id="listinganchor13-20">Listing 13-20</a> shows how to use the <code>CASE</code> statement to reclassify the temperature readings into descriptive groups (named according to my own bias against cold weather).</p>&#13;
<pre><code>SELECT max_temp,&#13;
       CASE WHEN max_temp &gt;= 90 THEN 'Hot'&#13;
            WHEN max_temp &gt;= 70 AND max_temp &lt; 90 THEN 'Warm'&#13;
            WHEN max_temp &gt;= 50 AND max_temp &lt; 70 THEN 'Pleasant'&#13;
            WHEN max_temp &gt;= 33 AND max_temp &lt; 50 THEN 'Cold'&#13;
            WHEN max_temp &gt;= 20 AND max_temp &lt; 33 THEN 'Frigid'&#13;
            WHEN max_temp &lt; 20 THEN 'Inhumane'&#13;
            ELSE 'No reading'&#13;
        END AS temperature_group&#13;
FROM temperature_readings&#13;
ORDER BY station_name, observation_date;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-20">Listing 13-20</a>: Reclassifying temperature data with <code>CASE</code></p>&#13;
<p>We create six ranges for the <code>max_temp</code> column in <code>temperature_readings</code>, which we define using comparison operators. The <code>CASE</code> statement evaluates each value to find whether any of the six expressions are <code>true</code>. If so, the statement outputs the appropriate text. Note that the ranges account for all possible values in the column, leaving no gaps. If none of the statements is <code>true</code>, then the <code>ELSE</code> clause assigns the value to the category <code>No reading</code>.</p>&#13;
<p>Run the code; the first five rows of output should look like this:</p>&#13;
<pre><code>max_temp    temperature_group&#13;
--------    -----------------&#13;
      31    Frigid&#13;
      34    Cold&#13;
      32    Frigid&#13;
      32    Frigid&#13;
      34    Cold&#13;
      <var>--snip--</var></code></pre>&#13;
<p>Now that we’ve collapsed the dataset into six categories, let’s use those categories to compare climate among the three cities in the table.</p>&#13;
<h2 id="h1-501065c13-0005">Using CASE in a Common Table Expression</h2>&#13;
<p class="BodyFirst">The operation we performed with <code>CASE</code> on the temperature data in the previous section is a good example of a preprocessing step you could use in a CTE. Now that we’ve grouped the temperatures in categories, let’s count <span epub:type="pagebreak" title="243" id="Page_243"/>the groups by city in a CTE to see how many days of the year fall into each temperature category.</p>&#13;
<p><a href="#listing13-21" id="listinganchor13-21">Listing 13-21</a> shows the code for reclassifying the daily maximum temperatures recast to generate a <code>temps_collapsed</code> CTE and then use it for an analysis.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> WITH temps_collapsed (station_name, max_temperature_group) AS&#13;
    (SELECT station_name,&#13;
           CASE WHEN max_temp &gt;= 90 THEN 'Hot'&#13;
                WHEN max_temp &gt;= 70 AND max_temp &lt; 90 THEN 'Warm'&#13;
                WHEN max_temp &gt;= 50 AND max_temp &lt; 70 THEN 'Pleasant'&#13;
                WHEN max_temp &gt;= 33 AND max_temp &lt; 50 THEN 'Cold'&#13;
                WHEN max_temp &gt;= 20 AND max_temp &lt; 33 THEN 'Frigid'&#13;
                WHEN max_temp &lt; 20 THEN 'Inhumane'&#13;
                ELSE 'No reading'&#13;
            END&#13;
     FROM temperature_readings)&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> SELECT station_name, max_temperature_group, count(*)&#13;
FROM temps_collapsed&#13;
GROUP BY station_name, max_temperature_group&#13;
ORDER BY station_name, count(*) DESC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing13-21">Listing 13-21</a>: Using <code>CASE</code> in a CTE</p>&#13;
<p>This code reclassifies the temperatures and then counts and groups by station name to find general climate classifications of each city. The <code>WITH</code> keyword defines the CTE of <code>temps_collapsed</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which has two columns: <code>station_name</code> and <code>max_temperature_group</code>. We then run a <code>SELECT</code> query on the CTE <span class="CodeAnnotation" aria-label="annotation2">2</span>, performing straightforward <code>count(*)</code> and <code>GROUP BY</code> operations on both columns. The results should look like this:</p>&#13;
<pre><code>station_name                      max_temperature_group    count&#13;
------------------------------    ---------------------    -----&#13;
CHICAGO NORTHERLY ISLAND IL US    Warm                       133&#13;
CHICAGO NORTHERLY ISLAND IL US    Cold                        92&#13;
CHICAGO NORTHERLY ISLAND IL US    Pleasant                    91&#13;
CHICAGO NORTHERLY ISLAND IL US    Frigid                      30&#13;
CHICAGO NORTHERLY ISLAND IL US    Inhumane                     8&#13;
CHICAGO NORTHERLY ISLAND IL US    Hot                          8&#13;
SEATTLE BOEING FIELD WA US        Pleasant                   198&#13;
SEATTLE BOEING FIELD WA US        Warm                        98&#13;
SEATTLE BOEING FIELD WA US        Cold                        50&#13;
SEATTLE BOEING FIELD WA US        Hot                          3&#13;
WAIKIKI 717.2 HI US               Warm                       361&#13;
WAIKIKI 717.2 HI US               Hot                          5</code></pre>&#13;
<p>Using this classification scheme, the amazingly consistent Waikiki weather, with <code>Warm</code> maximum temperatures 361 days of the year, confirms its appeal as a vacation destination. From a temperature standpoint, Seattle looks good too, with nearly 300 days of <code>Pleasant</code> or <code>Warm</code> high temps (although this belies Seattle’s legendary rainfall). Chicago, with 30 days of <code>Frigid</code> max temps and 8 days <code>Inhumane</code>, probably isn’t for me.</p>&#13;
<h2 id="h1-501065c13-0006"><span epub:type="pagebreak" title="244" id="Page_244"/>Wrapping Up</h2>&#13;
<p class="BodyFirst">In this chapter, you learned to make queries work harder for you. You can now add subqueries in multiple locations to provide finer control over filtering or preprocessing data before analyzing it in a main query. You also can visualize data in a matrix using cross tabulations and reclassify data into groups; both techniques give you more ways to find and tell stories using your data. Great work!</p>&#13;
<p>Throughout the next chapters, we’ll dive into SQL techniques that are more specific to PostgreSQL. We’ll begin by working with and searching text and strings.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>Try It Yourself</h2>&#13;
<p class="BoxBodyFirst">Perform the following two tasks to help you become more familiar with the concepts introduced in the chapter:</p>&#13;
<ol>&#13;
<li value="1">Revise the code in <a href="#listing13-21">Listing 13-21</a> to dig deeper into the nuances of Waikiki’s high temperatures. Limit the <code>temps_collapsed</code> table to the Waikiki maximum daily temperature observations. Then use the <code>WHEN</code> clauses in the <code>CASE</code> statement to reclassify the temperatures into seven groups that would result in the following text output:&#13;
<pre><code>'90 or more'&#13;
'88-89'&#13;
'86-87'&#13;
'84-85'&#13;
'82-83'&#13;
'80-81'&#13;
'79 or less'</code></pre>&#13;
<p>In which of those groups does Waikiki’s daily maximum temperature fall most often?</p>&#13;
</li>&#13;
<li value="2">Revise the ice cream survey crosstab in <a href="#listing13-17">Listing 13-17</a> to flip the table. In other words, make <code>flavor</code> the rows and <code>office</code> the columns. Which elements of the query do you need to change? Are the counts different?</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div></body></html>