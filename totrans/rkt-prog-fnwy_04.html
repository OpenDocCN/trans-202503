<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_75"/><span class="big">4</span><br/>PLOTTING, DRAWING, AND A BIT OF SET THEORY</h2>&#13;
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">In this chapter, we’ll explore how to exploit DrRacket’s ability to display graphical information. In particular, we’ll look at various ways of generating two-dimensional function plots as well as using some built-in graphics primitives (circles, rectangles, and so on) to create more-complex drawings. After introducing the basics, we’ll look at a few extended applications, involving set theory, the golden spiral, and the game of Nim.</p>&#13;
<h3 class="h3" id="ch00lev1sec_24">Plotting</h3>&#13;
<p class="noindent">All plotting functions will require the <em>plot</em> library, so be sure to execute the following before trying any of the examples in this section.</p>&#13;
<pre>&gt; <span class="codestrong1">(require plot)</span></pre>&#13;
<p class="indent">With that out of the way, let’s begin with something simple and familiar.</p>&#13;
<h4 class="h4" id="ch00lev2sec_27"><span epub:type="pagebreak" id="page_76"/><strong><em>X-Y Plots</em></strong></h4>&#13;
<p class="noindent">All two-dimensional plots use the <code>plot</code> function. This function takes either a single function or a list of functions, and generates a plot for each. Once a plot has been generated, if desired, it can be saved as a bitmap by right-clicking on the plot and clicking Save Image. . . from the pop-up menu.</p>&#13;
<p class="indent">The <code>plot</code> function accepts a number of keyword arguments (all of which are optional), but as a minimum, it’s probably a good idea to specify the plot limits since DrRacket can’t always determine the proper plot bounds. Here’s an example of generating a simple plot of the sine function:</p>&#13;
<pre>(plot (function sin #:color "Blue")&#13;
      #:x-min (* -2 pi) #:x-max (* 2 pi)&#13;
      #:title "The Sine Function")</pre>&#13;
<p class="indent">The result is shown in <a href="ch04.xhtml#ch4fig1">Figure 4-1</a>. Please note that figures are shown in grayscale, but when you input the code on your computer, graphs will appear in color.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig01.jpg"/></div>&#13;
<p class="figcap" id="ch4fig1"><em>Figure 4-1: Example plot using sine function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_77"/>Notice that the <code>sin</code> function is enclosed in a <code>function</code> form. The <code>function</code> is something called a <em>renderer</em>; it controls how the function argument passed to it gets rendered. The <code>function</code> form allows you to add optional keyword parameters to control how the individual function is displayed. In this case we specify that the sine function is rendered in a blue color.</p>&#13;
<p class="indent">The following code creates a plot that displays both the sine and cosine functions by combining them into a list.</p>&#13;
<pre>(plot (list&#13;
       (axes) ; can also use (axis x y) to specify location&#13;
       (function sin #:color "Blue" #:label "sin" #:style 'dot)&#13;
       (function cos 0 (* 2 pi) #:color "red"  #:label "cos"))&#13;
      #:x-min (* -2 pi) #:x-max (* 2 pi)&#13;
      #:y-min -2 #:y-max 2&#13;
      #:title "Sine and Cosine" &#13;
      #:x-label "X" &#13;
      #:y-label #f) ; suppress y-axis label</pre>&#13;
<p class="indent">The resulting plot is shown in <a href="ch04.xhtml#ch4fig2">Figure 4-2</a>. Notice that we’ve specified a narrower plot range for the cosine function and added text labels to both functions so that they can easily be differentiated on the plot. We’ve also overridden the default labels with specific values.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig02.jpg"/></div>&#13;
<p class="figcap" id="ch4fig2"><em>Figure 4-2: The sine and cosine functions</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_78"/>The following code demonstrates some additional plotting capabilities (see <a href="ch04.xhtml#ch4fig3">Figure 4-3</a> for the output).</p>&#13;
<pre>(plot (list (axes)&#13;
            (function sin #:color "Blue" #:label "sin" #:style 'dot)&#13;
            (inverse sqr -2 2 #:color "red" #:label "x^2" #:width 2))&#13;
      #:x-min (* -2 pi) #:x-max (* 2 pi)&#13;
      #:y-min -2 #:y-max 2&#13;
      #:title "Sine and Square" &#13;
      #:x-label "X" &#13;
      #:y-label #f&#13;
      #:legend-anchor 'bottom-left)</pre>&#13;
<p class="indent">Notice that we’re using a new <code>inverse</code> form in our list of functions to plot. This form works by using the y-axis as the axis for the independent variable. In this way, we effectively plot the inverse function without actually having to derive it algebraically. In addition we’ve specified some additional styles to help differentiate the plot curves. The sine curve is printed dotted, and the inverse square function is printed with a thicker line. The plot legend has been moved to the lower left corner by specifying <code>#:legend-anchor</code> ’<code>bottom-left</code> as an optional value to the <code>plot</code> function.</p>&#13;
<p class="indent">If you run the code, you should get something like <a href="ch04.xhtml#ch4fig3">Figure 4-3</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig03.jpg"/></div>&#13;
<p class="figcap" id="ch4fig3"><em>Figure 4-3: Sine and inverse square</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_79"/>Next we take a look at parametric plots.</p>&#13;
<h4 class="h4" id="ch00lev2sec_28"><strong><em>Parametric Plots</em></strong></h4>&#13;
<p class="noindent">A curve in a plane is said to be parameterized if the coordinates of the curve, (x, y), are represented by functions of a variable (or <em>parameter</em>), say <em>t</em>. Let’s look at an example.</p>&#13;
<h5 class="h5" id="ch00lev3sec_42"><strong>Parameterizing a Circle</strong></h5>&#13;
<p class="noindent">The standard definition of a circle centered at the origin is the set of all points equidistant from the origin. We can state this definition either algebraically as an implicit equation or via a pair of trigonometric expressions as illustrated in <a href="ch04.xhtml#ch4fig4">Figure 4-4</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig04.jpg"/></div>&#13;
<p class="figcap" id="ch4fig4"><em>Figure 4-4: Circle definitions</em></p>&#13;
<p class="indent">In <a href="ch04.xhtml#ch4fig4">Figure 4-4</a> (a), the circle is defined by this algebraic expression:</p>&#13;
<p class="center"><em>r</em><sup>2</sup> = <em>x</em><sup>2</sup> + <em>y</em><sup>2</sup></p>&#13;
<p class="noindent">To plot this as an x-y plot, we have to explicitly express <em>y</em> in terms of <em>x</em>, where the positive values of the expression give the top half of the circle and the negative values give the bottom half:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p079-01.jpg"/></div>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig4">Figure 4-4</a> (b) illustrates defining the circle in terms of the parameter <em>θ</em>. In this case the x- and y-coordinates of the curve are given by the trigonometric expressions cos <em>θ</em> and sin <em>θ</em> respectively.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>In Racket, parametric curves are defined in terms of a function that takes the parameter as its argument and returns a <code>vector</code> containing the computed values of <em>x</em> and <em>y</em>. The code below plots both the algebraic and the parametric versions of the circles. We’ve offset the parametric version so that it appears to the right of the algebraic version (see <a href="ch02.xhtml">Chapter 2</a> for information on the <code>infix</code> package and usage of <code>@</code> below).</p>&#13;
<pre>   #lang at-exp racket&#13;
   (require infix plot)&#13;
&#13;
   (define r 30)&#13;
   (define off (+ 5 (* 2 r)))&#13;
&#13;
   ; algebraic half-circles&#13;
<span class="ent">➊</span> (define (c1 x) @${ sqrt[r^2 - x^2]})&#13;
<span class="ent">➋</span> (define (c2 x) @${-sqrt[r^2 - x^2]})&#13;
&#13;
   ; parametric circle&#13;
<span class="ent">➌</span> (define (cp t) @${vector[off + r*cos[t], r*sin[t]]})&#13;
&#13;
   (plot (list&#13;
          (axes)&#13;
          (function c1 (- r) r #:color "blue" #:label "c1")&#13;
          (function c2 (- r) r #:style 'dot #:label "c2")&#13;
     <span class="ent">➍</span> (parametric cp 0 (* 2 pi) #:color "red" #:label "cp" #:width 2))&#13;
         #:x-min (- r)&#13;
         #:x-max (+ off r)&#13;
         #:y-min (- r)&#13;
         #:y-max (+ off r)&#13;
         #:legend-anchor 'top-right)</pre>&#13;
<p class="indent">We’ve made use of the <code>infix</code> package and the <code>at-exp</code> language extension so that we can present the algebraic expressions in a more natural form. We begin with definitions of the half-circle functions <code>c1</code> <span class="ent">➊</span> and <code>c2</code> <span class="ent">➋</span>. The parametric version is given as <code>cp</code> <span class="ent">➌</span>. Notice that <code>cp</code> is housed in a form that begins with <code>parametric</code> <span class="ent">➍</span> and a plot range specified as 0 to 2<em>π</em>. The output of this code is shown in <a href="ch04.xhtml#ch4fig5">Figure 4-5</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_81"/><img alt="Image" src="../images/04fig05.jpg"/></div>&#13;
<p class="figcap" id="ch4fig5"><em>Figure 4-5: Explicit versus parametric plots</em></p>&#13;
<h5 class="h5" id="ch00lev3sec_43"><strong>Circles in Motion</strong></h5>&#13;
<p class="noindent">Let’s face it: static circles are pretty boring. In this section we’ll take a look at circles in motion. Specifically, we’ll examine the path that a fixed point on a circle takes as it rolls along a straight line without slipping. The curve that describes this path is called a <em>cycloid</em>. We set the scene in <a href="ch04.xhtml#ch4fig6">Figure 4-6</a>, where a circle of radius <em>r</em> has rolled distance <em>x</em> from the origin. The point of interest is the dot marked with a <em>P</em>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig06.jpg"/></div>&#13;
<p class="figcap" id="ch4fig6"><em>Figure 4-6: Cycloid scene</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>Let’s take a look at the math needed to create a parametric plot of point <em>P</em> that lies on a circle with radius <em>r</em> rolling without slipping on a straight line.</p>&#13;
<p class="indent">Since the circle rolls without slipping, the length of the arc from <em>x</em> to <em>P</em> is equal to <em>d</em>. We can express this as <em>d</em> = <em>θr</em>. Thus, as the circle rotates by angle <em>θ</em>, the x-coordinate of <em>P</em> is <em>d - r</em>sin<em>θ</em>. But <em>d</em> = <em>rθ</em>, so <em>x</em> = <em>rθ - r</em>sin<em>θ</em> = <em>r</em>(<em>θ -</em> sin<em>θ</em>). It’s clear that <em>y</em> is simply given by <em>y</em> = <em>r</em>(1 <em>-</em> cos<em>θ</em>). Here’s the code for the plot:</p>&#13;
<pre>#lang at-exp racket&#13;
(require infix plot)&#13;
&#13;
(define r 30)&#13;
&#13;
(define (cycloid t) @${vector[r*(t - sin[t]),  r*(1-cos[t])]})&#13;
&#13;
(plot (list&#13;
       (axes)&#13;
       (parametric cycloid 0 (* 2 pi)&#13;
                   #:color "red"&#13;
                   #:samples 1000))&#13;
      #:x-min 0&#13;
      #:x-max (* r 2 pi)&#13;
      #:y-min 0&#13;
      #:y-max (* r 2 pi))</pre>&#13;
<p class="indent">In this case we’ve used the <code>#:samples</code> keyword to increase the number of samples used to generate the plot, giving it a smoother appearance. Here’s the plot.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p082.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>The plot curve has been superimposed on the original scene setup in <a href="ch04.xhtml#ch4fig7">Figure 4-7</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig08.jpg"/></div>&#13;
<p class="figcap" id="ch4fig7"><em>Figure 4-7: Cycloid</em></p>&#13;
<p class="indent">Later we’ll see how to animate this so that we can actually see it in motion.</p>&#13;
<h5 class="h5" id="ch00lev3sec_44"><strong>The Hypocycloid</strong></h5>&#13;
<p class="noindent">Instead of having our circle rolling on a straight line, we could have it rolling on another circle. Indeed, if the one circle is larger than the other, we could have the smaller circle rolling inside the larger circle. A curve generated in this fashion is called a <em>hypocycloid</em>. Here we create a parametric plot for a hypocycloid based on a circle with radius <em>r</em> and a larger circle with radius <em>R</em> where the smaller circle rolls without slipping in the interior of the larger circle. We assume that the larger circle is centered at the origin (<a href="ch04.xhtml#ch4fig8">Figure 4-8</a>).</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig09.jpg"/></div>&#13;
<p class="figcap" id="ch4fig8"><em>Figure 4-8: Hypocycloid setup</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_84"/>Since the circle rolls without slipping, the arc length <em>s</em> is given by <em>s</em> = <em>rθ</em> = R<em>ϕ</em>, so <img alt="Image" src="../images/p084.jpg"/>. The center of the smaller circle (<em>q</em> in the diagram) is at a distance <em>R - r</em> from the origin. To assist in our analysis, we’ve zoomed in on the smaller circle and provided some additional guidelines in <a href="ch04.xhtml#ch4fig9">Figure 4-9</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/p0084-01.jpg"/></div>&#13;
<p class="figcap" id="ch4fig9"><em>Figure 4-9: Setup zoomed in</em></p>&#13;
<p class="indent">Note the following:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0084-03.jpg"/></div>&#13;
<p class="indent">From this it’s clear that the x-coordinate of <em>P</em> is given by the following:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0084-04.jpg"/></div>&#13;
 <p class="indent">Likewise the y-coordinate of <em>P</em> is given by the following:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p084-6.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_85"/>We put this all together in the following Racket code:</p>&#13;
<pre>#lang at-exp racket&#13;
(require infix plot)&#13;
&#13;
(define r 20)&#13;
(define R (* r 3))&#13;
&#13;
(define (hypocycloid phi)&#13;
  @${vector[&#13;
    (R-r)*cos[phi] + r*cos[(R-r)/r * phi],&#13;
    (R-r)*sin[phi] - r*sin[(R-r)/r * phi]]})&#13;
&#13;
(plot (list&#13;
       (parametric (λ (t) @${vector[R*cos[t], R*sin[t]]})&#13;
                   0 (* r 2 pi)&#13;
                   #:color "black"&#13;
                   #:width 2)&#13;
       (parametric hypocycloid&#13;
                   0 (* r 2 pi)&#13;
                   #:color "red"&#13;
                   #:width 2))&#13;
      #:x-min (- -10 R ) #:x-max (+ 10 R )&#13;
      #:y-min (- -10 R ) #:y-max (+ 10 R )&#13;
      #:x-label #f #:y-label #f&#13;
      )</pre>&#13;
<p class="indent">You may enjoy the fruits of our labor in <a href="ch04.xhtml#ch4fig10">Figure 4-10</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig11.jpg"/></div>&#13;
<p class="figcap" id="ch4fig10"><em>Figure 4-10: Hypocycloid plot</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_86"/>To whet your appetite to further explore these fascinating curves, here’s another question for you: for what ratio of radii is a hypocycloid a straight line?</p>&#13;
<h4 class="h4" id="ch00lev2sec_29"><strong><em>Getting to the Point</em></strong></h4>&#13;
<p class="noindent">So far we’ve concentrated on generating continuous curves, but what if you want to plot individual points? Yes, Grasshopper, this too is possible. A <em>point</em>, from a plotting perspective, is just a vector with two numbers in it. For example, <code>#(1 2)</code> is a point. To plot a set of points, you just need to provide the <code>plot</code> routine a list consisting of vector points. Here’s an example:</p>&#13;
<pre>#lang racket&#13;
(require plot)&#13;
&#13;
(parameterize ([plot-width    250]&#13;
               [plot-height   250]&#13;
               [plot-x-label  #f]&#13;
               [plot-y-label  #f])&#13;
&#13;
  (define lim 30)&#13;
  (plot (list&#13;
         (points '(#(0 0))&#13;
                 #:size 300&#13;
                 #:sym 'fullcircle1&#13;
                 #:color "black"&#13;
                 #:fill-color "yellow")&#13;
         (points '(#(-5 5) #(5 5))&#13;
                 #:size 10&#13;
                 #:fill-color "black")&#13;
         (points '(#(0 -5))&#13;
                 #:size 30&#13;
                 #:sym 'fullcircle1&#13;
                 #:color "black"&#13;
                 #:fill-color "black"))&#13;
        #:x-min (- lim) #:x-max (+ lim)&#13;
        #:y-min (- lim) #:y-max (+ lim)))</pre>&#13;
<p class="indent">And here’s the output in <a href="ch04.xhtml#ch4fig11">Figure 4-11</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_87"/><img alt="Image" src="../images/04fig12.jpg"/></div>&#13;
<p class="figcap" id="ch4fig11"><em>Figure 4-11: A face drawn with points</em></p>&#13;
<p class="indent">In this case we’re using the <code>parameterize</code> form, which lets us specify the physical size of the plot in pixels (<code>plot-width</code> and <code>plot-height</code>) and suppress the plot labels. Note that the <code>#:size</code> keyword parameter is also expressed in pixels. The first point list is a single point that we use for the face. The <code>#:sym</code> keyword argument specifies what type of symbol to use to print the point. We’re using a filled circle specified by the symbol ’<code>fullcircle</code> for the face. There’s a large variety of predefined symbols (search for “known-point-symbols” in the documentation), but you may also use a Unicode character or a string.</p>&#13;
<p class="indent">Now that we have the ability to plot points, we can connect them together with lines using the <code>line</code> form. Like points, lines consist of a list of two-element vectors. The <code>plot</code> routine treats this list as a sequence of line segment end points and plots them appropriately. Here’s an example.</p>&#13;
<pre>#lang racket&#13;
(require plot)&#13;
&#13;
(define pts (for/list ([i (in-range 0 6)]) (vector i (sqr i))))&#13;
&#13;
(plot (list&#13;
       (lines pts&#13;
               #:width 2&#13;
               #:color "green")&#13;
       (points pts&#13;
               #:sym 'fulldiamond&#13;
               #:color "red"&#13;
               #:fill-color "red"))&#13;
      #:x-min -0.5 #:x-max 5.5&#13;
      #:y-min -0.5 #:y-max 26)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>The resulting plot is shown in <a href="ch04.xhtml#ch4fig12">Figure 4-12</a>:</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig13.jpg"/></div>&#13;
<p class="figcap" id="ch4fig12"><em>Figure 4-12: Plotting lines and points</em></p>&#13;
<h4 class="h4" id="ch00lev2sec_30"><strong><em>Polar Plots</em></strong></h4>&#13;
<p class="noindent">Polar plots are created with . . . (you guessed it!) the <code>polar</code> form. The <code>polar</code> form is supplied with a function that returns the distance from the origin when supplied with an angle of rotation. The simplest possible function to be used in a polar plot is that of a unit circle, which in the guise of a lambda expression would be <code>(</code>λ <code>(</code>θ<code>) 1)</code>. A slightly more ambitious example would be that of a counterclockwise spiral defined as <code>(</code>λ <code>(</code>θ<code>)</code> θ<code>)</code>. Here’s the code for both plots:</p>&#13;
<pre>(parameterize&#13;
    ([plot-width 150]&#13;
     [plot-height 150]&#13;
     [plot-tick-size 0]&#13;
     [plot-font-size 0]&#13;
     [plot-x-label  #f]&#13;
     [plot-y-label  #f])&#13;
     &#13;
  <span epub:type="pagebreak" id="page_89"/>(list (plot (polar (λ (<span class="codeitalic1">θ</span>) 1) 0 (* 2 pi))&#13;
              #:x-min -1 #:x-max 1&#13;
              #:y-min -1 #:y-max 1)&#13;
        (plot (polar (λ (<span class="codeitalic1">θ</span>) <span class="codeitalic1">θ</span>) 0 (* 2.5 pi))&#13;
              #:x-min -8 #:x-max 8&#13;
              #:y-min -8 #:y-max 8)&#13;
        ))</pre>&#13;
<p class="indent">We’ve taken advantage of some plot parameters to suppress the axis tick marks and labels. This code produces the following output in <a href="ch04.xhtml#ch4fig13">Figure 4-13</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig14.jpg"/></div>&#13;
<p class="figcap" id="ch4fig13"><em>Figure 4-13: Basic polar plots</em></p>&#13;
<p class="indent">Notice that the plots are in a list. In Racket a plot is just another data value.</p>&#13;
<p class="indent">Let’s produce the plot shown in <a href="ch04.xhtml#ch4fig14">Figure 4-14</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig15.jpg"/></div>&#13;
<p class="figcap" id="ch4fig14"><em>Figure 4-14: The polar rose</em></p>&#13;
<p class="indent">We need a function that goes from 0 to 1 and back to 0 again. Sounds like the sine function. We need it to take these values as it goes from 0 to <em>π</em>/2 (and repeating up to 2<em>π</em>), so the function we need is <em>r</em><sub><em>θ</em></sub> = sin(2<em>θ</em>). The code to plot this is then the following:</p>&#13;
<pre>#lang at-exp racket&#13;
(require infix plot)&#13;
&#13;
(parameterize&#13;
    <span epub:type="pagebreak" id="page_90"/>([plot-width 200]&#13;
     [plot-height 200]&#13;
     [plot-tick-size 0]&#13;
     [plot-font-size 0]&#13;
     [plot-x-label  #f]&#13;
     [plot-y-label  #f])&#13;
  &#13;
  (plot (list&#13;
         (polar-axes #:number 8)&#13;
         (polar (λ (t) @${sin[2*t]})  0 (* 2 pi)&#13;
         #:x-min -1 #:x-max 1&#13;
         #:y-min -1 #:y-max 1))))</pre>&#13;
<p class="indent">With the small addition of parameter <em>k</em> to the function <em>r</em><sub><em>θ</em></sub> = sin(<em>kθ</em>), it’s possible to produce a large variety of interesting curves (see <a href="ch04.xhtml#ch4fig15">Figure 4-15</a>).</p>&#13;
<pre>(parameterize&#13;
     ([plot-width 200]&#13;
     [plot-height 200]&#13;
     [plot-tick-size 0]&#13;
     [plot-font-size 0]&#13;
     [plot-x-label  #f]&#13;
     [plot-y-label  #f])&#13;
     &#13;
  (define (rose k)&#13;
    (plot (polar (λ (t) @${sin[k*t]})  0 (* 4 pi)&#13;
                 #:x-min -1 #:x-max 1&#13;
                 #:y-min -1 #:y-max 1)))&#13;
  (for/list ([k '(1 1.5 2 2.5 3 4 5)]) (rose k)))</pre>&#13;
<div class="image"><img alt="Image" src="../images/04fig16.jpg"/></div>&#13;
<p class="figcap" id="ch4fig15"><em>Figure 4-15: Polar roses</em></p>&#13;
<p class="indent">As another example of a polar plot, here’s the code we used to produce the golden spiral first introduced on <a href="ch03.xhtml#page_68">page 68</a> in <a href="ch03.xhtml">Chapter 3</a> and reproduced here in <a href="ch04.xhtml#ch4fig16">Figure 4-16</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_91"/>(define <span class="codeitalic1">ϕ</span> (/ (add1 (sqrt 5)) 2))&#13;
(define π pi)&#13;
(plot (polar (λ (<span class="codeitalic1">θ</span>) (expt <span class="codeitalic1">ϕ</span> (* <span class="codeitalic1">θ</span> (/ 2 π))))&#13;
             0 (* 4 pi)&#13;
             #:x-min -20 #:x-max 50&#13;
             #:y-min -40 #:y-max 30&#13;
             #:color "red")&#13;
      #:title "Golden Spiral"&#13;
      #:x-label #f ; suppress axis labels&#13;
      #:y-label #f)</pre>&#13;
<p class="indent">So now we have the actual code used to generate the golden spiral we first encountered in <a href="ch03.xhtml">Chapter 3</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig17.jpg"/></div>&#13;
<p class="figcap" id="ch4fig16"><em>Figure 4-16: The golden spiral</em></p>&#13;
<p class="indent">While we’ve tried to give a good overview of the plotting capabilities that DrRacket affords, there’s even more: contours, interval graphs, error bars, vector fields, the list goes on. I encourage you to consult the documentation for additional topics that may be of interest to you. For now, though, we’ll be moving on to creating drawings using graphics primitives.</p>&#13;
<h3 class="h3" id="ch00lev1sec_25">Drawing</h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_92"/>Drawing in Racket requires something called a <em>drawing context (DC)</em>. You can think of this as a canvas where the drawing takes place. Drawing contexts can be set up for various objects such as bitmaps, PostScript files, or a Racket GUI application.</p>&#13;
<p class="indent">Unlike coordinates used for plotting functions, drawing contexts use coordinates where the y-axis is inverted as shown in <a href="ch04.xhtml#ch4fig17">Figure 4-17</a>. Note that the origin is at the upper left corner of the canvas.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig18.jpg"/></div>&#13;
<p class="figcap" id="ch4fig17"><em>Figure 4-17: Drawing coordinates</em></p>&#13;
<p class="indent">All drawings created using the Racket drawing library will need to import the <em>draw</em> library, like so:</p>&#13;
<pre>&gt; <span class="codestrong1">(require racket/draw)</span></pre>&#13;
<p class="indent">In this section, we’ll focus on creating simple drawings using a bitmap drawing context. To create such a context, we need a bitmap (via <code>make-bitmap</code> as shown below):</p>&#13;
<pre>&gt; <span class="codestrong1">(define drawing (make-bitmap 50 50)) ; a 50x50 bitmap</span></pre>&#13;
<p class="noindent">We also need a bitmap drawing context:</p>&#13;
<pre>&gt; <span class="codestrong1">(define dc (new bitmap-dc% [bitmap drawing]))</span></pre>&#13;
<p class="indent">Next, we need some drawing tools. In real life we use pens to draw lines and brushes to fill in areas on a canvas; with Racket it’s much the same. We can tell Racket the type of pen we want to use in a couple of ways:</p>&#13;
<pre>&gt; <span class="codestrong1">(send dc set-pen "black" 2 'solid)</span>&#13;
&gt; <span class="codestrong1">(send dc set-pen (new pen% [color "black"] [width 2] [style 'solid]))</span></pre>&#13;
<p class="indent">The first method is a quick and dirty way of setting a solid black pen with a width of 2. The second method creates a <em>pen object</em> and sends it to the <span epub:type="pagebreak" id="page_93"/>drawing context. Colors can be specified as either a string name as shown above, or a color object where red, green, blue, and optionally alpha (transparency) values can be specified. Each of these values must fall in the range 0–255 (inclusive). For example the following inputs will create a cyan color object and set the drawing context to use it.</p>&#13;
<pre>&gt; <span class="codestrong1">(define cyan (make-object color% 0 255 255))</span>&#13;
&gt; <span class="codestrong1">(send dc set-pen cyan 2 'solid)</span></pre>&#13;
<p class="indent">An equivalent, but slightly more efficient way to perform the above would be the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(define cyan (make-color 0 255 255))</span>&#13;
&gt; <span class="codestrong1">(send dc set-pen cyan 2 'solid)</span></pre>&#13;
<p class="indent">Brushes control the type of fill used inside of two-dimensional objects like rectangles and circles. Like pens, brushes can be defined in a couple of different ways:</p>&#13;
<pre>&gt; <span class="codestrong1">(send dc set-brush "blue" 'cross-hatch)</span>&#13;
&gt; <span class="codestrong1">(send dc set-brush (new brush% [color "red"] [style 'solid]))</span></pre>&#13;
<p class="indent">The first example will create a brush that produces a blue cross-hatch fill. The second example uses a <em>brush object</em> that has a solid red fill. An equivalent but slightly different way to achieve the same effect in the second example would be the following:</p>&#13;
<pre>(send dc set-brush (make-brush #:color "red" #:style 'solid))</pre>&#13;
<p class="indent">With these preliminaries out of the way, we can actually start drawing by using <code>send</code> to send drawing commands to the drawing context. To draw a single line segment, we would input the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(send dc draw-line 10 10 30 25)</span></pre>&#13;
<p class="indent">This would draw a line segment beginning at (10, 10) and ending at (30, 25). We have added the line to the drawing context, but it’s not immediately displayed. To actually see the line, we do the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(print drawing)</span></pre>&#13;
<p class="indent">This produces the following:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p093-01.jpg"/></div>&#13;
<p class="indent">Remember that <code>drawing</code> was defined earlier and is the actual bitmap we are drawing to.</p>&#13;
<p class="indent">Rectangles are just as easy to produce:</p>&#13;
<pre>&gt; <span class="codestrong1">(send dc draw-rectangle 0 0 50 25)</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_94"/>The first two parameters (0, 0) are the x- and y-coordinates of the upper left corner of the rectangle. The next two are the width and height.</p>&#13;
<p class="indent">Circles and ellipses are handled in a similar fashion.</p>&#13;
<pre>&gt; <span class="codestrong1">(send dc draw-ellipse 10 10 30 25)</span></pre>&#13;
<p class="indent">In this case the parameters specify a <em>bounding box</em> that contains the ellipse, where again the first two parameters are the x- and y-coordinates of the upper left corner of the bounding rectangle and the next two are its width and height (see the gray area in <a href="ch04.xhtml#ch4fig18">Figure 4-18</a>—we’ll discuss the wedge shape later).</p>&#13;
<div class="image"><img alt="Image" src="../images/p0094-01.jpg"/></div>&#13;
<p class="figcap" id="ch4fig18"><em>Figure 4-18: Ellipse bounding box</em></p>&#13;
<p class="indent">To display the drawing, we simply print the variable (<code>drawing</code>) that contains the bitmap we’ve been drawing to (via the drawing context <code>dc</code>):</p>&#13;
<pre>&gt; <span class="codestrong1">(print drawing)</span></pre>&#13;
<p class="indent">It produces this:</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig19.jpg"/></div>&#13;
<p class="indent">Text can be added to a drawing with the <code>draw-text</code> method.</p>&#13;
<pre>&gt; <span class="codestrong1">(send dc draw-text "Hello, World!" 10 10)</span></pre>&#13;
<p class="indent">In this case, the last two parameters specify the x- and y-coordinates of the upper left corner of the text.</p>&#13;
<p class="indent">To pull these ideas together, here is some simple code to draw a crude automobile.</p>&#13;
<pre>#lang racket&#13;
&#13;
(require racket/draw)&#13;
&#13;
<span epub:type="pagebreak" id="page_95"/>(define drawing (make-bitmap 200 100)) ; a 200x100 bitmap&#13;
(define dc (new bitmap-dc% [bitmap drawing]))&#13;
&#13;
; background&#13;
(send dc set-brush (new brush% [color "yellow"]))&#13;
(send dc draw-rectangle 0 0 200 100)&#13;
&#13;
; antenna&#13;
(send dc draw-line 160 5 160 50)&#13;
(send dc set-brush (new brush% [color "gray"]))&#13;
(send dc draw-rectangle 155 45 10 5)&#13;
&#13;
; body&#13;
(send dc set-pen "black" 2 'solid)&#13;
(send dc set-brush (new brush% [color "gray"]))&#13;
(send dc draw-rectangle 60 20 80 30)&#13;
&#13;
(send dc set-brush (new brush% [color "red"]))&#13;
(define c (make-object color% 0 255 255))&#13;
(send dc set-pen c 2 'solid)&#13;
(send dc draw-rectangle 20 50 160 30)&#13;
&#13;
; wheels&#13;
(send dc set-pen "black" 2 'solid)&#13;
(send dc set-brush (new brush% [color "blue"]))&#13;
(send dc draw-ellipse  40 60 40 40)&#13;
(send dc draw-ellipse 120 60 40 40)&#13;
&#13;
(send dc draw-text "This is a car?" 5 1)&#13;
&#13;
(print drawing)</pre>&#13;
<p class="indent">Running this code will produce the the stunning work of art shown in <a href="ch04.xhtml#ch4fig19">Figure 4-19</a>. Depending on your computer the output may look a bit different (primarily due to how fonts are handled).</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig20.jpg"/></div>&#13;
<p class="figcap" id="ch4fig19"><em>Figure 4-19: A stunning work of art</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_96"/>The drawing library contains much more functionality than we’ve illustrated here, but we’ve learned enough to get started. We’ll make practical use of our new skills (and learn some new ones) in the next sections.</p>&#13;
<h3 class="h3" id="ch00lev1sec_26">Set Theory</h3>&#13;
<p class="noindent">You might be thinking that a chapter on graphics is an odd place to host a discussion about set theory, and you’d be right. But it’s easier to understand set theory when you can see it, and we can use DrRacket’s excellent graphics capabilities to illustrate various basic concepts about set theory. We’ll also get to see some additional features of the graphics library.</p>&#13;
<h4 class="h4" id="ch00lev2sec_31"><strong><em>The Basics</em></strong></h4>&#13;
<p class="noindent">A <em>set</em> is just some arbitrary collection of things, such as <em>{</em>5, 1/2, 7, 12<em>}</em> or <em>{</em>car, bus, train<em>}</em>. One distinguishing feature of a mathematical set is that a mathematical set is not allowed to contain two identical objects. For example <em>{</em>8, 2, 9, 2<em>}</em> is <em>not</em> a set, since the number 2 occurs twice (such a thing is typically called a <em>bag</em> or <em>multiset</em>). We can indicate that something is in a set by the <em>member</em> (or <em>in</em>) symbol: ∈. For instance 5 ∈ <em>{</em>8, 2, 5, 9, 3<em>}</em>. Likewise, we can specify that something is not in a set by the not-member symbol: ∉, as in 7 ∉ <em>{</em>8, 2, 9, 3<em>}</em>.</p>&#13;
<p class="indent">In Racket, a set can be represented by an object called a <em>hash set</em>. A hash set can be either mutable or immutable, depending on how it’s constructed. A mutable hash set is created with the <code>mutable-set</code> form and an immutable set is constructed with the <code>set</code> form. We can test whether an element is a member of a hash set with <code>set-member?</code>. Elements can be added to a mutable set by the <code>set-add!</code> form and a new set can be created from an old (immutable) one by the <code>set-add</code> form.</p>&#13;
<p class="indent">In the examples that follow, <code>mset</code> will designate a mutable set and <code>iset</code> will designate an immutable set.</p>&#13;
<pre>   &gt; <span class="codestrong1">(define mset {mutable-set 5 1/2 7 12 1/2})</span>&#13;
   &gt; <span class="codestrong1">mset</span>&#13;
   (mutable-set 5 1/2 7 12)&#13;
   &#13;
   &gt; <span class="codestrong1">(set-member? mset 7)</span>&#13;
   #t&#13;
   &#13;
   &gt; <span class="codestrong1">(set-member? mset 9)</span>&#13;
   #f&#13;
   &#13;
<span class="ent">➊</span> &gt; <span class="codestrong1">(set-add mset 9)</span>&#13;
   . . set-add:&#13;
     expected: (not/c set-mutable?)&#13;
     given mutable set: (mutable-set 5 1/2 7 12)&#13;
     argument position: 1st&#13;
     &#13;
   <span epub:type="pagebreak" id="page_97"/>&gt; <span class="codestrong1">(set-add! mset 9)</span>&#13;
   &gt; <span class="codestrong1">mset</span>&#13;
   (mutable-set 5 1/2 7 9 12)&#13;
   &#13;
<span class="ent">➋</span> &gt; <span class="codestrong1">(set-add! mset 7)</span>&#13;
   &gt; <span class="codestrong1">mset</span>&#13;
   (mutable-set 5 1/2 7 9 12)&#13;
   &#13;
   &gt; <span class="codestrong1">(define iset (set 3 8 9 7 4))</span>&#13;
   &#13;
   &gt; <span class="codestrong1">iset</span>&#13;
   (set 9 3 7 4 8)&#13;
   &#13;
   &gt; <span class="codestrong1">(set-add iset 2)</span>&#13;
   (set 9 3 7 2 4 8)&#13;
   &#13;
   &gt; <span class="codestrong1">(set-add iset 3) ; note, no change in output</span>&#13;
   (set 9 3 7 2 4 8)&#13;
   &#13;
<span class="ent">➌</span> &gt; <span class="codestrong1">(set-add! iset 2)</span>&#13;
   . . set-add!:&#13;
     expected: set-mutable?&#13;
     given immutable set: (set 9 3 7 4 8)&#13;
     argument position: 1st</pre>&#13;
<p class="indent">Observe that we were not able to use <code>set-add</code> on our mutable set <span class="ent">➊</span>, and we were not able to use <code>set-add!</code> on our immutable set <span class="ent">➌</span>. Further, while it did not generate an error, adding the number 7 to <code>mset</code> <span class="ent">➋</span> had no effect since 7 was already a member.</p>&#13;
<p class="indent">In many mathematical texts, sets are illustrated by using a diagram that contains a rectangle and one or more circles. These diagrams are known as <em>Venn diagrams</em>. The rectangle is used to designate all the items of interest (called the <em>universe of discourse</em>—we’ll use the symbol <em>U</em> to represent this), and circles are used to represent particular sets. To aid in our exploration, we’ll define some helper methods to draw various objects in these diagrams.</p>&#13;
<pre>#lang racket&#13;
#lang racket&#13;
(require racket/draw)&#13;
&#13;
(define WIDTH 150)&#13;
(define HEIGHT 100)&#13;
&#13;
(define venn (make-bitmap WIDTH HEIGHT))&#13;
(define dc (new bitmap-dc% [bitmap venn]))&#13;
&#13;
<span epub:type="pagebreak" id="page_98"/>(send dc scale 1.0 -1.0)&#13;
(send dc translate (/ WIDTH 2) (/ HEIGHT -2))&#13;
(send dc set-smoothing 'smoothed) &#13;
(send dc set-pen "black" 2 'solid)&#13;
&#13;
(define IN-BRUSH (new brush% [color "green"]))&#13;
(define OUT-BRUSH (new brush% [color (make-object color% 220 220 220)]))</pre>&#13;
<p class="indent">The code through <code>(define dc (new bitmap-dc% [bitmap venn]))</code> should be familiar from our previous discussions.</p>&#13;
<p class="indent">It’s a bit inconvenient to have our drawing origin in the upper left corner, with the y-axis inverted, so we use a new feature called a <em>transformation</em>. We use the <code>scale</code> transform to scale our drawing environment by 1 in the x-axis direction and -1 in the y-axis direction. This keeps everything the same size, but inverts the y-axis so that up is in the positive direction. To get the origin in the middle of the diagram, we use <code>translate</code> to center it. (There’s also a rotate transformation, but it’s not needed for our present purposes.)</p>&#13;
<p class="indent">The <code>set-smoothing</code> argument to <code>send dc</code> enables or disables anti-aliased smoothing for a drawing. The default value of ’<code>unsmoothed</code> produces drawings with a slightly jagged appearance.</p>&#13;
<p class="indent">The <code>IN-BRUSH</code> will be used as the color to designate things that are in a set, and the <code>OUT-BRUSH</code> is for the color to indicate things that are not in a set.</p>&#13;
<p class="indent">Next, we’ll create a couple of methods to actually do some drawing.</p>&#13;
<pre>(define (rect x y w h b)&#13;
  (let ([x (- x (/ w 2))]&#13;
        [y (- y (/ h 2))])&#13;
    (send dc set-brush b)&#13;
    (send dc draw-rectangle x y w h)))&#13;
&#13;
(define (circle x y r b)&#13;
  (let ([x (- x r)]&#13;
        [y (- y r)])&#13;
    (send dc set-brush b)&#13;
    (send dc draw-ellipse x y (* 2 r) (* 2 r))))</pre>&#13;
<p class="indent">The <code>rect</code> method will draw a rectangle whose center is at coordinates (x,y) with width and height of <code>w</code> and <code>h</code> respectively. And <code>b</code> is the brush that we want to use to draw the rectangle. Similarly, <code>circle</code> will draw a circle whose center is at coordinates (<em>x, y</em>), with radius <code>r</code>, and brush <code>b</code>.</p>&#13;
<p class="indent">Since we’ll only have occasion to draw a single rectangle (representing the universe of discourse, <em>U</em>), we create a special function such that it draws it appropriately; we only need to supply it with a brush for the color.</p>&#13;
<pre>(define (universe b) (rect 0 0 (- WIDTH 10) (- HEIGHT 10) b))</pre>&#13;
<p class="indent">Let’s try these out (see <a href="ch04.xhtml#ch4fig20">Figure 4-20</a>).</p>&#13;
<pre>&gt; <span class="codestrong1">(universe OUT-BRUSH)</span>&#13;
&gt; <span class="codestrong1">(circle 0 0 30 IN-BRUSH)</span>&#13;
&gt; <span class="codestrong1">venn</span></pre>&#13;
<div class="image"><span epub:type="pagebreak" id="page_99"/><img alt="Image" src="../images/04fig21.jpg"/></div>&#13;
<p class="figcap" id="ch4fig20"><em>Figure 4-20: A diagram indicating a single set</em></p>&#13;
<p class="indent">Suppose our universe of discourse is the integers (that is, <em>U</em> = ℤ). We can represent the set of even numbers by the green circle. Now suppose that we’re interested in anything that is <em>not</em> an even number. This is the <em>complement</em> of the set of even numbers. The set complement of <em>A</em> can be represented as <em>A</em><sup><em>c</em></sup>, Ā, or <em>A</em>’. We represent this in a Venn diagram as follows (and shown in <a href="ch04.xhtml#ch4fig21">Figure 4-21</a>):</p>&#13;
<pre>&gt; <span class="codestrong1">(send dc erase)</span>&#13;
&gt; <span class="codestrong1">(universe IN-BRUSH)</span>&#13;
&gt; <span class="codestrong1">(circle 0 0 30 OUT-BRUSH)</span> &#13;
&gt; <span class="codestrong1">venn</span></pre>&#13;
<div class="image"><span epub:type="pagebreak" id="page_100"/><img alt="Image" src="../images/04fig22.jpg"/></div>&#13;
<p class="figcap" id="ch4fig21"><em>Figure 4-21: Items not in the set</em></p>&#13;
<p class="indent">Note that we used <code>erase</code> to clear the drawing context before generating the next diagram.</p>&#13;
<p class="indent">Sets can be combined in various ways. Suppose we have two sets: <em>A</em> and <em>B</em>. One way to combine these sets is to form a new set that is the unique combination of all the elements from set <em>A</em> and <em>B</em>. This operation is called <em>set union</em>, and is designated by the symbol ∪. If <em>C</em> is the union of <em>A</em> and <em>B</em>, the mathematical expression to reflect this is <em>C</em> = <em>A</em> ∪ <em>B</em>. Using <em>set-builder</em> notation, the set complement would be expressed as <em>A</em><sup><em>c</em></sup> = <em>{x</em> ∈ <em>U</em> ∣ <em>x</em> ∉ <em>A}</em>. In words this would be “the set of all <em>x</em> in U such that <em>x</em> is not in <em>A</em>."</p>&#13;
<p class="indent">Another way to think of the union of sets <em>A</em> and <em>B</em> is to see that it consists of following components:</p>&#13;
<ul>&#13;
<li class="noindent">All the elements that are in <em>A</em>  and not in <em>B</em>  (left partial circle).</li>&#13;
<li class="noindent">All the elements that are in <em>B</em>  and not in <em>A</em>  (right partial circle).</li>&#13;
<li class="noindent">All the elements that are in both <em>A</em>  and <em>B</em>  (the central shape of the diagram—this shape is called a <em>vesica</em>  <em>piscis</em>, Latin for “bladder of a fish").</li>&#13;
</ul>&#13;
<p class="indent">See <a href="ch04.xhtml#ch4fig22">Figure 4-22</a> for an example.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig23.jpg"/></div>&#13;
<p class="figcap" id="ch4fig22"><em>Figure 4-22: Set union</em></p>&#13;
<h4 class="h4" id="ch00lev2sec_32"><strong><em>A Short Mathematical Detour</em></strong></h4>&#13;
<p class="noindent">In order to be able to draw the Venn diagram components in <a href="ch04.xhtml#ch4fig22">Figure 4-22</a>, we’ll need to do a few straightforward calculations first. We’ll base our calculation on the nomenclature illustrated in <a href="ch04.xhtml#ch4fig23">Figure 4-23</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/p0100-01.jpg"/></div>&#13;
<p class="figcap" id="ch4fig23"><em>Figure 4-23: How to draw a Venn diagram</em></p>&#13;
<p class="indent">Let’s see how to find the values of <em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>i</em></sub>, <em>θ</em>, and <em>ϕ</em> shown in <a href="ch04.xhtml#ch4fig23">Figure 4-23</a>. Assume that <em>x</em><sub><em>c</em></sub>, <em>y</em><sub><em>c</em></sub>, and <em>r</em> are given. Note that the circles are clearly symmetric about the y-axis, which eases our task somewhat. It’s immediate that <em>x</em><sub><em>i</em></sub> = 0. The equation of a circle with center on the x-axis is given by the following:</p>&#13;
<p class="center">(x - x<sub>c</sub>)<sup>2</sup> + y<sup>2</sup> = r<sup>2</sup></p>&#13;
<p class="indent">The intersection points occur at <em>x</em> = 0. With this substitution and solving for <em>y</em>, we have the following:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0100-02.jpg"/></div>&#13;
<p class="indent">Given <em>y</em>, the angles are easy:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0100-03.jpg"/></div>&#13;
<p class="indent">Now let’s exercise a new DrRacket graphics feature called <em>paths</em>. The path functionality allows one to draw arbitrary figures. A path is constructed by selecting a starting location and building a sequence of segments to define the entire path. Path segments can consist of straight lines, arcs and something called bezier curves (see the manual). We construct a filled path to represent the center portion of the Venn diagram (the <em>vesica piscis</em>) with the following method.</p>&#13;
<pre><span epub:type="pagebreak" id="page_101"/>(define (piscis x y r b)&#13;
  (let* ([y (- y r)]&#13;
         [2r (* 2 r)]&#13;
         [yi (sqrt (- (sqr r) (sqr x)))] ; y-intersection&#13;
         [π pi]&#13;
      <span class="ent">➊</span> [<span class="codeitalic1">ϕ</span> (asin (/ yi r))]&#13;
      <span class="ent">➋</span> [<span class="codeitalic1">θ</span> (- π <span class="codeitalic1">ϕ</span>)]&#13;
      <span class="ent">➌</span> [path (new dc-path%)])&#13;
    (send dc set-brush b)&#13;
 <span class="ent">➍</span> (send path move-to 0 (- yi))&#13;
 <span class="ent">➎</span> (send path arc (- x r)     y 2r 2r  <span class="codeitalic1">θ</span>    (+ π  <span class="codeitalic1">ϕ</span>))&#13;
 <span class="ent">➏</span> (send path arc (- (- x) r) y 2r 2r (- <span class="codeitalic1">ϕ</span>) <span class="codeitalic1">ϕ</span>)&#13;
 <span class="ent">➐</span> (send dc draw-path path)))</pre>&#13;
<p class="indent">Within the <code>let*</code> form we find direct translations of Equations (4.1) <span class="ent">➊</span> and (4.2) <span class="ent">➋</span>. The identifier <code>path</code> is then bound to a new <code>dc-path%</code> object <span class="ent">➌</span>. Paths work sort of like drawing contexts in that path commands are sent to the path object to build the path. The code then positions us at the initial location to draw the first arc <span class="ent">➍</span> . The first arc is then drawn <span class="ent">➎</span>, and completed by mirroring the first arc <span class="ent">➏</span>. The path <code>arc</code> command works like a drawing context <code>draw-ellipse</code> command. The only difference is that <code>arc</code> takes additional parameters specifying the start and stop angles. The finished path is then sent to the drawing context to be rendered <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch00lev2sec_33"><strong><em>Drawing Conclusions</em></strong></h4>&#13;
<p class="noindent">With <code>piscis</code> under our belt, we have most of the machinery we need to draw any binary set operation. To aid in our quest, let’s define a simple function to generate the final diagrams.</p>&#13;
<pre>(define SET-BRUSH (new brush% [color (make-object color% 220 255 220)]))&#13;
&#13;
(define (venn-bin b1 b2 b3)&#13;
  (universe OUT-BRUSH)&#13;
  (circle (- CIRCLE-OFF) 0 30 b1)&#13;
  (circle CIRCLE-OFF 0 30 b3)&#13;
  (piscis CIRCLE-OFF 0 30 b2)&#13;
  (print venn))</pre>&#13;
<p class="indent">We define a new light green color in <code>SET-BRUSH</code> to identify the sets participating in the operation. The <code>venn-bin</code> method (the <code>bin</code> part just refers to the fact that it’s drawing a binary operation) takes three brushes, one to identify each component of the diagram. The rest of the code should be self-explanatory.</p>&#13;
<p class="indent">To generate the union diagram we saw in <a href="ch04.xhtml#ch4fig22">Figure 4-22</a>, we use:</p>&#13;
<pre>&gt; <span class="codestrong1">(venn-bin IN-BRUSH IN-BRUSH IN-BRUSH)</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_102"/>To illustrate Racket’s set operations we’ll use two sets:</p>&#13;
<pre>&gt; <span class="codestrong1">(define A (set 2 4 6 8 10 12 14 16 18))</span>&#13;
&gt; <span class="codestrong1">(define B (set 3 6 9 12 15 18))</span></pre>&#13;
<p class="indent">Here’s the result of forming the union (<em>A</em> ∪ <em>B</em>) of the two sets:</p>&#13;
<pre>&gt; <span class="codestrong1">(set-union A B)</span>&#13;
(set 9 18 14 3 16 2 6 10 15 4 8 12)</pre>&#13;
<p class="indent">Notice that sets are not guaranteed to be in any particular order.</p>&#13;
<p class="indent">Our next operation is <em>set intersection</em>. Set intersection is designated by the symbol ∩. The intersection of <em>A</em> and <em>B</em> consists of all the elements that are in both <em>A</em> and <em>B</em>. That’s <em>A</em> ∩ <em>B</em> = <em>{x</em> ∣ <em>x</em> ∈ <em>A</em> and <em>x</em> ∈ <em>B}</em>. The Venn diagram for intersection is given by the following:</p>&#13;
<pre>(venn-bin SET-BRUSH IN-BRUSH SET-BRUSH)</pre>&#13;
<p class="indent">It’s also shown in <a href="ch04.xhtml#ch4fig24">Figure 4-24</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig25.jpg"/></div>&#13;
<p class="figcap" id="ch4fig24"><em>Figure 4-24: Set intersection</em></p>&#13;
<p class="indent">Here’s an example of Racket code for intersection:</p>&#13;
<pre>&gt; <span class="codestrong1">(set-intersect A B)</span>&#13;
(set 18 6 12)</pre>&#13;
<p class="indent">Next up is <em>set difference</em>. Set difference is designated by the symbol <em>\</em>. The set difference of <em>A</em> and <em>B</em> consists of all the elements that are in <em>A</em> that are not also in <em>B</em>. That’s <em>A \ B</em> = <em>{x</em> ∣ <em>x</em> ∈ <em>A</em> and <em>x</em> ∉ <em>B}</em>. The Venn diagram for set difference is given by the following:</p>&#13;
<pre>(venn-bin IN-BRUSH SET-BRUSH SET-BRUSH)</pre>&#13;
<p class="indent">It’s also shown in <a href="ch04.xhtml#ch4fig25">Figure 4-25</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig26.jpg"/></div>&#13;
<p class="figcap" id="ch4fig25"><em>Figure 4-25: Set difference</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>Set difference is performed with the <code>set-subtract</code> function in Racket.</p>&#13;
<pre>&gt; <span class="codestrong1">(set-subtract A B)</span>&#13;
(set 14 16 2 10 4 8)</pre>&#13;
<p class="indent">Our final operation is <em>symmetric difference</em>. Symmetric difference is designated by the symbol △. The symmetric difference of <em>A</em> and <em>B</em> consists of all the elements that are in <em>A</em> or <em>B</em>, but are not also in both <em>A</em> and <em>B</em>. That’s <em>A</em> △ <em>B</em> = {<em>x</em> ∣ <em>x</em> ∈ <em>A</em> or <em>x</em> ∈ <em>B</em>, but not <em>x</em> ∈ <em>A</em> and <em>x</em> ∈ <em>B</em>}. The Venn diagram for symmetric difference is given by</p>&#13;
<pre>(venn-bin SET-BRUSH IN-BRUSH SET-BRUSH)</pre>&#13;
<p class="indent">See an example in <a href="ch04.xhtml#ch4fig26">Figure 4-26</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_104"/><img alt="Image" src="../images/04fig27.jpg"/></div>&#13;
<p class="figcap" id="ch4fig26"><em>Figure 4-26: Symmetric difference</em></p>&#13;
<p class="indent">Symmetric set difference is performed with the <code>set-symmetric-difference</code> function in Racket.</p>&#13;
<pre>&gt; <span class="codestrong1">(set-symmetric-difference A B)</span>&#13;
(set 9 14 3 16 2 10 15 4 8)</pre>&#13;
<h4 class="h4" id="ch00lev2sec_34"><strong><em>Are We Related?</em></strong></h4>&#13;
<p class="noindent">There are a couple of important relationships in the theory of sets that you should be aware of. The first is the concept of <em>subsets</em>. A set <em>A</em> is a subset of another set <em>B</em> if all the elements of <em>A</em> are also elements of <em>B</em>. This relationship is represented by the symbol ⊆. In Racket it’s possible to test whether one set is a subset of another with the predicate <code>subset?</code>.</p>&#13;
<pre>&gt; <span class="codestrong1">(subset? (set 2 4 6 8) (set 1 2 3 4 5 6 7 8 9 10))</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(subset? (set 2 4 6 8) (set 3 4 5 6 7 8 9 10))</span>&#13;
#f</pre>&#13;
<p class="indent">A subset relationship like the one in the first example can be represented by the Venn diagram shown in <a href="ch04.xhtml#ch4fig27">Figure 4-27</a>. In this case the inner circle is entirely enclosed by the outer circle.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig28.jpg"/></div>&#13;
<p class="figcap" id="ch4fig27"><em>Figure 4-27: A subset relationship</em></p>&#13;
<p class="indent">If a set <em>A</em> is a subset of <em>B</em>, but <em>A</em> ≠ <em>B</em>, <em>A</em> is said to be a <em>proper subset</em> of <em>B</em>. This is designated by the symbol ⊂. Racket provides the <code>proper-subset?</code> predicate to perform this function.</p>&#13;
<pre>&gt; <span class="codestrong1">(subset? (set 2 4 6 8) (set 2 4 6 8))</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(proper-subset? (set 2 4 6 8) (set 2 4 6 8))</span>&#13;
#f</pre>&#13;
<p class="indent">Given sets <em>A</em> and <em>B</em>, the <em>Cartesian product</em> is defined as the following:</p>&#13;
<p class="center"><em>A</em> × <em>B</em> = {(<em>a</em>, <em>b</em>) | ∣ <em>a</em> ∈ <em>A</em> and <em>b</em> ∈ <em>B</em>}</p>&#13;
<p class="indent">While Racket doesn’t have a built-in function that returns the Cartesian product of two sets, it’s easy enough to produce our own version.</p>&#13;
<pre>&gt; <span class="codestrong1">(define (cart-prod A B)&#13;
    (list-&gt;set&#13;
     (for*/list ([a A]&#13;
                 [b B])&#13;
       (list a b))))</span></pre>&#13;
<p class="indent">But a somewhat more succinct version is the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(define (cart-prod A B)&#13;
    (for*/set ([a A]&#13;
               [b B])&#13;
      (list a b)))</span></pre>&#13;
<p class="noindent">which we can test as follows:</p>&#13;
<pre>&gt; <span class="codestrong1">(define A (set 'a 'b 'c))</span>&#13;
&gt; <span class="codestrong1">(define B (set 1 2 3))</span>&#13;
&#13;
&gt; <span class="codestrong1">(cart-prod A B)</span>&#13;
(set '(a 1) '(c 3) '(c 1) '(c 2) '(a 2) '(a 3) '(b 2) '(b 3) '(b 1))</pre>&#13;
<p class="indent">From this it can be seen that the Cartesian product is the set of all possible pairs of values that can be generated from two given sets. Subsets of Cartesian products are frequently used to define relationships. For example, if <em>A</em> = {1, 2, 3, 4}, we can express the “less than” relationship as follows:</p>&#13;
<p class="center"><span epub:type="pagebreak" id="page_105"/>{(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}</p>&#13;
<p class="indent">Observe that the first value in each pair is always less than the second element.</p>&#13;
<p class="indent">This completes our brief foray into applying DrRacket’s graphical capabilities to the exciting topic of set theory. Next we’ll take a look at a couple of extended applications where we utilize these capabilities to explore additional topics in mathematics.</p>&#13;
<h3 class="h3" id="ch00lev1sec_27">Applications</h3>&#13;
<p class="noindent">Let’s begin with an old acquaintance, the Fibonacci sequence.</p>&#13;
<h4 class="h4" id="ch00lev2sec_35"><strong><em>Fibonacci Revisited</em></strong></h4>&#13;
<p class="noindent">As we learned in the last chapter in the Fibonacci and Friends section, it’s always possible to tile a rectangle with squares whose sides are given by the Fibonacci sequence. In this section we’ll create a function that can draw the tiling for any Fibonacci number (up to the screen limit). The tiling begins in the center of the drawing canvas and proceeds by essentially spiraling out from that point. Before we dive into writing code for this, a little analysis will guide our way.</p>&#13;
<h5 class="h5" id="ch00lev3sec_45"><strong>Tiling</strong></h5>&#13;
<p class="noindent">Observe <a href="ch04.xhtml#ch4fig28">Figure 4-28</a>. We’ll use the upper left corner of each square as a reference point (as indicated by the black quadrants). Each arrow indicates the direction we must move to create the next Fibonacci square.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig29.jpg"/></div>&#13;
<p class="figcap" id="ch4fig28"><em>Figure 4-28: Tile analysis</em></p>&#13;
<p class="indent">If <em>n</em> is the <em>n</em>th Fibonacci number (<em>F</em><sub><em>n</em></sub>), we designate <em>f</em><sub><em>n</em></sub> as the <em>n</em>th Fibonacci square with sides of length <em>s</em><sub><em>n</em></sub> (this is just some constant multiple of <em>F</em><sub><em>n</em></sub>). The coordinates of the upper left corner of <em>f</em><sub><em>n</em></sub> will be given by (<em>x</em><sub><em>n</em></sub>, <em>y</em><sub><em>n</em></sub>). We assume the drawing is initialized with <em>f</em><sub>1</sub> and <em>f</em><sub>2</sub> as indicated by the two small, unlabeled squares in the center of the drawing. Moving up from <em>f</em><sub>2</sub> to <em>f</em><sub>3</sub>, we see that (<em>x</em><sub>3</sub>, <em>y</em><sub>3</sub>) = (<em>x</em><sub>1</sub>, <em>y</em><sub>2</sub> - 2). We can generalize this to (<em>x</em><sub>n</sub>, <em>y</em><sub>n</sub>) = (<em>x</em><sub>n-2</sub>, y<sub>n-1</sub> - s<sub>n</sub>) whenever we move from one tile to another in an upward direction. <a href="ch04.xhtml#ch4tab1">Table 4-1</a> gives the change in coordinates for all four directions. <span epub:type="pagebreak" id="page_106"/>Since the pattern repeats itself after four moves, the applicable move is given in the remainder (<em>n</em> mod 4) column.</p>&#13;
<p class="tabcap" id="ch4tab1"><strong>Table 4-1</strong>: Direction Coordinates</p>&#13;
<table class="table1">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:45%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba">Direction</p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba">Coordinates</p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><em>n</em> mod 4</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba"><em>↑</em></p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">(x<sub>n-2</sub>, y<sub>n-1</sub> – s<sub>n</sub>)</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">←</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">(x<sub>n-1</sub> – s<sub>n</sub>, y<sub>n-1</sub>)</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba"><em>↓</em></p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">(x<sub>n-1</sub>, y<sub>n-1</sub> + s<sub>n-1</sub>)</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-h1aa" style="vertical-align: top;"><p class="taba">→</p></td>&#13;
<td class="table-h1aa" style="vertical-align: top;"><p class="taba">(x<sub>n-1</sub> + s<sub>n-1</sub>, y<sub>n-2</sub>)</p></td>&#13;
<td class="table-h1aa" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">This table tells us that at any stage of the drawing process we’ll need access to not only <em>F</em><sub><em>n</em></sub> and <em>F</em><sub><em>n-</em>1</sub>, but also (x<sub>n-1</sub>, y<sub>n-1</sub>) and (<em>x</em><sub>n-2</sub>, <em>y</em><sub>n-2</sub>). We’ll use the second method introduced in the Fibonacci and Friends section to produce <em>F</em><sub><em>n</em></sub> in our drawing code. Hence, we’ll describe a <code>draw-tiles</code> function that takes a Fibonacci <em>n</em> and returns four values: <em>x</em><sub><em>n-</em>1</sub>, <em>y</em><sub><em>n-</em>1</sub>, <em>x</em><sub><em>n-</em>2</sub>, and <em>y</em><sub><em>n-</em>2</sub>. These values along with <em>F</em><sub><em>n</em></sub> and <em>F</em><sub><em>n-</em>1</sub> will be used to draw the <em>n</em>th tile.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig29">Figure 4-29</a> shows the result from calling <code>(draw-tiles 10)</code>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig30.jpg"/></div>&#13;
<p class="figcap" id="ch4fig29"><em>Figure 4-29: A Fibonacci tiling</em></p>&#13;
<p class="indent">Our code begins with some constant definitions to establish the parameters to be used in the rest of the program.</p>&#13;
<pre>#lang racket&#13;
(require racket/draw)&#13;
&#13;
(define WIDTH 600)  ; width of drawing area&#13;
(define HEIGHT 400) ; height of drawing area&#13;
(define UNIT 6) ; pixels in unit-width square&#13;
(define OFFSET-X 140) ; starting x offset&#13;
(define OFFSET-Y 75) ; starting y offset&#13;
<span epub:type="pagebreak" id="page_107"/>(define START-X (- (/ WIDTH 2)  UNIT OFFSET-X))&#13;
(define START-Y (- (/ HEIGHT 2) UNIT OFFSET-Y))</pre>&#13;
<p class="indent">There should be sufficient comments here to determine what’s what. We’ve fudged a bit by adding some offset values to account for the asymmetric nature of the tiling.</p>&#13;
<p class="indent">Next we set up our drawing surface, pen, and brush.</p>&#13;
<pre>(define tiling (make-bitmap WIDTH HEIGHT)) &#13;
(define dc (new bitmap-dc% [bitmap tiling]))&#13;
&#13;
(define TILE-PEN   (new pen% [color "black"] [width 1] [style 'solid]))&#13;
(send dc set-pen TILE-PEN)&#13;
&#13;
(define TILE-BRUSH (new brush% [color "yellow"] [style 'solid]))&#13;
(send dc set-brush TILE-BRUSH)</pre>&#13;
<p class="indent">Now we define two functions: one to compute <em>F</em><sub><em>n</em></sub> and the other, <code>draw-n</code>, to actually produce the tiling in <a href="ch04.xhtml#ch04list1">Listing 4-1</a>:</p>&#13;
<pre>  ; function to compute F(n)&#13;
  (define (F n)&#13;
    (define (f a b cnt)&#13;
      (if (= cnt 0) b&#13;
          (f (+ a b) a (- cnt 1))))&#13;
    (f 1 0 n))&#13;
  &#13;
  ; function to draw the tiling&#13;
  (define (draw-n n)&#13;
 <span class="ent">➊</span> (let* ([fn (F n)]&#13;
       <span class="ent">➋</span> [sn (* UNIT fn)]&#13;
       <span class="ent">➌</span> [fn1 (F (sub1 n))]&#13;
       <span class="ent">➍</span> [sn1 (* UNIT fn1)]&#13;
          [n-mod-4 (remainder n 4)])&#13;
     (cond [(&lt; n 2) #f] ; do nothing tiles already drawn&#13;
           [(= n 2) (values (+ UNIT START-X) START-Y START-X START-Y)]&#13;
           [else&#13;
         <span class="ent">➎</span> (let-values ([(x1 y1 x2 y2) (draw-n (sub1 n))])&#13;
              (let-values ([(x y)&#13;
                            (case n-mod-4&#13;
                           <span class="ent">➏</span> [(0) (values (- x1 sn) y1)]&#13;
                              [(1) (values x1 (+ y1 sn1))]&#13;
                              [(2) (values (+ x1 sn1) y2)]&#13;
                           <span class="ent">➐</span> [(3) (values x2 (- y1 sn))])])&#13;
              <span class="ent">➑</span> (draw-tile x y sn)&#13;
              <span class="ent">➒</span> (values x y x1 y1)))])))</pre>&#13;
<p class="caption" id="ch04list1"><em>Listing 4-1: Fibonacci with Tiling</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_108"/>The <code>draw-n</code> function is the workhorse of this process. This procedure is recursively called <span class="ent">➎</span> until the desired number of tiles is drawn. First, we compute <em>F</em><sub><em>n</em></sub> <span class="ent">➊</span> and <em>F</em><sub><em>n-</em>1</sub> <span class="ent">➌</span>. Then we simply multiply these numbers by the constant <code>UNIT</code> <span class="ent">➋</span> <span class="ent">➍</span> to determine the sizes of the squares. Next, we determine the coordinates of the upper left corner of the square as described during the discussion of <a href="ch04.xhtml#ch4tab1">Table 4-1</a> <span class="ent">➏</span> <span class="ent">➐</span>. Following this, the tile is actually drawn <span class="ent">➑</span>. Finally, the values <em>x</em><sub><em>n-</em>1</sub>, <em>y</em><sub><em>n-</em>1</sub>, <em>x</em><sub><em>n-</em>2</sub>, and <em>y</em><sub><em>n-</em>2</sub> mentioned in our analysis section above are returned <span class="ent">➒</span> as these values are needed by the preceding recursive call <span class="ent">➎</span>.</p>&#13;
<p class="indent">To actually produce the drawing, we have this code:</p>&#13;
<pre>(define (draw-tiles n)&#13;
  (draw-tile START-X START-Y UNIT)&#13;
  (draw-tile (+ UNIT START-X) START-Y UNIT)&#13;
  (draw-n n)&#13;
  (print tiling))</pre>&#13;
<p class="indent">It initializes the drawing with the two unit squares, calls <code>draw-n</code>, and outputs the constructed bitmap to the screen.</p>&#13;
<p class="indent">Finally, calling <code>(draw-tiles 10)</code> will produce the output shown previously in <a href="ch04.xhtml#ch4fig29">Figure 4-29</a>.</p>&#13;
<h5 class="h5" id="ch00lev3sec_46"><strong>The Golden Spiral (Approximation)</strong></h5>&#13;
<p class="noindent">To produce the golden spiral discussed in <a href="ch03.xhtml">Chapter 3</a> (and reproduced in <a href="ch04.xhtml#ch4fig30">Figure 4-30</a>), we only need to make a few additions to our tiling code.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig31.jpg"/></div>&#13;
<p class="figcap" id="ch4fig30"><em>Figure 4-30: The golden spiral</em></p>&#13;
<p class="indent">We begin by defining a new drawing pen and brush to be used for creating the spiral.</p>&#13;
<pre>(define SPIRAL-PEN (new pen% [color "red"] [width 2] [style 'solid]))&#13;
(define TRANS-BRUSH (new brush% [style 'transparent]))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>To produce the spiral, we’ll be using the <code>draw-arc</code> function. This function works just like <code>draw-ellipse</code> except that it takes two additional arguments that specify the start and stop angles for the arc. These values are designated by <em>θ</em><sub>0</sub> and <em>θ</em><sub>1</sub> in <a href="ch04.xhtml#ch4fig18">Figure 4-18</a>. By default, arcs use a filled brush, so to keep from covering the tiles, we define <code>TRANS-BRUSH</code> as a transparent brush. The spirals are produced by drawing an arc each time a tile is produced. We predefine the various angles (in radians) we will need to use for the arcs:</p>&#13;
<pre>; define angle constants&#13;
(define 0d 0)&#13;
(define 90d (/ pi 2))&#13;
(define 180d pi)&#13;
(define 270d (* 3 (/ pi 2)))&#13;
(define 360d (* 2 pi))</pre>&#13;
<p class="indent">Next we define the actual function used to draw the spiral segments.</p>&#13;
<pre>(define (arc x y r a)&#13;
  (let-values ([(d) (values (* 2 r))]&#13;
               [(start stop x y)&#13;
                (case a&#13;
               <span class="ent">➊</span> [(0) (values  90d 180d x       y  )]&#13;
                  [(1) (values 180d 270d x       (- y r)  )]&#13;
                  [(2) (values 270d 360d (- x r) (- y r) )]&#13;
                  [(3) (values   0d  90d (- x r) y)])])&#13;
    (send dc set-pen SPIRAL-PEN)&#13;
    (send dc set-brush TRANS-BRUSH)&#13;
    (send dc draw-arc x y d d start stop)&#13;
    (send dc set-pen TILE-PEN)&#13;
    (send dc set-brush TILE-BRUSH)))</pre>&#13;
<p class="indent">First, we determine the start and stop angles for the arcs <span class="ent">➊</span>, as well as the x-coordinate and y-coordinate of the location to draw the arcs. Next, we switch to the appropriate pen and brush to draw the arc. Finally, the drawing context is reset to the one needed to draw the tiles.</p>&#13;
<p class="indent">The only change needed to the <code>draw-n</code> code is to add this single line immediately after the <code>(draw-tile x y sn)</code> statement <span class="ent">➑</span> in <a href="ch04.xhtml#ch04list1">Listing 4-1</a>:</p>&#13;
<pre>(arc x y sn n-mod-4)</pre>&#13;
<p class="indent">With this change, calling <code>(draw-tiles 10)</code> will now produce the tiling overlaid by the golden spiral as shown in <a href="ch04.xhtml#ch4fig30">Figure 4-30</a>.</p>&#13;
<h4 class="h4" id="ch00lev2sec_36"><strong><em>Nim</em></strong></h4>&#13;
<p class="noindent">Nim is a strategy game in which two players take turns removing objects from distinct heaps. On each turn, a player must remove at least one object, and may remove any number of objects provided they all come from the same heap. The winner of the game is the player who removes the last <span epub:type="pagebreak" id="page_110"/>object. This game can also be played where the person who removes the last object loses, but in our version, the player who takes the last object wins.</p>&#13;
<p class="indent">In this version of Nim we’ll have three piles with up to 15 balls in each pile, as shown in <a href="ch04.xhtml#ch4fig31">Figure 4-31</a>. Instead of two human players, this time it will be man versus machine, you against the computer, <em>mano a mano</em>.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig32.jpg"/></div>&#13;
<p class="figcap" id="ch4fig31"><em>Figure 4-31: Nim starting piles</em></p>&#13;
<h5 class="h5" id="ch00lev3sec_47"><strong>Setting Up the Graphics</strong></h5>&#13;
<p class="noindent">We’ll begin with some basic definitions to establish some useful constants. Most of these should be fairly obvious. The <code>BOARD</code> references are to the brown board the balls rest on.</p>&#13;
<pre>#lang racket&#13;
(require racket/draw)&#13;
&#13;
; overall dimensions of drawing area&#13;
(define WIDTH 300)&#13;
(define HEIGHT 110)&#13;
(define BOTTOM-MARGIN 20)&#13;
&#13;
(define RADIUS 8) ; ball radius&#13;
(define DIAMETER (* 2 RADIUS))&#13;
(define DELTA-Y (- (* DIAMETER (sin (/ pi 3)))))&#13;
&#13;
(define BOARD-THICKNESS 10)&#13;
(define BOARD-Y (- HEIGHT BOARD-THICKNESS BOTTOM-MARGIN))&#13;
&#13;
; location to start drawing pile numbers&#13;
(define TEXT-X (+ 5 (* RADIUS 5)))&#13;
(define TEXT-Y (- HEIGHT BOTTOM-MARGIN))&#13;
&#13;
; x, y location to start drawing balls&#13;
(define START-X 20)&#13;
(define START-Y (- BOARD-Y RADIUS))&#13;
&#13;
(define BALL-BRUSH (new brush% [color "red"]))&#13;
(define BACKGROUND-BRUSH (new brush% [color "yellow"]))&#13;
(define BOARD-BRUSH (new brush% [color "brown"]))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_111"/>The linchpin of Nim’s graphics is the <code>draw-pile</code> routine, shown below, which draws a single pile of balls. This code calls <code>draw-ball</code> with the x- and y- coordinates of the location of the center of each ball. It draws each row (see <code>draw-row</code>), bottom up, until there are either no more balls or the row has its full complement of balls.</p>&#13;
<pre>(define (draw-ball x y) ; draw ball with center at (x,y)&#13;
  (send dc draw-ellipse (- x RADIUS) (- y RADIUS) DIAMETER DIAMETER))&#13;
&#13;
(define (draw-pile n start-x)&#13;
  {let ([rem n]&#13;
        [x start-x]&#13;
        [y START-Y])&#13;
    (define (draw-row x y n max)&#13;
       (when (and (&gt; rem 0) (&lt;= n max))&#13;
         (set! rem (sub1 rem))&#13;
         (draw-ball x y)&#13;
         (draw-row (+ x DIAMETER) y (add1 n) max)))&#13;
    (for ([r (in-range 5 0 -1)])&#13;
      (draw-row x y 1 r)&#13;
      (set! x (+ x RADIUS))&#13;
      (set! y (+ y DELTA-Y)))})</pre>&#13;
<p class="indent">Finally, we come to the code that actually draws the entire Nim environment, <code>draw-game</code>:</p>&#13;
<pre>(define pile (make-vector 3 15))&#13;
&#13;
(define (draw-game)&#13;
  (send dc set-pen "black" 2 'solid)&#13;
  (send dc set-brush BACKGROUND-BRUSH)&#13;
  (send dc draw-rectangle 0 0 WIDTH HEIGHT)&#13;
  (send dc set-brush BOARD-BRUSH)&#13;
  (send dc draw-rectangle 0 BOARD-Y WIDTH BOARD-THICKNESS)&#13;
  (send dc set-brush BALL-BRUSH)&#13;
&#13;
  (draw-pile (vector-ref pile 0) START-X)&#13;
  (send dc draw-text "0" TEXT-X TEXT-Y)&#13;
&#13;
  (draw-pile (vector-ref pile 1) (+ START-X (* 6 DIAMETER)))&#13;
  (send dc draw-text "1" (+ TEXT-X (* 6 DIAMETER)) TEXT-Y)&#13;
&#13;
  (draw-pile (vector-ref pile 2) (+ START-X (* 12 DIAMETER)))&#13;
  (send dc draw-text "2" (+ TEXT-X (* 12 DIAMETER)) TEXT-Y)&#13;
  &#13;
  (print drawing) ; display the board&#13;
)&#13;
(draw-game)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_112"/>This routine simply draws rectangles for the background and board under the piles. It then calls <code>draw-pile</code> once for each pile. The number of balls contained in each pile is stored in the vector variable <code>pile</code>. For reference, the pile number is shown below each pile.</p>&#13;
<h5 class="h5" id="ch00lev3sec_48"><strong>Gameplay</strong></h5>&#13;
<p class="noindent">Nim is a bit unusual in the world of games in that a perfect play strategy is known to exist. It’s relatively easy to implement, but it’s not obvious. So once you’ve programmed this, you can spring it on one of your unsuspecting friends and have the computer beat the snot out of them.</p>&#13;
<p class="indent">The key to this strategy is something called the <em>nim-sum</em>. The nim-sum is simply the bitwise exclusive-or of the number of pieces in each pile. The exclusive-or operator is given by the mathematical symbol ⊕ and is often designated as xor. It’s computed in Racket by the function <code>bitwise-xor</code>.</p>&#13;
<p class="indent">Bitwise exlusive-or is computed as follows: if you are combining two single bits and both bits are the same, then the result is 0; otherwise, it’s 1. For example, 1 ⊕ 1 = 0 and 1 ⊕ 0 = 1.</p>&#13;
<p class="indent">In Racket we can display the binary representation of a number by using <code>"</code>˜<code>b"</code> in the form string of the <code>printf</code> statement. For example, we have the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(printf "~b" 13)</span>&#13;
1101&#13;
&#13;
&gt; <span class="codestrong1">(printf "~b" 9)</span>&#13;
1001&#13;
&#13;
&gt; <span class="codestrong1">(printf "~b" (bitwise-xor 13 9))</span>&#13;
0100</pre>&#13;
<p class="indent">Notice that if you take the bitwise exclusive-or in each corresponding bit position of 13<sub>10</sub> = 1101<sub>2</sub> and 9<sub>10</sub> = 1001<sub>2</sub> , you wind up with 0100<sub>2</sub>.</p>&#13;
<p class="indent">It turns out that the winning strategy is just to finish every move with a nim-sum (that is, an exclusive-or) of 0. This is always possible <span epub:type="pagebreak" id="page_113"/>if the nim-sum is not zero before the move. The way to achieve this is with the following:</p>&#13;
<ol>&#13;
<li class="noindent">Designate <em>b</em><sub>0</sub>,  <em>b</em><sub>1</sub>,  and <em>b</em><sub>2</sub>,  as the number of balls in piles 0, 1, and 2 respectively.</li>&#13;
<li class="noindent">Let <em>s</em> = <em>b</em><sub>0</sub> ⊕ <em>b</em><sub>1</sub> ⊕ <em>b</em><sub>2</sub>  be the nim-sum of the all the pile sizes.</li>&#13;
<li class="noindent">Compute <em>n</em><sub>0</sub> = <em>s</em> ⊕ <em>b</em><sub>0</sub>,  <em>n</em><sub>1</sub> = <em>s</em> ⊕ <em>b</em><sub>1</sub>,  and <em>n</em><sub>2</sub> = <em>s</em> ⊕ <em>b</em><sub>2</sub>.</li>&#13;
<li class="noindent">Of the three piles, at least one of the values <em>n</em><sub>0</sub>,  <em>n</em><sub>1</sub>,  or <em>n</em><sub>2</sub>  will be numerically less than the number of items in the corresponding  pile. We select from one of these piles and designate it by the letter  <em>i</em>.</li>&#13;
<li class="noindent">The winning play is then to simply reduce pile <em>i</em>  to size <em>n</em><sub><em>i</em></sub>.  That is, the move is to remove <em>b</em><sub><em>i</em></sub> <em>- n</em><sub><em>i</em></sub>  balls from pile <em>i</em>.</li>&#13;
</ol>&#13;
<p class="indent">If the nim-sum is zero at the beginning of a player’s turn, that player will lose if their opponent plays perfectly. In that case, the best strategy is to stall by picking a single ball from one of the piles and hope that the opponent will make a mistake at some point. The reason this strategy works is somewhat technical, but an analysis can be found in the Wikipedia article at <em><a href="https://en.wikipedia.org/wiki/Nim">https://en.wikipedia.org/wiki/Nim</a></em>.</p>&#13;
<p class="indent">This brings us to the actual Racket code to find a winning move.</p>&#13;
<pre><span class="ent">➊</span> (define nim-sum bitwise-xor)&#13;
&#13;
<span class="ent">➋</span> (define (random-pile) ; select a random pile that has balls&#13;
     (let ([i (random 3)])&#13;
       (if (&gt; (vector-ref pile i) 0) i (random-pile))))&#13;
&#13;
   (define (find-move)&#13;
     (let* ([balls (vector-&gt;list pile)]&#13;
         <span class="ent">➌</span> [s (apply nim-sum balls)])&#13;
    <span class="ent">➍</span> (if (= 0 s)&#13;
           (let ([i (random-pile)]) (values i 1)) ; stall&#13;
        <span class="ent">➎</span> (let ([n (list-&gt;vector (map (λ (b) (nim-sum s b)) balls))])&#13;
          <span class="ent">➏</span> (define (test? i) (&lt; (vector-ref n i) (vector-ref pile i)))&#13;
             (define (move i) (values i  (- (vector-ref pile i) (vector-ref n i))))  &#13;
          <span class="ent">➐</span> (cond [(test? 0) (move 0)]&#13;
             [(test? 1) (move 1)]&#13;
             [(test? 2) (move 2)])))))</pre>&#13;
<p class="indent">First, we define <code>nim-sum</code> as <code>bitwise-xor</code> <span class="ent">➊</span>. Next, we have the helper function <code>random-pile</code> <span class="ent">➋</span>, which just finds a random pile that has balls. We use this to implement the stalling strategy mentioned above. <code>find-move</code> implements our overall playing strategy mentioned in the itemized steps above. This function returns two values: the pile number and the number of balls to remove from the pile. Now we compute the overall nim-sum <span class="ent">➌</span> (step 2 in the above procedure). This sum is then tested <span class="ent">➍</span>, and if it’s zero, it simply returns a random pile with one ball to be removed. The computation mentioned in step 3 above is performed <span class="ent">➎</span>. The local function <code>test?</code> <span class="ent">➏</span> determines whether <em>n</em><sub><em>i</em></sub> &lt; <em>b</em><sub><em>i</em></sub>. The local function <code>move</code> returns the pile number and the number of balls to remove as mentioned in step 5 above. Finally, we perform tests to determine which pile to use <span class="ent">➐</span>.</p>&#13;
<p class="indent">Before we create code for the player to enter their move, we define a few helper functions.</p>&#13;
<pre>(define (apply-move p n) ; remove n balls from pile p&#13;
  (vector-set! pile p (- (vector-ref pile p) n)))&#13;
&#13;
(define (game-over?)&#13;
  (for/and ([i (in-range 3)]) (= 0 (vector-ref pile i))))&#13;
&#13;
(define (valid-move? p n)&#13;
  <span epub:type="pagebreak" id="page_114"/>(cond [(not (&lt;= 0 p 2)) #f]&#13;
        [(&lt; n 0) #f]&#13;
        [else (&gt;= (vector-ref pile p) n)]))</pre>&#13;
<p class="indent">The <code>apply-move</code> function updates the designated pile by removing the specified number of balls. The <code>game-over?</code> function tests whether there are any balls left to play. And the <code>valid-move?</code> function tests whether a given move is valid.</p>&#13;
<p class="indent">Tying it all together is the function that implements the following game loop:</p>&#13;
<pre>(define (move p n)&#13;
  (if (not (valid-move? p n))&#13;
    (printf"\n Invalid move.\n\n")&#13;
    (begin (apply-move p n)&#13;
           (if (game-over?)&#13;
             (printf "\nYou win!")&#13;
             (let-values ([(p n) (find-move)])&#13;
             (draw-game)&#13;
             (printf "\n\nComputer removes ~a balls from pile ~a.\n" n p)&#13;
             (apply-move p n)&#13;
             (draw-game)&#13;
             (when (game-over?)&#13;
               (printf "\nComputer wins!")))))))</pre>&#13;
<p class="indent">The player enters their move by specifying the pile number followed by the number of balls to remove. For instance, to remove 5 balls from pile 1, one would enter the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(move 1 5)</span></pre>&#13;
<p class="indent">To make things interesting, we define an <code>init</code> function that randomly initializes each pile with from 10 to 15 balls.</p>&#13;
<pre>(define (init)&#13;
  (for ([i (in-range 3)]) (vector-set! pile i (random 10 16)))&#13;
  (newline)&#13;
  (draw-game)&#13;
  (newline))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_115"/><a href="ch04.xhtml#ch4fig32">Figure 4-32</a> illustrates a game in progress.</p>&#13;
<div class="image"><img alt="Image" src="../images/04fig33.jpg"/></div>&#13;
<p class="figcap" id="ch4fig32"><em>Figure 4-32: Nim: game in progress</em></p>&#13;
<h3 class="h3" id="ch00lev1sec_28">Summary</h3>&#13;
<p class="noindent">In this chapter, we played with plotting, grappled with graphics, and in the process discovered Racket’s extensive capability for visual representation. In the next chapter, we’ll build upon this capability to escape the confines of the command line to produce animations and take the first steps toward making interactive applications.</p>&#13;
</body></html>