- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Table Lookups
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses how to speed up or reduce the complexity of computations
    by using table lookups. Back in the early days of x86 programming, replacing expensive
    computations with table lookups was a common way to improve program performance.
    Today, memory speeds in modern systems limit performance gains that can be obtained
    by using table lookups. However, for complex calculations, this is still a viable
    technique for writing high-performance code. This chapter demonstrates the space/speed
    trade-offs when using table lookups.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To an assembly language programmer, a *table* is an array containing initialized
    values that do not change once created. In assembly language, you can use tables
    for a variety of purposes: computing functions, controlling program flow, or simply
    looking things up. In general, tables provide a fast mechanism for performing
    an operation at the expense of space in your program (the extra space holds the
    tabular data). In this section, we’ll explore some of the many possible uses of
    tables in an assembly language program.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.1 Function Computation via Table Lookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simple-looking high-level-language arithmetic expression can be equivalent
    to a considerable amount of x86-64 assembly language code and, therefore, could
    be expensive to compute. Assembly language programmers often precompute many values
    and use a table lookup of those values to speed up their programs. This has the
    advantage of being easier, and it’s often more efficient as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Pascal statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This Pascal `if` statement converts the `character` variable’s value from lowercase
    to uppercase if `character` is in the range `a` to `z`. The MASM code that does
    the same thing requires a total of seven machine instructions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a table lookup, however, allows you to reduce this sequence to just four
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `xlat`, or translate, instruction does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This instruction uses the current value of the AL register as an index into
    the array whose base address is found in RBX. It fetches the byte at that index
    in the array and copies that byte into the AL register. Intel calls this instruction
    *translate* because programmers typically use it to translate characters from
    one form to another by using a lookup table, exactly the way we are using it here.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, `CnvrtLower` is a 256-byte table that contains the
    values 0 to 60h at indices 0 to 60h, 41h to 5Ah at indices 61h to 7Ah, and 7Bh
    to 0FFh at indices 7Bh to 0FFh. Therefore, if AL contains a value in the range
    0 to 60h or 7Ah to 0FFh, the `xlat` instruction returns the same value, effectively
    leaving AL unchanged. However, if AL contains a value in the range 61h to 7Ah
    (the ASCII codes for a to z), then the `xlat` instruction replaces the value in
    AL with a value in the range 41h to 5Ah (the ASCII codes for A to Z), thereby
    converting lowercase to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the complexity of a function increases, the performance benefits of the
    table-lookup method increase dramatically. While you would almost never use a
    lookup table to convert lowercase to uppercase, consider what happens if you want
    to swap cases; for example, via computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code has 13 machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table-lookup code to compute this same function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when using a table lookup to compute a function, only the table
    changes; the code remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.1.1 Function Domains and Range
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Functions computed via table lookup have a limited *domain* (the set of possible
    input values they accept), because each element in the domain of a function requires
    an entry in the lookup table. For example, our previous uppercase/lowercase conversion
    functions have the 256-character extended ASCII character set as their domain.
    A function such as `sin` or `cos` accepts the (infinite) set of real numbers as
    possible input values. You won’t find it very practical to implement a function
    via table lookup whose domain is the set of real numbers, because you must limit
    the domain to a small set.
  prefs: []
  type: TYPE_NORMAL
- en: Most lookup tables are quite small, usually 10 to 256 entries. Rarely do lookup
    tables grow beyond 1000 entries. Most programmers don’t have the patience to create
    (and verify the correctness) of a 1000-entry table (though see “Generating Tables”
    on page 590 for a discussion of generating tables programmatically).
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation of functions based on lookup tables is that the elements
    in the domain must be fairly contiguous. Table lookups use the input value to
    a function as an index into the table, and return the value at that entry in the
    table. A function that accepts values 0, 100, 1000, and 10,000 would require 10,001
    different elements in the lookup table because of the range of input values. Therefore,
    you cannot efficiently create such a function via a table lookup. Throughout this
    section on tables, we’ll assume that the domain of the function is a fairly contiguous
    set of values.
  prefs: []
  type: TYPE_NORMAL
- en: The *range* of a function is the set of possible output values it produces.
    From the perspective of a table lookup, a function’s range determines the size
    of each table entry. For example, if a function’s range is the integer values
    0 through 255, then each table entry requires a single byte; if the range is 0
    through 65,535, each table entry requires 2 bytes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best functions you can implement via table lookups are those whose domain
    and range are always 0 to 255 (or a subset of this range). Any such function can
    be computed using the same two instructions: `lea rbx, table` and `xlat`. The
    only thing that ever changes is the lookup table. The uppercase/lowercase conversion
    routines presented earlier are good examples of such a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot (conveniently) use the `xlat` instruction to compute a function
    value once the range or domain of the function takes on values outside 0 to 255\.
    There are three situations to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The domain is outside 0 to 255, but the range is within 0 to 255.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain is inside 0 to 255, but the range is outside 0 to 255.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the domain and range of the function take on values outside 0 to 255.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will consider these cases in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.1.2 Domain Outside 0 to 255, Range Within 0 to 255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the domain of a function is outside 0 to 255, but the range of the function
    falls within this set of values, our lookup table will require more than 256 entries,
    but we can represent each entry with a single byte. Therefore, the lookup table
    can be an array of bytes. Other than those lookups that can use the `xlat` instruction,
    functions falling into this class are the most efficient. The following Pascal
    function invocation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: where `Func` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'is easily converted to the following MASM code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code loads the function parameter into RDX, uses this value (in the range
    0 to ??) as an index into the `FuncTable` table, fetches the byte at that location,
    and stores the result into `B`. Obviously, the table must contain a valid entry
    for each possible value of `X`. For example, suppose you wanted to map a cursor
    position on an 80×25 text-based video display in the range 0 to 1999 (there are
    2000 character positions on an 80×25 video display) to its `X` (0 to 79) or `Y`
    (0 to 24) coordinate on the screen. You could compute the `X` coordinate via the
    function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: and the `Y` coordinate with the formula
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '(where `Posn` is the cursor position on the screen). This can be computed using
    this x86-64 code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `div` instruction on the x86-64 is very slow. If you need to do
    this computation for every character you write to the screen, you will seriously
    degrade the speed of your video-display code. The following code, which realizes
    these two functions via table lookup, may improve the performance of your code
    considerably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that loading a value into ECX automatically zero-extends that value
    into RCX. Therefore, the `movzx` instruction in this code sequence actually zero-extends
    `Posn` into RCX, not just ECX.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re willing to live with the limitations of the `LARGEADDRESSAWARE:NO`
    linking option (see “Large Address Unaware Applications” in Chapter 3), you can
    simplify this code somewhat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 10.1.1.3 Domain in 0 to 255 and Range Outside 0 to 255, or Both Outside 0 to
    255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the domain of a function is within 0 to 255, but the range is outside this
    set, the lookup table will contain 256 or fewer entries, but each entry will require
    2 or more bytes. If both the range and domains of the function are outside 0 to
    255, each entry will require 2 or more bytes and the table will contain more than
    256 entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from Chapter 4 that the formula for indexing into a single-dimensional
    array (of which a `table` is a special case) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If elements in the range of the function require 2 bytes, you must multiply
    the index by 2 before indexing into the table. Likewise, if each entry requires
    3, 4, or more bytes, the index must be multiplied by the size of each table entry
    before being used as an index into the table. For example, suppose you have a
    function, `F(``x``)`, defined by the following (pseudo) Pascal declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create this function by using the following x86-64 code (and, of course,
    the appropriate table named `F`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you can live with the limitations of `LARGEADDRESSAWARE:NO`, you can reduce
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Any function whose domain is small and mostly contiguous is a good candidate
    for computation via table lookup. In some cases, noncontiguous domains are acceptable
    as well, as long as the domain can be coerced into an appropriate set of values
    (an example you’ve already seen is processing `switch` statement expressions).
    Such operations, called *conditioning*, are the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.1.4 Domain Conditioning
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Domain conditioning* is taking a set of values in the domain of a function
    and massaging them so that they are more acceptable as inputs to that function.
    Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This says that the (computer) function `sin(``x``)` is equivalent to the (mathematical)
    function sin *x* where
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we know, sine is a circular function, which will accept any real-value input.
    The formula used to compute sine, however, accepts only a small set of these values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This range limitation doesn’t present any real problems; by simply computing
    `sin(``x` `mod (2 * pi))`, we can compute the sine of any input value. Modifying
    an input value so that we can easily compute a function is called *conditioning
    the input*. In the preceding example, we computed `x` `mod 2 * pi` and used the
    result as the input to the `sin` function. This truncates `x` to the domain `sin`
    needs without affecting the result. We can apply input conditioning to table lookups
    as well. In fact, scaling the index to handle word entries is a form of input
    conditioning. Consider the following Pascal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This function computes a value for `x` in the range 0 to 4 and returns 0 if
    `x` is outside this range. Since `x` can take on 65,536 different values (being
    a 16-bit word), creating a table containing 65,536 words where only the first
    five entries are nonzero seems to be quite wasteful. However, we can still compute
    this function by using a table lookup if we use input conditioning. The following
    assembly language code presents this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code checks to see if `x` ``is outside the range 0 to 4\. If so, it manually
    sets AX to 0; otherwise, it looks up the function value through the `val` table.
    With input conditioning, you can implement several functions that would otherwise
    be impractical to do via table lookup.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
