- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 17 FUNDAMENTALS OF THE FOR COMMAND
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, I’ll introduce the for command, in particular, the for command
    used without any options, which just touches on its overall power. This optionless
    command creates loops, where the input is zero to many values, either simple text
    values or filenames. Some call this the *basic* for command, but I chafe at the
    modifier because there’s nothing basic about the for command, even without the
    options (which I’ll discuss in upcoming chapters).
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of modifiers in a totally different context, the syntax for this command
    allows for several *modifiers*, and you’ll learn how to use these modifiers to
    extract a wealth of information about any file, such as its size, last modified
    date and time, attributes, and portions of the path and filename. You’ll also
    see a couple detailed real-world applications of the optionless for command as
    a small demonstration of its power, and I’ll start with suggestions on how to
    build personalized documentation about this important command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Personalized Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before getting started in earnest, I highly recommend dumping the help documentation
    for the for command into a text file for future reference. As you learned in [Chapter
    12](chapter12.xhtml), you can redirect the output for any command to a file, and
    this is true for the help command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the use of this path, the command creates the *ForCommand.txt* file on
    my Windows desktop. You can try it with the *OneDrive\* node removed or write
    it to the folder of your choosing, but the desktop is a handy place for this file.
    (You’ll learn about the userprofile pseudo-environment variable in [Chapter 21](chapter21.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: I haven’t suggested that you do this for any other command, and you’ll always
    be able to find the help information at the command prompt, so you might be curious
    why I’m suggesting it here. It’ll eventually become more *self*-documentation
    (like a digital notebook) than *help*-documentation, as you explore and experiment
    more with the for command. Some of the documentation isn’t the clearest and, as
    you’ll soon see, could really use some annotating. With this file, you can add
    your own comments and amend the stated syntax so that it makes more sense to you.
    You can also add examples of the different forms the command can take and include
    templates that you can retrieve and use later.
  prefs: []
  type: TYPE_NORMAL
- en: Subtle changes in the syntax of the for command will greatly impact its functionality
    or possibly render it inoperable. As a result, all too often coders will take
    a stab at a for command. If that doesn’t work, they’ll take another stab or several,
    adding a certain keyword, using double quotes around the input, or maybe trying
    single quotes. They’ll eventually find something that works or appears to work.
    A better way is to understand the intricacies of the command’s many forms. Create
    this personalized documentation and you’ll have everything you need to know about
    the command in one place (other than this book, of course).
  prefs: []
  type: TYPE_NORMAL
- en: The Optionless for Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with the optionless for command. The for command can be used with
    (appropriately enough) four options, and I’ll delve into those in the next two
    chapters, but even when used without options, it''s a heavy lifter. The following
    isn’t an actual command but is the general syntax used to execute a loop zero
    to many times, and it’s loosely based on what you’ll find in the help documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The words for, in, and do are reserved words and will appear just as shown here
    in your for commands. The parentheses also will appear as shown, but what’s inside
    them is one of the three main components of an optionless for. Those components
    are the for variable (%%variable), the input you are feeding into the command
    (input), and the core logic executed in the loop (command).
  prefs: []
  type: TYPE_NORMAL
- en: '**The **for** Variable**'
  prefs: []
  type: TYPE_NORMAL
- en: The for variable is central to this command. If the loop executes multiple times,
    its value changes with each pass. You define the for variable as two percent signs
    followed by a singular character. Numbers and many special characters are valid,
    but most coders use letters of the alphabet pretty much universally. Typically,
    %%i is the variable of choice, where i represents *index*.
  prefs: []
  type: TYPE_NORMAL
- en: Some coders use %%i exclusively as if it was the only allowed for variable,
    but don’t limit yourself. A one-character variable name doesn’t allow for a great
    deal of descriptive potential, but use what’s at your disposal. I often use %%f
    for a *file*, %%c for a *count*, and %%n for a *name* or *number*, although %%#
    also works for *number*. As with other variable names, many coders use uppercase,
    but I use lowercase. Do what makes sense to you, and do it consistently.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Input**'
  prefs: []
  type: TYPE_NORMAL
- en: The second component of the for command is the input found inside the parentheses
    or the input you’re feeding into the command. It can be a set of filenames, a
    single filename, a file mask, multiple file masks, hardcoded text, or resolved
    variables. It’ll be a while before I can show you all of those, so for now, just
    consider it to be the input, starting with a single file. (The help documentation
    uses set instead of input, as in a *set* of files, but that term is incomplete
    and easily confused with the command of the same name.)
  prefs: []
  type: TYPE_NORMAL
- en: '**The Command**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the command is the core logic that executes for each pass of the loop,
    which can be zero to many times. It can be a single command or many commands spanning
    several lines of code, and anywhere in that logic you can resolve the for variable
    to its current value, but this variable is quite different from variables you’ve
    seen up to this point. Typically, you resolve variables with percent signs, front
    and back, but you resolve the for variable as it’s defined: prefixed with two
    percent signs. More plainly, if you define the for variable as %%n, you can resolve
    it with %%n as part of the command.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the way Batch accepts parameters, a strategically placed tilde removes
    any double quotes encasing the variable. With for variables, the tilde comes after
    the second percent sign and before the variable name—for example, %%~n. As with
    parameters, if there are no double quotes, the tilde has no effect on the resolution.
  prefs: []
  type: TYPE_NORMAL
- en: In a very surprising twist, the for variable is case-sensitive, which is a notable
    oddity in the world of Batch. Therefore, %%i isn’t the same entity as %%I. In
    yet another twist, in [Chapter 14](chapter14.xhtml) you learned to escape a percent
    sign with another percent sign. This variable also sports double percent signs,
    but the interpreter is smart enough to differentiate. For instance, if %%i turns
    out to be a for variable, the interpreter resolves it to its value; if not, the
    interpreter treats the first character as an escape character and resolves it
    to the text, %i. Let’s put this all together into some examples we can actually
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following for command writes the path and filename to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For its three components, I’m choosing %%f for the for variable as shorthand
    for *file* because the input is a file, *C:\Batch\MyInputFile.txt*. The command
    component is a single echo command that writes text to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before long you’ll see how the for command can create a loop executing multiple
    times, but this example executes exactly once, with the variable set to the path
    and filename inside the parentheses. Moving to the command after the do reserved
    word, the %%f in the echo command resolves to the input text, which writes the
    following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice the two instances of %%f in the line of code, one close to the beginning
    and a second at the very end. The first defines the for variable, and the second
    instance uses the variable; that is, the command component resolves it and uses
    its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s a bit easier to follow if you add parentheses around the echo command,
    which is also legitimate syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the command component contains logic that’s at all complex, it’s best to
    rewrite it on multiple lines for the sake of readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is functionally equivalent to the two previous examples,
    but the echo command is now on its own line. With multiple line syntax, the parentheses
    are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The open parenthesis must follow the do reserved word on the same line. That’s
    an important stipulation because other languages allow, and even encourage, the
    open parenthesis to be on its own line, lined up with the close parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: 'This next example demonstrates three additional points about the optionless
    for command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, notice that multiple commands are more than possible in the code block
    of a for command. Second, I changed the for variable to %%F, just to show that
    I can make it pretty much any character that I desire, as long as I consistently
    use %%F or %%~F in the code block (although you won’t see me use a capital for
    this type of variable again). Third, I’ve encased the input path and filename
    in double quotes. Embedded spaces, parentheses, and even plus signs are in the
    path and name of the Notepad++ 32-bit executable, but the interpreter is unfazed
    because of those double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate that the tilde works as it does with parameters, notice that
    the double quotes are present in the output from the first echo command using
    %%F, but not the second using %%~F:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This for command might seem like overkill for a single filename as input because
    it most definitely is overkill. You could’ve written these two lines of text to
    the console far more easily with nothing more than two echo commands. The real
    benefit of this logic becomes apparent when you use filesets and file masks to
    execute the loop multiple times, once for each file.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The terms for*command *and for* loop *are largely interchangeable, but there’s
    a subtle difference. Technically, loops can execute zero to many times, but I
    often use the term* loop *when, because of the nature of the input, I’m confident
    that it will execute multiple times. Conversely, I use* command *when I know that
    the logic in the code block will execute exactly once, as in all of the previous
    examples, but I also use it if there’s ambiguity since it’s the more general and
    inclusive term.*'
  prefs: []
  type: TYPE_NORMAL
- en: Filesets, File Masks, and Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *fileset* is, as you might expect, a set of files, and the for command accepts
    a fileset as input as easily as it accepts a single file. Two files delimited
    by a comma and a space are in the input fileset here, but you can include any
    realistic number of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A comma without the space would also delimit the two files, as would a space
    without the comma, but both make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the first example of a for command transformed into something that executes
    more than once—that is, something more often called a for loop. The interpreter
    executes the code block twice because the fileset contains exactly two files.
    A third file in the fileset would have produced a third line of output.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](chapter7.xhtml), I introduced file masks using wildcards in the
    context of the xcopy and robocopy commands, and the same rules (and batveats)
    apply when you create a file mask as the input to a for command. The asterisk
    stands in for any number of characters, even no characters at all, and the question
    mark usually represents exactly one character. However, question marks coming
    at the end of the mask or followed by a dot, can also represent no character at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, I’ll start with a familiar for command, replacing the filename
    with the simplest of all masks, a lone asterisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Instead of writing a single filename to the console, the interpreter now outputs
    every file in the folder, one by one, because every file satisfies the mask. If
    there are 17 files in *C:\Batch\*, all 17 fit the mask, and the interpreter writes
    a message to the console for all 17\. The echo command executes just once if only
    one file exists in the folder, and it doesn’t execute at all if no files exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing filenames to the console isn’t very satisfying, but you can perform
    far more interesting tasks with file masks. You might rename every file that satisfies
    a mask, or you might call a compiled program once for each file. Whatever the
    task, the basic structure of the for loop won’t change, and if the logic is going
    to be at all complex, it’s best to set it up in an internal routine. Here’s a
    call command invoking just such a routine for each file, passing the path and
    filename of each file as the sole argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If a dozen files fit this mask, the call command invokes the routine 12 times,
    once for each file.
  prefs: []
  type: TYPE_NORMAL
- en: Batch even accepts a comma-delimited list of file masks as input to a for command.
    That is, you can create a fileset containing multiple files and/or file masks.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Text as Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another intriguing use of the optionless for command isn’t found in the help.
    You can process a list of values one by one by entering them inside the parentheses
    as the input. The same set of characters that Batch uses for delimiting passed
    arguments also delimits this list, so you can use commas, semicolons, equal signs,
    and tab characters, but a space-delimited list is the norm. The syntax is similar
    to several previous examples, but with the delimited text replacing the filename
    or mask. For example, this for loop sequentially passes each of the five words
    in the parentheses to the code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result sees each word written to the console on individual lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that Batch treats the for inside the parentheses as simple text and not
    as the reserved word that starts the command. I’ve taken some shots at the interpreter,
    but it’s smart enough to recognize the difference contextually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The prior input list is space-delimited, but the interpreter treats anything
    encased in double quotes as a single value, meaning that the following for command
    executes its code block exactly twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is these two lines of output to the console, not seven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the use of a tilde when resolving the for variable, %%~i, removes
    the double quotes from each string.
  prefs: []
  type: TYPE_NORMAL
- en: These simple examples belie the immense usefulness of the technique. To illustrate,
    I’ll start with a bat file that accepts a single parameter for some sort of processing.
    The process isn’t important here; maybe the passed value is added to a data structure,
    or maybe it’s a filename passed to a called executable. Whatever the process,
    the point is that if I have 17 items to process, I must call the bat file 17 times.
    But with this technique of using a list as input to a for command, I can enhance
    the bat file so that it’ll accept any number of these parameters and process them
    one by one in a single execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by putting the logic for processing a single parameter into a callable
    routine defined by the :ProcessParm label. Now I can call that routine zero to
    many times with this code at the top of my bat file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I’ve entered %* into the parentheses as the input of the for command. (Remember
    from [Chapter 11](chapter11.xhtml) that these two bytes expand to the entire parameter
    list as received by the bat file.)
  prefs: []
  type: TYPE_NORMAL
- en: If there are 99 parameters, all 99 values become the input to the for command,
    and the interpreter executes the body of the loop 99 times. In its first pass,
    %%i resolves to the first parameter in the list and is the argument passed to
    the routine in the call command. After the first pass completes, the second parameter
    becomes the argument for the second pass, and so on, until the interpreter processes
    all 99 parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Other uses for this technique abound. For instance, you can easily sum up a
    space-delimited list of numbers. I haven’t introduced arrays yet, but this offers
    a great means of adding multiple values to an array.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving File Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The optionless for command has one more awesome feature. It can retrieve copious
    amounts of information and data about a file, such as its size, last modified
    date/time, and much more. Earlier in this chapter, I discussed using the technique
    of passing a filename into a for loop for the unimpressive purpose of simply writing
    the path and filename to the console. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let’s turn that into something impressive. Instead of just regurgitating a path
    and filename, the code will retrieve and write out an abundance of information
    about the file. If the file has something to hide, we’ll expose it. The only changes
    I’ll eventually make to the code in the previous example is to the code block
    associated with the for command, but first I must introduce modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The tools for extracting this bevy of useful data about a file are called *modifiers*,
    and 9 out of 10 of them are a single alpha character strategically inserted into
    the for variable as it’s being resolved. (I’ll get to the 10th one soon.)
  prefs: []
  type: TYPE_NORMAL
- en: To use a modifier, start with a for variable such as %%f. Then insert a tilde
    and the modifier character after the two percent signs and before the one-character
    variable name. For instance, X is the modifier for retrieving a file’s extension,
    meaning that for the for variable, %%f, the interpreter resolves %%~Xf to the
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block now has 11 echo commands. The first two are nothing
    new; they both display the path and filename, the first with the double quotes
    in place and the second with them removed. The nine other echo commands use a
    specific modifier to, understandably enough, modify the %%f variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I’ve documented each of the nine modifiers in the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing this code might write the following text to the console. Carefully
    examine the impact of each modifier on the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That’s quite a bit of data. Starting with the third line, the F modifier gives
    us the fully qualified pathname. Often, %%~Ff resolves to the same value as %%~f
    as it does here, but not always. If the input consists of a filename and extension
    without a path and if the interpreter finds the file in the current directory,
    then %%~f mimics the input without the path, but %%~Ff resolves to the full path
    and filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can see the individual components of this fully qualified pathname
    in the next four modifiers: D (drive letter with the colon), P (path or directory
    without the drive letter), N (bare filename—that is, without the extension), and
    the aforementioned X (file extension, including the preceding dot).'
  prefs: []
  type: TYPE_NORMAL
- en: The S modifier generates the short filename defined by the operating system
    (I promised I’d show you how to find this in [Chapter 7](chapter7.xhtml)), while
    the A modifier generates a list of file attributes. A file has 11 possible attributes,
    and if the file doesn’t have a particular attribute, the corresponding byte is
    a dash. The only attribute that pops in this list is a, meaning that the file
    is archived, but the lack of other values indicates that the file isn’t hidden,
    compressed, read only, or characterized by any of the other possible attributes.
    (I’ll discuss attributes more in [Chapter 30](chapter30.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the T modifier provides the date and time when the file was last modified,
    and the Z modifier returns the file size in bytes. (Remember that S is taken.)
    The lack of commas makes it hard to read, but you can see from the output that
    the file is nearly 3MB.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Unless you’ve jumped directly to this portion of the book, you know that I’m
    not a fan of the overuse of capitalization, but everything has its place. The
    modifiers are case-insensitive, but I use uppercase to make them stand out. The
    lowercase for variable, which in this case is f for* file*, terminates what’s
    to be resolved, but I know that I’m in the minority. Be aware that most coders
    do just the opposite, so you’re more likely to see %%~zI to get the file size
    of %%I than my %%~Zf used to get the size of %%f.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The applications of modifiers are boundless, but one simple use is to execute
    some sort of complex task for a file, but only if the file has data in it. Say
    the Batch code is to process a data file coming from another source. Even if the
    source has no data to report, it’s best for it to create an empty file, because
    no file at all would leave the specter of a failed process. To make this work,
    the bat file needs to determine whether the file is empty or populated. Consider
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The if command inside the for command efficiently (and maybe even elegantly)
    verifies that the size of an intermediate data file, %%~Zf, is greater than 0
    bytes before calling a routine and passing it the path and name of the file.
  prefs: []
  type: TYPE_NORMAL
- en: The path Modifier
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: I owe you a 10th modifier, and just in case you haven’t found this syntax convoluted
    enough, the syntax for the path modifier is completely different from the other
    nine. But that’s not a problem, because its function is also completely different.
    I’ll explain what it does momentarily, but first understand that this modifier
    is actually an oddly delimited variable. While the other modifiers are each a
    single character, the path modifier is a variable name preceded by a dollar sign
    and trailed by a colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set this up, and for reasons that will soon become obvious, let’s use the
    path variable in the modifier (the same variable containing a concatenation of
    semicolon-delimited directories introduced in [Chapter 8](chapter8.xhtml)). The
    variable should already be set on your machine, but you can append and prepend
    additional directories to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To see this modifier in action, let’s modify the %%f variable with the %%~$path:f
    syntax. Notice the path variable, sandwiched between the $ and : characters; all
    three pieces make up the modifier. Now we can use it in a for command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s this modifier’s actual function? It instructs the interpreter to traverse
    the path variable, starting from its first listed directory, looking for the first,
    and only the first, file named *FourBrits.txt*. If the file exists in the second
    directory in our path variable, but not the first, the resulting output contains
    the fully qualified path and filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If the interpreter can’t find a file named *FourBrits.txt* in any of the directories
    defined in the path variable, it simply resolves %%~$path:f to null.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality was clearly designed for the path variable, and the help
    documentation explicitly uses the path variable in its example; only near the
    bottom does it mention that you can replace it with any valid variable, meaning
    any variable containing a list of directories. Even so, this is usually referred
    to simply as the *path* modifier and used nearly exclusively with the path variable.
  prefs: []
  type: TYPE_NORMAL
- en: Stacked Modifiers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Used individually the modifiers are very helpful, but their real power becomes
    apparent when you stack multiple modifiers—that is, when used together to resolve
    more than one file characteristic at a time. For instance, you can resolve the
    filename and extension separately and then concatenate them as %%~Nf%%~Xf, but
    that’s a tad bit messy. Instead, %%~NXf sublimely produces the identical result
    more elegantly. Here are three typical examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code might write the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With stacked modifiers you can easily retrieve the full path of a file without
    the filename, or just the filename and extension without the path. The last example
    might look good on a report with the hardcoded text, bytes, at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stacked modifiers even work with the path modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code writes out the full path, sans the filename and extension, of the
    first file found in the path hierarchy named *FourBrits.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters with Modifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before getting into a couple of real-world examples, I’ll return to a discussion
    on parameters from [Chapter 11](chapter11.xhtml). It turns out that the modifiers
    that extract file information in the context of for commands work equally well
    on parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'I had mentioned that you can pass filenames, with or without their paths, as
    arguments to a bat file and that the called bat file can resolve them with %~1,
    %~2, and so on. Also, you can resolve %~0 to the full path and filename of the
    bat file being executed. Well, the same modifiers (and stacked modifiers) just
    discussed also apply to any parameter that represents a file. Assume that the
    following code receives the names of two files as its first two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first command writes out the size in bytes of the first file, and the second
    command writes out the last modified date and time of the second file.
  prefs: []
  type: TYPE_NORMAL
- en: Attach two specific stacked modifiers to the hidden parameter, and %~DP0 resolves
    to the drive letter and path of the bat file being executed. With this information,
    you can create a subdirectory, deposit other files in this or sibling directories,
    or update a logfile associated with the bat file, and you can do this without
    knowing where the bat file will eventually be installed. Maybe it will live on
    multiple servers.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers allow you to retrieve a great deal of file information with minimal
    keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: Real-World Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s put all of the useful tools that you’ve just learned in this chapter to
    use in two real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming Files on a Backup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the use of a file mask, the optionless for command can generate a list
    of files, and the modifiers can extract the individual components of the path
    and filename of each. Combining both of those features, you can copy a set of
    files to a mirror folder structure on another drive, all while tweaking the target
    filenames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that I have a folder called *C:\Budget\* that unsurprisingly contains
    budget information. The name certainly suggests a directory that should be backed
    up, perhaps to an external *D:\* drive, but with the exact same folder structure
    so that the files are easy to find and compare. To complicate matters, I’d like
    to prepend the name of every file with Bkup_, because when both folders are open,
    it’s far too easy to work in the wrong one, but not if every file in the backup
    directory starts with this unique and descriptive text. One way to accomplish
    this task is with a single command inside a for loop (although in the real-real-world,
    you’ll want some error handling):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve encased both the source and destination in double quotes to accommodate
    the possibility of embedded spaces in a filename. The source is the fully qualified
    path and filename, %%~Ff, but the destination is a bit more esoteric. While it
    might look like random keystrokes, it’s really a concatenation of four items that
    become more readable when I bolded the two for variables using modifiers in contrast
    to the constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The destination path starts with the hardcoded drive letter and a colon, D:,
    followed by the path of the source file variable without the drive letter, %%~Pf;
    this mimics the source folder from the original drive. The path starts and ends
    with a backslash, so what comes next, Bkup_, is the start of the filename. To
    complete the target filename, the interpreter finds a second for variable, %%~NXf,
    this one having stacked modifiers for the source filename (N) and file extension
    (X).
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, if the interpreter finds a file named *C:\Budget\Budget.January2023.xlsx*,
    the resulting destination string is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Where the variable names start and end can be confusing if you’re used to Batch
    variables that are delimited by percent signs. When the compiler sees %%~, it
    knows that it’s about to resolve a for variable—that’s the start. Because the
    variable defined by this for command is %%f, the interpreter terminates the variable
    when it finds a lowercase f—that’s the end. In between the start and end, the
    interpreter looks for zero to a few valid modifiers. Anything after its termination
    could be constants, a single percent sign starting the resolution of a more traditional
    Batch variable, or another for variable.
  prefs: []
  type: TYPE_NORMAL
- en: Each and every file in the source directory matching the mask is copied to the
    backup path on the *D:\* drive with the name of the destination file tweaked.
    This tool is very powerful with a lot going on inside an apparently modest for
    command, but to harness that power, a deep understanding of the syntax is a must.
  prefs: []
  type: TYPE_NORMAL
- en: Processing a Variable Number of Files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the end of [Chapter 11](chapter11.xhtml), I introduced the concept of a *wrapper*
    bat file—that is, a bat file that does little more than execute a program designed
    to process a single input file. The bat file is a wrapper around the executable.
    Also in that chapter, I demonstrated how to drag and drop multiple files onto
    a bat file, resulting in one execution of the bat file with multiple arguments.
    As impressive as that is, it’s of little use without a bat file that not only
    can handle all of those parameters but can do so for a variable number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ve discussed two important concepts that are applicable to
    building such a wrapper bat file. One is the immensely useful technique of using
    modifiers on a parameter to extract file information, and the other is the for
    command’s ability to process a list of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for the setup. I’ve created a compiled program to convert Java code to
    C# code, and it accepts two arguments: the input file followed by the output file.
    Code conversion programs can help minimize the pain of updating old code to a
    newer language. A module of one language is the input to the program that converts
    much of the original syntax to another language, outputting a file of the same
    name but with a different extension in the same folder. From the perspective of
    the bat file, it accepts one to many *.java* files as parameters, determines the
    path and filename of the corresponding *.cs* output files, and invokes the compiled
    code with those two arguments—and the *.java* files can be in any folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following bat file, stripped of all error handling and comments, does everything
    desired. The for command accepts the entire list of parameters as %*, passing
    them one by one into the code block as %%f, which in turn is the sole argument
    passed to the :ConvOneFile routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When invoking *ConvJava2CS.exe*, this Batch code passes it two arguments, the
    input and output files, respectively. I’m retrieving the fully qualified name
    of the input file with %~F1, which is the first parameter with the F modifier.
    The output path and filename, %~DPN1.cs, is more complex. I’m using the same parameter,
    namely, %~1, but with the modifiers for the drive (D), path (P), and filename
    (N)—that is, %~F1 without the extension denoted by the X modifier. Then I tack
    on the new extension with the hardcoded .cs to create the output filename. Notice
    that a single percent sign, not two, is leading these variables, because these
    are parameters, not for variables; I’m calling the executable from inside a routine,
    not inside the for command.
  prefs: []
  type: TYPE_NORMAL
- en: A critic (or maybe someone not versed in Batch) might balk at this, arguing
    that it’s better or easier to accept a single parameter into the compiled code
    and do the manipulation of the filename in the program. But this approach is inflexible;
    if someone else wanted to run this process on scores or even hundreds of files,
    they might want the output dropped into a subfolder, or even a folder on another
    server. By manipulating the filenames in the Batch code, dropping the output into
    a subdirectory doesn’t require a change to the compiled code; instead, simply
    change %~DPN1.cs to %~DP1%subDir%\%~N1.cs. You could define a hardcoded subdirectory,
    but here I’m using subDir as the variable for the subdirectory node. You can even
    execute an md command with %~DP1%subDir%\ as its argument to create the subdirectory
    if it doesn’t already exist.
  prefs: []
  type: TYPE_NORMAL
- en: There’s always overhead with changes to compiled code, even simple ones. You
    have to run the compiler and take care to keep the source and executable in sync.
    Whenever possible, coders should make simple changes, such as deriving file connectors
    or filenames, in the Batch code, in my humble opinion at least.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use this bat file to process multiple files or a single file or
    even no files. If no arguments are passed, the for command has no input, and the
    code block never executes. Once again, just a few lines of code are doing much
    more than first meets the eye.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving Variables in Code Blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before moving forward with all of the functionality and power that you can unlock
    from the for command with options, I must mention that up to this point I’ve resolved
    variables for a single use inside of a code block associated with a for command,
    but this is hopelessly simplistic and naive. It’s far more common to assign a
    piece of data to a variable and then use it, and maybe even modify it, all inside
    a complex code block. This is the same type of code block detailed in [Chapter
    16](chapter16.xhtml), and the same rules concerning how to resolve variables apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might want two distinct fields for a file’s date and time,
    but the T modifier resolves them as a single value, and that isn’t an issue at
    all with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the code block, I assign the entire string to the filDtTm variable
    and then substring out the date and time on the next two lines, respectively.
    This is a fine yet crucial point: I’m using exclamation marks and delayed expansion
    to resolve the variable just set inside the code block. Percent sign delimiters
    would’ve resolved this to the value of filDtTm prior to the code block, and since
    it’s unlikely to have been set at all, the results probably would’ve been garbage
    (~0,10 and ~11).'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, if you assign a value to a variable inside a code block, you must
    use exclamation marks to retrieve its current value. If the logic gets overly
    complex, there are other techniques, and in [Chapter 20](chapter20.xhtml), I’ll
    demonstrate how to make full use of delayed expansion inside these more complex
    code blocks. But as a rule, understand that these variables have two possible
    values and do your best to not overcomplicate the code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I detailed the optionless for command, its components, how
    it works with filesets and file masks, and how to retrieve a great deal of file
    information with modifiers. You learned that this command usually accepts a file
    or files as input, but it can also accept a string of text. I hope you found the
    real-world applications interesting and informative and that they encouraged you
    to think about other pertinent uses for this important command. I also included
    some pointers on how to resolve variables defined in the code block of the for
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining chapters of [Part II](part2.xhtml) will reveal much more, all
    of which will be needed to appreciate the panorama of the for command. In the
    next chapter, I’ll discuss some functionality that’s opened up with options; one
    enumerates directories instead of files, one traverses subdirectories looking
    for files, and the last implements a crucial bit of functionality: an iterative
    loop.'
  prefs: []
  type: TYPE_NORMAL
