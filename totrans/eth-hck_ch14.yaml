- en: '**14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PIVOTING AND PRIVILEGE ESCALATION**
  prefs: []
  type: TYPE_NORMAL
- en: '*What I cannot create, I do not understand.*'
  prefs: []
  type: TYPE_NORMAL
- en: –Richard Feynman
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By this point in the book, we’ve explored many ways of compromising a single
    machine. But attackers often want full control of the entire private network they’re
    targeting. With full control of the network, the attacker can move freely from
    machine to machine, extracting information and implanting malware as they please.
    Moreover, once the attacker has control of the network, removing them can be very
    difficult because they could be hiding anywhere. In this chapter we’ll explore
    two techniques for moving through the network.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll learn a pivoting technique that attackers can use to gain access
    to a private network by routing traffic through a dual-homed machine with access
    to both a public network and private network. Second, we’ll extract user credentials
    from a machine’s memory using a privilege escalation attack. In some cases, we
    can use the stolen credentials to log in to another machine on the private network.
    Using stolen credentials is one of the best ways an attacker can move around in
    a network.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pivoting from a Dual-Homed Device**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We often refer to networks that are open to anyone as public networks. For example,
    the internet is a public network. On the other hand, networks that are closed
    to the public, such as a network inside an organization, are called private networks.
    However, users on a private network will often need access to resources on a public
    network such as the internet. For example, employees in a corporation still need
    access to Google. Thus, companies often use firewalls to safely bridge the public
    network (the internet) and the private, corporate network. Because the firewall
    is connected to both the public and private networks, we refer to the machine
    running the firewall as a *dual-homed device*.
  prefs: []
  type: TYPE_NORMAL
- en: Dual-homed devices are critical for attackers because most attackers on a public
    network who hope to access an organization’s private network must pass through
    this firewall. Routing traffic through a dual-homed machine to gain access to
    a network is a technique called *pivoting*. Let’s set up a test network to demonstrate
    pivoting. We’ll compromise the Metasploitable virtual machine, which we’ll configure
    as a dual-homed device, and use it as a proxy to access the private network to
    attack an Ubuntu virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: '***Configuring a Dual-Homed Device***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The pfSense machine in our virtual environment is an example of a dualhomed
    device because it acts as a bridge between our private network and the public
    internet. However, we don’t want to compromise our pfSense machine in our pivoting
    demonstration; it protects our devices from being attacked by real attackers on
    the internet. Instead, we’ll convert the Metasploitable virtual machine into a
    dual-homed device and attach it to another private network containing an Ubuntu
    virtual machine. [Figure 14-1](ch14.xhtml#ch14fig1) depicts the network we’ll
    be attacking.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch14fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: An overview of the network*'
  prefs: []
  type: TYPE_NORMAL
- en: The Metasploitable server’s primary interface is denoted at ➊. This is the interface
    we’ll connect to our simulated public network containing the Kali Linux virtual
    machine. The second interface ➋ is connected to the private network. Our goal
    will be to compromise the Metasploitable server and use it to route traffic from
    the primary interface to the private network on the secondary interface. But first,
    we must set up the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by enabling the second interface on the Metasploitable virtual machine
    and then connecting it to a private network. To do this, navigate to Metasploitable’s
    settings in VirtualBox ([Figure 14-2](ch14.xhtml#ch14fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch14fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Configuring the second network interface*'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Network** tab ➊, click the second adapter ➋, and then enable it
    ➌. Name the private network **Private LAN** ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we must assign an IP address to the interface we just enabled. We’ll do
    that by editing the Metasploitable server’s network *interface* file. Run the
    following command to open the file in `vim`, which comes preinstalled on Metasploitable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you open the file, you should see the primary interface defined at ➊. This
    interface is usually connected to the public network. The value `iface eth0` refers
    to the Ethernet (`eth0`) interface. See [Chapter 1](ch01.xhtml#ch1) for a discussion
    on interfaces. Next, `inet` represents IPv4 addressing, and `dhcp` means we’ll
    allow the *dynamic host configuration protocol (DHCP)* server to assign an IP
    address to the interface. DHCP is the protocol routers normally use to assign
    IP addresses to machines when they join a network. For example, your home Wi-Fi
    router has a DHCP server built in, meaning that your laptop uses the DHCP protocol
    to obtain an IP address when it connects. This ensures that your laptop doesn’t
    use the same IP address as a machine already connected to your network. Alternatively,
    a value of `static` means that we’ll manually assign an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll configure the second interface and set it to have a static IPv4 address
    ➋ of `10.0.0.1` ➌ and then set its subnet mask to `255.255.255.0` ➍. Save the
    file and then start the `eth1` interface by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, restart the networking interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '***Connecting a Machine to Your Private Network***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve set up our dual-homed machine, we can move the Ubuntu virtual
    machine to our new private network. However, as soon as we do, it will no longer
    have access to the internet. So before we move it, let’s take the opportunity
    to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use OpenSSH to log in to the Ubuntu machine. OpenSSH is an open source
    implementation of an SSH server that allows users to connect to a machine using
    SSH. Log in to your Ubuntu virtual machine and install the OpenSSH server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once the installation completes, move your Ubuntu virtual machine to the private
    network by updating the interface in VirtualBox to connect to **Private LAN**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll need to assign an IP address to the interface on the Ubuntu virtual
    machine. This is because our private network doesn’t have a DHCP server. Set the
    static IP address on your Ubuntu virtual machine by opening **Settings** ([Figure
    14-3](ch14.xhtml#ch14fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch14fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Setting up a static IP address on the Ubuntu machine*'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Network**, click the **Settings** gear icon, and click the **IPv4**
    tab. Select **Manual** configuration and set the IP address to **10.0.0.15**,
    the subnet mask to **255.255.255.0**, and the default gateway to **10.0.0.1**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that you can access the Metasploitable server from the Ubuntu virtual
    machine by pinging it. If you can reach the Metasploitable server, you should
    get the following, with no packets lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Press CTRL-C to end the ping.
  prefs: []
  type: TYPE_NORMAL
- en: Although your Ubuntu virtual machine can reach the Metasploitable machine, it
    doesn’t have access to anything outside of the private network. Similarly, no
    machines outside of the private network can access the Ubuntu virtual machine.
    This means that you’ve correctly set up your dual-homed machine and private network.
    Now let’s discuss how you can gain access to the private network by compromising
    the Metasploitable machine and transforming it into a bridge between the virtual
    environment’s internal LAN and the private LAN. We commonly refer to this bridge
    as a *proxy*, which is a program that takes data from one connection and passes
    it to another. You can think of it as an intermediary that facilitates a connection
    between two machines.
  prefs: []
  type: TYPE_NORMAL
- en: '***Pivoting with Metasploit***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Metasploit Framework has a built-in proxy capability, so let’s use it to
    execute a pivoting attack from start to finish. We’ll begin by scanning the Metasploitable
    server from our Kali Linux virtual machine. Once we’ve found a vulnerability,
    we’ll exploit it and upload a reverse shell. Then we’ll check to see if the Metasploitable
    server has access to multiple networks.
  prefs: []
  type: TYPE_NORMAL
- en: After we’ve discovered that it does, we’ll use the Metasploitable server as
    a proxy to access the private network containing our Ubuntu virtual machine. Then,
    we’ll use stolen SSH credentials to log in to the Ubuntu virtual machine on the
    private network and upload another reverse shell. Lastly, we’ll control the reverse
    shell in the private LAN by routing our commands through the proxy on the Metasploitable
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started. Scan the Metasploitable server using a vulnerability scanner
    like the ones we discussed in [Chapter 8](ch08.xhtml#ch8). The *Nexpose* vulnerability
    scanner allows you to perform scans from the Metasploit console. Keep in mind
    that these scanners use heuristics, meaning that they might incorrectly identify
    vulnerabilities. Thus, you might need to try multiple vulnerabilities before you
    discover one that gives you access to the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed scanning in [Chapter 8](ch08.xhtml#ch8), so I will assume you
    have already identified some vulnerabilities. For variety, instead of exploiting
    our trusty FTP vulnerability, let’s exploit a vulnerability in the Postgres server
    that lets us upload a reverse shell by exploiting a configuration error. If you
    haven’t already, start Metasploit on Kali Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, select the Postgres exploit by entering the `**use**` keyword followed
    by the path to the exploit. We didn’t select a payload, so Metasploit will default
    to the `reverse_tcp` Meterpreter payload. See [Chapter 10](ch10.xhtml#ch10) for
    an overview of the different types of payloads and how to select them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, we’ll set the IP address of the remote host (`RHOST`). In our case, this
    is the IP address of the Metasploitable server (`192.168.1.101`). We’ll then execute
    the exploit by entering `**run**`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a Meterpeter shell, let’s check the interfaces on the Metasploitable
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplicity I’ve omitted the loopback and primary interfaces in the output
    as these are always present in a network-connected device. We see a new interface
    ➊, which indicates that this machine is connected to another network. We can now
    add a *route* that allows us to send traffic from the virtual environment’s internal
    LAN to the private LAN ➋. A *route* is an entry in the network table that instructs
    the operating system how to forward packets between interfaces. Once we’ve added
    the route, we’ll send the Meterpreter session to the background so that we can
    access the original Metasploit console. Deselect the current module using the
    `**back**` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s load a reverse shell onto the Ubuntu virtual machine. Although you
    could simply log in to Ubuntu to do this, we’ll simulate a real attack scenario
    by assuming that you don’t know the credentials ahead of time. Instead, let’s
    pretend you’ve obtained several credentials during the OSINT phase of the attack
    that you can now use in a dictionary-based attack. We’ll try each of these credentials
    and hope that one of them allows us to log in to the SSH server. Create a file
    on your Kali Linux desktop containing the username and password of the Ubuntu
    machine called *Ubuntu_passwords.txt*. Each username–password pair should be on
    its own line with the username and password separated by a space. Add some dummy
    credentials, but remember to also include the username and password for your Ubuntu
    machine so that you can access the machine. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this file in a dictionary-based attack on the SSH server. We’ll begin by
    selecting Metasploit’s `ssh_login` module. Then we set the remote host, supply
    the password file, and run the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When the attack completes, you should have a shell running on the Ubuntu virtual
    machine. Run the following command to view a list of all your sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Session 2 is the Linux shell running on the Ubuntu machine. The Connection
    column shows that the connection to the shell flows from 192.168.1.115 (Kali Linux)
    to 192.168.1.112 (Metasploitable) to 10.0.0.15 (Ubuntu). To execute commands on
    the Ubuntu virtual machine, run the following command to select session 2\. Then
    try running a terminal command like `**ls**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now you can control the Ubuntu virtual machine on the private LAN from a machine
    outside of that network.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used Metasploit’s proxy. Next, we’ll discuss how you can
    write your own proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing an Attacker Proxy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Create a folder called *ProxyFun* and copy the following code into a new file
    within that folder called *proxy.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The proxy starts a TCP server to listen to the private LAN’s IP address ➌. Remember
    that our target, the Ubuntu virtual machine, can only access IP addresses on the
    private network. So if we want to communicate with it, we must set up a TCP server
    to listen on an IP address associated with the interface connected to the private
    network.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we’ll assume that we’ve already implanted a reverse shell on the Ubuntu
    virtual machine, so we can focus on seeing how the data flows from the reverse
    shell in the private LAN, through the proxy, and into the attacker’s Kali Linux
    machine on our simulated public network.
  prefs: []
  type: TYPE_NORMAL
- en: First, the reverse shell will connect to the proxy’s IP address on the private
    LAN. When the shell connects to the proxy and sends its first message, the proxy
    will extract the data from the message ➊ and open a new TCP connection on the
    external LAN to the hacker’s server. The proxy will send data from the shell in
    the private LAN to the external LAN, acting as a bridge ➋. The proxy will also
    listen for traffic from the external LAN, which it will send to the shell on the
    private LAN. Great! You should now have a two-way bridge between the private LAN
    and the external LAN.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s test our proxy. Instead of running the TCP server code we wrote in
    [Chapter 4](ch04.xhtml#ch4), we’ll keep this test lightweight. We’ll use netcat
    (`nc`) to start a new TCP server that listens (`l`) on port (`p`) 5050\. We’ll
    also enable the verbose flag (`v`) to print out information on the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, copy the *proxy.py* file onto the Metasploitable server and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that the proxy is up and running, open the Ubuntu virtual machine on the
    private network. Instead of using the reverse shell we wrote in [Chapter 4](ch04.xhtml#ch4),
    we’ll use netcat to connect to the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Enter the phrase `**BOT Reporting For Duty**` in the Ubuntu terminal running
    netcat. If the proxy is working correctly, it will route the private LAN’s traffic
    to the terminal on your Kali Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extracting Password Hashes on Linux**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve gained access to a machine, you can try to extract user credentials
    from the machine’s memory that you can use to log in to other machines and move
    around the network. This section describes how you can extract usernames and password
    hashes from a Linux machine using privilege escalation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '***Where Linux Stores Usernames and Passwords***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The operating system stores usernames in the */etc/passwd* file, which anyone
    on the system can read. The file’s name is deceiving, because it doesn’t contain
    any passwords. Still, we can often glean useful information from this file, such
    as whether an account requires a password. Run the following command to view the
    contents of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A colon separates each property of entries, which follow this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The second property, `has_password`, specifies whether the user has a password.
    An `x` in this property means that the user account has a password, and an empty
    field means it’s a guest account that doesn’t require a password.
  prefs: []
  type: TYPE_NORMAL
- en: So, where does the operating system store the passwords? After all, it must
    keep a copy of the passwords to compare them to the value a user enters when they
    log in. Linux doesn’t store plaintext passwords. Instead, it stores an HMAC-SHA256
    hash of the passwords in the file */etc/shadow*. When a user logs in, Linux hashes
    their password, compares it to the stored hash, and gives access if they match.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can extract these password hashes by reading the */etc/shadow* file; however,
    you’ll need root permissions to do so, as you can see by running the `**ls**`
    command with the `**-l**` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The label `-rw-r-----` represents the file’s permissions. [Figure 14-4](ch14.xhtml#ch14fig4)
    explains the structure of Linux permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The permissions on the */etc/shadow/* file indicate that only the owner (`root`)
    and the group (`shadow`) can read the file, and that only a root user can write
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: If we’re lucky, we’ve found credentials for a user with root permissions and
    can gain root access to the system by entering `sudo -i`. But suppose we aren’t
    this lucky. In that case, we can still gain root access by exploiting a vulnerability
    in the operating system, a process commonly known as *privilege escalation*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch14fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Linux permissions*'
  prefs: []
  type: TYPE_NORMAL
- en: An attacker might use a variety of techniques to gain root privileges on a system.
    For example, they might use a buffer overflow attack to inject code into a kernel
    module or driver. The kernel module would then execute the code with root-level
    permissions, giving the hacker a reverse shell with root permissions.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker could also take advantage of incorrect permissions on a file or
    directory to escalate privileges. For example, if a process executes a file with
    root privileges, an attacker could modify the file to contain code that runs a
    reverse shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unix-privesc` tool is preinstalled on Kali Linux and allows you to check
    a system for vulnerabilities that might allow a privilege escalation attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The Meterpreter shell has similar functionality built in. You can use the command
    `getsystem` to search for and exploit possible privilege escalation vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After you gain root privileges, run the Meterpreter module `**hashdump**` to
    extract the hashes from the system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve looked at these privilege escalations in general, let’s take
    a look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: '***Performing a Dirty COW Privilege Escalation Attack***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2016, Phil Oester discovered a kernel-level vulnerability nicknamed *Dirty
    COW*. The vulnerability (CVE-2016-5195) allows an attacker without root privileges
    to edit any file by exploiting a bug in how the Linux kernel manages memory. Among
    other things, an attacker could use this vulnerability to create a new user with
    root privileges by editing the */etc/shadow* file we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The vulnerability takes its name from the process the Linux kernel uses to manage
    *virtual memory*. Virtual memory is the mechanism operating systems use to give
    processes their own isolated memory spaces. It does this by creating a table that
    maps the process’s virtual memory address to a real physical address in memory.
    Because separate processes may share libraries or files, two processes may have
    virtual memory addresses that point to the same physical memory. The virtual memory
    will only create a copy if one process writes to the memory, a procedure known
    as *copy-on-write (COW)*.
  prefs: []
  type: TYPE_NORMAL
- en: The Dirty COW vulnerability tricks the operating system into letting a user
    edit a file they don’t own. It does this by exploiting a race condition in the
    Linux kernel. A *race condition* occurs when two or more threads rush to access
    a variable and the program’s output depends on the order in which the threads
    finish. Attackers can exploit race conditions by repeatably performing multiple
    order-sensitive operations until they achieve a favorable order of events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dirty COW vulnerability exploits a race condition related to how the Linux
    kernel reads and writes files. The Linux kernel blocks processes from writing
    to read-only files, but it does allow a process to write to a copy of a read-only
    file. When a process writes to its own copy, the Linux kernel would normally execute
    the following events in order: 1) open a processspecific copy of the file, 2)
    write to the copy, and 3) discard the changes and map back to the original file,
    thus leaving the original file unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if an attacker uses two threads to independently write and discard
    changes, a race condition can occur that causes the kernel to execute the sequence
    out of order: 1) open a process-specific copy of the file, 3) discard the changes
    and map back to the original file, and 2) write to the copy, which is now the
    original file. In this scenario, the attacker was able to trick the kernel into
    allowing them to write to a read-only file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this vulnerability to edit the read-only password file and add a
    new user with root privileges. Let’s execute this privilege escalation attack
    on the Metasploitable server. We’ll start by discovering whether your server is
    vulnerable in the first place. Log in to it and then run the `**whoami**` command
    to get the current user, and `**uname -a**` to get the current version of Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have the server’s Linux version, use `searchsploit` to search for
    known vulnerabilities affecting that version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are several implementations of Dirty COW. Some implementations
    use the vulnerability to change the password file, whereas others use it to inject
    shell code into a file with SUID privileges. *SUID* is a Linux permission that
    allows a regular user to execute a file with the privileges of that file’s owner.
    For example, a regular user can execute the `ping` command with root privileges
    even if they aren’t root because the SUID permission is set.
  prefs: []
  type: TYPE_NORMAL
- en: Some exploits are more reliable than others. The *Dirty COW PTRACE* exploit
    works reliably on the Linux version running on the Metasploitable server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the exploit is available on your Kali Linux virtual machine. Using
    `**searchsploit**`, supply the exploit number `**40839.c**`, and use the `**-p**`
    option to find the path to the exploit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, copy the code onto the Metasploitable machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and execute the exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the exploit (`kernelexploit`). You’ll be prompted to create a new root
    user (`firefart`) and provide it with a password. I’ve chosen `147` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to the newly created user with root privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you should be able to read the */etc/shadow* file containing the password
    hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The entry should contain the HMAC-SHA256 hash of the users’ passwords. You can
    crack these hashes using the tools introduced in [Chapter 12](ch12.xhtml#ch12).
    If you succeed, you’ll have escalated your privileges and extracted the plaintext
    passwords for the system’s users.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use these credentials to log in to other machines. The best credentials
    to extract are admin credentials because admins maintain the network and normally
    have access to all machines. However, regular user credentials can also be useful
    because they might have access to other machines on the network, like desktops
    or printers. Tools like `spray` allow you to test multiple passwords and connections
    simultaneously. However, these tools do unusual things and could generate security
    alerts, so you’ll want to be careful when using them.
  prefs: []
  type: TYPE_NORMAL
- en: What about the hashes that you couldn’t crack? You might still be able to use
    them to perform other attacks, such as the *pass-the-hash attacks* that we’ll
    look at in [Chapter 15](ch15.xhtml#ch15).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These exercises are designed to enhance your understanding of privilege escalations
    and pivoting. In the first exercise, you extend your Metasploitable machine so
    that it can route traffic out of the private network, transforming it into a fully
    functional router. The second exercise provides some suggested reading on privilege
    escalation for Windows devices.
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding NAT to Your Dual-Homed Device***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Allow your dual-homed device to route packets out of the private network, as
    a router would, by enabling NAT. First, you must enable IP forwarding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the ARP spoofing attack you performed in [Chapter 2](ch02.xhtml#ch2),
    we need to enable `ip_forward` so that the machine can accept and forward packets
    that don’t match its IP address. Next, set `iptables` to allow the Metasploitable
    virtual machine to route packets from your private network to your virtual environment’s
    internal network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Check to see whether you can access the outside world by pinging the pfSense
    firewall from your Ubuntu virtual machine in the private LAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '***Suggested Reading on Windows Privilege Escalation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Check out Hanno Heinrichs’ blog post “Exploiting GlobalProtect for Privilege
    Escalation, Part One: Windows” at *[https://www.crowdstrike.com/blog/exploiting-escalation-of-privileges-via-globalprotect-part-1/](https://www.crowdstrike.com/blog/exploiting-escalation-of-privileges-via-globalprotect-part-1/)*.
    Crowdstrike’s blog is a great place to find information on new vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another great privilege escalation bug is the Sudo buffer overflow bug (CVE-2021-3156);
    you can read more about it here: *[https://github.com/stong/CVE-2021-3156](https://github.com/stong/CVE-2021-3156)*.'
  prefs: []
  type: TYPE_NORMAL
