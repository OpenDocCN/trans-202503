- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: ADDING ANIMATION AND COLLISION DETECTION WITH TIMERS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用计时器添加动画和碰撞检测
- en: '![Image](../images/circle.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/circle.jpg)'
- en: In this chapter, we’ll add timer-based animation to our BubbleDraw app to create
    floating, bouncing bubbles, and we’ll enhance the app with a user-friendly GUI
    interface. The enhanced app, called BubbleDrawGUI, will add a `JPanel` containing
    the GUI components shown in [Figure 10-1](ch10.xhtml#ch10fig1), giving the user
    the power to animate or pause the bubbles, change the animation speed, and clear
    the screen.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的BubbleDraw应用添加基于计时器的动画，创建漂浮、弹跳的气泡，并为应用增强一个用户友好的图形用户界面（GUI）。增强后的应用称为BubbleDrawGUI，它将添加一个`JPanel`，该面板包含[图10-1](ch10.xhtml#ch10fig1)中显示的GUI组件，使用户能够控制气泡的动画、暂停动画、调整动画速度以及清除屏幕。
- en: '![Image](../images/f0222-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0222-01.jpg)'
- en: '*Figure 10-1: The enhanced BubbleDrawGUI app features animated, bouncing, semitransparent
    bubbles, with a GUI interface to control the animation.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：增强版的BubbleDrawGUI应用展示了动画、弹跳的半透明气泡，并带有一个可以控制动画的GUI界面。*'
- en: This version of the app is even more interactive and user-friendly than before,
    allowing the user to draw with floating, bouncy bubbles as they click and drag
    their mouse on the screen.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的应用比之前更具互动性和用户友好性，用户可以在屏幕上点击和拖动鼠标时，通过漂浮、弹跳的气泡进行绘画。
- en: Copying the BubbleDraw Java Project to Create BubbleDrawGUI
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制BubbleDraw Java项目以创建BubbleDrawGUI
- en: The new GUI app will build directly on the BubbleDraw project from [Chapter
    9](ch9.xhtml#ch9). So, instead of creating a new Java project from scratch, we’ll
    copy the BubbleDraw project and paste it into the same workspace with a new name.
    This is a useful approach anytime you want to expand and work on a newer version
    of a program while keeping the previous version intact.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 新的GUI应用将直接建立在[第9章](ch9.xhtml#ch9)的BubbleDraw项目上。因此，我们不需要从头开始创建一个新的Java项目，而是复制BubbleDraw项目并将其粘贴到同一工作空间中，并为其指定一个新名称。这是一种非常实用的方法，尤其是在你想扩展并开发程序的新版时，同时保留旧版本不变。
- en: In Eclipse, right-click the *BubbleDraw* project folder in the Package Explorer
    pane and select **Copy**. Then, right-click in the Package Explorer pane and select
    **Paste**. The Copy Project pop-up window will allow you to give the copied project
    a new name. Enter `BubbleDrawGUI` and click **OK**. Eclipse will create a new
    copy of the BubbleDraw project in the Package Explorer pane as BubbleDrawGUI.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中，右键点击Package Explorer面板中的*BubbleDraw*项目文件夹，选择**复制**。然后，在Package Explorer面板中右键点击并选择**粘贴**。复制项目的弹出窗口将允许你为复制的项目指定新名称。输入`BubbleDrawGUI`并点击**确定**。Eclipse将在Package
    Explorer面板中创建一个新的BubbleDraw项目副本，命名为BubbleDrawGUI。
- en: '*Renaming the Main Class and Java File*'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*重命名主类和Java文件*'
- en: Now let’s rename the *BubbleDraw.java* file. This is the file with a `public
    static void main()` method that runs the application, and renaming it will help
    us distinguish between the new app and the old version. Inside the new *BubbleDrawGUI*
    project folder, right-click *BubbleDraw.java* and select **Refactor** ▸ **Rename**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重命名*BubbleDraw.java*文件。这个文件包含一个`public static void main()`方法，用于运行应用程序，重命名它有助于我们区分新应用和旧版本。在新的*BubbleDrawGUI*项目文件夹中，右键点击*BubbleDraw.java*，选择**重构**
    ▸ **重命名**。
- en: '*Refactoring* means restructuring your code, but not its functionality. Usually
    programmers refactor when they’ve thought of a better, more efficient way of getting
    their code to do the same thing. When the Rename Compilation Unit window pops
    up, enter the new name, `BubbleDrawGUI`, and then click **Finish**. A second window
    may pop up, warning you that the class contains a `main()` method. You can ignore
    this warning and just click **Finish** a second time. The refactoring process
    will rename both the class and the Java file to BubbleDrawGUI. We’ll leave the
    `BubblePanel` class unchanged for now.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*重构*意味着重新组织你的代码结构，而不是改变其功能。通常，程序员会在想出一种更好、更高效的方式来实现同样的功能时进行重构。当重命名编译单元窗口弹出时，输入新名称`BubbleDrawGUI`，然后点击**完成**。可能会弹出第二个窗口，警告你类中包含`main()`方法。你可以忽略这个警告，只需再点击一次**完成**。重构过程将同时重命名类和Java文件为BubbleDrawGUI。我们暂时不会更改`BubblePanel`类。'
- en: 'Finally, let’s modify the `JFrame` window’s title to match the new GUI version
    of the app. Open the *BubbleDrawGUI.java* file. Find the line that creates the
    `JFrame` and modify it to say *Your Name''s* `BubbleDraw GUI App` as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们修改`JFrame`窗口的标题，以匹配新的GUI版本的应用程序。打开*BubbleDrawGUI.java*文件。找到创建`JFrame`的那一行，并将其修改为显示*Your
    Name's* `BubbleDraw GUI App`，如下所示：
- en: import javax.swing.JFrame;
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JFrame;
- en: public class BubbleDrawGUI extends JFrame {
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubbleDrawGUI extends JFrame {
- en: public static void main(String[] args) {
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: JFrame frame = new JFrame("Your Name's BubbleDraw GUI App");
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JFrame frame = new JFrame("Your Name's BubbleDraw GUI App");
- en: '**NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The first time you run an app containing multiple files, such as the BubblePanel
    and BubbleDrawGUI apps, you’ll need to run the file that contains the main() method.
    Running the main file will create configurations that enable you to run the program
    just by clicking the run button from then on. The BubblePanel class doesn’t contain
    a main() method, so we must either run* BubbleDrawGUI.java *or right-click the*
    BubbleDrawGUI *project folder and select **Run As*** ▸ ***Java Application***.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一次运行包含多个文件的应用程序时，例如BubblePanel和BubbleDrawGUI应用程序，你需要运行包含main()方法的文件。运行主文件会创建配置，使你以后只需点击运行按钮就能启动程序。BubblePanel类没有main()方法，所以我们必须运行*
    BubbleDrawGUI.java *文件，或者右键点击* BubbleDrawGUI *项目文件夹，选择 **Run As** ▸ ***Java Application***。'
- en: Save your file and then run it to see the new title in the title bar at the
    top of the window, as shown in [Figure 10-2](ch10.xhtml#ch10fig2).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并运行它，在窗口顶部的标题栏中查看新标题，如[图10-2](ch10.xhtml#ch10fig2)所示。
- en: '![Image](../images/f0223-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0223-01.jpg)'
- en: '*Figure 10-2: The new* BubbleDrawGUI.java *file opens a window with* “Your
    Name’s *BubbleDraw GUI App” in the title bar.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：新的* BubbleDrawGUI.java *文件打开一个窗口，标题栏上显示* “Your Name’s *BubbleDraw GUI
    App*”。'
- en: Now, let’s make one more change to make the bubbles look more realistic.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们做一个更改，让气泡看起来更逼真。
- en: '*Adding Transparency*'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*添加透明度*'
- en: 'Real bubbles often have a semitransparent look. Think about blowing a bubble
    with bubble gum: once it gets big enough, you can see through the thin surface
    of the bubble. We can add transparency to the bubbles in the BubbleDrawGUI app
    to give them a more lifelike appearance.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的气泡通常具有半透明的外观。想象一下吹气泡糖气泡：一旦它变得足够大，你可以透过气泡薄薄的表面看到里面的东西。我们可以在BubbleDrawGUI应用程序中为气泡添加透明度，使它们看起来更加逼真。
- en: In addition to the RGB color components you learned about in [Chapter 9](ch9.xhtml#ch9),
    Java can store a fourth component in the `java.awt.Color` class. This is called
    the *alpha* component, and it represents how transparent or opaque a color should
    appear onscreen when it is drawn in front of other objects. Just like the RGB
    color values, the alpha component can have values from `0` to `255`. An alpha
    value of `0` will make the color invisible, `128` will make it look semitransparent
    like watercolor paint, and `255` will make it completely obscure any objects behind
    it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在[第9章](ch9.xhtml#ch9)中学习的RGB颜色组件外，Java还可以在`java.awt.Color`类中存储第四个组件。这被称为*alpha*组件，它表示当颜色绘制在其他物体前面时，颜色应显示为多透明或不透明。像RGB颜色值一样，alpha组件的值范围是从`0`到`255`。alpha值为`0`时，颜色将变为不可见，`128`会使颜色看起来像水彩颜料那样半透明，而`255`则会使它完全遮挡其后面的物体。
- en: 'Because the `Color` class’s constructor can accept the alpha value as a fourth
    argument (right after the RGB color values), we only need to change one line in
    the *BubblePanel.java* file to add transparency. Open *BubblePanel.java* under
    the BubbleDrawGUI project’s *src* folder and scroll to the bottom of the file
    where the `Bubble` class is defined:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Color`类的构造函数可以接受作为第四个参数的alpha值（紧跟在RGB颜色值之后），所以我们只需要在*BubblePanel.java*文件中修改一行来添加透明度。打开BubbleDrawGUI项目的*src*文件夹下的*BubblePanel.java*文件，滚动到文件底部，找到定义`Bubble`类的位置：
- en: private class Bubble {
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: private int x;
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: private int x;
- en: --snip--
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: color = new Color(rand.nextInt(256),
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: color = new Color(rand.nextInt(256),
- en: rand.nextInt(256),
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256),
- en: rand.nextInt(256),
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256),
- en: rand.nextInt(256) );
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256) );
- en: '}'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Here we change the color variable’s constructor by adding a fourth random value
    that can range from `0` to `255`. We do so by adding a comma at the end of the
    third `rand.nextInt(256)` in the `color` statement and adding a fourth `rand.nextInt(256)`
    before the closing parenthesis of the `Color()` constructor. Be careful to check
    your commas and parentheses against the code shown here, or the app won’t work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过添加一个第四个随机值来修改颜色变量的构造函数，该值的范围是从`0`到`255`。我们通过在`color`语句中的第三个`rand.nextInt(256)`后面添加逗号，并在`Color()`构造函数的右括号前添加第四个`rand.nextInt(256)`来完成此操作。请小心检查逗号和括号是否与这里显示的代码一致，否则应用程序将无法正常工作。
- en: Save the file and then run it. Click around the screen to draw dots that overlap
    slightly, as shown in [Figure 10-3](ch10.xhtml#ch10fig3).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并运行它。点击屏幕上的任意位置绘制稍微重叠的点，如[图10-3](ch10.xhtml#ch10fig3)所示。
- en: You’ll see now that the bubbles have not only random colors but also varying
    levels of transparency. Some bubbles are opaque and completely cover the screen
    behind them, while others are so transparent they’re barely visible. Our bubbles
    are more bubbly than ever! Now let’s make them float for an even more realistic
    appearance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会看到，气泡不仅有随机的颜色，还有不同程度的透明度。有些气泡是完全不透明的，完全遮挡了它们背后的屏幕，而其他一些则是透明的，几乎看不见。我们的气泡比以往更加“气泡”了！现在，让我们让它们漂浮起来，获得更加逼真的效果。
- en: '![Image](../images/f0225-01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0225-01.jpg)'
- en: '*Figure 10-3: Adding an alpha component to the color of each bubble gives them
    a cool, transparent appearance.*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：给每个气泡的颜色添加一个 alpha 组件，使它们看起来既酷又透明。*'
- en: 'Adding Animation: Bubbles Rising!'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加动画：气泡上升！
- en: '*Animation* is the illusion of movement created by showing a sequence of images
    on the screen. You may have created a flipbook-style animation in a notebook:
    each drawing was shifted slightly from the previous one, and when you flipped
    through the notebook, you could see the animation come to life. We’ll add this
    type of effect to make it look like the bubbles are floating away in the BubbleDrawGUI
    app.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*动画*是通过在屏幕上展示一系列图像来创造的运动错觉。你可能在笔记本上做过翻书式的动画：每一幅画都相较前一幅略微移动，当你翻阅笔记本时，你就能看到动画活了起来。我们将添加这种效果，让气泡看起来像是在
    BubbleDrawGUI 应用程序中漂浮起来。'
- en: To animate the bubbles, we need to draw all the bubbles on the screen, change
    their location slightly, and then draw the screen again a few times every second.
    Each screen we draw is called a *frame*. If we redraw the objects quickly enough,
    our eyes and brains fill in the gaps between frames, making us believe the same
    object has moved in a smooth path. The animation’s *frame rate*, or how quickly
    we redraw the screen, is usually around 30 frames per second. We’ll use a new
    class, `javax.swing.Timer`, which creates timers, to tell our program when to
    redraw the bubbles. We’ll also use an event handler to update the bubbles’ location
    and repaint the screen each time the timer goes off.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现气泡的动画，我们需要在屏幕上绘制所有气泡，稍微改变它们的位置，然后每秒重新绘制几次屏幕。我们绘制的每一帧都叫做一个 *帧*。如果我们足够快地重新绘制物体，我们的眼睛和大脑会填补帧之间的空白，让我们觉得同一个物体沿着平滑的路径移动。动画的
    *帧率*，即我们重新绘制屏幕的速度，通常是每秒 30 帧左右。我们将使用一个新的类，`javax.swing.Timer`，它可以创建定时器，来告诉程序何时重新绘制气泡。我们还会使用一个事件处理器来更新气泡的位置，并在每次定时器触发时重绘屏幕。
- en: 'There are four steps to create the animated bubbles: adding a timer, setting
    the timer, preparing the animation, and starting the timer. These are the same
    steps you would use to add animation to a game or any other app that uses a timer
    in Java.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建动画气泡有四个步骤：添加定时器、设置定时器、准备动画和启动定时器。这些步骤和你在 Java 中为游戏或任何其他使用定时器的应用程序添加动画时会使用的步骤相同。
- en: '*Adding a Timer*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*添加定时器*'
- en: 'To add a timer to our app, we’ll need to import the `javax.swing.Timer` class.
    At the top of your *BubblePanel.java* file, add the following `import` statement:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的应用程序添加定时器，我们需要导入 `javax.swing.Timer` 类。在你的 *BubblePanel.java* 文件的顶部，添加以下
    `import` 语句：
- en: import javax.swing.Timer;
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.Timer;
- en: import java.awt.event.*;
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.event.*;
- en: import java.util.ArrayList;
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.ArrayList;
- en: import java.awt.Graphics;
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Graphics;
- en: import java.util.Random;
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Random;
- en: import java.awt.Color;
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Color;
- en: import javax.swing.JPanel;
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JPanel;
- en: Importing the `Timer` class from `javax.swing` enables us to create a `timer`
    object that triggers an event as often as we choose. Notice on the second line
    in the code snippet, we have already imported `java.awt.event.*`. This line imports
    all the `java.awt` event handlers, including the `ActionListener` class we’ll
    use to handle timer events.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `javax.swing` 的 `Timer` 类使我们能够创建一个 `timer` 对象，这个对象会根据我们设定的频率触发事件。注意在代码片段的第二行，我们已经导入了
    `java.awt.event.*`。这行代码导入了所有的 `java.awt` 事件处理器，包括我们将用来处理定时器事件的 `ActionListener`
    类。
- en: 'Next, inside the `BubblePanel` class, add two variables: one named `timer`
    for the timer itself and an `int` named `delay` to store how many milliseconds
    the timer should wait before redrawing the screen:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `BubblePanel` 类中，添加两个变量：一个名为 `timer`，用于存储定时器对象，另一个是 `int` 类型的 `delay`，用于存储定时器等待多少毫秒后再重新绘制屏幕：
- en: public class BubblePanel extends JPanel {
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubblePanel extends JPanel {
- en: Random rand = new Random();
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Random rand = new Random();
- en: ArrayList<Bubble> bubbleList;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayList<Bubble> bubbleList;
- en: int size = 25;
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: int size = 25;
- en: Timer timer;
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Timer 定时器;
- en: int delay = 33;
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: int delay = 33;
- en: Timers in Java need to know how many milliseconds, or thousandths of a second,
    to wait until they trigger a timer event. A millisecond is really fast, so I’ve
    chosen a delay of 33 milliseconds. This will cause the screen to be redrawn about
    30 times per second, since 1 second = 1,000 milliseconds and 1,000 / 33 = 30 drawings
    per second. This is about the same rate as a cartoon on television.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的计时器需要知道应该等待多少毫秒，或千分之一秒，才能触发计时器事件。由于毫秒非常短，因此我选择了33毫秒的延迟。这样屏幕大约每秒会重绘30次，因为1秒=1,000毫秒，而1,000
    / 33 = 30次绘制每秒。这大约和电视上的卡通动画播放速度相同。
- en: '*Setting the Timer*'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*设置计时器*'
- en: 'Now we’re ready to set the timer. Inside the `BubblePanel()` constructor, add
    the following line to initialize the timer and set it with the given delay:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好设置计时器了。在`BubblePanel()`构造函数内部，添加以下代码来初始化计时器并设置给定的延迟：
- en: public BubblePanel() {
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: public BubblePanel() {
- en: timer = new Timer(delay, new BubbleListener() );
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: timer = new Timer(delay, new BubbleListener() );
- en: bubbleList = new ArrayList<Bubble>();
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList = new ArrayList<Bubble>();
- en: setBackground(Color.BLACK);
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: setBackground(Color.BLACK);
- en: // testBubbles();
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: // testBubbles();
- en: addMouseListener( new BubbleListener() );
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: addMouseListener( new BubbleListener() );
- en: addMouseMotionListener( new BubbleListener() );
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: addMouseMotionListener( new BubbleListener() );
- en: addMouseWheelListener( new BubbleListener() );
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: addMouseWheelListener( new BubbleListener() );
- en: '}'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'The constructor for a new `Timer()` requires two parameters: the first is the
    delay in milliseconds, and the second is the event handler that will listen for
    timer events. A timer triggers an `actionPerformed()` event every time it goes
    off, similar to the `actionPerformed()` event we handle for button clicks in a
    GUI interface. A timer is sort of like an automatic button that “clicks” itself
    every few milliseconds. We’ve placed the timer first in the constructor so that
    we can change it in response to GUI events later.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Timer()`构造函数需要两个参数：第一个是延迟时间，以毫秒为单位，第二个是事件处理程序，用来监听计时器事件。每当计时器触发时，它会像我们在GUI界面中处理按钮点击时的`actionPerformed()`事件一样触发一个`actionPerformed()`事件。计时器有点像一个自动按钮，每隔几毫秒“点击”一次。我们将计时器放在构造函数的第一位，以便稍后可以根据GUI事件来修改它。
- en: 'To listen for timer events, we’re going to modify the `BubbleListener` class.
    Scroll down in *BubblePanel.java* to find the private class `BubbleListener` that
    we created earlier. Then add `implements ActionListener` before the opening brace
    for the class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监听计时器事件，我们将修改`BubbleListener`类。在*BubblePanel.java*中向下滚动，找到我们之前创建的`BubbleListener`私有类。然后在类的开头加上`implements
    ActionListener`：
- en: private class BubbleListener extends MouseAdapter implements ActionListener
    {
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: private class BubbleListener extends MouseAdapter implements ActionListener
    {
- en: 'This change allows the `BubbleListener` class to listen for `actionPerformed()`
    events by implementing the `ActionListener` class from `java.awt.event.*`. Implementing
    an event listener class is another way of handling user events. To handle these
    timer events, we’ll need to add an `actionPerformed()` event handler. Add the
    following method to the bottom of the `BubbleListener` class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改允许`BubbleListener`类通过实现`java.awt.event.*`中的`ActionListener`类来监听`actionPerformed()`事件。实现一个事件监听器类是处理用户事件的另一种方式。为了处理这些计时器事件，我们需要添加一个`actionPerformed()`事件处理程序。将以下方法添加到`BubbleListener`类的底部：
- en: private class BubbleListener extends MouseAdapter implements ActionListener
    {
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: private class BubbleListener extends MouseAdapter implements ActionListener
    {
- en: public void mousePressed(MouseEvent e) {
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: public void mousePressed(MouseEvent e) {
- en: --snip--
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '}'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void mouseDragged(MouseEvent e) {
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: public void mouseDragged(MouseEvent e) {
- en: --snip--
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '}'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void mouseWheelMoved(MouseWheelEvent e) {
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: public void mouseWheelMoved(MouseWheelEvent e) {
- en: --snip--
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void actionPerformed(ActionEvent e) {
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: public void actionPerformed(ActionEvent e) {
- en: '}'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This new `actionPerformed()` method is where we’ll add the code that moves the
    bubbles and repaints the screen every time the timer goes off. We’ll add those
    statements next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`actionPerformed()`方法是我们每次计时器触发时用来移动气泡并重绘屏幕的地方。我们接下来会添加这些语句。
- en: '*Preparing the Animation*'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*准备动画*'
- en: Now that we’ve added a timer and set up the `BubbleListener` to listen for timer
    events, we need to tell Java what to do when the timer triggers an event.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了计时器并设置了`BubbleListener`来监听计时器事件，我们需要告诉Java，当计时器触发事件时应该做什么。
- en: Every time the timer fires off an event, it’s time to draw the next image in
    the animated bubble sequence. First, we’ll tell the `actionPerformed()` event
    handler to update the bubbles and redraw the screen. Then, we’ll tell the `Bubble`
    class to update a bubble by moving it upward on the screen. We’ll have the program
    do these steps about 30 times per second.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每次定时器触发事件时，都是绘制动画气泡序列中下一帧图像的时刻。首先，我们会告诉 `actionPerformed()` 事件处理器去更新气泡并重绘屏幕。然后，我们会告诉
    `Bubble` 类通过向上移动气泡来更新它。程序将每秒执行约 30 次这些步骤。
- en: 'Inside the `actionPerformed()` method that we added to the `BubbleListener`
    class, add the following three lines of code to update the bubbles and repaint
    the screen:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加到 `BubbleListener` 类中的 `actionPerformed()` 方法内部，添加以下三行代码来更新气泡并重绘屏幕：
- en: public void actionPerformed(ActionEvent e) {
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: public void actionPerformed(ActionEvent e) {
- en: '➊ for (Bubble b : bubbleList)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ for (Bubble b : bubbleList)'
- en: ➋ b.update();
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ b.update();
- en: ➌ repaint();
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ repaint();
- en: '}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: At ➊, we’re using the `for-each` version of a `for` statement to loop through
    each `Bubble` `b` in `bubbleList`. Remember that `bubbleList` is the `ArrayList`
    containing all the bubbles we’ve created by clicking and dragging the mouse on
    the screen.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们使用 `for-each` 版本的 `for` 语句遍历 `bubbleList` 中的每个 `Bubble` `b`。请记住，`bubbleList`
    是包含所有气泡的 `ArrayList`，这些气泡是通过在屏幕上点击并拖动鼠标创建的。
- en: As we loop through each bubble in `bubbleList`, we call a new function named
    `update()` ➋ on all the bubbles. Eclipse underlines this statement in red because
    we haven’t yet defined the `update()` method in the `Bubble` class, but we’ll
    do that in just a moment. The `update()` method is where we’ll change the location
    of the bubbles to make them look like they’re floating up toward the top of the
    screen.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历 `bubbleList` 中的每个气泡时，我们会对所有气泡调用一个名为 `update()` ➋ 的新函数。Eclipse 用红色下划线标出这行代码，因为我们还没有在
    `Bubble` 类中定义 `update()` 方法，但我们马上就会定义。`update()` 方法是我们将改变气泡位置的地方，使它们看起来像是在朝屏幕顶部浮动。
- en: At ➌, we call the `repaint()` method to refresh the screen, clearing the drawing
    window and painting the bubbles in their new, updated locations. By doing this
    30 times per second, we’ll achieve the animated effect we want to see.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们调用 `repaint()` 方法来刷新屏幕，清空绘图窗口并以新的、更新的位置重新绘制气泡。通过每秒执行 30 次这个操作，我们就能实现想要的动画效果。
- en: Now let’s create the `update()` method to tell the `Bubble` class how to move
    bubbles each time the animation timer is triggered. In Java’s (x, y) coordinate
    system, we need to subtract from the `y` value (the top of the screen is where
    `y` equals `0`). So, to make the bubbles appear to move upward, we can subtract
    a small amount from the y-coordinate at each update.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建 `update()` 方法，告诉 `Bubble` 类每次动画定时器触发时如何移动气泡。在 Java 的 (x, y) 坐标系中，我们需要从
    `y` 值中减去一个值（屏幕顶部是 `y` 等于 `0`）。因此，为了让气泡看起来向上移动，我们可以在每次更新时从 y 坐标中减去一个小值。
- en: 'Scroll down to the bottom of *BubblePanel.java* where we defined the `Bubble`
    class and add the `update()` method just below the `draw()` method, as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动到 *BubblePanel.java* 文件的底部，我们在这里定义了 `Bubble` 类，并在 `draw()` 方法下方添加 `update()`
    方法，如下所示：
- en: public void draw(Graphics canvas) {
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: public void draw(Graphics canvas) {
- en: canvas.setColor(color);
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: canvas.setColor(color);
- en: canvas.fillOval(x - size/2, y - size/2, size, size);
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: canvas.fillOval(x - size/2, y - size/2, size, size);
- en: '}'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void update() {
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: public void update() {
- en: y -=5;
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: y -=5;
- en: '}'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The function to update the position of a bubble subtracts five pixels from the
    `y` value for that bubble. Each time a bubble is redrawn on the screen, it will
    be located five pixels higher than before.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更新气泡位置的函数会从该气泡的 `y` 值中减去五个像素。每次气泡在屏幕上重新绘制时，它将比之前高五个像素。
- en: Save your file. You only have one more step before you can run the app!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的文件。在运行应用程序之前，你只需要再做一步！
- en: '*Starting the Timer*'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*启动定时器*'
- en: 'The final step in animating the BubbleDrawGUI app is starting the timer. Scroll
    up to the `BubblePanel()` constructor and add the following line:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 动画化 **BubbleDrawGUI** 应用程序的最后一步是启动定时器。向上滚动到 `BubblePanel()` 构造函数，并添加以下代码行：
- en: public BubblePanel() {
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: public BubblePanel() {
- en: timer = new Timer(delay, new BubbleListener() );
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: timer = new Timer(delay, new BubbleListener() );
- en: --snip--
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: addMouseWheelListener( new BubbleListener() );
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: addMouseWheelListener( new BubbleListener() );
- en: timer.start();
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: timer.start();
- en: '}'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The `timer.start()` method will start the timer so that it will fire events
    every few milliseconds as specified, until the `timer.stop()` method is called
    or until you exit the program.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer.start()` 方法将启动定时器，以便它按照指定的时间间隔触发事件，直到调用 `timer.stop()` 方法或退出程序为止。'
- en: Save and run the program now. When you draw bubbles, they should float upward,
    smoothly animated by the timer event handler.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存并运行程序。当你绘制气泡时，它们应该会向上漂浮，由定时器事件处理程序平滑地动画化。
- en: The mouse scroll wheel and every other feature we built in [Chapter 9](ch9.xhtml#ch9)
    still work with our mesmerizing animation effect. The bubbles float in only one
    direction so far, but we’ve achieved the illusion of motion we were aiming for.
    In the next section, you’ll learn how to make the bubbles float in every direction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标滚轮和我们在[第 9 章](ch9.xhtml#ch9)中构建的其他功能仍然适用于我们的迷人动画效果。到目前为止，气泡只向一个方向漂浮，但我们已经实现了预期的运动假象。在接下来的部分中，你将学习如何让气泡向各个方向漂浮。
- en: 'Forever Blowing Bubbles: Adding Random Speed and Direction'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 永远吹泡泡：添加随机速度和方向
- en: The `update()` function we created in the previous section changed only the
    y-location of each bubble, causing the bubbles to move vertically every time the
    screen was redrawn. In this section, we’ll make the bubbles move both vertically
    and horizontally at random speeds so they appear to be blowing away in every direction,
    as shown in [Figure 10-4](ch10.xhtml#ch10fig4).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一部分创建的 `update()` 函数只改变了每个气泡的 y 位置，导致气泡每次屏幕重绘时都垂直移动。在这一部分中，我们将使气泡在随机速度下同时水平和垂直移动，这样它们看起来就像是被吹向各个方向，如[图
    10-4](ch10.xhtml#ch10fig4)所示。
- en: '![Image](../images/f0229-01.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0229-01.jpg)'
- en: '*Figure 10-4: Changing both the x- and y-locations of each bubble makes the
    bubbles look like they’re blowing in random directions from the mouse pointer
    as we drag.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：同时改变每个气泡的 x 和 y 位置会让气泡看起来像是从鼠标指针处向随机方向吹动。*'
- en: The bubble’s horizontal speed is how many pixels to the left or right it moves
    each frame. This is what determines the bubble’s new x-location. Similarly, the
    bubble’s vertical speed determines its new y-location. By just moving the bubble
    in the horizontal and vertical directions, we can make it move in any direction.
    [Figure 10-5](ch10.xhtml#ch10fig5) shows how the horizontal speed and vertical
    speed combine to create the illusion that the bubble is moving diagonally.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 气泡的水平速度是每一帧它向左或向右移动的像素数。这决定了气泡的新 x 位置。同样，气泡的垂直速度决定了它的新 y 位置。通过仅在水平和垂直方向上移动气泡，我们可以使它向任何方向移动。[图
    10-5](ch10.xhtml#ch10fig5) 展示了水平速度和垂直速度如何结合，产生气泡斜向移动的假象。
- en: '![Image](../images/f0230-01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0230-01.jpg)'
- en: '*Figure 10-5: Changing a bubble’s location in both the x- and y-directions
    quickly will make the bubble appear to move diagonally on the screen.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：快速改变气泡在 x 和 y 方向上的位置会让气泡看起来在屏幕上对角线方向移动。*'
- en: 'First, let’s add variables to store how many pixels each bubble should travel
    in the x- and y-directions each time the screen is redrawn. Add these two lines
    to the top of the `Bubble` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加变量来存储每次屏幕重绘时，每个气泡在 x 和 y 方向上应该移动多少像素。将以下两行添加到 `Bubble` 类的顶部：
- en: private class Bubble {
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: --snip--
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: private Color color;
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: private Color color;
- en: ➊ private int xspeed, yspeed;
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ private int xspeed, yspeed;
- en: ➋ private final int MAX_SPEED = 5;
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ private final int MAX_SPEED = 5;
- en: 'At ➊, we’ve declared two integer variables: `xspeed` for the number of pixels
    the bubble will move horizontally each time the screen updates and `yspeed` for
    the number of pixels the bubble will move vertically. At ➋, we add a *constant*
    called `MAX_SPEED` for the maximum number of pixels a bubble should move at one
    time. Constants are named values similar to variables, but constants don’t change
    inside a program, so we declare them as `final` to tell Java that the value of
    the constant is permanent. We also name constants in all uppercase as a convention
    so we can tell them apart from regular variables.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们声明了两个整数变量：`xspeed` 用于每次屏幕更新时气泡在水平上移动的像素数，`yspeed` 用于气泡在垂直方向上移动的像素数。在 ➋，我们添加了一个
    *常量*，名为 `MAX_SPEED`，表示气泡每次最多可以移动的像素数。常量是类似于变量的命名值，但常量在程序内部不可更改，因此我们将其声明为 `final`，告诉
    Java 该常量的值是永久的。为了方便区分常量和普通变量，我们通常将常量命名为全大写字母。
- en: 'We’ll give each bubble a random `x` and `y` speed using the `rand.nextInt()`
    method, just as we did for the bubble’s color. Add these two lines to the `Bubble()`
    constructor:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `rand.nextInt()` 方法给每个气泡一个随机的 `x` 和 `y` 速度，正如我们为气泡的颜色所做的那样。将这两行添加到 `Bubble()`
    构造函数中：
- en: public Bubble(int newX, int newY, int newSize) {
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: public Bubble(int newX, int newY, int newSize) {
- en: x = newX;
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: x = newX;
- en: y = newY;
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: y = newY;
- en: size = newSize;
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: size = newSize;
- en: color = new Color(rand.nextInt(256),
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: color = new Color(rand.nextInt(256),
- en: rand.nextInt(256),
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256),
- en: rand.nextInt(256),
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256),
- en: rand.nextInt(256) );
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256) );
- en: xspeed = rand.nextInt(MAX_SPEED * 2 + 1) - MAX_SPEED;
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: xspeed = rand.nextInt(MAX_SPEED * 2 + 1) - MAX_SPEED;
- en: yspeed = rand.nextInt(MAX_SPEED * 2 + 1) - MAX_SPEED;
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: yspeed = rand.nextInt(MAX_SPEED * 2 + 1) - MAX_SPEED;
- en: '}'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: We need the `x` and `y` speed values to allow the bubble to move in any direction,
    but we have only two variables for four directions (left or right, up or down).
    We can handle this by using both negative and positive values. When the `xspeed`
    is negative, the bubble will move toward the left, and when it’s positive, the
    bubble will move to the right. The `yspeed` will make the bubble move upward when
    negative and downward when positive. To make the `xspeed` and `yspeed` ranges
    span negative and positive values, I’ve multiplied `MAX_SPEED` by `2` and added
    `1`, which is equal to `11` since `5 * 2 + 1 = 11`. This makes `rand.nextInt(MAX_SPEED
    * 2 + 1)` equivalent to `rand.nextInt(11)`, which will return a number between
    `0` and `10`. By subtracting `MAX_SPEED` from this value, you’ll get a result
    between `-5` and `+5` since `0 - 5 = -5`, and `10 - 5 = 5`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`x`和`y`的速度值来让气泡能够朝任意方向移动，但我们只有两个变量来处理四个方向（左或右，上或下）。我们可以通过使用正值和负值来解决这个问题。当`xspeed`为负时，气泡会朝左移动，当`xspeed`为正时，气泡会朝右移动。`yspeed`则会让气泡在`yspeed`为负时向上移动，`yspeed`为正时向下移动。为了让`xspeed`和`yspeed`的范围涵盖负值和正值，我将`MAX_SPEED`乘以2并加上1，这样就得到了11（因为`5
    * 2 + 1 = 11`）。这使得`rand.nextInt(MAX_SPEED * 2 + 1)`等同于`rand.nextInt(11)`，返回的值会在0到10之间。通过从这个值中减去`MAX_SPEED`，就会得到一个在-5到+5之间的结果，因为`0
    - 5 = -5`，`10 - 5 = 5`。
- en: 'Finally, we need to change the `update()` function to move the bubble to its
    new location each time the screen is redrawn. Replace the statement `y -= 5;`
    with the following two statements:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改`update()`函数，使得每次屏幕重绘时，气泡能够移动到新的位置。将语句`y -= 5;`替换为以下两条语句：
- en: public void update() {
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: public void update() {
- en: x += xspeed;
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: x += xspeed;
- en: y += yspeed;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: y += yspeed;
- en: '}'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Instead of moving up five pixels every time the screen is redrawn, each bubble
    will move horizontally by the `xspeed` and vertically by the `yspeed` values we
    randomly generated for that bubble. The result is a colorful explosion of bubbles
    everywhere we drag the mouse!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次屏幕重绘时，气泡将不再每次垂直移动5个像素，而是根据我们为每个气泡随机生成的`xspeed`和`yspeed`值进行水平和垂直的移动。结果就是我们拖动鼠标时，气泡会在屏幕上形成五光十色的爆炸效果！
- en: Save and run the program with these changes, and you’ll see an animated effect
    like the one we saw in [Figure 10-4](ch10.xhtml#ch10fig4). The effect of moving
    the bubbles in the x- and y-directions over time gives each bubble the illusion
    of both a random speed and direction.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行程序，进行这些修改后，你将看到像在[图10-4](ch10.xhtml#ch10fig4)中看到的那样的动画效果。气泡在x和y方向上的移动，随着时间的推移，给每个气泡带来了既随机又具有方向性的速度效果。
- en: One curious behavior that you might notice is that some bubbles, such as the
    ones in the center of [Figure 10-6](ch10.xhtml#ch10fig6), stay put. This is because
    we’re randomly generating numbers between `-5` and `+5` for the `x` and `y` speed,
    and sometimes a bubble’s `xspeed` and `yspeed` will both be `0`. When this happens,
    the bubble won’t move at all.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到一个有趣的现象，就是有些气泡，比如图中[图10-6](ch10.xhtml#ch10fig6)中心的气泡，会停在原地。这是因为我们为`x`和`y`速度随机生成的值在`-5`和`+5`之间，有时气泡的`xspeed`和`yspeed`都为0。当发生这种情况时，气泡将完全不动。
- en: '![Image](../images/f0231-01.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0231-01.jpg)'
- en: '*Figure 10-6: Because the random speed values can be 0, bubbles like the ones
    near the center here will stay put.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-6：由于随机速度值可能为0，像图中靠近中心的这些气泡将保持原地不动。*'
- en: 'You can avoid having stuck bubbles by checking whether both `xspeed` and `yspeed`
    are equal to `0` and changing one or both of them—this is Programming Challenge
    #1 on [page 244](ch10.xhtml#page_244).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查`xspeed`和`yspeed`是否都为0，并改变其中一个或两个值来避免气泡停在原地——这是[第244页](ch10.xhtml#page_244)上的编程挑战#1。
- en: 'Now that our bubbles are floating away as we draw them, there are a couple
    of functions we might want to add to the app: the ability to pause the animation
    and to clear the screen. It’s time to build a GUI interface within our animated,
    graphical app.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的气泡在绘制时飘动起来，我们可能需要为应用添加一些功能：暂停动画和清空屏幕。是时候在我们的动画图形应用中构建一个GUI界面了。
- en: Building a GUI for Our Animated Drawing App
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的动画绘图应用构建GUI
- en: The BubbleDrawGUI app is graphical, but it doesn’t have an interface like our
    other GUI apps. A Pause/Start button and a Clear button, shown in [Figure 10-7](ch10.xhtml#ch10fig7),
    would make it easy for the user to understand and interact with the app, so let’s
    add those next.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: BubbleDrawGUI应用程序是图形化的，但它没有像我们其他的GUI应用程序那样的界面。暂停/开始按钮和清除按钮，如[图10-7](ch10.xhtml#ch10fig7)所示，会让用户更容易理解和与应用程序互动，因此接下来我们将添加这些按钮。
- en: '![Image](../images/f0232-01.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0232-01.jpg)'
- en: '*Figure 10-7: The Pause/Start and Clear buttons*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-7：暂停/开始和清除按钮*'
- en: '*Setting Up the GUI Panel and Buttons*'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*设置GUI面板和按钮*'
- en: In the Package Explorer pane, right-click *BubblePanel.java* and select **Open
    With** ▸ **WindowBuilder Editor**. Click the Design tab, and you should see the
    GUI design view.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在包资源管理器面板中，右键点击*BubblePanel.java*并选择**Open With** ▸ **WindowBuilder Editor**。点击设计选项卡，您应该能看到GUI设计视图。
- en: First, let’s add a `JPanel` to serve as the container for the Pause/Start and
    Clear buttons, as well as any other GUI components you might want to add later.
    In the Palette pane, under Containers, select **JPanel**. Then, hover your mouse
    over the design preview to the right and click the `BubblePanel` design preview
    to place a new `JPanel` onto the black background.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个`JPanel`作为暂停/开始和清除按钮的容器，以及您以后可能想要添加的任何其他GUI组件。在调色板面板中，选择容器下的**JPanel**。然后，将鼠标悬停在右侧的设计预览上，点击`BubblePanel`设计预览，在黑色背景上放置一个新的`JPanel`。
- en: Alternatively, you can add a new `JPanel` by clicking the **javax.swing.JPanel**
    entry under the Structure pane and inside the Components pane to the left. You’ll
    see a very small gray `JPanel` appear at the top of the black `BubblePanel` design
    preview.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过在结构面板中点击**javax.swing.JPanel**条目，并在左侧的组件面板中点击来添加一个新的`JPanel`。您将看到一个非常小的灰色`JPanel`出现在黑色`BubblePanel`设计预览的顶部。
- en: Next, let’s place the Pause/Start and Clear buttons. In the Palette pane, scroll
    down to the Components section, select the **JButton** component, and then hover
    and click inside the small `JPanel` we just added to place the first `JButton`.
    Enter `Pause` as the button’s text, either directly in the GUI preview or in the
    Properties pane. (You’ll see why we refer to it as the *Pause/Start* button shortly.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加暂停/开始按钮和清除按钮。在调色板面板中，向下滚动到组件部分，选择**JButton**组件，然后将鼠标悬停并点击我们刚刚添加的小`JPanel`中，放置第一个`JButton`。将按钮的文本设置为`Pause`，可以直接在GUI预览中或者在属性面板中设置。（稍后您会明白为什么我们称之为*暂停/开始*按钮。）
- en: 'Follow the same steps for the clear button: select **JButton** in the Palette
    pane, click inside the `JPanel` to place the button, and enter `Clear` for the
    button’s text.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 按照清除按钮的相同步骤操作：在调色板面板中选择**JButton**，点击`JPanel`内以放置按钮，并将按钮的文本设置为`Clear`。
- en: If it’s difficult to place the buttons in the `JPanel` because it is too small,
    select **JButton** in the Palette and then click the panel in the Structure pane
    to the left to place each button inside the panel, as shown expanded in [Figure
    10-8](ch10.xhtml#ch10fig8). Name the buttons `btnPause` and `btnClear` either
    as you place them or by changing the `Variable` property in the Properties pane.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于`JPanel`太小而难以放置按钮，请在调色板中选择**JButton**，然后点击左侧结构面板中的面板，将每个按钮放置在面板内，如[图10-8](ch10.xhtml#ch10fig8)中所扩展的那样。将按钮命名为`btnPause`和`btnClear`，可以在放置按钮时直接命名，或者通过在属性面板中更改`Variable`属性进行命名。
- en: '![Image](../images/f0233-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0233-01.jpg)'
- en: '*Figure 10-8: When building a GUI, you can select components from the Palette
    and add them directly to the Structure pane. Here, we’ve added btnPause and btnClear
    to the panel we just created.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-8：在构建GUI时，您可以从调色板中选择组件并直接将其添加到结构面板。在这里，我们已经将btnPause和btnClear添加到我们刚创建的面板中。*'
- en: The Structure pane is a useful way to add components to the GUI in situations
    like this, when we can’t see the `JPanel` well in the design preview, or when
    we want to change the ordering or grouping of the components in the GUI. [Figure
    10-9](ch10.xhtml#ch10fig9) shows both buttons in the finished GUI.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 结构面板是一种在这种情况下向GUI添加组件的有用方法，当我们无法在设计预览中很好地看到`JPanel`，或者当我们想要更改GUI中组件的顺序或分组时。[图10-9](ch10.xhtml#ch10fig9)展示了完成的GUI中的两个按钮。
- en: '![Image](../images/f0233-02.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0233-02.jpg)'
- en: '*Figure 10-9: The Pause/Start and Clear buttons in the finished GUI*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-9：完成的GUI中的暂停/开始和清除按钮*'
- en: Now that we’ve added the Pause/Start and Clear buttons to the top of the drawing
    screen, it’s time to code the buttons’ event handlers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将暂停/开始和清除按钮添加到绘图界面的顶部，是时候编写按钮的事件处理程序了。
- en: '*Coding the Clear and Pause/Start Buttons*'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*编写清除和暂停/开始按钮的代码*'
- en: 'Let’s start with the Clear button. One way to clear all the bubbles from the
    screen would be to reset the `bubbleList` variable to a new, empty list—that way,
    there are no bubbles to be drawn, and the user can begin painting afresh. To implement
    this behavior, double-click the **Clear** button (remember that double-clicking
    a button in the Design tab will create an event listener for the button and switch
    you back to the Source tab) and then add the following two lines inside the braces
    for `bubbleList`’s action listener:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**清除**按钮开始。清除屏幕上所有气泡的一种方式是将`bubbleList`变量重置为一个新的空列表——这样就没有气泡需要绘制，用户可以重新开始绘制。为了实现这一行为，双击**清除**按钮（记住，在设计标签中双击按钮会为按钮创建一个事件监听器，并将你切换回源代码标签），然后在`bubbleList`的事件监听器的花括号内添加以下两行代码：
- en: JButton btnClear = new JButton("Clear");
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: JButton btnClear = new JButton("清除");
- en: btnClear.addActionListener(new ActionListener() {
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: btnClear.addActionListener(new ActionListener() {
- en: public void actionPerformed(ActionEvent arg0) {
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: public void actionPerformed(ActionEvent arg0) {
- en: ➊ bubbleList = new ArrayList<Bubble>();
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ bubbleList = new ArrayList<Bubble>();
- en: ➋ repaint();
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ repaint();
- en: '}'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: panel.add(btnClear);
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: panel.add(btnClear);
- en: At ➊, we clear the `bubbleList` variable by setting it equal to a new `ArrayList`
    of `Bubble` objects. This new list will be empty, so all we have to do is repaint
    the screen and we’ll have a clean, black background just like when we opened the
    app. At ➋, we call the `repaint()` function to draw the new, empty screen.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们通过将`bubbleList`变量设置为一个新的`Bubble`对象的`ArrayList`来清空它。这个新列表将为空，因此我们只需重新绘制屏幕，就可以得到一个干净的黑色背景，就像我们打开应用程序时一样。在➋处，我们调用`repaint()`函数来绘制新的空屏幕。
- en: Save and run the app. Then draw a few bubbles and click the **Clear** button
    to clear the screen.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行应用程序。然后绘制一些气泡并点击**清除**按钮以清除屏幕。
- en: Switch back to the Design tab and double-click the **Pause/Start** button to
    create another event listener. When the user clicks the Pause/Start button, we
    want to not only stop the animation by stopping the timer but also change the
    text on the button to *Start*. Then, when the user clicks again, we want to restart
    the timer to resume the animation and set the button’s text back to *Pause*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回设计标签并双击**暂停/开始**按钮以创建另一个事件监听器。当用户点击暂停/开始按钮时，我们不仅要通过停止计时器来暂停动画，还要将按钮的文本更改为*开始*。然后，当用户再次点击时，我们希望重新启动计时器以恢复动画，并将按钮的文本改回*暂停*。
- en: Enter the following code into the `actionPerformed()` method Eclipse provided
    when you double-clicked the Pause/Start button.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码到Eclipse为你双击暂停/开始按钮时提供的`actionPerformed()`方法中。
- en: '**NOTE**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Make sure your ActionEvent variable in the actionPerformed() method is named
    e, as highlighted in bold in this code.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保你的ActionEvent变量在actionPerformed()方法中命名为e，如代码中的粗体所示。*'
- en: JButton btnPause = new JButton("Pause");
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: JButton btnPause = new JButton("暂停");
- en: btnPause.addActionListener(new ActionListener() {
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: btnPause.addActionListener(new ActionListener() {
- en: public void actionPerformed(ActionEvent e) {
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: public void actionPerformed(ActionEvent e) {
- en: ➊ JButton btn = (JButton)e.getSource();
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ JButton btn = (JButton)e.getSource();
- en: ➋ if (btn.getText().equals("Pause")) {
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ if (btn.getText().equals("暂停")) {
- en: ➌ timer.stop();
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ timer.stop();
- en: ➍ btn.setText("Start");
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ btn.setText("开始");
- en: '}'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else {
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: else {
- en: ➎ timer.start();
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ timer.start();
- en: ➏ btn.setText("Pause");
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ btn.setText("暂停");
- en: '}'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: panel.add(btnPause);
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: panel.add(btnPause);
- en: At ➊, going from right to left, we use the `e.getSource()` method to find out
    which button was clicked, cast it to a `JButton` variable type, and store a link
    to the button as `btn`. The `getSource()` method is useful for finding out whether
    a GUI element has been clicked or changed, especially when you’re writing event
    handlers for multiple elements at once. In this example, we can use `getSource()`
    to access the button’s properties, such as its `text` property.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，从右到左，我们使用`e.getSource()`方法来找出哪个按钮被点击，将其强制转换为`JButton`变量类型，并将按钮的链接存储为`btn`。`getSource()`方法对于查找是否有GUI元素被点击或更改非常有用，特别是在你为多个元素编写事件处理器时。在这个例子中，我们可以使用`getSource()`来访问按钮的属性，比如它的`text`属性。
- en: At ➋, we check whether the text on the button is equal to the string `"Pause"`.
    If so, we stop the timer ➌ to pause the animation, and then we change the text
    on the button to the string `"Start"` ➍.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处，我们检查按钮上的文本是否等于字符串`"暂停"`。如果是，我们停止计时器➌以暂停动画，然后将按钮上的文本更改为字符串`"开始"`➍。
- en: If the text on the button wasn’t `"Pause"`—in other words, if the animation
    was already paused and the text on the button had been changed to `"Start"` from
    a previous click—the event handler would go to the `else` statement instead and
    start the timer ➎ to resume the animation. Finally, the text on the Pause/Start
    button will change back to `"Pause"` ➏.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按钮上的文字不是 `"暂停"`——换句话说，如果动画已经暂停且按钮上的文字因为之前的点击已更改为 `"开始"`——事件处理器将会跳转到 `else`
    语句，启动计时器 ➎ 来恢复动画。最后，暂停/开始按钮上的文字会再次变回 `"暂停"` ➏。
- en: Save the file and run it once more. Now you can pause the animation, draw something,
    and then restart the animation to achieve the jaw-dropping, exploding-bubbles
    effect shown in [Figure 10-10](ch10.xhtml#ch10fig10).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并再次运行。现在你可以暂停动画，绘制一些东西，然后重新启动动画，达到图 [10-10](ch10.xhtml#ch10fig10) 中展示的惊人爆炸气泡效果。
- en: '![Image](../images/f0235-01.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0235-01.jpg)'
- en: '*Figure 10-10: Pause the animation, draw a shape, and then start the animation
    again to see your drawing explode into colorful bubbles.*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-10：暂停动画，绘制一个形状，然后重新启动动画，看到你的画作爆炸成五彩斑斓的气泡。*'
- en: The BubbleDrawGUI app is a visually stunning animated app, and the buttons give
    the user more control over the drawing screen. But once the animation runs, bubbles
    float off the edges of the screen, never to return. What if we could make the
    bubbles bounce around inside the window so that they stayed around a bit longer?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: BubbleDrawGUI 应用程序是一个视觉效果惊艳的动画应用，按钮让用户对绘图界面有更多的控制。但是，一旦动画开始，气泡就会从屏幕边缘漂浮出去，再也不会回来。如果我们能让气泡在窗口内反弹，这样它们就能在屏幕上停留得更长时间，怎么样？
- en: Bouncing off the Walls with Collision Detection
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞检测下的墙壁反弹
- en: 'Animation isn’t just for flipbook cartoons and screensavers. There’s another
    place you encounter animation all the time: computer games. Whether it’s a mobile
    app or the latest online or console game, animation is how game developers give
    the user a sense of movement and action.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 动画不仅仅是翻书动画和屏幕保护程序。你经常会遇到动画的另一个地方：计算机游戏。无论是移动应用程序，还是最新的在线或主机游戏，动画是游戏开发者让用户感受到运动和动作的方式。
- en: One useful game programming concept that we can add to the final version of
    the BubbleDrawGUI app is *collision detection*, which allows us to check whether
    two objects overlap, or *collide*, on the screen. You might use collision detection
    to tell the program what to do when a player shoots an enemy spaceship or kicks
    a football in a video game. In this app, we want to find out whether a bubble
    has reached the edge of the drawing screen so we can change the bubble’s direction,
    making it appear to bounce off the edge of the screen back toward the center like
    the bubble in [Figure 10-11](ch10.xhtml#ch10fig11).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 BubbleDrawGUI 应用的最终版本中加入一个有用的游戏编程概念——*碰撞检测*，它让我们检查屏幕上两个物体是否重叠或*碰撞*。你可能会用碰撞检测来告诉程序当玩家击中敌方飞船或踢足球时应该做什么。在这个应用程序中，我们想要找出气泡是否已经到达绘图屏幕的边缘，这样我们就可以改变气泡的方向，让它看起来像图
    [10-11](ch10.xhtml#ch10fig11) 中的气泡那样，从屏幕边缘反弹回中心。
- en: '![Image](../images/f0236-01.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0236-01.jpg)'
- en: '*Figure 10-11: The bubble bounces off the right edge of the window, courtesy
    of collision detection.*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：气泡从窗口右边缘反弹，这是得益于碰撞检测。*'
- en: Collision detection can give virtual objects, such as our bubbles in BubbleDrawGUI,
    a more realistic appearance. In your favorite computer game, collision detection
    is what keeps your player from falling through the floor or walking through walls.
    These objects are imaginary—they’re all just computer graphics, so they can’t
    *actually* bump into one another—but collision detection creates the illusion
    that they are solid. So, if we give our bubbles a gentle bounce off the edges
    of the screen, they’ll feel more like real objects to us. Let’s see how that works.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检测可以使虚拟物体（比如我们在 BubbleDrawGUI 中的气泡）看起来更加逼真。在你最喜欢的计算机游戏中，碰撞检测是防止玩家掉进地板或穿墙的机制。这些物体是虚拟的——它们全都是计算机图形，所以它们不能*真正*相互碰撞——但是碰撞检测创造了它们是坚固的幻觉。因此，如果我们让气泡在屏幕边缘轻轻反弹，它们会给我们一种更像真实物体的感觉。我们来看看这怎么实现。
- en: '*A Soft Bounce*'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*柔和的反弹*'
- en: First, we’ll break down how collision detection works for bubbles bouncing off
    the window’s edges. We already know that each bubble has a pair of x -and y-coordinates
    for its location and an `xspeed` and `yspeed` for the number of pixels to move
    horizontally and vertically from one screen refresh to the next.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将分解一下气泡如何在碰到窗口边缘时进行碰撞检测。我们已经知道，每个气泡都有一对用于定位的x和y坐标，以及用于表示水平方向和垂直方向上每帧移动像素数的`xspeed`和`yspeed`。
- en: To figure out whether a bubble has collided with the window’s edge, we need
    to know the x- and y-coordinates of the edges of the screen so we can compare
    them to the bubble’s x- and y-coordinates. The left edge of the screen is the
    lowest `x` value, or `x==0`. And the top of the screen is the smallest `y` value,
    or `y==0`. But how about the right edge and bottom of the screen?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定气泡是否与窗口边缘发生碰撞，我们需要知道屏幕边缘的x和y坐标，以便将其与气泡的x和y坐标进行比较。屏幕的左边缘是最小的 `x` 值，或者 `x==0`。屏幕的顶部是最小的
    `y` 值，或者 `y==0`。那么右边缘和底部的坐标呢？
- en: 'Every GUI component in Java inherits a pair of methods to return the width
    and height of the component: `getWidth()` and `getHeight()`. Our drawing screen
    for the BubbleDrawGUI app is the `JPanel` `BubblePanel`. So, if we call the `getWidth()`
    and `getHeight()` functions inside `BubblePanel`, the maximum `x` value is `getWidth()`,
    and the maximum `y` value is `getHeight()`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的每个GUI组件都继承了两个方法，用来返回组件的宽度和高度：`getWidth()` 和 `getHeight()`。我们的BubbleDrawGUI应用程序的绘图屏幕是`JPanel`的`BubblePanel`。因此，如果我们在`BubblePanel`中调用`getWidth()`和`getHeight()`函数，那么最大`x`值就是`getWidth()`，最大`y`值就是`getHeight()`。
- en: We check whether a bubble’s `x` and `y` value has collided with an edge of the
    screen in the `Bubble` class’s `update()` method. You might remember that the
    `update()` method is also where we change each bubble’s x- and y-coordinates using
    `xspeed` and `yspeed` to give it the illusion of motion.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Bubble` 类的 `update()` 方法中检查气泡的 `x` 和 `y` 值是否与屏幕边缘发生碰撞。你可能还记得，`update()`
    方法也是我们使用 `xspeed` 和 `yspeed` 来更新每个气泡的 `x` 和 `y` 坐标，从而实现运动效果的地方。
- en: Let’s be more precise about what we mean by a “bounce.” Back in [Figure 10-11](ch10.xhtml#ch10fig11),
    the bubble is moving toward the right edge of the screen, where `x==getWidth()`,
    meaning the bubble’s `x` value is at the maximum x-coordinate, the width of the
    screen in pixels. To make the bubble look like it’s bouncing, we change the direction
    it’s moving by reversing the `xspeed`. The bubble was moving by some positive
    number of pixels each time it updated; after it touches the edge of the screen,
    we can make it move in the opposite direction by changing the sign of `xspeed`.
    In other words, we can make `xspeed` *negative* to make the bubble move to the
    left and away from the right edge of the screen after it bounces.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更精确地定义一下“反弹”的含义。在[图10-11](ch10.xhtml#ch10fig11)中，气泡正朝着屏幕的右边缘移动，其中`x==getWidth()`，意味着气泡的`x`值达到了屏幕宽度的最大值（以像素为单位）。为了让气泡看起来像在反弹，我们通过反转`xspeed`来改变它的运动方向。气泡每次更新时都会按某个正数像素数移动；当它触碰到屏幕边缘后，我们可以通过改变`xspeed`的符号使气泡朝反方向移动。换句话说，我们可以将`xspeed`设置为*负值*，让气泡在反弹后朝左移动，远离屏幕右边缘。
- en: We can reverse the bubble’s horizontal speed by setting `xspeed = -xspeed`,
    which makes `xspeed` the opposite of itself. So, an `xspeed` of `3` pixels per
    frame would change to an `xspeed` of `-3` pixels per frame after the bubble collides
    with the right edge of the screen, reversing its direction after the bounce.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置`xspeed = -xspeed`来反转气泡的水平速度，这会让`xspeed`变成它自身的相反数。所以，原本每帧`xspeed`为3个像素的气泡，在碰到屏幕右边缘后，`xspeed`会变为`-3`，即反转其方向，向左移动。
- en: 'We can do the same with the left edge of the screen, where `x==0`. If the bubble’s
    `x` value allows the bubble to touch the left edge, setting `xspeed = -xspeed`
    flips the horizontal motion again: an `xspeed` of `-3` would become `-(-3)`, or
    `+3`. This will make the bubble move to the right again, away from the left edge
    of the screen.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对屏幕的左边缘进行相同的操作，其中`x==0`。如果气泡的`x`值使得气泡可以触碰到左边缘，设置`xspeed = -xspeed`会使得水平运动方向发生反转：`xspeed`为`-3`时会变成`-(-3)`，即`+3`。这将使气泡重新朝右移动，远离屏幕的左边缘。
- en: 'In *BubblePanel.java*, scroll all the way down to the bottom of the file, where
    we defined the `Bubble` class. Find the `update()` method and add the following
    collision detection code for the left and right edges of the screen:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *BubblePanel.java* 文件中，向下滚动到底部，找到我们定义的 `Bubble` 类。找到 `update()` 方法，并添加以下用于检测左边缘和右边缘碰撞的代码：
- en: public void update() {
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: public void update() {
- en: x += xspeed;
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: x += xspeed;
- en: y += yspeed;
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: y += yspeed;
- en: if (x <= 0 || x >= getWidth())
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: if (x <= 0 || x >= getWidth())
- en: xspeed = -xspeed;
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: xspeed = -xspeed;
- en: '}'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: If the bubble’s `x` value goes below `0`, or if `x` goes past the width of the
    screen, the bubble must have touched either the left or right edge of the screen,
    so we change the `xspeed` to send the bubble bouncing in the opposite direction.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果气泡的`x`值小于`0`，或者`x`超过了屏幕的宽度，说明气泡一定碰到了屏幕的左边或右边，因此我们将`xspeed`更改为使气泡朝相反方向弹回。
- en: 'For the top and bottom edges, we’ll do the same thing, but this time we change
    the `yspeed`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上下边缘，我们将执行相同的操作，但这次我们会改变`yspeed`：
- en: public void update() {
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: public void update() {
- en: x += xspeed;
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: x += xspeed;
- en: y += yspeed;
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: y += yspeed;
- en: if (x <= 0 || x >= getWidth())
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: if (x <= 0 || x >= getWidth())
- en: xspeed = -xspeed;
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: xspeed = -xspeed;
- en: if (y <= 0 || y >= getHeight())
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: if (y <= 0 || y >= getHeight())
- en: yspeed = -yspeed;
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: yspeed = -yspeed;
- en: '}'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: If the bubble’s `y` value goes below `0`, or past the height of the screen in
    pixels, we change `yspeed` to `-yspeed` to make the bubble move in the opposite
    direction.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果气泡的`y`值小于`0`，或者超过了屏幕的高度（以像素为单位），我们将`yspeed`更改为`-yspeed`，使气泡朝相反方向移动。
- en: 'Once you’ve made these additions to the `update()` method, save and run the
    file again. This time, you’ll see the bubbles you create rebound softly off all
    four edges. You may notice a small issue, however: the bubbles move halfway off
    the screen in any direction before they seem to bounce, as shown in [Figure 10-12](ch10.xhtml#ch10fig12).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些对`update()`方法的修改后，保存并重新运行文件。这一次，你会看到你创建的气泡从四个边缘轻轻反弹。然而，你可能会注意到一个小问题：气泡在任何方向上移动到屏幕的一半位置时才会反弹，如[图
    10-12](ch10.xhtml#ch10fig12)所示。
- en: '![Image](../images/f0238-01.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0238-01.jpg)'
- en: '*Figure 10-12: Around the edge of the window there are many bubbles that are
    almost halfway off the screen before they rebound.*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12：在窗口的边缘，有许多气泡几乎在反弹前就已经移出了屏幕一半。*'
- en: This “soft” bounce happens because we’re checking for a collision between the
    *center* of each bubble and the edges of the screen. Recall that we centered each
    bubble around the (x, y) coordinates of the user’s click in [Chapter 9](ch9.xhtml#ch9),
    so each bubble’s `x` and `y` values represent the location of the center of that
    bubble. To make the bubbles stay on the screen completely, we’ll need to test
    for collisions between the outside edge of each bubble and the edges of the drawing
    window.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“软”弹跳发生的原因是我们正在检查每个气泡的*中心*与屏幕边缘的碰撞。回想一下，在[第9章](ch9.xhtml#ch9)中，我们将每个气泡的中心设置为用户点击的(x,
    y)坐标，因此每个气泡的`x`和`y`值表示该气泡中心的位置。为了让气泡完全停留在屏幕内，我们需要检测每个气泡的外边缘与绘图窗口的边缘之间的碰撞。
- en: '*A Hard Bounce*'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*一个硬弹跳*'
- en: 'To check for collisions with the edge of each bubble, we’ll have to account
    for the distance from the center of each bubble to the edge, which is the bubble’s
    radius (since each bubble is a perfect circle). The radius is the same as half
    of the `size` value of each bubble, or `size/2`. Modify the two `if` statements
    in the `update()` method to account for the size of each bubble as shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测每个气泡与边缘的碰撞，我们需要考虑从每个气泡中心到边缘的距离，即气泡的半径（因为每个气泡是一个完美的圆形）。半径等于每个气泡`size`值的一半，即`size/2`。修改`update()`方法中的两个`if`语句，以考虑每个气泡的大小，如下所示：
- en: public void update() {
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: public void update() {
- en: x += xspeed;
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: x += xspeed;
- en: y += yspeed;
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: y += yspeed;
- en: ➊ if (x - size/2 <= 0 || x + size/2 >= getWidth())
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ if (x - size/2 <= 0 || x + size/2 >= getWidth())
- en: xspeed = -xspeed;
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: xspeed = -xspeed;
- en: ➋ if (y - size/2 <= 0 || y + size/2 >= getHeight())
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ if (y - size/2 <= 0 || y + size/2 >= getHeight())
- en: yspeed = -yspeed;
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: yspeed = -yspeed;
- en: '}'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: At ➊, we subtract `size/2` from `x` to see whether the left edge of the bubble
    has touched the left side of the screen, which will be true if `x - size/2` is
    less than or equal to `0`. Division is performed before subtraction. Therefore
    `size/2` will be evaluated first and then subtracted from `x`, so we don’t need
    to add parentheses around `size/2`. We also add `size/2` to `x` to see whether
    the right edge of the bubble is touching the right edge of the screen, which would
    mean `x + size/2` is greater than or equal to `getWidth()`. At ➋, we make the
    same changes to check for the top edge (`y - size/2`) and bottom edge (`y + size/2`)
    of each bubble to see whether they are touching the top or bottom, respectively,
    of the drawing window.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们从`x`中减去`size/2`，以查看气泡的左边缘是否已触及屏幕的左侧，如果`x - size/2`小于或等于`0`，则为真。除法在减法之前进行。因此，`size/2`会首先计算，然后从`x`中减去，所以我们不需要给`size/2`加括号。我们还将`size/2`加到`x`中，以查看气泡的右边缘是否已触及屏幕的右边缘，这意味着`x
    + size/2`大于或等于`getWidth()`。在➋处，我们对每个气泡的上边缘（`y - size/2`）和下边缘（`y + size/2`）做同样的修改，以查看它们是否分别触及绘图窗口的顶部或底部。
- en: Save your program and run it again. Now all the bubbles you create, big and
    small, bounce solidly off the edges of the window, as shown in [Figure 10-13](ch10.xhtml#ch10fig13).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 保存程序并重新运行。现在，所有你创建的气泡，无论大或小，都将在窗口的边缘坚固地反弹，如[图 10-13](ch10.xhtml#ch10fig13)所示。
- en: '![Image](../images/f0239-01.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0239-01.jpg)'
- en: '*Figure 10-13: Now our bubbles make a “hard” bounce against the window’s edges,
    for a more solid appearance.*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-13：现在我们的气泡在窗口的边缘做出了“硬”反弹，呈现出更为坚固的外观。*'
- en: Click the maximize button on the app’s title bar or double-click the title bar
    to expand the window. You’ll see that the bubbles expand to bounce off the edges
    of the drawing window even when the app is fullscreen. We used the `getWidth()`
    and `getHeight()` methods to determine the right and bottom edges, and those methods
    will always return the current width and height, so feel free to resize the app
    as you draw.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 点击应用程序标题栏上的最大化按钮，或双击标题栏以展开窗口。即使在应用程序全屏时，你也会看到气泡会扩展并弹跳到绘图窗口的边缘。我们使用了`getWidth()`和`getHeight()`方法来确定右边和底部的边缘，这些方法将始终返回当前的宽度和高度，因此你可以在绘制时随意调整应用程序的大小。
- en: Now let’s make one final addition to give the user even more control via the
    GUI.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们做最后一次添加，通过GUI给用户更多控制。
- en: Adding a Slider to Control the Animation Speed
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加滑块来控制动画速度
- en: At this point, we’ve given the user control over pausing and clearing the screen,
    as well as the ability to create big and small bubbles. Let’s also give them control
    over the animation speed by providing a slider that changes the timer’s delay,
    as shown in [Figure 10-14](ch10.xhtml#ch10fig14).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经让用户可以控制暂停和清除屏幕的操作，并能够创建大大小小的气泡。现在，让我们通过提供一个滑块来控制动画速度，滑块改变定时器的延迟，如[图 10-14](ch10.xhtml#ch10fig14)所示。
- en: '![Image](../images/f0240-01.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0240-01.jpg)'
- en: '*Figure 10-14: Adding a slider will allow the user to speed up or slow down
    the animation.*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-14：添加一个滑块将允许用户加速或减慢动画速度。*'
- en: First, switch back to the Design tab and add a `JLabel` and `JSlider` to the
    GUI control panel. Scroll down under the Palette to find the Components section
    and select **JLabel**. Click inside the small panel just before the Pause/Start
    button in your GUI design preview to place the label. Change the label’s text
    to `Animation Speed:`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，切换回设计标签，并将`JLabel`和`JSlider`添加到GUI控制面板中。在调色板下方滚动，找到组件部分并选择**JLabel**。点击GUI设计预览中的暂停/开始按钮前的小面板以放置标签。将标签的文本更改为`动画速度:`。
- en: Next, click the **JSlider** component on the Palette. Then click between the
    Animation Speed label and the Pause/Start button to place the slider, as shown
    in [Figure 10-15](ch10.xhtml#ch10fig15).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击调色板中的**JSlider**组件。然后，点击动画速度标签和暂停/开始按钮之间的空白处以放置滑块，如[图 10-15](ch10.xhtml#ch10fig15)所示。
- en: '![Image](../images/f0240-02.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0240-02.jpg)'
- en: '*Figure 10-15: Add a label and slider to the app’s GUI control panel in the
    design view.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-15：在设计视图中将标签和滑块添加到应用程序的GUI控制面板中。*'
- en: You may notice that the `JPanel` for all the GUI components grows as we add
    elements. If you click the panel in the Structure pane, you’ll see that the `Layout`
    property has the default value `java.awt.FlowLayout`. This layout expands to fit
    as many GUI elements as you place inside it. We used the `AbsoluteLayout` for
    the Hi-Lo guessing game and Secret Messages apps because we wanted to place elements
    in specific positions. In this drawing app, we can be more flexible, and the `FlowLayout`
    is perfect for adding GUI components on the fly.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，随着我们添加元素，所有GUI组件的`JPanel`大小也在增长。如果你点击结构面板中的面板，你会看到`Layout`属性的默认值为`java.awt.FlowLayout`。这种布局会扩展以容纳你放置的所有GUI元素。我们为Hi-Lo猜数字游戏和秘密消息应用程序使用了`AbsoluteLayout`，因为我们希望将元素放置在特定位置。在这个绘图应用程序中，我们可以更加灵活，`FlowLayout`非常适合动态添加GUI组件。
- en: '*Customizing the Slider*'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*自定义滑块*'
- en: We’ll change a few properties to customize the slider next, so let’s figure
    out what we want the slider to look like. The slider should allow the user to
    change the animation speed easily and intuitively. In other words, if the user
    slides the animation speed to 0, the animation should slow down almost to a stop.
    If the user slides the animation speed all the way to the right, the animation
    should go really fast.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改一些属性来定制滑块，所以我们需要弄清楚滑块的外观。滑块应该允许用户轻松直观地调整动画速度。换句话说，如果用户将动画速度滑动到0，动画应该几乎停下来。如果用户将动画速度滑动到最右端，动画应该非常快。
- en: Monitors usually refresh the screen between 30 and 120 times per second, with
    60 Hz (short for *hertz*, a measure of frequency per second) being the most common
    refresh rate. If we animate the bubbles faster than 120 times per second, your
    monitor likely won’t be able to show all of the individual frames in the animation.
    So it makes sense to set our maximum speed value on the slider to 120 frames per
    second.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 显示器通常每秒刷新30到120次，60 Hz（即*赫兹*，每秒的频率单位）是最常见的刷新率。如果我们将气泡动画的速度设置为每秒超过120帧，你的显示器可能无法显示所有单独的帧。因此，将滑块的最大速度值设置为每秒120帧是有道理的。
- en: The number of frames per second, abbreviated *fps*, is often a measure of the
    smoothness of the animation. A game that runs at 60 fps on your computer will
    look smoother than a game that runs at 30 fps.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒的帧数，缩写为*fps*，通常用于衡量动画的流畅度。在你的电脑上运行60 fps的游戏比运行30 fps的游戏看起来更平滑。
- en: Select the slider in your design preview. In the Properties pane in the lower
    left, set the range by specifying a **maximum** of `120` and a **minimum** of
    `0` (the default). To prepare the labels and tick marks, set **majorTickSpacing**
    to `30`, set **minorTickSpacing** to `5`, and select the checkboxes next to **paintLabels**,
    **paintTicks**, and **paintTrack** to make all three values `true`. Finally, change
    the **value** property to `30`, the default number of frames per second. [Figure
    10-16](ch10.xhtml#ch10fig16) shows the Properties pane with all of our customized
    values, along with a preview of the `JSlider` after the changes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计预览中选择滑块。在左下角的属性面板中，设置范围，通过指定**最大值**为`120`和**最小值**为`0`（默认值）。为了准备标签和刻度标记，将**majorTickSpacing**设置为`30`，将**minorTickSpacing**设置为`5`，并选中**paintLabels**、**paintTicks**和**paintTrack**旁边的复选框，将这三个值设为`true`。最后，将**value**属性设置为`30`，即每秒的默认帧数。[图10-16](ch10.xhtml#ch10fig16)展示了具有我们所有自定义值的属性面板，以及更改后的`JSlider`预览。
- en: '![Image](../images/f0241-01.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0241-01.jpg)'
- en: '*Figure 10-16: The Properties pane for the Animation Speed slider with customized
    values (left); a preview of the slider showing the customizations (right)*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-16：动画速度滑块的属性面板，包含自定义值（左）；显示自定义设置的滑块预览（右）*'
- en: The slider is labeled from 0 to 120 in increments of 30 because you checked
    `paintLabels` and set `majorTickSpacing` to `30`. The small tick marks show up
    between those values because you set `minorTickSpacing` to `5` and checked `paintTicks`.
    We’ve got a customized slider ready to change the animation speed, so now let’s
    edit the code to put the slider to work.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你勾选了`paintLabels`并将`majorTickSpacing`设置为`30`，滑块标记从0到120，每隔30个单位。由于你设置了`minorTickSpacing`为`5`并勾选了`paintTicks`，小刻度标记将显示在这些值之间。我们已经准备好了一个自定义滑块，可以用来改变动画速度，现在让我们编辑代码让滑块开始工作。
- en: '*Implementing the Slider Event Handler*'
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*实现滑块事件处理程序*'
- en: 'In the Design tab’s design preview, right-click the slider and select **Add
    event handler** ▸ **change** ▸ **stateChanged**. Eclipse will add a `ChangeListener`
    with a `stateChanged()` method like the one we used in the Secret Messages app’s
    slider implementation. The code looks like the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: JSlider slider = new JSlider();
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: slider.addChangeListener(new ChangeListener() {
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: public void stateChanged(ChangeEvent e) {
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to declare the `JSlider` at the top of the class so that we’ll
    be able to access the slider’s value inside the `stateChanged()` event handler’s
    code. Scroll up to the top of the `BubblePanel` class and add the following line
    just below the `timer` and `delay` variables:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: public class BubblePanel extends JPanel {
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Random rand = new Random();
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: ArrayList<Bubble> bubbleList;
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: int size = 25;
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Timer timer;
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: int delay = 33;
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: JSlider slider;
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, scroll back down to the slider code and remove the `JSlider` type declaration
    from the beginning of the first line:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: slider = new JSlider();  // Remove "JSlider" from beginning of line
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: slider.addChangeListener(new ChangeListener() {
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: public void stateChanged(ChangeEvent e) {
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user changes the slider’s position, we want to change the speed of
    the animation by changing the length of delay between each timer event. To do
    this, we’ll need to get the speed value from the slider, convert the speed into
    a number of milliseconds, and then set the timer’s delay to the new value. Add
    the following three lines inside the braces for the `stateChanged()` method:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: slider = new JSlider();
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: slider.addChangeListener(new ChangeListener() {
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: public void stateChanged(ChangeEvent arg0) {
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: ➊ int speed = slider.getValue() + 1;
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: ➋ int delay = 1000 / speed;
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: ➌ timer.setDelay(delay);
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➊, we use the `getValue()` method to get the speed value from the slider
    and store it in an integer variable named `speed`. Notice, though, that we add
    1 to the slider value here. We’re doing this to prevent a division-by-zero error
    at ➋, where we divide `1000` by the `speed` to determine the number of milliseconds
    of delay between each frame. The slider can go all the way down to 0, but by adding
    1 to its value, we prevent the delay from causing an error: `1000/0` throws a
    division-by-zero exception, but `1000/1` gives us a very slow 1,000 milliseconds
    between frames that feels like the animation is nearly stopped. This means that
    when the user moves the slider to 0, the animation won’t actually stop. In order
    to stop the animation completely, they’ll need to click the Pause/Start button
    instead.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update the timer by setting the new delay value in milliseconds
    ➌. This will slow down or speed up the animation by changing the amount of time
    between timer events.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and run it. Move the slider back and forth, and you’ll see you
    now have control over the speed of the animation.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The BubbleDrawGUI app is our most interactive, entertaining, visually engaging
    app so far—a graphical, animated drawing app with a GUI interface that gives the
    user complete control over the animation. Play around with it for a while—and
    congratulate yourself on a job well done!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**SHARE AND SHARE ALIKE**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: This would also be a great app to share with friends. To export a runnable JAR
    file from Eclipse, go to **File ▸ Export**. Then, expand the *Java* folder and
    click **Runnable JAR file**. Click **Next** and, under **Launch configuration**,
    click the drop-down list and choose **BubbleDrawGUI – BubbleDrawGUI**.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Under **Export destination**, click **Browse**, and then select the destination
    folder you’d like to save your finished app in, perhaps *Desktop*. Give your program
    file a name, such as *Bryson’s BubbleDraw.jar*. Click **Save**, then **Finish**.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Find where you saved your JAR file, run it, and share it with a friend. Even
    if your friend doesn’t have Eclipse, as long as they have Java installed, they’ll
    be able to run your BubbleDrawGUI app. Enjoy!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: What You Learned
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We built on the BubbleDraw app from [Chapter 9](ch9.xhtml#ch9) to produce an
    animated GUI version with bouncing bubbles. Here are some of the skills we’ve
    added in this chapter:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: • Combining a graphical app with a GUI interface
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: • Copying a project and pasting a new version in the Package Explorer in Eclipse
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: • Renaming a class or object by refactoring
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: • Using transparency by setting the alpha component in RGBA colors
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: • Creating, setting, and starting a `Timer` object
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: • Handling `Timer` object events
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: • Creating an animation by moving graphical objects with a timer
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: • Making virtual objects bounce via collision detection
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: • Using `getWidth()` and `getHeight()` to find the edges of the window
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: • Using a slider to change a timer’s delay
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: • Varying an animation’s speed by changing the `delay` property of a timer
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Programming Challenges
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try these programming challenge exercises to review and practice what you’ve
    learned, as well as to expand your programming skills. Visit the book’s website
    at *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    for sample solutions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '*#1: No Bubble Left Behind*'
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One problem we noted in the chapter was that some bubbles get a random speed
    of `0`, causing them to seem stuck in place while the other bubbles float away.
    This happens when the bubble’s `xspeed` and `yspeed` are both set to `0`. For
    this challenge, add some code to make sure that no bubbles get a random speed
    of `0`. To do so, you’ll test the `xspeed` and `yspeed` values to see whether
    they’re both equal to `0`. If they are, all you need to do is set the two values
    to something else, like `1`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '**HINT**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '*Add the if statement inside the Bubble() constructor, after the xspeed and
    yspeed values are created.*'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: private class Bubble {
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: public Bubble(int newX, int newY, int newSize) {
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: xspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: yspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: if  // Add your code here
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Make your changes, save and run the file, and voilà—no more stranded bubbles!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '*#2: Flexi-Draw!*'
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because of the random speed values, the bubbles move in every direction, which
    is the effect we originally wanted. But what if we wanted to draw shapes and have
    them stay together?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Setting the speed of every bubble to the same fixed value creates a funky, flexible,
    twisty effect as the objects bounce off the edges of the screen, as shown in [Figure
    10-17](ch10.xhtml#ch10fig17).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0245-01.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-17: Giving all bubbles the same xspeed and yspeed creates a flexible,
    bouncy effect that keeps shapes together as they rebound and twist off the edges
    of the screen.*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'For this challenge, create a new copy of the app so that the original version
    is still available. Copy and paste the BubbleDrawGUI project in the Package Explorer
    pane, renaming it FlexiDraw or another app name of your choice. In the *BubblePanel*
    file, change the `Bubble()` constructor so that instead of creating random `xspeed`
    and `yspeed` variables, it sets them equal to the same value, perhaps like this:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: xspeed = yspeed = 2;
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: This line of code makes use of an interesting feature of the assignment operator
    (`=`). This is called a *chained assignment*, because both `xspeed` and `yspeed`
    are being assigned the value of `2`, and the equal sign allows us to assign the
    same value to several variables in a chain sequence.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: You can pick a higher or lower number for your speed value. The important point
    to note is that we’ve replaced the random speeds with a fixed starting speed and
    direction for every bubble. Each bubble will move right two pixels and down two
    pixels the first time it’s drawn, so the bubbles will form groups as you draw.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Save the file, right-click the *FlexiDraw* folder in the Package Explorer, and
    select **Run As** ▸ **Java Application**. Pause the animation to draw, and then
    press **Start** to see your shapes bend, twist, and bounce as they move around
    the screen! You can even draw as the animation runs for a cool spiral effect.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '*#3: PixelDraw 2.0*'
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this challenge, you’ll reuse the PixelDraw code from [Chapter 9](ch9.xhtml#ch9)
    (Programming Challenge #2 on [page 219](ch9.xhtml#page_219)). Adding the pixelated
    effect to the animated drawing program will allow you to draw square pixel shapes
    and animate them. Combine this effect with the FlexiDraw trick from the previous
    challenge exercise, and you’ve got a bouncing, bending *Minecraft*-esque drawing
    app like the one shown in [Figure 10-18](ch10.xhtml#ch10fig18).'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0246-01.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-18: The PixelDraw 2.0 effect (left); the same shape after bouncing
    off the sides and twisting upside down and backward (right)*'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Pause the animation to keep the blocks in a clean, gridlike shape like the example
    in [Figure 10-18](ch10.xhtml#ch10fig18). Draw with the animation going to achieve
    a stacked, 3D look like the example in [Figure 10-19](ch10.xhtml#ch10fig19).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0246-02.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-19: The PixelDraw 2.0 code creates a stacked, 3D effect if you drag
    the mouse while the animation is running.*'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a hint to help with the math: to achieve the blocky style, you need
    to “divide” the screen into a grid based on the size of each block, and then draw
    a block at that grid location. This time, try changing your `x` and `y` variables
    at the top of the `Bubble()` constructor to something like the following:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: x = (newX / newSize) * newSize + newSize/2;
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: y = (newY / newSize) * newSize + newSize/2;
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the formula, `(newX / newSize) * newSize`, divides the screen
    into grid blocks based on `newSize`, the size of the current bubble. In order
    to align the x- and y-positions with a `newSize` by `newSize` grid, we need them
    to be multiples of `newSize`. For the x-coordinate, we do this by dividing `newX`
    by `newSize`, which results in an integer without decimal points that we multiply
    by `newSize` to make an integer that is a multiple of `newSize`. This places the
    x-coordinate of the bubble at the edge of the grid block the user clicks in. For
    example, if `newSize` is `10`, the division and multiplication “snap” the x-coordinate
    to `10` by `10` gridlines by making `x` a multiple of `10`. If we stopped there,
    this would result in a bubble with its center at the point where the gridlines
    meet. Since we want the bubble to be contained within a grid block instead, the
    second part (`+ newSize/2`) shifts the bubble to the center of that block.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Finally, draw blocks instead of bubbles by changing the `draw()` method to fill
    rectangles instead of ovals using `fillRect()`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! But you can—and should!—make additional changes to customize the
    new app even further and make it your own. Change the `JFrame` title in the *BubbleDrawGUI.java*
    file or even refactor/rename the files if you’d like. The sky’s the limit!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'After making those changes, you’ll be able to draw beautiful, blocky, pixelized,
    and animated creations. Take a screenshot and tweet it to your friends. Use the
    hashtag #JavaTheEasyWay or tag me @brysonpayne, and I’ll retweet it to a few thousand
    of my friends as well!'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
