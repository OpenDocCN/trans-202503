["```\nint f(void) {\n    int a = 1;\n    int b = 2;\n  ➊ return (a*b)+3;\n}\n```", "```\nmovl    $1, -4(%rbp)\nmovl    $2, -8(%rbp)\nmovl    -4(%rbp), %eax\nimull   -8(%rbp), %eax\naddl    $3, %eax\n```", "```\nmovl    $5, %eax\n```", "```\n#!/usr/bin/python\n\nimport argparse\nimport os\nimport networkx\nfrom networkx.drawing.nx_pydot import write_dot\nimport itertools\n\ndef jaccard(set1, set2):\n    \"\"\"\n    Compute the Jaccard distance between two sets by taking\n    their intersection, union and then dividing the number\n    of elements in the intersection by the number of elements\n    in their union.\n    \"\"\"\n    intersection = set1.intersection(set2)\n    intersection_length = float(len(intersection))\n    union = set1.union(set2)\n    union_length = float(len(union))\n    return intersection_length / union_length\n```", "```\ndef getstrings(fullpath):\n    \"\"\"\n    Extract strings from the binary indicated by the 'fullpath'\n    parameter, and then return the set of unique strings in\n    the binary.\n    \"\"\"\n    strings = os.popen(\"strings '{0}'\".format(fullpath)).read()\n    strings = set(strings.split(\"\\n\"))\n    return strings\n\ndef pecheck(fullpath):\n    \"\"\"\n    Do a cursory sanity check to make sure 'fullpath' is\n    a Windows PE executable (PE executables start with the\n    two bytes 'MZ')\n    \"\"\"\n    return open(fullpath).read(2) == \"MZ\"\n```", "```\nIf __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"Identify similarities between malware samples and build similarity graph\"\n    )\n\n    parser.add_argument(\n        \"target_directory\",\n        help=\"Directory containing malware\"\n    )\n\n    parser.add_argument(\n        \"output_dot_file\",\n        help=\"Where to save the output graph DOT file\"\n    )\n\n    parser.add_argument(\n        \"--jaccard_index_threshold\", \"-j\", dest=\"threshold\", type=float,\n        default=0.8, help=\"Threshold above which to create an 'edge' between samples\"\n    )\n\n    args = parser.parse_args()\n```", "```\nmalware_paths = []  # where we'll store the malware file paths\nmalware_features = dict()  # where we'll store the malware strings\ngraph = networkx.Graph()  # the similarity graph\n\nfor root, dirs, paths in os.walk(args.target_directory):\n    # walk the target directory tree and store all of the file paths\n    for path in paths:\n        full_path = os.path.join(root, path)\n        malware_paths.append(full_path)\n\n# filter out any paths that aren't PE files\nmalware_paths = filter(pecheck, malware_paths)\n\n# get and store the strings for all of the malware PE files\nfor path in malware_paths:\n    features = getstrings(path)\n    print \"Extracted {0} features from {1} ...\".format(len(features), path)\n    malware_features[path] = features\n\n    # add each malware file to the graph\n    graph.add_node(path, label=os.path.split(path)[-1][:10])\n```", "```\n# iterate through all pairs of malware\nfor malware1, malware2 in itertools.combinations(malware_paths, 2):\n\n    # compute the jaccard distance for the current pair\n    jaccard_index = jaccard(malware_features[malware1], malware_features[malware2])\n\n    # if the jaccard distance is above the threshold, add an edge\n    if jaccard_index > args.threshold:\n        print malware1, malware2, jaccard_index\n        graph.add_edge(malware1, malware2, penwidth=1+(jaccard_index-args.threshold)*10)\n\n# write the graph to disk so we can visualize it\nwrite_dot(graph, args.output_dot_file)\n```", "```\n#!/usr/bin/python\n\nimport argparse\nimport os\nimport murmur\nimport shelve\nimport numpy as np\nfrom listings_5_2_to_5_6 import *\n\nNUM_MINHASHES = 256\nSKETCH_RATIO = 8\n```", "```\n➊ def wipe_database():\n       \"\"\"\n       This problem uses the python standard library 'shelve' database to persist\n       information, storing the database in the file 'samples.db' in the same\n       directory as the actual Python script. 'wipe_database' deletes this file\n       effectively reseting the system.\n       \"\"\"\n       dbpath = \"/\".join(__file__.split('/')[:-1] + ['samples.db'])\n       os.system(\"rm -f {0}\".format(dbpath))\n\n➋ def get_database():\n       \"\"\"\n       Helper function to retrieve the 'shelve' database, which is a simple\n       key value store.\n       \"\"\"\n       dbpath = \"/\".join(__file__.split('/')[:-1] + ['samples.db'])\n       return shelve.open(dbpath,protocol=2,writeback=True)\n```", "```\ndef minhash(features):\n    \"\"\"\n    This is where the minhash magic happens, computing both the minhashes of\n    a sample's features and the sketches of those minhashes. The number of\n    minhashes and sketches computed is controlled by the NUM_MINHASHES and\n    NUM_SKETCHES global variables declared at the top of the script.\n    \"\"\"\n    minhashes = []\n    sketches = []\n  ➊ for i in range(NUM_MINHASHES):\n        minhashes.append(\n          ➋ min([murmur.string_hash(`feature`,i) for feature in features])\n        )\n  ➌ for i in xrange(0,NUM_MINHASHES,SKETCH_RATIO):\n      ➍ sketch = murmur.string_hash(`minhashes[i:i+SKETCH_RATIO]`)\n        sketches.append(sketch)\n    return np.array(minhashes),sketches\n```", "```\ndef store_sample(path):\n    \"\"\"\n    Function that stores a sample and its minhashes and sketches in the\n    'shelve' database\n    \"\"\"\n  ➊ db = get_database()\n  ➋ features = getstrings(path)\n  ➌ minhashes,sketches = minhash(features)\n  ➍ for sketch in sketches:\n        sketch = str(sketch)\n      ➎ if not sketch in db:\n            db[sketch] = set([path])\n        else:\n            obj = db[sketch]\n          ➏ obj.add(path)\n            db[sketch] = obj\n        db[path] = {'minhashes':minhashes,'comments':[]}\n        db.sync()\n\n    print \"Extracted {0} features from {1} ...\".format(len(features),path)\n```", "```\n➊ def comment_sample(path):\n      \"\"\"\n      Function that allows a user to comment on a sample.  The comment the\n      user provides shows up whenever this sample is seen in a list of similar\n      samples to some new samples, allowing the user to reuse their\n      knowledge about their malware database.\n      \"\"\"\n      db = get_database()\n      comment = raw_input(\"Enter your comment:\")\n      if not path in db:\n          store_sample(path)\n      comments = db[path]['comments']\n      comments.append(comment)\n      db[path]['comments'] = comments\n      db.sync()\n      print \"Stored comment:\", comment\n\n➋ def search_sample(path):\n      \"\"\"\n      Function searches for samples similar to the sample provided by the\n      'path' argument, listing their comments, filenames, and similarity values\n      \"\"\"\n      db = get_database()\n      features = getstrings(path)\n      minhashes, sketches = minhash(features)\n      neighbors = []\n\n    ➌ for sketch in sketches:\n          sketch = str(sketch)\n\n          if not sketch in db:\n              continue\n\n        ➍ for neighbor_path in db[sketch]:\n              neighbor_minhashes = db[neighbor_path]['minhashes']\n              similarity = (neighbor_minhashes == minhashes).sum() \n              / float(NUM_MINHASHES)\n              neighbors.append((neighbor_path, similarity))\n\n      neighbors = list(set(neighbors))\n    ➎ neighbors.sort(key=lambda entry:entry[1], reverse=True)\n      print \"\"\n      print \"Sample name\".ljust(64), \"Shared code estimate\"\n      for neighbor, similarity in neighbors:\n          short_neighbor = neighbor.split(\"/\")[-1]\n          comments = db[neighbor]['comments']\n          print str(\"[*] \"+short_neighbor).ljust(64), similarity\n          for comment in comments:\n              print \"\\t[comment]\",comment\n```", "```\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(\n        description=\"\"\"\nSimple code-sharing search system which allows you to build up \na database of malware samples (indexed by file paths) and\nthen search for similar samples given some new sample\n\"\"\"\n    )\n\n    parser.add_argument(\n        \"-l\", \"--load\", dest=\"load\", default=None,\n        help=\"Path to malware directory or file to store in database\"\n    )\n\n    parser.add_argument(\n        \"-s\", \"--search\", dest=\"search\", default=None,\n        help=\"Individual malware file to perform similarity search on\"\n    )\n\n    parser.add_argument(\n        \"-c\", \"--comment\", dest=\"comment\", default=None,\n        help=\"Comment on a malware sample path\"\n    )\n\n    parser.add_argument(\n        \"-w\", \"--wipe\", action=\"store_true\", default=False,\n        help=\"Wipe sample database\"\n    )\n\n    args = parser.parse_args()\n  ➊ if args.load:\n        malware_paths = []  # where we'll store the malware file paths\n        malware_features = dict()  # where we'll store the malware strings\n        for root, dirs, paths in os.walk(args.load):\n            # walk the target directory tree and store all of the file paths\n            for path in paths:\n                full_path = os.path.join(root,path)\n                malware_paths.append(full_path)\n\n        # filter out any paths that aren't PE files\n        malware_paths = filter(pecheck, malware_paths)\n\n        # get and store the strings for all of the malware PE files\n        for path in malware_paths:\n            store_sample(path)\n\n  ➋ if args.search:\n        search_sample(args.search)\n\n  ➌ if args.comment:\n        comment_sample(args.comment)\n  ➍ if args.wipe:\n        wipe_database()\n```", "```\npython listings_5_7_to_5_12.py –l <path to directory or individual malware\nsample>\n```", "```\npython listings_5_7_to_5_12.py –c <path to malware sample>\n```", "```\npython listings_5_7_to_5_12.py –s <path to malware sample>\n```", "```\npython listings_5_7_to_5_12.py –w\n```", "```\nmds@mds:~/malware_data_science/ch5/code$ python listings_5_7_to_5_12.py -l ../\ndata\nExtracted 240 attributes from ../data/APT1_MALWARE_FAMILIES/WEBC2-YAHOO/WEBC2-\nYAHOO_sample/WEBC2-YAHOO_sample_A8F259BB36E00D124963CFA9B86F502E ...\nExtracted 272 attributes from ../data/APT1_MALWARE_FAMILIES/WEBC2-YAHOO/WEBC2-\nYAHOO_sample/WEBC2-YAHOO_sample_0149B7BD7218AAB4E257D28469FDDB0D ...\nExtracted 236 attributes from ../data/APT1_MALWARE_FAMILIES/WEBC2-YAHOO/WEBC2-\nYAHOO_sample/WEBC2-YAHOO_sample_CC3A9A7B026BFE0E55FF219FD6AA7D94 ...\nExtracted 272 attributes from ../data/APT1_MALWARE_FAMILIES/WEBC2-YAHOO/WEBC2-\nYAHOO_sample/WEBC2-YAHOO_sample_1415EB8519D13328091CC5C76A624E3D ...\nExtracted 236 attributes from ../data/APT1_MALWARE_FAMILIES/WEBC2-YAHOO/WEBC2-\nYAHOO_sample/WEBC2-YAHOO_sample_7A670D13D4D014169C4080328B8FEB86 ...\nExtracted 243 attributes from ../data/APT1_MALWARE_FAMILIES/WEBC2-YAHOO/WEBC2-\nYAHOO_sample/WEBC2-YAHOO_sample_37DDD3D72EAD03C7518F5D47650C8572 ...\n--snip--\n```", "```\nmds@mds:~/malware_data_science/ch5/code$ python listings_5_7_to_5_12.py –s \\ \n../data/APT1_MALWARE_FAMILIES/GREENCAT/GREENCAT_sample/GREENCAT_sample_AB20\\\n8F0B517BA9850F1551C9555B5313\nSample name                                                      Shared code estimate\n[*] GREENCAT_sample_5AEAA53340A281074FCB539967438E3F             1.0\n[*] GREENCAT_sample_1F92FF8711716CA795FBD81C477E45F5             1.0\n[*] GREENCAT_sample_3E69945E5865CCC861F69B24BC1166B6             1.0\n[*] GREENCAT_sample_AB208F0B517BA9850F1551C9555B5313             1.0\n[*] GREENCAT_sample_3E6ED3EE47BCE9946E2541332CB34C69             0.99609375\n[*] GREENCAT_sample_C044715C2626AB515F6C85A21C47C7DD             0.6796875\n[*] GREENCAT_sample_871CC547FEB9DBEC0285321068E392B8             0.62109375\n[*] GREENCAT_sample_57E79F7DF13C0CB01910D0C688FCD296             0.62109375\n```"]