- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REST
    AND GRAPHQL APIS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An *API* is a generic pattern used to connect computers or computer programs.
    Unlike a user interface, it’s designed to be accessed not by a user but by another
    piece of software. One purpose of APIs is to hide the internal details of a system’s
    workings while exposing a standardized gateway to the system’s data or functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a full-stack developer, you’ll usually interact with, or *consume*, two
    kinds of APIs: internal and third-party. When querying an internal API, you’re
    consuming data from your own systems, typically from your own database or service.
    Private APIs are not available to outside parties. For example, your bank might
    use private APIs to check your credit score or account balance on its internal
    systems and display them in your online banking profile.'
  prefs: []
  type: TYPE_NORMAL
- en: Third-party APIs provide access to data from an external system. For example,
    the OAuth login you’ll implement in [Part II](part2.xhtml) uses an API. You might
    also use an API to fetch a social media feed or weather information from an external
    provider to display on your website. Because external APIs are exposed to the
    public, you can reach them through a public URL, and they document the conventions
    you should use to access their data in an *API contract*. This contract defines
    the format of the communications, the parameters the API expects, and the possible
    responses you might receive for each request. We briefly discussed API and function
    contracts and why you should type them in [Chapter 3](chapter3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Full-stack web development primarily uses two types of APIs, REST and GraphQL,
    both of which transmit data over HTTP. This chapter covers these.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">REST APIs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: REST is an architectural pattern used to design RESTful web APIs. These APIs
    are essentially a set of URLs, each of which provides access to a single resource.
    They rely on the use of HTTP methods and the standard HTTP status codes to transmit
    data and accept URL-encoded or request header parameters. Typically, they respond
    with the requested data in JSON or plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, you’ve already built your first REST API. Recall the Next.js server
    you created in [Exercise 5](chapter5.xhtml#Exe5) on page 89, which provided the
    *api/weather/:zipcode* endpoint. So far, we’ve used this endpoint to play with
    Next.js’s routing, understand dynamic URLs, and learn how to access query parameters.
    You’ll soon see, however, that this API follows REST conventions: to access it,
    we used the HTTP GET method to consume the URL endpoint and received a JSON response
    with an HTTP status code of *200: OK*. Common status code ranges are *2XX* for
    successful requests and *3XX* for redirects. If the request fails, we see the
    *4XX* range to indicate a client-related error, such as *401: Unauthorized*, and
    *5XX* for server errors, often the generic *500: Internal Server Error*.'
  prefs: []
  type: TYPE_NORMAL
- en: As full-stack developers, we might sometimes create our own APIs; more often,
    though, we’ll find ourselves consuming third-party APIs. Why might we consume,
    say, a third-party weather API? Well, imagine that we want our app to display
    the current weather at multiple remote locations. Instead of setting up and maintaining
    various weather stations on our own and then reading the data from the sensors,
    which would involve both providing and consuming an API for each of them, we could
    consume data from a third-party API offered by an existing weather service. Our
    code might call that API, pass in a ZIP code as a parameter, and receive the weather
    data for this location in a predetermined format. We’d then display this data
    on our website.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs enable us to interact with data without knowing anything about
    how that data was stored or what underlying technology provided it. If you follow
    an API’s specifications, you should receive the requested data, even if the underlying
    technology or architecture changes. Beyond this, there are a handful of requirements
    for an API to be considered RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The URL</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A unique URL provides an interface to a RESTful API. Each of a provider’s APIs
    typically has the same base URL, called the *root entry point*, such as *http://localhost:3000/api*.
    You can think of this as the APIs’ family name. Often, you’ll see a version number
    added to the root entry point, because a provider might have multiple versions
    of an API. For example, there might be the legacy *http://localhost:3000/api/v1*
    and an updated *http://localhost:3000/api/v2*. To honor this pattern, you can
    create a folder *v1* inside the *api* folder and move the REST API code there.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Other common ways of versioning an API include custom headers and query strings.
    In the first case, the client would request the API with a custom Accept-Version
    header and receive a matching Content-Version header. In the second case, an API
    request would use* ?version=1.0.0 *as a query parameter in the URL.*'
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the API’s URL is the path, often called the *endpoint*. It
    specifies the resource we want to query (for example, the weather API). API specifications
    usually mention only the endpoint itself, such as */v1/weather*, leaving the root
    entry point implied. The URL generally also accepts parameters. These can be path
    parameters that are part of the URL, like in our ZIP code API endpoint, */v1/weather/{zipcode}*,
    or they can be query parameters, which are added as encoded key-value pairs after
    an initial question mark, as in */v1/weather?zipcode*=<*zipcode*>. By convention,
    path parameters are usually used to refer to a resource or resources, and query
    parameters are used to perform operations on the data returned, like sorting or
    filtering.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Specification</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The resources themselves are separate from the representations returned to the
    client. In other words, the server might send data in formats like HTML, XML,
    JSON, or others, regardless of the way in which the data is stored in the application’s
    database. You can learn about an API’s response format in its *specification*,
    which serves as the manual for an API. One excellent way to document your APIs
    is with the OpenAPI format, which is widely used in the industry and is part of
    the Linux Foundation. You can use the Swagger graphical editor at [*https://<wbr>editor<wbr>.swagger<wbr>.io*](https://editor.swagger.io)
    to experiment with it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Listing 6-1](chapter6.xhtml#Lis6-1) shows a specification for
    the */v1/weather/ {zipcode}* endpoint, written as JSON. Paste the code into the
    Swagger editor to explore the generated documentation in a more user-friendly
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: The OpenAPI specification for the /v1/weather/{zipcode} endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: First we define general information, such as the API’s title and description.
    The most important value here is the API version. In [Exercise 6](#Exe6) on page
    108, we’ll adjust our server to reflect this version. The next property we set
    is the server, or the root entry point of the API. We use localhost here, because
    our Next.js application runs locally for now.
  prefs: []
  type: TYPE_NORMAL
- en: Then we specify the unique API endpoints under <samp class="SANS_TheSansMonoCd_W5Regular_11">paths</samp>,
    setting the path, parameters, and responses for each of them. In this example,
    we specify the minimum required data for one endpoint, the */v1/weather/{zipcode}*,
    and clarify that it uses the GET method. The curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>)
    indicate the URL parameter, but we also set the parameter with the name <samp
    class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> explicitly in the path.
    In addition, we define the *schema*, or format, for the parameter, which should
    be a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">responses</samp>
    section, we set the response that the API should return if the HTTP status code
    is *200: OK*. This content, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">application/json</samp>
    format, is <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherDetailType</samp>,
    which you should already be familiar with from previous chapters. It’s similar
    to the custom type definition in our *custom.d.ts* file, except here we use JSON
    instead of TypeScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Swagger editor also generates an interactive playground based
    on the specification that lets us test the API’s endpoints against a running server.
    In addition, we can generate a server and client directly in the editor’s interface.
    The generated server will provide the REST API described in the specification,
    whereas the client will generate a library we can use in any application that
    consumes the API from the spec. This interactive playground and generated code
    make working with third-party APIs very easy.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">State and Authentication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: RESTful APIs are *stateless*, meaning they don’t store session information on
    the server. *Session information* is any data about previous user interactions.
    For example, imagine an online store’s shopping cart. In a stateful design, the
    application would store the content of your cart on the server and update it whenever
    you add new items. In a RESTful design, the client instead sends all relevant
    session data in each request. User–server interactions are understood in isolation,
    without context from previous requests.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, public RESTful APIs often require some form of authentication. In order
    to distinguish the requests of authenticated users from the requests of unauthenticated
    users, those APIs typically provide a token that users should include in subsequent
    requests. Consumers send this token as part of the request’s data or in the HTTP
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp> header. We’ll
    provide more details about authorization tokens and how they work in [Chapter
    9](chapter9.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: This stateless design means that the authentication works regardless of whether
    the client requests the data from the end server directly, a proxy, or a load
    balancer. Therefore, a RESTful API is capable of handling a layered system. Stateless
    architectures are also ideal in high-volume situations, because they remove the
    server load caused by the retrieval of session information from a database.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">HTTP Methods</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In REST, there are four standard ways to interact with a dataset: create, read,
    update, and delete. These interactions are commonly called *CRUD* operations.
    REST APIs use the following HTTP methods to perform these operations on the request’s
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET  **Used to retrieve data from a resource. It’s the most common request;
    each time you visit a website in your browser, you make a GET request to the website’s
    address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**POST  **Used to add a new element to a collection resource. Sending the same
    POST request multiple times creates a new element for each request, resulting
    in multiple elements with the same content. When you send an email or submit a
    web form, your client is usually sending a POST request behind the scenes, because
    you’re creating a new resource in a database.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PUT  **Used to overwrite or update an existing resource. Sending the same
    PUT request multiple times creates or overwrites a single element with updated
    content. For example, when you re-upload a picture on Instagram or Facebook, you
    might send a PUT request.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PATCH  **Used to partially update an existing resource. Unlike with PUT,
    you’re sending only the data that differs from the current dataset. Hence, it’s
    a smaller and more performant operation. For example, an update to your profile
    on a social media page might be done with a PATCH request.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DELETE  **Used to delete a resource (for example, to remove a picture on
    Instagram).'
  prefs: []
  type: TYPE_NORMAL
- en: REST API requests suffer from the same performance implications as do all HTTP
    requests. Developers must consider critical factors such as network bandwidth,
    latency, and server load. While the application usually can’t influence the network
    latency or user bandwidth, it can increase its performance by caching the requests
    and responding with the previously cached results.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the recommended approach is to cache requests aggressively. By avoiding
    additional server requests, we can speed up our application significantly. Unfortunately,
    not all HTTP requests are cacheable. The responses for GET requests are cacheable
    by default, but PUT and DELETE answers aren’t cacheable at all, because they don’t
    guarantee a predictable response. Between two similar PUT requests, a DELETE request
    might have deleted the resource, or vice versa. POST and PATCH request responses
    can, in theory, be cached if the response provides an <samp class="SANS_TheSansMonoCd_W5Regular_11">Expire</samp>
    header or a <samp class="SANS_TheSansMonoCd_W5Regular_11">Cache-Control</samp>
    header and your subsequent calls are GET requests to the same resource. Still,
    servers frequently won’t cache those two types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with REST</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s practice working with REST by taking a look at our fictional weather service.
    Say we read the API contract and see that an authorized user can receive and update
    datasets from the service by using its public REST API. The API returns JSON data,
    the server’s URL is *https://www.usemodernfullstack.dev*, and the endpoint at
    */api/v2/weather/{zipcode}* accepts GET and PUT requests. In this section, we
    walk through the requests and responses for getting the current weather data for
    a specific ZIP code with a GET request to the API, as well as for updating the
    stored weather data with a PUT request.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading Data</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To receive the weather for your location, you might make a GET request containing
    the ZIP code 96815 and an authorization token. We can make such a GET request
    with a command line tool like cURL, which should be part of your system. If necessary,
    you can install it from [*https://<wbr>curl<wbr>.se*](https://curl.se). A typical
    cURL request looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> flag displays the
    header details we are interested in. We can set the HTTP method with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-X</samp> flag and send an additional
    header with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-H</samp> flag.
    Use the escape character to send a multiline command (<samp class="SANS_TheSansMonoCd_W7Bold_B_11">\</samp>
    on macOS and <samp class="SANS_TheSansMonoCd_W7Bold_B_11">^</samp> on Windows).
    Avoid adding a space character behind the escape character. If you’re curious,
    try using cURL to query one of the API endpoints in the app you created in [Exercise
    5](chapter5.xhtml#Exe5) on page 89. A cURL call for a GET request to the weather
    API *v2/weather/{zipcode}* at *https://www.usemodernfullstack.dev/api* would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We make this request to the API endpoint *v2/weather/{zipcode}* on the server
    at *https://www.usemodernfullstack.dev/api.* The ZIP code is included in the URL.
    We set the return format to JSON in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp>
    header and pass an access token in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>
    header. Because this is an example API, it accepts any token; if one is not supplied,
    the API returns a status code of *401*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the API’s response to our GET request looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The API responds with an HTTP status code of *200*, indicating that the request
    was successful. We asked for a JSON response, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">content-type</samp>
    header confirms that the response data is indeed of that type.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Access-Control-Allow-Origin</samp>
    header, which we discussed in [Chapter 5](chapter5.xhtml), here allows access
    to any domain. With this setting, a browser whose client-side JavaScript wants
    to access the API will allow these requests regardless of the website’s domain.
    Without the CORS header, the browser would block the request and the script’s
    access to the response and instead throw a CORS error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we see that the response’s body contains a JSON string with the API
    response.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating Data</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now imagine that you want to add display data from your neighborhood (96814)
    and the adjacent one (96826) to your website. Unfortunately, these ZIP codes aren’t
    yet available on the API. Luckily, because it’s open source, we can hook up our
    own weather station and extend the system. Say we’ve set up our weather sensors
    and connected them to the API. As soon as the weather changes, we add the dataset
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the PUT request we make to update the weather for the ZIP code 96814\.
    PUT requests store data in the request body; therefore, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp>
    flag in the cURL command to send the encoded JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We request the same API endpoint, */api/v2/weather/*, but replace the GET method
    with PUT, because we don’t want to get the data from the database; instead, we
    want to add data. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp>
    header to tell the API provider that the payload in the request body is a JSON
    string. The API updates the dataset and responds with a status code of *200* and
    a JSON object with additional status details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about RESTful APIs at [*https://<wbr>restfulapi<wbr>.net*](https://restfulapi.net),
    which covers more specific topics, such as compression and security models, and
    guides you through designing your own RESTful APIs. Now let’s turn our attention
    to GraphQL, a different, more advanced type of API.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">GraphQL APIs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike REST, GraphQL isn’t merely an architectural pattern. It’s a complete,
    open source data query and manipulation language for APIs. It’s also the most
    popular REST alternative in full-stack web development, used by Airbnb, GitHub,
    PayPal, and many other companies. In fact, 10 percent of the top 10,000 sites
    reportedly use GraphQL. This section covers only certain of its features but should
    give you a solid understanding of GraphQL principles.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Despite its name, GraphQL doesn’t require the use of a graph database like
    Neo4j. We can use it to query any data source connected to the GraphQL server,
    including common databases such as MySQL and MongoDB.*'
  prefs: []
  type: TYPE_NORMAL
- en: Like REST, GraphQL APIs operate over HTTP. However, a GraphQL implementation
    exposes only a single API endpoint, typically called */graphql*, for accessing
    all resources and performing all CRUD operations. By contrast, REST has one dedicated
    endpoint per resource.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that we connect to the GraphQL server by using POST requests
    exclusively. Rather than using HTTP methods to define a desired CRUD operation,
    we use queries and mutations in the POST request body. *Queries* are read operations,
    while *mutations* are operations for creating, updating, and deleting data.
  prefs: []
  type: TYPE_NORMAL
- en: And unlike REST, which relies on standard HTTP status codes, GraphQL returns
    *500*, that is, an *Internal Server Error*, when an operation cannot be executed
    at all. Otherwise, the response uses *200* even if there are problems with the
    queries or mutations. The reason for this is that the resolver might have partially
    executed before encountering an issue. Keep this in mind when deploying a GraphQL
    API in production. Many standard operational practices and tools may need to change
    to account for this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Schema</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A GraphQL API defines the available queries and mutations in its schema, which
    is equivalent to the REST API’s specification. Also called a *typedef*, the schema
    is written in the Schema Definition Language (SDL). SDL’s core elements are *types*,
    which are objects that contain typed *fields* defining their properties, and optional
    *directives* that add additional information, for example, to specify caching
    rules for queries or mark fields as deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-2](chapter6.xhtml#Lis6-2) shows a GraphQL schema for our fictional
    weather API, which returns the weather data for a location.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: The GraphQL schema for the weather API'
  prefs: []
  type: TYPE_NORMAL
- en: You should notice that the schema is a tagged template literal, which you learned
    about in [Chapter 2](chapter2.xhtml). We begin by describing custom GraphQL object
    types. These object types represent the data that the API returns. They are similar
    to the custom types we defined in TypeScript. A type has a name and can implement
    an interface. Each of these custom object types contains fields, which have a
    name and a type. GraphQL has the built-in scalar types <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Float</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ID</samp>.
    Exclamation marks (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>) denote
    non-nullable fields, and lists within square brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>)
    indicate arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The first custom object type is <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationWeatherType</samp>,
    which describes the location information for a weather query. Here we use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">String!</samp> expression to mark
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ZIP</samp> field as non-nullable.
    Hence, the GraphQL service always returns a value for this field. We define a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> field as an array
    of strings to represent related weather stations by ZIP code. It is also non-nullable,
    so it will always contain an array (with zero or more items) when added to the
    return values. The <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>
    inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> array
    ensures that every item will be a string.
  prefs: []
  type: TYPE_NORMAL
- en: Then we define the input type object for our first mutation. These types are
    necessary for mutations, and they represent the input received from the API’s
    consumer. Because consumers should be able to pass in only the fields they’d like
    to update, we omit the exclamation marks to make the fields optional. In GraphQL,
    we need to define input objects and types for the return value separately, with
    the built-in types. Unlike in TypeScript, we can’t use generic custom types.
  prefs: []
  type: TYPE_NORMAL
- en: The schema also defines the query and mutation functions. These are the operations
    that consumers can send to the API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    query takes a ZIP code as a parameter and always returns an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationType</samp>
    objects. The <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> mutation
    takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationInput</samp>
    parameter and always returns the modified <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationType</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Our schema doesn’t contain any directives, and we won’t go deep into their syntax
    in this chapter. However, one reason to use directives is for caching. Because
    GraphQL queries use POST, which isn’t cacheable using the default HTTP cache,
    we must implement caching manually, on the server side. We can configure caching
    statically on the type definitions with the directive <samp class="SANS_TheSansMonoCd_W5Regular_11">@cacheControl</samp>
    or dynamically, in the resolver functions, with <samp class="SANS_TheSansMonoCd_W5Regular_11">cacheControl.setCacheHint</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Resolvers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In GraphQL, the *resolvers* are the functions that implement the schema. Each
    resolver function maps to a field. Query resolvers implement the reading of data,
    whereas mutation resolvers implement the creation, updating, and deletion of data.
    Together they provide complete CRUD functionality.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how resolvers work, you can think of each GraphQL operation as
    a tree of nested function calls. In such an *abstract syntax tree (AST)*, each
    part of the operation represents a node. For example, consider a complex, nested
    GraphQL query, which asks for the location’s current weather, as well as the weather
    of all its neighbors. Our GraphQL schema for this example looks like [Listing
    6-3](chapter6.xhtml#Lis6-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-3: The GraphQL schema for the nested GraphQL query example'
  prefs: []
  type: TYPE_NORMAL
- en: In the schema for the example, we replace the content of the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    array. Instead of a simple string, we want it to contain an object with a ZIP
    code and weather information. Therefore, we define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">FriendsType</samp>
    and use this type for the array items.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-4](chapter6.xhtml#Lis6-4) defines the complex example query.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-4: The nested GraphQL query'
  prefs: []
  type: TYPE_NORMAL
- en: This query takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>
    parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">96815</samp> and then
    returns its <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> property,
    as well as all of its friends’ <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    properties, as strings. But how does the query work under the hood?
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-1](chapter6.xhtml#fig6-1) shows the resolver chain and corresponding
    AST. The GraphQL server would first parse the query into this structure and then
    validate the AST against the type-definition schema to ensure that the query can
    be executed without running into logical problems. Finally, the server would execute
    the query.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 6-1: Querying the GraphQL
    AST</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the resolver chain for the query. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Query.weather</samp>
    function takes one argument, the ZIP code, and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    object for this ZIP code. Then the server continues along each branch separately.
    For the weather in the query, it returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    object, <samp class="SANS_TheSansMonoCd_W5Regular_11">Location.weather</samp>,
    at which point the branch ends. The second part of the query, which asks for all
    friends from the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    object and their <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    properties, runs the <samp class="SANS_TheSansMonoCd_W5Regular_11">Location.Friends</samp>
    query and then returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">Friends.weather</samp>
    property for each result. The resolver object of each step contains the result
    returned by the parent field’s resolver.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to our weather schema and define the resolvers. We’ll keep these
    simple. In [Listing 6-5](chapter6.xhtml#Lis6-5), you can see that their names
    match those defined in the schema.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-5: The GraphQL resolvers for the weather API'
  prefs: []
  type: TYPE_NORMAL
- en: We first define async functions for the query and mutation properties and assign
    the object to the const <samp class="SANS_TheSansMonoCd_W5Regular_11">resolvers</samp>.
    Each takes two parameters. The first one represents the previous resolver object
    in the resolver chain. We aren’t using a nested or complex query; hence, here
    it is always undefined. For this reason, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type to avoid a TypeScript error and use the underscore (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>)
    convention you learned in [Chapter 3](chapter3.xhtml) to mark it as unused. The
    second parameter is an object containing the data passed to the function on invocation.
    For the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> query and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> mutation, it
    is an object that implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: For now, both functions ignore this parameter for the most part, using only
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> property to reflect
    the input. Also, they return a static JSON object similar to the REST API we created
    in the previous listings. The static data is just a placeholder, which we’ll replace
    with the result from our database queries later. The response honors the API contract
    we defined in the GraphQL schema, as this data consists of arrays with weather
    location datasets.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comparing GraphQL to REST</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve already implemented RESTful APIs in our Next.js application, and as you
    saw in this chapter, REST is fairly simple to work with. You might be wondering
    why you’d even consider using GraphQL. Well, GraphQL solves two problems common
    in REST APIs: over-fetching and under-fetching.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Over-Fetching</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a client queries a REST endpoint, the API always returns the complete dataset
    for that endpoint. This means that, often, the API delivers more data than necessary,
    a common performance problem called *over-fetching*. For example, our example
    RESTful weather API at */api/v2/weather/zip/96815* delivers all weather data for
    a ZIP code even if all you need is the temperature in Celsius. You’d then need
    to manually filter the results. In GraphQL, the API requests explicitly define
    the data they want returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example to see how GraphQL lets us keep the API response data
    to a minimum. The following GraphQL query returns only the temperature in Celsius
    for the location with the ZIP code 96815:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In GraphQL, we send the query as a JSON string with the POST request’s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We consume the API with a POST request to the */api/graphql* endpoint, then
    set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp> header
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp> header to JSON
    to explicitly tell the API that we’re sending a JSON object in the request body
    and expect a JSON response. We set the access token in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>
    header, as in a RESTful request. The POST body contains the query for the weather
    data, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> control
    characters indicate the newlines in the GraphQL query. As defined in the contract,
    the query expects a parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>,
    for which we pass in the ZIP code <samp class="SANS_TheSansMonoCd_W5Regular_11">96815</samp>.
    In addition, we request that the API return only the <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>
    field of the weather node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the response from the GraphQL API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The API responds with a status code of *200*. We specified in the request’s
    query that we are interested in only the requested field <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> object, so
    this is what we received. The API doesn’t return the ZIP code, temperature in
    Fahrenheit, weather string, or friends array.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Under-Fetching</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On the other hand, a REST dataset might not contain all the data you need, requiring
    you to send follow-up requests. This problem is called *under-fetching*. Imagine
    that your friends also have weather stations and that you want to get the current
    weather at their ZIP codes. The RESTful weather API returns an array with related
    ZIP codes (<samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>). However,
    you’d need to make additional requests for each ZIP code to receive their weather
    information, potentially causing performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL treats datasets as nodes in a graph, with relationships between them.
    Therefore, extending a single query to receive related data is pretty simple.
    Our example GraphQL server’s resolvers are set up to fetch additional data about
    friends if the request’s query contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    field. We define the GraphQL query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows an example request that fetches all related nodes through
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> array. Again,
    we define the return data and query the friends only for the field <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The POST body contains the query for weather data pertaining to the 96815 ZIP
    code in one line and asks for the <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>
    field, as in the previous request. To extend the query, we add a sub-selection
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> field. Now
    GraphQL traverses the related nodes and their fields and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>
    field of the nodes whose ZIP codes match the ones in the 96815 node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the response from the GraphQL server. We see that it contains data
    from the related nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you’ve discovered, GraphQL lets us easily extend queries by adjusting the
    data in the request.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 6: Add a GraphQL API to Next.js</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s rework our weather application’s API to use GraphQL. To do so, we must
    first add GraphQL to the project. GraphQL isn’t a pattern but an environment that
    consists of a server and a query language, both of which we must add to Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll install the stand-alone Apollo server, one of the most popular GraphQL
    servers, which also provides a Next.js integration. Open your terminal and navigate
    to the refactored application you built in [Chapter 5](chapter5.xhtml). In the
    directory’s top level, next to the *package.json* file, execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command also installs the GraphQL language and the GraphQL tag modules
    we’ll need.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Schema</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we discussed, every GraphQL API starts with a schema definition. Create a
    folder called *graphql* next to the *pages* folder in the Next.js directory. This
    is where we’ll add all GraphQL-related files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a file called *schema.ts* and paste the code you wrote back in [Listing
    6-2](chapter6.xhtml#Lis6-2). We’ve already defined and discussed the type definition
    used here. Simply add one line to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This line imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">qql</samp>
    tagged template literal we use to define the schema.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Data</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want our API to return different data depending on the parameters and properties
    of the queries sent to it. Therefore, we need to add datasets to our project.
    GraphQL can query any database, even static JSON data. So let’s implement a JSON
    dataset. Create the file *data.ts* inside the *graphql* directory and add the
    code from [Listing 6-6](chapter6.xhtml#Lis6-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-6: The graphql/data.ts file for the GraphQL API'
  prefs: []
  type: TYPE_NORMAL
- en: This JSON defines three weather locations and their properties. A consumer will
    be able to query our API for these datasets.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Resolvers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we can define our resolvers. Add the file *resolvers.ts* to the *graphql*
    directory and paste in the code from [Listing 6-7](chapter6.xhtml#Lis6-7). This
    is similar to the code we previously discussed when we introduced resolvers, but
    instead of returning the same static JSON object to the consumer, we query our
    new dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-7: The graphql/resolvers.ts file for the GraphQL API'
  prefs: []
  type: TYPE_NORMAL
- en: 'We import the array of JSON objects we created earlier and define an interface
    for the resolvers. The query resolver finds an object by using the ZIP code passed
    to it and returns it to the Apollo server. The mutation does the same, except
    that the parameter structure is slightly different: it is accessible through the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> property. Alas, we can’t
    actually change the data by using the mutation, as the data is a static JSON file.
    We’ve implemented the mutation here for illustration purposes only.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the API
    Route</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Apollo GraphQL server exposes one endpoint, *graphql/*, which we’ll implement
    now. Create a new file, *graphql.ts*, in the *api* folder and add the code from
    [Listing 6-8](chapter6.xhtml#Lis6-8). This code initializes the GraphQL server
    and adds a CORS header so that we can access the API from different domains and
    use the built-in GraphQL sandbox explorer to play with GraphQL later. You saw
    this header in the previous cURL responses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-8: The api/graphql.ts file, which creates the API entry point for
    GraphQL'
  prefs: []
  type: TYPE_NORMAL
- en: This code is all we need to create the GraphQL entry point. First we import
    the necessary modules, including our GraphQL schema and the resolvers, both of
    which we created previously. Then we initialize a new GraphQL server with typedefs
    and resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: We start the server and continue by creating the API handler. To do this, we
    use the Next.js integration helper to start the server and return the Next.js
    handler. The integration helper connects the serverless Apollo instance to the
    Next.js custom server. Before we define the default export as an async function
    that takes the API’s request and response objects as parameters, we create a wrapper
    to add the CORS headers to the request. The first block inside the function sets
    up the CORS headers, and we limit the allowed request to POST requests. We need
    the CORS headers here to make our GraphQL API publicly available. Otherwise, we
    wouldn’t be able to connect to the API from a website running on a different domain
    or even use the server’s built-in GraphQL sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the CORS setup here is that we immediately return *200* for any OPTIONS
    requests. The CORS patterns use OPTIONS requests as preflight checks. Here the
    browser requests only headers, and then checks the response’s CORS headers to
    verify that the domain from which it calls the API is allowed to access the resource
    before making the actual request.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, our Apollo server allows only POST and GET requests and would return
    *405: Method Not Allowed* for the preflight OPTIONS request. So, instead of passing
    this request to the Apollo server, we end the request and return *200* with the
    previous CORS headers. The browser should then proceed with the CORS pattern.
    Finally, we start the server and create the API handler on the desired path, *api/graphql*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Apollo
    Sandbox</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Start your Next.js server with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp>. You should see the Next.js application running on *http://localhost:3000*.
    If you navigate to the GraphQL API at *http://localhost:3000/api/graphql*, you’ll
    find the Apollo sandbox interface for querying the API, as in [Figure 6-2](chapter6.xhtml#fig6-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 6-2: The Apollo sandbox’s
    API querying interface</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the Documentation pane on the left side, we see the available queries as
    fields of the query object we defined earlier. As expected, we see the <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>
    query here, and when we click it, a new query appears in the Operation pane in
    the middle. At the same time, the interface changes, and we see the available
    arguments and fields. Clicking each provides more information. Using the plus
    (+) button, we can add fields to the Query pane and run them against the data.
  prefs: []
  type: TYPE_NORMAL
- en: Try creating a <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>
    query that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> properties. This
    query requires a ZIP code as an argument; add it through the user interface on
    the left-hand side, and then add the ZIP code 96826 as a string to the JSON object
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">variables</samp> section
    of the lower pane. Now run the query by clicking the **Weather** button at the
    top of the Operation pane. You should receive the result for this ZIP code in
    the Response pane on the right as JSON. Compare your screen with [Figure 6-3](chapter6.xhtml#fig6-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 6-3: The GraphQL query
    and response from the server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Play around with crafting queries, accessing properties, and creating errors
    with invalid arguments to get a feel for GraphQL before moving on to the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter explored RESTful and GraphQL web APIs and their role in full-stack
    development. Although we used a REST design in previous chapters, you should now
    be familiar with the concept of stateless servers, as well as the five HTTP methods
    for performing CRUD operations in REST. You also practiced working with a public
    REST API to read and update data, then evaluated its requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL APIs require a bit more work to implement, but they reduce the over-fetching
    and under-fetching issues often experienced in REST. You learned to define the
    API contract with a schema and implement its functionality with resolvers. Then
    you queried an API and defined the dataset to return in the request.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you added a GraphQL API to your existing Next.js application by adding
    the Apollo server to it. You should now be able to create your own GraphQL API
    and consume third-party resources. To learn more about GraphQL, I recommend the
    tutorials at [*https://<wbr>www<wbr>.howtographql<wbr>.com*](https://www.howtographql.com)
    and the official GraphQL introduction at [*https://<wbr>graphql<wbr>.org<wbr>/learn<wbr>/*](https://graphql.org/learn/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll explore the MongoDB database and Mongoose, an object
    data modeling library, for storing data.
  prefs: []
  type: TYPE_NORMAL
