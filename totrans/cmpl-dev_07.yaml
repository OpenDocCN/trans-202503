- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REST
    AND GRAPHQL APIS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REST
    和 GRAPHQL API</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: An *API* is a generic pattern used to connect computers or computer programs.
    Unlike a user interface, it’s designed to be accessed not by a user but by another
    piece of software. One purpose of APIs is to hide the internal details of a system’s
    workings while exposing a standardized gateway to the system’s data or functionality.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*API* 是一种通用模式，用于连接计算机或计算机程序。与用户界面不同，它的设计目的是让软件而非用户来访问。API 的一个目的是隐藏系统内部工作细节，同时暴露出一个标准化的网关，供访问系统的数据或功能。'
- en: 'As a full-stack developer, you’ll usually interact with, or *consume*, two
    kinds of APIs: internal and third-party. When querying an internal API, you’re
    consuming data from your own systems, typically from your own database or service.
    Private APIs are not available to outside parties. For example, your bank might
    use private APIs to check your credit score or account balance on its internal
    systems and display them in your online banking profile.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为全栈开发人员，你通常会与两种类型的 API 进行交互或*使用*：内部 API 和第三方 API。在查询内部 API 时，你是从自己的系统中获取数据，通常来自自己的数据库或服务。私有
    API 不对外部方开放。例如，你的银行可能使用私有 API 来检查其内部系统中的信用评分或账户余额，并将这些信息显示在你的在线银行账户页面上。
- en: Third-party APIs provide access to data from an external system. For example,
    the OAuth login you’ll implement in [Part II](part2.xhtml) uses an API. You might
    also use an API to fetch a social media feed or weather information from an external
    provider to display on your website. Because external APIs are exposed to the
    public, you can reach them through a public URL, and they document the conventions
    you should use to access their data in an *API contract*. This contract defines
    the format of the communications, the parameters the API expects, and the possible
    responses you might receive for each request. We briefly discussed API and function
    contracts and why you should type them in [Chapter 3](chapter3.xhtml).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方 API 提供对外部系统数据的访问。例如，你将在[第二部分](part2.xhtml)中实现的 OAuth 登录就使用了一个 API。你还可以使用
    API 从外部提供者获取社交媒体动态或天气信息，并在网站上展示它们。由于外部 API 对公众开放，你可以通过公共 URL 访问它们，它们会在*API 合同*中记录你应使用的访问数据的约定。这个合同定义了通信格式、API
    期望的参数以及每个请求可能收到的响应。我们在[第三章](chapter3.xhtml)中简要讨论了 API 和功能合同，并解释了为什么你应该为它们指定类型。
- en: Full-stack web development primarily uses two types of APIs, REST and GraphQL,
    both of which transmit data over HTTP. This chapter covers these.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈 web 开发主要使用两种类型的 API，分别是 REST 和 GraphQL，它们都通过 HTTP 传输数据。本章将介绍这两种 API。
- en: <samp class="SANS_Futura_Std_Bold_B_11">REST APIs</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">REST API</samp>
- en: REST is an architectural pattern used to design RESTful web APIs. These APIs
    are essentially a set of URLs, each of which provides access to a single resource.
    They rely on the use of HTTP methods and the standard HTTP status codes to transmit
    data and accept URL-encoded or request header parameters. Typically, they respond
    with the requested data in JSON or plaintext.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是一种用于设计 RESTful web API 的架构模式。这些 API 本质上是一组 URL，每个 URL 提供对单一资源的访问。它们依赖于使用
    HTTP 方法和标准 HTTP 状态码来传输数据，并接受 URL 编码或请求头参数。通常，它们会以 JSON 或纯文本的形式响应请求的数据。
- en: 'In fact, you’ve already built your first REST API. Recall the Next.js server
    you created in [Exercise 5](chapter5.xhtml#Exe5) on page 89, which provided the
    *api/weather/:zipcode* endpoint. So far, we’ve used this endpoint to play with
    Next.js’s routing, understand dynamic URLs, and learn how to access query parameters.
    You’ll soon see, however, that this API follows REST conventions: to access it,
    we used the HTTP GET method to consume the URL endpoint and received a JSON response
    with an HTTP status code of *200: OK*. Common status code ranges are *2XX* for
    successful requests and *3XX* for redirects. If the request fails, we see the
    *4XX* range to indicate a client-related error, such as *401: Unauthorized*, and
    *5XX* for server errors, often the generic *500: Internal Server Error*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，你已经构建了第一个REST API。回想一下你在[第5节练习](chapter5.xhtml#Exe5)中创建的Next.js服务器，它提供了*api/weather/:zipcode*端点。到目前为止，我们已使用这个端点来玩转Next.js的路由，理解动态URL，并学习如何访问查询参数。然而，很快你就会发现，这个API遵循了REST的约定：为了访问它，我们使用了HTTP的GET方法来访问URL端点，并收到了一个带有HTTP状态码*200:
    OK*的JSON响应。常见的状态码范围是*2XX*表示请求成功，*3XX*表示重定向。如果请求失败，我们会看到*4XX*范围表示与客户端相关的错误，例如*401:
    Unauthorized*，以及*5XX*表示服务器错误，通常是通用的*500: Internal Server Error*。'
- en: As full-stack developers, we might sometimes create our own APIs; more often,
    though, we’ll find ourselves consuming third-party APIs. Why might we consume,
    say, a third-party weather API? Well, imagine that we want our app to display
    the current weather at multiple remote locations. Instead of setting up and maintaining
    various weather stations on our own and then reading the data from the sensors,
    which would involve both providing and consuming an API for each of them, we could
    consume data from a third-party API offered by an existing weather service. Our
    code might call that API, pass in a ZIP code as a parameter, and receive the weather
    data for this location in a predetermined format. We’d then display this data
    on our website.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为全栈开发人员，我们有时可能会创建自己的API；但更多的时候，我们会使用第三方API。为什么我们会使用第三方的天气API呢？好吧，想象一下，我们希望我们的应用在多个远程地点显示当前天气。与其自行设置并维护多个天气站，然后从传感器中读取数据，这不仅需要为每个天气站提供和消费API，不如直接从现有天气服务提供的第三方API中获取数据。我们的代码可能会调用该API，传递一个邮政编码作为参数，并以预定的格式接收该地点的天气数据。然后，我们会在网站上显示这些数据。
- en: RESTful APIs enable us to interact with data without knowing anything about
    how that data was stored or what underlying technology provided it. If you follow
    an API’s specifications, you should receive the requested data, even if the underlying
    technology or architecture changes. Beyond this, there are a handful of requirements
    for an API to be considered RESTful.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API使我们能够与数据交互，而无需了解数据是如何存储的或由何种底层技术提供的。如果你遵循API的规范，即使底层技术或架构发生变化，你也应该能够收到请求的数据。除此之外，还有一些要求，API才能被认为是RESTful的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The URL</samp>
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">URL</samp>
- en: A unique URL provides an interface to a RESTful API. Each of a provider’s APIs
    typically has the same base URL, called the *root entry point*, such as *http://localhost:3000/api*.
    You can think of this as the APIs’ family name. Often, you’ll see a version number
    added to the root entry point, because a provider might have multiple versions
    of an API. For example, there might be the legacy *http://localhost:3000/api/v1*
    and an updated *http://localhost:3000/api/v2*. To honor this pattern, you can
    create a folder *v1* inside the *api* folder and move the REST API code there.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个独特的URL为RESTful API提供了接口。每个提供者的API通常都有相同的基本URL，称为*根入口点*，例如*http://localhost:3000/api*。你可以把它看作是API的姓氏。通常，你会看到根入口点后面加上版本号，因为提供者可能有多个API版本。例如，可能会有旧版的*http://localhost:3000/api/v1*和新版的*http://localhost:3000/api/v2*。为了遵循这个模式，你可以在*api*文件夹中创建一个*v1*文件夹，并将REST
    API代码移动到该文件夹中。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Other common ways of versioning an API include custom headers and query strings.
    In the first case, the client would request the API with a custom Accept-Version
    header and receive a matching Content-Version header. In the second case, an API
    request would use* ?version=1.0.0 *as a query parameter in the URL.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*API版本控制的其他常见方式包括自定义头部和查询字符串。在第一种情况下，客户端会使用自定义的Accept-Version头部请求API，并收到匹配的Content-Version头部。在第二种情况下，API请求会在URL中使用*
    ?version=1.0.0 *作为查询参数。*'
- en: The next part of the API’s URL is the path, often called the *endpoint*. It
    specifies the resource we want to query (for example, the weather API). API specifications
    usually mention only the endpoint itself, such as */v1/weather*, leaving the root
    entry point implied. The URL generally also accepts parameters. These can be path
    parameters that are part of the URL, like in our ZIP code API endpoint, */v1/weather/{zipcode}*,
    or they can be query parameters, which are added as encoded key-value pairs after
    an initial question mark, as in */v1/weather?zipcode*=<*zipcode*>. By convention,
    path parameters are usually used to refer to a resource or resources, and query
    parameters are used to perform operations on the data returned, like sorting or
    filtering.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: API URL的下一部分是路径，通常被称为*端点*。它指定我们想要查询的资源（例如天气API）。API规范通常只提到端点本身，如*/v1/weather*，并暗示根入口点。URL通常还接受参数。这些可以是路径参数，它们是URL的一部分，例如我们的邮政编码API端点*/v1/weather/{zipcode}*，也可以是查询参数，它们作为编码的键值对在初始问号后添加，如*/v1/weather?zipcode*=<*zipcode*>。按照惯例，路径参数通常用于表示一个或多个资源，而查询参数用于对返回的数据执行操作，如排序或过滤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Specification</samp>
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">规范</samp>
- en: The resources themselves are separate from the representations returned to the
    client. In other words, the server might send data in formats like HTML, XML,
    JSON, or others, regardless of the way in which the data is stored in the application’s
    database. You can learn about an API’s response format in its *specification*,
    which serves as the manual for an API. One excellent way to document your APIs
    is with the OpenAPI format, which is widely used in the industry and is part of
    the Linux Foundation. You can use the Swagger graphical editor at [*https://<wbr>editor<wbr>.swagger<wbr>.io*](https://editor.swagger.io)
    to experiment with it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 资源本身与返回给客户端的表示是分开的。换句话说，服务器可能会以HTML、XML、JSON等格式发送数据，无论数据是如何存储在应用程序的数据库中的。你可以在API的*规范*中了解API的响应格式，它作为API的手册。记录API的一种优秀方法是使用OpenAPI格式，它在行业中被广泛使用，并且是Linux基金会的一部分。你可以使用Swagger图形编辑器，访问[*https://<wbr>editor<wbr>.swagger<wbr>.io*](https://editor.swagger.io)进行实验。
- en: For example, [Listing 6-1](chapter6.xhtml#Lis6-1) shows a specification for
    the */v1/weather/ {zipcode}* endpoint, written as JSON. Paste the code into the
    Swagger editor to explore the generated documentation in a more user-friendly
    manner.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[清单6-1](chapter6.xhtml#Lis6-1)显示了一个*v1/weather/{zipcode}*端点的规范，格式为JSON。将代码粘贴到Swagger编辑器中，以更友好的方式浏览生成的文档。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: The OpenAPI specification for the /v1/weather/{zipcode} endpoint'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-1：/v1/weather/{zipcode}端点的OpenAPI规范
- en: First we define general information, such as the API’s title and description.
    The most important value here is the API version. In [Exercise 6](#Exe6) on page
    108, we’ll adjust our server to reflect this version. The next property we set
    is the server, or the root entry point of the API. We use localhost here, because
    our Next.js application runs locally for now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义一般信息，如API的标题和描述。这里最重要的值是API版本。在[练习6](#Exe6)中，我们将调整服务器以反映这个版本。在下一步中，我们设置服务器，即API的根入口点。这里我们使用localhost，因为我们的Next.js应用程序现在是在本地运行的。
- en: Then we specify the unique API endpoints under <samp class="SANS_TheSansMonoCd_W5Regular_11">paths</samp>,
    setting the path, parameters, and responses for each of them. In this example,
    we specify the minimum required data for one endpoint, the */v1/weather/{zipcode}*,
    and clarify that it uses the GET method. The curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>)
    indicate the URL parameter, but we also set the parameter with the name <samp
    class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> explicitly in the path.
    In addition, we define the *schema*, or format, for the parameter, which should
    be a string.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在<samp class="SANS_TheSansMonoCd_W5Regular_11">paths</samp>下指定唯一的API端点，设置每个端点的路径、参数和响应。在这个示例中，我们为一个端点*/v1/weather/{zipcode}*指定了最小的必需数据，并明确指出它使用GET方法。大括号(<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>)表示URL参数，但我们也在路径中显式设置了名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>的参数。此外，我们定义了*schema*，即该参数的格式，应该是一个字符串。
- en: 'Next, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">responses</samp>
    section, we set the response that the API should return if the HTTP status code
    is *200: OK*. This content, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">application/json</samp>
    format, is <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherDetailType</samp>,
    which you should already be familiar with from previous chapters. It’s similar
    to the custom type definition in our *custom.d.ts* file, except here we use JSON
    instead of TypeScript.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">responses</samp> 部分，我们设置了如果
    HTTP 状态码为 *200: OK* 时，API 应该返回的响应。该内容采用 <samp class="SANS_TheSansMonoCd_W5Regular_11">application/json</samp>
    格式，是 <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherDetailType</samp>，你应该已经从之前的章节中熟悉了它。它类似于我们
    *custom.d.ts* 文件中的自定义类型定义，只不过这里我们使用的是 JSON，而不是 TypeScript。'
- en: Note that the Swagger editor also generates an interactive playground based
    on the specification that lets us test the API’s endpoints against a running server.
    In addition, we can generate a server and client directly in the editor’s interface.
    The generated server will provide the REST API described in the specification,
    whereas the client will generate a library we can use in any application that
    consumes the API from the spec. This interactive playground and generated code
    make working with third-party APIs very easy.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Swagger 编辑器还会根据规范生成一个交互式的“游乐场”，允许我们在运行中的服务器上测试 API 的端点。此外，我们可以直接在编辑器的界面中生成服务器和客户端。生成的服务器将提供规范中描述的
    REST API，而客户端将生成一个库，我们可以在任何使用该 API 的应用程序中使用。这个交互式“游乐场”和生成的代码使得与第三方 API 的协作变得非常简单。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">State and Authentication</samp>
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">状态与身份验证</samp>
- en: RESTful APIs are *stateless*, meaning they don’t store session information on
    the server. *Session information* is any data about previous user interactions.
    For example, imagine an online store’s shopping cart. In a stateful design, the
    application would store the content of your cart on the server and update it whenever
    you add new items. In a RESTful design, the client instead sends all relevant
    session data in each request. User–server interactions are understood in isolation,
    without context from previous requests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 是*无状态的*，这意味着它们不在服务器上存储会话信息。*会话信息*是关于之前用户交互的任何数据。例如，想象一个在线商店的购物车。在有状态设计中，应用程序会将购物车的内容存储在服务器上，并在你添加新商品时进行更新。在
    RESTful 设计中，客户端会在每次请求中发送所有相关的会话数据。用户与服务器的交互是孤立理解的，不依赖于之前请求的上下文。
- en: Even so, public RESTful APIs often require some form of authentication. In order
    to distinguish the requests of authenticated users from the requests of unauthenticated
    users, those APIs typically provide a token that users should include in subsequent
    requests. Consumers send this token as part of the request’s data or in the HTTP
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp> header. We’ll
    provide more details about authorization tokens and how they work in [Chapter
    9](chapter9.xhtml).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，公共的 RESTful API 通常要求某种形式的身份验证。为了区分认证用户的请求和未认证用户的请求，这些 API 通常会提供一个令牌，用户应该在后续的请求中包含该令牌。消费者将此令牌作为请求数据的一部分，或者放在
    HTTP <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp> 头部。我们将在[第9章](chapter9.xhtml)中提供关于授权令牌及其工作原理的更多细节。
- en: This stateless design means that the authentication works regardless of whether
    the client requests the data from the end server directly, a proxy, or a load
    balancer. Therefore, a RESTful API is capable of handling a layered system. Stateless
    architectures are also ideal in high-volume situations, because they remove the
    server load caused by the retrieval of session information from a database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种无状态设计意味着，无论客户端是直接从终端服务器、代理服务器，还是负载均衡器请求数据，身份验证都能正常工作。因此，RESTful API 能够处理分层系统。无状态架构在高流量情况下也很理想，因为它们消除了因从数据库检索会话信息而导致的服务器负载。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">HTTP Methods</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">HTTP 方法</samp>
- en: 'In REST, there are four standard ways to interact with a dataset: create, read,
    update, and delete. These interactions are commonly called *CRUD* operations.
    REST APIs use the following HTTP methods to perform these operations on the request’s
    resource:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 中，有四种标准方式与数据集交互：创建、读取、更新和删除。这些交互通常被称为*CRUD*操作。REST API 使用以下 HTTP 方法在请求的资源上执行这些操作：
- en: '**GET  **Used to retrieve data from a resource. It’s the most common request;
    each time you visit a website in your browser, you make a GET request to the website’s
    address.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**GET  **用于从资源中检索数据。这是最常见的请求；每当你在浏览器中访问一个网站时，实际上就是向该网站地址发送GET请求。'
- en: '**POST  **Used to add a new element to a collection resource. Sending the same
    POST request multiple times creates a new element for each request, resulting
    in multiple elements with the same content. When you send an email or submit a
    web form, your client is usually sending a POST request behind the scenes, because
    you’re creating a new resource in a database.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**POST  **用于向集合资源中添加新元素。多次发送相同的POST请求会为每个请求创建一个新的元素，导致多个具有相同内容的元素。当你发送电子邮件或提交网页表单时，你的客户端通常会在后台发送一个POST请求，因为你在数据库中创建了一个新资源。'
- en: '**PUT  **Used to overwrite or update an existing resource. Sending the same
    PUT request multiple times creates or overwrites a single element with updated
    content. For example, when you re-upload a picture on Instagram or Facebook, you
    might send a PUT request.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**PUT  **用于覆盖或更新现有资源。多次发送相同的PUT请求会创建或覆盖一个元素并更新其内容。例如，当你重新上传Instagram或Facebook上的图片时，你可能会发送一个PUT请求。'
- en: '**PATCH  **Used to partially update an existing resource. Unlike with PUT,
    you’re sending only the data that differs from the current dataset. Hence, it’s
    a smaller and more performant operation. For example, an update to your profile
    on a social media page might be done with a PATCH request.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**PATCH  **用于部分更新现有资源。与PUT不同，你只会发送与当前数据集不同的数据。因此，这是一项更小且性能更好的操作。例如，你在社交媒体页面上更新个人资料时，可能会使用PATCH请求。'
- en: '**DELETE  **Used to delete a resource (for example, to remove a picture on
    Instagram).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**DELETE  **用于删除资源（例如，在Instagram上删除一张图片）。'
- en: REST API requests suffer from the same performance implications as do all HTTP
    requests. Developers must consider critical factors such as network bandwidth,
    latency, and server load. While the application usually can’t influence the network
    latency or user bandwidth, it can increase its performance by caching the requests
    and responding with the previously cached results.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: REST API请求面临与所有HTTP请求相同的性能问题。开发者必须考虑关键因素，如网络带宽、延迟和服务器负载。虽然应用程序通常无法影响网络延迟或用户带宽，但它可以通过缓存请求并返回之前缓存的结果来提高性能。
- en: In general, the recommended approach is to cache requests aggressively. By avoiding
    additional server requests, we can speed up our application significantly. Unfortunately,
    not all HTTP requests are cacheable. The responses for GET requests are cacheable
    by default, but PUT and DELETE answers aren’t cacheable at all, because they don’t
    guarantee a predictable response. Between two similar PUT requests, a DELETE request
    might have deleted the resource, or vice versa. POST and PATCH request responses
    can, in theory, be cached if the response provides an <samp class="SANS_TheSansMonoCd_W5Regular_11">Expire</samp>
    header or a <samp class="SANS_TheSansMonoCd_W5Regular_11">Cache-Control</samp>
    header and your subsequent calls are GET requests to the same resource. Still,
    servers frequently won’t cache those two types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，推荐的做法是积极缓存请求。通过避免额外的服务器请求，我们可以显著加快应用程序的速度。不幸的是，并非所有HTTP请求都可以缓存。GET请求的响应默认是可缓存的，但PUT和DELETE的响应完全不可缓存，因为它们不能保证可预测的响应。在两个类似的PUT请求之间，可能会有DELETE请求删除了资源，或者反之。理论上，POST和PATCH请求的响应可以缓存，如果响应提供了<code
    class="SANS_TheSansMonoCd_W5Regular_11">Expire</code>头部或<code class="SANS_TheSansMonoCd_W5Regular_11">Cache-Control</code>头部，并且后续调用是对相同资源的GET请求。然而，服务器通常不会缓存这两种类型的请求。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with REST</samp>
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <code class="SANS_Futura_Std_Bold_B_11">与REST工作</code>
- en: Let’s practice working with REST by taking a look at our fictional weather service.
    Say we read the API contract and see that an authorized user can receive and update
    datasets from the service by using its public REST API. The API returns JSON data,
    the server’s URL is *https://www.usemodernfullstack.dev*, and the endpoint at
    */api/v2/weather/{zipcode}* accepts GET and PUT requests. In this section, we
    walk through the requests and responses for getting the current weather data for
    a specific ZIP code with a GET request to the API, as well as for updating the
    stored weather data with a PUT request.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一个虚构的天气服务来练习使用REST。假设我们阅读了API文档，发现授权用户可以通过使用其公开的REST API接收和更新服务中的数据集。该API返回JSON数据，服务器的URL是*https://www.usemodernfullstack.dev*，并且*/api/v2/weather/{zipcode}*端点支持GET和PUT请求。在本节中，我们将通过GET请求获取特定邮政编码的当前天气数据，以及通过PUT请求更新存储的天气数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading Data</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">读取数据</samp>
- en: 'To receive the weather for your location, you might make a GET request containing
    the ZIP code 96815 and an authorization token. We can make such a GET request
    with a command line tool like cURL, which should be part of your system. If necessary,
    you can install it from [*https://<wbr>curl<wbr>.se*](https://curl.se). A typical
    cURL request looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取你所在位置的天气，你可能会发出一个包含邮政编码96815和授权令牌的GET请求。我们可以使用像cURL这样的命令行工具来发出此类GET请求，cURL应该是你系统的一部分。如有必要，你可以从[*https://<wbr>curl<wbr>.se*](https://curl.se)安装它。一个典型的cURL请求如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> flag displays the
    header details we are interested in. We can set the HTTP method with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-X</samp> flag and send an additional
    header with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-H</samp> flag.
    Use the escape character to send a multiline command (<samp class="SANS_TheSansMonoCd_W7Bold_B_11">\</samp>
    on macOS and <samp class="SANS_TheSansMonoCd_W7Bold_B_11">^</samp> on Windows).
    Avoid adding a space character behind the escape character. If you’re curious,
    try using cURL to query one of the API endpoints in the app you created in [Exercise
    5](chapter5.xhtml#Exe5) on page 89. A cURL call for a GET request to the weather
    API *v2/weather/{zipcode}* at *https://www.usemodernfullstack.dev/api* would look
    like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>标志显示我们感兴趣的头部详情。我们可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-X</samp>标志设置HTTP方法，并通过<samp class="SANS_TheSansMonoCd_W5Regular_11">-H</samp>标志发送额外的头部。使用转义字符发送多行命令（macOS上使用<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">\</samp>，Windows上使用<samp class="SANS_TheSansMonoCd_W7Bold_B_11">^</samp>）。避免在转义字符后添加空格。如果你感兴趣，可以尝试使用cURL查询你在[第5章练习](chapter5.xhtml#Exe5)第89页中创建的应用程序的一个API端点。对天气API
    *v2/weather/{zipcode}* 发起GET请求的cURL调用如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We make this request to the API endpoint *v2/weather/{zipcode}* on the server
    at *https://www.usemodernfullstack.dev/api.* The ZIP code is included in the URL.
    We set the return format to JSON in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp>
    header and pass an access token in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>
    header. Because this is an example API, it accepts any token; if one is not supplied,
    the API returns a status code of *401*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向服务器上的API端点 *v2/weather/{zipcode}* 发出此请求，服务器的地址为 *https://www.usemodernfullstack.dev/api*。邮政编码包含在URL中。我们在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp>头部中设置返回格式为JSON，并在<samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>头部中传递访问令牌。由于这是一个示例API，它接受任何令牌；如果未提供令牌，API将返回状态码*401*。
- en: 'Here is what the API’s response to our GET request looks like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是API对我们GET请求的响应示例：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The API responds with an HTTP status code of *200*, indicating that the request
    was successful. We asked for a JSON response, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">content-type</samp>
    header confirms that the response data is indeed of that type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: API响应的HTTP状态码为*200*，表示请求成功。我们要求返回JSON响应，并且<samp class="SANS_TheSansMonoCd_W5Regular_11">content-type</samp>头部确认响应数据确实是该类型。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Access-Control-Allow-Origin</samp>
    header, which we discussed in [Chapter 5](chapter5.xhtml), here allows access
    to any domain. With this setting, a browser whose client-side JavaScript wants
    to access the API will allow these requests regardless of the website’s domain.
    Without the CORS header, the browser would block the request and the script’s
    access to the response and instead throw a CORS error.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Access-Control-Allow-Origin</samp>头部，我们在[第5章](chapter5.xhtml)中讨论过，它允许访问任何域名。通过这个设置，任何客户端JavaScript希望访问API的浏览器都会允许这些请求，而不管网站的域名是什么。如果没有CORS头部，浏览器会阻止请求，脚本无法访问响应，反而会抛出CORS错误。
- en: Finally, we see that the response’s body contains a JSON string with the API
    response.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到响应体包含一个JSON字符串，包含API的响应。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating Data</samp>
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">更新数据</samp>
- en: Now imagine that you want to add display data from your neighborhood (96814)
    and the adjacent one (96826) to your website. Unfortunately, these ZIP codes aren’t
    yet available on the API. Luckily, because it’s open source, we can hook up our
    own weather station and extend the system. Say we’ve set up our weather sensors
    and connected them to the API. As soon as the weather changes, we add the dataset
    to it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想在你的网站上添加来自你所在邻里的显示数据（邮政编码96814）以及邻近区域（邮政编码96826）的数据。不幸的是，这些邮政编码还没有在API中提供。幸运的是，由于它是开源的，我们可以连接我们自己的气象站并扩展系统。假设我们已经设置了气象传感器并将它们连接到API。一旦天气发生变化，我们就将数据集添加到其中。
- en: 'Here is the PUT request we make to update the weather for the ZIP code 96814\.
    PUT requests store data in the request body; therefore, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp>
    flag in the cURL command to send the encoded JSON:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们发送的PUT请求，用于更新邮政编码96814的天气数据。PUT请求将数据存储在请求体中；因此，我们在cURL命令中使用<samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp>标志来发送编码后的JSON：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We request the same API endpoint, */api/v2/weather/*, but replace the GET method
    with PUT, because we don’t want to get the data from the database; instead, we
    want to add data. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp>
    header to tell the API provider that the payload in the request body is a JSON
    string. The API updates the dataset and responds with a status code of *200* and
    a JSON object with additional status details:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求相同的API端点，*/api/v2/weather/*，但将GET方法替换为PUT，因为我们不想从数据库获取数据，而是想添加数据。我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp>头部告诉API提供者请求体中的有效负载是一个JSON字符串。API更新数据集并返回状态码*200*，以及包含额外状态信息的JSON对象：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can learn more about RESTful APIs at [*https://<wbr>restfulapi<wbr>.net*](https://restfulapi.net),
    which covers more specific topics, such as compression and security models, and
    guides you through designing your own RESTful APIs. Now let’s turn our attention
    to GraphQL, a different, more advanced type of API.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[*https://<wbr>restfulapi<wbr>.net*](https://restfulapi.net)了解更多关于RESTful
    API的内容，该网站涵盖了更具体的话题，比如压缩和安全模型，并指导你设计自己的RESTful API。现在，让我们将注意力转向GraphQL，这是一种不同且更先进的API类型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">GraphQL APIs</samp>
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">GraphQL API</samp>
- en: Unlike REST, GraphQL isn’t merely an architectural pattern. It’s a complete,
    open source data query and manipulation language for APIs. It’s also the most
    popular REST alternative in full-stack web development, used by Airbnb, GitHub,
    PayPal, and many other companies. In fact, 10 percent of the top 10,000 sites
    reportedly use GraphQL. This section covers only certain of its features but should
    give you a solid understanding of GraphQL principles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与REST不同，GraphQL不仅仅是一个架构模式。它是一个完整的、开源的数据查询和操作语言，专为API设计。它也是全栈Web开发中最受欢迎的REST替代方案，Airbnb、GitHub、PayPal等众多公司都在使用它。事实上，据报道，前10,000个网站中有10%的站点使用GraphQL。本节仅涵盖其部分功能，但应该能让你对GraphQL的原理有一个扎实的理解。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Despite its name, GraphQL doesn’t require the use of a graph database like
    Neo4j. We can use it to query any data source connected to the GraphQL server,
    including common databases such as MySQL and MongoDB.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管其名称中带有“Graph”，GraphQL并不要求使用像Neo4j这样的图数据库。我们可以用它查询连接到GraphQL服务器的任何数据源，包括常见的数据库如MySQL和MongoDB。*'
- en: Like REST, GraphQL APIs operate over HTTP. However, a GraphQL implementation
    exposes only a single API endpoint, typically called */graphql*, for accessing
    all resources and performing all CRUD operations. By contrast, REST has one dedicated
    endpoint per resource.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 和 REST 一样，GraphQL API 也是通过 HTTP 操作的。然而，GraphQL 的实现只暴露一个单一的 API 端点，通常称为 */graphql*，用于访问所有资源并执行所有
    CRUD 操作。相比之下，REST 为每个资源提供一个专门的端点。
- en: Another difference is that we connect to the GraphQL server by using POST requests
    exclusively. Rather than using HTTP methods to define a desired CRUD operation,
    we use queries and mutations in the POST request body. *Queries* are read operations,
    while *mutations* are operations for creating, updating, and deleting data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，我们只能通过 POST 请求连接到 GraphQL 服务器。与其使用 HTTP 方法来定义所需的 CRUD 操作，我们在 POST 请求体中使用查询和变更。*查询*是读取操作，而*变更*则是创建、更新和删除数据的操作。
- en: And unlike REST, which relies on standard HTTP status codes, GraphQL returns
    *500*, that is, an *Internal Server Error*, when an operation cannot be executed
    at all. Otherwise, the response uses *200* even if there are problems with the
    queries or mutations. The reason for this is that the resolver might have partially
    executed before encountering an issue. Keep this in mind when deploying a GraphQL
    API in production. Many standard operational practices and tools may need to change
    to account for this behavior.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖标准 HTTP 状态码的 REST 不同，GraphQL 在操作无法执行时会返回*500*，即*内部服务器错误*。否则，即使查询或变更存在问题，响应也会使用*200*。这是因为解析器可能在遇到问题之前已经部分执行。部署
    GraphQL API 到生产环境时，需牢记这一点。许多标准操作实践和工具可能需要调整，以适应这一行为。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Schema</samp>
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">架构</samp>
- en: A GraphQL API defines the available queries and mutations in its schema, which
    is equivalent to the REST API’s specification. Also called a *typedef*, the schema
    is written in the Schema Definition Language (SDL). SDL’s core elements are *types*,
    which are objects that contain typed *fields* defining their properties, and optional
    *directives* that add additional information, for example, to specify caching
    rules for queries or mark fields as deprecated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API 在其架构中定义了可用的查询和变更，这相当于 REST API 的规范。架构也叫做*typedef*，它是用架构定义语言（SDL）编写的。SDL
    的核心元素是*类型*，这些类型是包含有类型的*字段*的对象，字段定义了它们的属性，还有可选的*指令*，它们可以添加额外的信息，例如，指定查询的缓存规则或标记字段为废弃。
- en: '[Listing 6-2](chapter6.xhtml#Lis6-2) shows a GraphQL schema for our fictional
    weather API, which returns the weather data for a location.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-2](chapter6.xhtml#Lis6-2)展示了我们虚构的天气 API 的 GraphQL 架构，它返回某个地点的天气数据。'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-2: The GraphQL schema for the weather API'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-2：天气 API 的 GraphQL 架构
- en: You should notice that the schema is a tagged template literal, which you learned
    about in [Chapter 2](chapter2.xhtml). We begin by describing custom GraphQL object
    types. These object types represent the data that the API returns. They are similar
    to the custom types we defined in TypeScript. A type has a name and can implement
    an interface. Each of these custom object types contains fields, which have a
    name and a type. GraphQL has the built-in scalar types <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Float</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ID</samp>.
    Exclamation marks (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>) denote
    non-nullable fields, and lists within square brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>)
    indicate arrays.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，架构是一个标签模板字面量，这是你在[第 2 章](chapter2.xhtml)中学到的内容。我们首先描述自定义的 GraphQL 对象类型。这些对象类型表示
    API 返回的数据。它们类似于我们在 TypeScript 中定义的自定义类型。一个类型有一个名称，并可以实现一个接口。每个自定义对象类型包含字段，每个字段都有名称和类型。GraphQL
    有内建的标量类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Float</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">String</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ID</samp>。感叹号 (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>)
    表示不可为空的字段，而方括号 (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>) 表示数组。
- en: The first custom object type is <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationWeatherType</samp>,
    which describes the location information for a weather query. Here we use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">String!</samp> expression to mark
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ZIP</samp> field as non-nullable.
    Hence, the GraphQL service always returns a value for this field. We define a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> field as an array
    of strings to represent related weather stations by ZIP code. It is also non-nullable,
    so it will always contain an array (with zero or more items) when added to the
    return values. The <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>
    inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> array
    ensures that every item will be a string.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个自定义对象类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationWeatherType</samp>，用于描述天气查询的位置信息。这里我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">String!</samp> 表达式将 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZIP</samp>
    字段标记为非空。由此，GraphQL 服务始终会为此字段返回一个值。我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    字段定义为一个字符串数组，表示通过 ZIP 代码关联的天气站。它也是非空的，因此在添加到返回值中时，它将始终包含一个数组（零个或多个项）。<samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    数组中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp> 确保每个项都是一个字符串。
- en: Then we define the input type object for our first mutation. These types are
    necessary for mutations, and they represent the input received from the API’s
    consumer. Because consumers should be able to pass in only the fields they’d like
    to update, we omit the exclamation marks to make the fields optional. In GraphQL,
    we need to define input objects and types for the return value separately, with
    the built-in types. Unlike in TypeScript, we can’t use generic custom types.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为第一个变更定义输入类型对象。这些类型在变更中是必要的，它们代表从 API 消费者处接收到的输入。因为消费者应该仅传入他们想要更新的字段，所以我们省略了感叹号，使字段变为可选。在
    GraphQL 中，我们需要分别为返回值定义输入对象和类型，使用内建类型。与 TypeScript 不同，我们不能使用通用自定义类型。
- en: The schema also defines the query and mutation functions. These are the operations
    that consumers can send to the API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    query takes a ZIP code as a parameter and always returns an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationType</samp>
    objects. The <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> mutation
    takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationInput</samp>
    parameter and always returns the modified <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationType</samp>
    object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 模式还定义了查询和变更函数。这些是消费者可以发送到 API 的操作。<samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    查询将 ZIP 代码作为参数，并始终返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationType</samp>
    对象数组。<samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 变更函数接受一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationInput</samp> 参数，并始终返回修改后的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherLocationType</samp> 对象。
- en: Our schema doesn’t contain any directives, and we won’t go deep into their syntax
    in this chapter. However, one reason to use directives is for caching. Because
    GraphQL queries use POST, which isn’t cacheable using the default HTTP cache,
    we must implement caching manually, on the server side. We can configure caching
    statically on the type definitions with the directive <samp class="SANS_TheSansMonoCd_W5Regular_11">@cacheControl</samp>
    or dynamically, in the resolver functions, with <samp class="SANS_TheSansMonoCd_W5Regular_11">cacheControl.setCacheHint</samp>.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式中没有包含任何指令，且在本章中我们不会深入探讨它们的语法。然而，使用指令的一个原因是缓存。由于 GraphQL 查询使用 POST 方法，而默认的
    HTTP 缓存无法缓存 POST 请求，因此我们必须在服务器端手动实现缓存。我们可以通过在类型定义中静态配置指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">@cacheControl</samp>
    或在解析器函数中动态配置 <samp class="SANS_TheSansMonoCd_W5Regular_11">cacheControl.setCacheHint</samp>
    来实现缓存。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Resolvers</samp>
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析器</samp>
- en: In GraphQL, the *resolvers* are the functions that implement the schema. Each
    resolver function maps to a field. Query resolvers implement the reading of data,
    whereas mutation resolvers implement the creation, updating, and deletion of data.
    Together they provide complete CRUD functionality.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 中，*解析器*是实现模式的函数。每个解析器函数映射到一个字段。查询解析器实现数据的读取，而变更解析器实现数据的创建、更新和删除。它们共同提供完整的
    CRUD 功能。
- en: To understand how resolvers work, you can think of each GraphQL operation as
    a tree of nested function calls. In such an *abstract syntax tree (AST)*, each
    part of the operation represents a node. For example, consider a complex, nested
    GraphQL query, which asks for the location’s current weather, as well as the weather
    of all its neighbors. Our GraphQL schema for this example looks like [Listing
    6-3](chapter6.xhtml#Lis6-3).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解解析器是如何工作的，你可以将每个 GraphQL 操作看作是一个嵌套函数调用的树。在这样的*抽象语法树（AST）*中，操作的每个部分代表一个节点。例如，考虑一个复杂的嵌套
    GraphQL 查询，它请求位置的当前天气以及所有邻居的天气。我们为此示例设计的 GraphQL 架构如[清单 6-3](chapter6.xhtml#Lis6-3)所示。
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-3: The GraphQL schema for the nested GraphQL query example'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-3：嵌套 GraphQL 查询示例的 GraphQL 架构
- en: In the schema for the example, we replace the content of the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    array. Instead of a simple string, we want it to contain an object with a ZIP
    code and weather information. Therefore, we define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">FriendsType</samp>
    and use this type for the array items.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的架构中，我们替换了<samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>数组的内容。我们希望它包含一个对象，而不是一个简单的字符串，这个对象包含邮政编码和天气信息。因此，我们定义了一个新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FriendsType</samp>并使用该类型作为数组项的类型。
- en: '[Listing 6-4](chapter6.xhtml#Lis6-4) defines the complex example query.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-4](chapter6.xhtml#Lis6-4)定义了复杂的示例查询。'
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-4: The nested GraphQL query'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-4：嵌套的 GraphQL 查询
- en: This query takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>
    parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">96815</samp> and then
    returns its <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> property,
    as well as all of its friends’ <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    properties, as strings. But how does the query work under the hood?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> 参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">96815</samp>，然后返回其
    <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 属性，以及所有朋友的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 属性，作为字符串。但这个查询在幕后是如何工作的呢？
- en: '[Figure 6-1](chapter6.xhtml#fig6-1) shows the resolver chain and corresponding
    AST. The GraphQL server would first parse the query into this structure and then
    validate the AST against the type-definition schema to ensure that the query can
    be executed without running into logical problems. Finally, the server would execute
    the query.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](chapter6.xhtml#fig6-1)展示了解析器链和相应的 AST。GraphQL 服务器首先将查询解析成这种结构，然后将 AST
    与类型定义架构进行验证，以确保查询可以在不遇到逻辑问题的情况下执行。最后，服务器执行查询。'
- en: '![](../images/Figure6-1.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 6-1: Querying the GraphQL
    AST</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 6-1：查询 GraphQL AST</samp>
- en: Let’s examine the resolver chain for the query. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Query.weather</samp>
    function takes one argument, the ZIP code, and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    object for this ZIP code. Then the server continues along each branch separately.
    For the weather in the query, it returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    object, <samp class="SANS_TheSansMonoCd_W5Regular_11">Location.weather</samp>,
    at which point the branch ends. The second part of the query, which asks for all
    friends from the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    object and their <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    properties, runs the <samp class="SANS_TheSansMonoCd_W5Regular_11">Location.Friends</samp>
    query and then returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">Friends.weather</samp>
    property for each result. The resolver object of each step contains the result
    returned by the parent field’s resolver.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查这个查询的解析器链。<samp class="SANS_TheSansMonoCd_W5Regular_11">Query.weather</samp>
    函数接受一个参数，即邮政编码，并返回该邮政编码对应的 <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    对象。然后，服务器分别沿着每个分支继续执行。对于查询中的天气，它返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 属性，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">Location.weather</samp>，此时分支结束。查询的第二部分请求所有来自
    <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> 对象的朋友及其 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    属性，它执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">Location.Friends</samp> 查询，然后返回每个结果的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Friends.weather</samp> 属性。每个步骤的解析器对象包含由父字段的解析器返回的结果。
- en: Let’s return to our weather schema and define the resolvers. We’ll keep these
    simple. In [Listing 6-5](chapter6.xhtml#Lis6-5), you can see that their names
    match those defined in the schema.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的天气架构并定义解析器。我们将保持这些解析器简单。在 [清单 6-5](chapter6.xhtml#Lis6-5) 中，你可以看到它们的名称与架构中定义的名称一致。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-5: The GraphQL resolvers for the weather API'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-5：天气 API 的 GraphQL 解析器
- en: We first define async functions for the query and mutation properties and assign
    the object to the const <samp class="SANS_TheSansMonoCd_W5Regular_11">resolvers</samp>.
    Each takes two parameters. The first one represents the previous resolver object
    in the resolver chain. We aren’t using a nested or complex query; hence, here
    it is always undefined. For this reason, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type to avoid a TypeScript error and use the underscore (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>)
    convention you learned in [Chapter 3](chapter3.xhtml) to mark it as unused. The
    second parameter is an object containing the data passed to the function on invocation.
    For the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> query and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> mutation, it
    is an object that implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为查询和变更属性定义异步函数，并将对象赋值给常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">resolvers</samp>。每个函数都有两个参数。第一个参数表示解析器链中前一个解析器对象。我们没有使用嵌套或复杂的查询；因此，在这里它始终是未定义的。为此，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 类型来避免 TypeScript 错误，并使用你在
    [第 3 章](chapter3.xhtml) 中学到的下划线 (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>)
    约定将其标记为未使用。第二个参数是一个包含在调用时传递给函数的数据的对象。对于 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    查询和 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 变更，它是一个实现了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp> 的对象。
- en: For now, both functions ignore this parameter for the most part, using only
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> property to reflect
    the input. Also, they return a static JSON object similar to the REST API we created
    in the previous listings. The static data is just a placeholder, which we’ll replace
    with the result from our database queries later. The response honors the API contract
    we defined in the GraphQL schema, as this data consists of arrays with weather
    location datasets.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，两个函数大部分时间忽略这个参数，仅使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>
    属性来反映输入。此外，它们返回一个类似于我们在前面列表中创建的 REST API 的静态 JSON 对象。静态数据仅是一个占位符，稍后我们将用来自数据库查询的结果替换它。该响应遵循我们在
    GraphQL 架构中定义的 API 合同，因为这些数据是包含天气位置数据集的数组。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comparing GraphQL to REST</samp>
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">将 GraphQL 与 REST 进行比较</samp>
- en: 'We’ve already implemented RESTful APIs in our Next.js application, and as you
    saw in this chapter, REST is fairly simple to work with. You might be wondering
    why you’d even consider using GraphQL. Well, GraphQL solves two problems common
    in REST APIs: over-fetching and under-fetching.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 Next.js 应用程序中实现了 RESTful API，正如你在本章中看到的，REST 相对简单易用。你可能会想，为什么还要考虑使用 GraphQL。其实，GraphQL
    解决了 REST API 中常见的两个问题：过度获取（over-fetching）和获取不足（under-fetching）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Over-Fetching</samp>
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">过度获取（Over-Fetching）</samp>
- en: When a client queries a REST endpoint, the API always returns the complete dataset
    for that endpoint. This means that, often, the API delivers more data than necessary,
    a common performance problem called *over-fetching*. For example, our example
    RESTful weather API at */api/v2/weather/zip/96815* delivers all weather data for
    a ZIP code even if all you need is the temperature in Celsius. You’d then need
    to manually filter the results. In GraphQL, the API requests explicitly define
    the data they want returned.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端查询 REST 端点时，API 总是返回该端点的完整数据集。这意味着，通常情况下，API 返回的数据比实际需要的要多，这是一个常见的性能问题，称为
    *过度获取*。例如，我们的示例 RESTful 天气 API 在 */api/v2/weather/zip/96815* 返回该邮政编码的所有天气数据，即使你只需要摄氏温度。你还需要手动筛选结果。而在
    GraphQL 中，API 请求明确指定它们想要返回的数据。
- en: 'Let’s look at an example to see how GraphQL lets us keep the API response data
    to a minimum. The following GraphQL query returns only the temperature in Celsius
    for the location with the ZIP code 96815:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看 GraphQL 如何让我们将 API 响应数据保持在最低限度。以下 GraphQL 查询仅返回 ZIP 码为 96815 的位置的摄氏温度：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In GraphQL, we send the query as a JSON string with the POST request’s data:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 中，我们通过 POST 请求的数据将查询作为 JSON 字符串发送：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We consume the API with a POST request to the */api/graphql* endpoint, then
    set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp> header
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp> header to JSON
    to explicitly tell the API that we’re sending a JSON object in the request body
    and expect a JSON response. We set the access token in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>
    header, as in a RESTful request. The POST body contains the query for the weather
    data, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> control
    characters indicate the newlines in the GraphQL query. As defined in the contract,
    the query expects a parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>,
    for which we pass in the ZIP code <samp class="SANS_TheSansMonoCd_W5Regular_11">96815</samp>.
    In addition, we request that the API return only the <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>
    field of the weather node.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 POST 请求访问 */api/graphql* 端点，设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp> 头为 JSON，明确告知 API
    我们正在请求体中发送一个 JSON 对象，并期待 JSON 响应。我们像在 RESTful 请求中一样，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>
    头中设置访问令牌。POST 请求体包含天气数据的查询，<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    控制字符表示 GraphQL 查询中的换行符。如合同所定义，查询期望一个参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>，我们传入了邮政编码
    <samp class="SANS_TheSansMonoCd_W5Regular_11">96815</samp>。另外，我们请求 API 仅返回天气节点中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp> 字段。
- en: 'Here is the response from the GraphQL API:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是来自 GraphQL API 的响应：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The API responds with a status code of *200*. We specified in the request’s
    query that we are interested in only the requested field <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> object, so
    this is what we received. The API doesn’t return the ZIP code, temperature in
    Fahrenheit, weather string, or friends array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: API 以 *200* 状态码响应。我们在请求的查询中指定，只关心 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    对象中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp> 字段，所以这就是我们接收到的数据。API
    不返回邮政编码、华氏温度、天气字符串或朋友数组。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Under-Fetching</samp>
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">欠取数据</samp>
- en: On the other hand, a REST dataset might not contain all the data you need, requiring
    you to send follow-up requests. This problem is called *under-fetching*. Imagine
    that your friends also have weather stations and that you want to get the current
    weather at their ZIP codes. The RESTful weather API returns an array with related
    ZIP codes (<samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>). However,
    you’d need to make additional requests for each ZIP code to receive their weather
    information, potentially causing performance issues.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，REST 数据集可能不包含您所需的所有数据，这需要您发送后续请求。这种问题被称为 *欠取数据*。假设您的朋友也有气象站，您想获取他们邮政编码的当前天气。RESTful
    天气 API 返回一个包含相关邮政编码（<samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>）的数组。然而，您需要为每个邮政编码发出额外的请求，以获取他们的天气信息，这可能导致性能问题。
- en: 'GraphQL treats datasets as nodes in a graph, with relationships between them.
    Therefore, extending a single query to receive related data is pretty simple.
    Our example GraphQL server’s resolvers are set up to fetch additional data about
    friends if the request’s query contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    field. We define the GraphQL query as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 将数据集视为图中的节点，并且它们之间存在关系。因此，扩展单一查询以接收相关数据非常简单。我们的示例 GraphQL 服务器的解析器已设置好，如果请求的查询包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> 字段，则会获取关于朋友的额外数据。我们定义
    GraphQL 查询如下：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following shows an example request that fetches all related nodes through
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> array. Again,
    we define the return data and query the friends only for the field <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例请求，展示如何通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    数组获取所有相关节点。再次地，我们定义返回数据并仅查询 <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>
    字段：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The POST body contains the query for weather data pertaining to the 96815 ZIP
    code in one line and asks for the <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>
    field, as in the previous request. To extend the query, we add a sub-selection
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> field. Now
    GraphQL traverses the related nodes and their fields and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>
    field of the nodes whose ZIP codes match the ones in the 96815 node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    array.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: POST 请求体包含了针对 96815 邮政编码的天气数据查询，要求返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>
    字段，和之前的请求一样。为了扩展查询，我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    字段上添加了一个子选择。现在，GraphQL 会遍历相关节点及其字段，并返回与 96815 节点的 <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    数组中的邮政编码匹配的节点的 <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp> 字段。
- en: 'Here is the response from the GraphQL server. We see that it contains data
    from the related nodes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 GraphQL 服务器的响应。我们看到它包含了相关节点的数据：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you’ve discovered, GraphQL lets us easily extend queries by adjusting the
    data in the request.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经发现的，GraphQL 让我们通过调整请求中的数据轻松扩展查询。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 6: Add a GraphQL API to Next.js</samp>'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 6：将 GraphQL API 添加到 Next.js</samp>
- en: Let’s rework our weather application’s API to use GraphQL. To do so, we must
    first add GraphQL to the project. GraphQL isn’t a pattern but an environment that
    consists of a server and a query language, both of which we must add to Next.js.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新设计天气应用程序的 API 来使用 GraphQL。为此，我们必须首先将 GraphQL 添加到项目中。GraphQL 不是一种模式，而是一个由服务器和查询语言组成的环境，我们必须将它们都添加到
    Next.js 中。
- en: 'We’ll install the stand-alone Apollo server, one of the most popular GraphQL
    servers, which also provides a Next.js integration. Open your terminal and navigate
    to the refactored application you built in [Chapter 5](chapter5.xhtml). In the
    directory’s top level, next to the *package.json* file, execute this command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装独立的 Apollo 服务器，它是最流行的 GraphQL 服务器之一，也提供了 Next.js 的集成。打开终端并导航到你在 [第 5 章](chapter5.xhtml)
    中构建的重构应用程序。在目录的顶层，靠近 *package.json* 文件，执行以下命令：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command also installs the GraphQL language and the GraphQL tag modules
    we’ll need.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令还会安装我们所需的 GraphQL 语言和 GraphQL 标签模块。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Schema</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建 Schema</samp>
- en: As we discussed, every GraphQL API starts with a schema definition. Create a
    folder called *graphql* next to the *pages* folder in the Next.js directory. This
    is where we’ll add all GraphQL-related files.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，每个 GraphQL API 都是从 schema 定义开始的。在 Next.js 目录中创建一个名为 *graphql* 的文件夹，紧挨着
    *pages* 文件夹。这将是我们添加所有 GraphQL 相关文件的地方。
- en: 'Now create a file called *schema.ts* and paste the code you wrote back in [Listing
    6-2](chapter6.xhtml#Lis6-2). We’ve already defined and discussed the type definition
    used here. Simply add one line to the top of the file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为 *schema.ts* 的文件，并粘贴你在 [清单 6-2](chapter6.xhtml#Lis6-2) 中写的代码。我们已经定义并讨论了这里使用的类型定义。只需在文件顶部添加一行：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This line imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">qql</samp>
    tagged template literal we use to define the schema.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行导入了我们用来定义 schema 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">qql</samp>
    标记模板字面量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Data</samp>
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加数据</samp>
- en: We want our API to return different data depending on the parameters and properties
    of the queries sent to it. Therefore, we need to add datasets to our project.
    GraphQL can query any database, even static JSON data. So let’s implement a JSON
    dataset. Create the file *data.ts* inside the *graphql* directory and add the
    code from [Listing 6-6](chapter6.xhtml#Lis6-6).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的 API 根据传递给它的查询的参数和属性返回不同的数据。因此，我们需要将数据集添加到项目中。GraphQL 可以查询任何数据库，甚至是静态的
    JSON 数据。所以让我们实现一个 JSON 数据集。在 *graphql* 目录中创建 *data.ts* 文件，并添加来自 [清单 6-6](chapter6.xhtml#Lis6-6)
    的代码。
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 6-6: The graphql/data.ts file for the GraphQL API'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-6：用于 GraphQL API 的 graphql/data.ts 文件
- en: This JSON defines three weather locations and their properties. A consumer will
    be able to query our API for these datasets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JSON 定义了三个天气位置及其属性。消费者将能够查询我们的 API 获取这些数据集。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Resolvers</samp>
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实现解析器</samp>
- en: Now we can define our resolvers. Add the file *resolvers.ts* to the *graphql*
    directory and paste in the code from [Listing 6-7](chapter6.xhtml#Lis6-7). This
    is similar to the code we previously discussed when we introduced resolvers, but
    instead of returning the same static JSON object to the consumer, we query our
    new dataset.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义解析器了。将文件 *resolvers.ts* 添加到 *graphql* 目录中，并粘贴[Listing 6-7](chapter6.xhtml#Lis6-7)中的代码。这与我们之前讨论的代码类似，当时我们介绍了解析器，但是这次我们查询的是我们新的数据集，而不是返回相同的静态
    JSON 对象给消费者。
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 6-7: The graphql/resolvers.ts file for the GraphQL API'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-7: GraphQL API 的 graphql/resolvers.ts 文件'
- en: 'We import the array of JSON objects we created earlier and define an interface
    for the resolvers. The query resolver finds an object by using the ZIP code passed
    to it and returns it to the Apollo server. The mutation does the same, except
    that the parameter structure is slightly different: it is accessible through the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> property. Alas, we can’t
    actually change the data by using the mutation, as the data is a static JSON file.
    We’ve implemented the mutation here for illustration purposes only.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入之前创建的 JSON 对象数组，并为解析器定义接口。查询解析器通过使用传入的邮政编码查找对象，并将其返回给 Apollo 服务器。突变（mutation）执行相同的操作，只是参数结构稍有不同：它可以通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">data</samp>属性访问。不幸的是，我们实际上无法通过使用突变来更改数据，因为数据是静态的
    JSON 文件。我们在这里实现突变只是为了说明问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the API
    Route</samp>
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建 API 路由</samp>
- en: The Apollo GraphQL server exposes one endpoint, *graphql/*, which we’ll implement
    now. Create a new file, *graphql.ts*, in the *api* folder and add the code from
    [Listing 6-8](chapter6.xhtml#Lis6-8). This code initializes the GraphQL server
    and adds a CORS header so that we can access the API from different domains and
    use the built-in GraphQL sandbox explorer to play with GraphQL later. You saw
    this header in the previous cURL responses.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo GraphQL 服务器暴露一个端点，*graphql/*，我们现在将实现它。创建一个新的文件，*graphql.ts*，并将[Listing
    6-8](chapter6.xhtml#Lis6-8)中的代码添加到 *api* 文件夹中。此代码初始化 GraphQL 服务器，并添加 CORS 头，以便我们可以从不同的域访问
    API，并稍后使用内置的 GraphQL 沙盒浏览器来玩转 GraphQL。你在之前的 cURL 响应中看到过这个头部。
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 6-8: The api/graphql.ts file, which creates the API entry point for
    GraphQL'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-8: 创建 GraphQL 的 API 入口点的 api/graphql.ts 文件'
- en: This code is all we need to create the GraphQL entry point. First we import
    the necessary modules, including our GraphQL schema and the resolvers, both of
    which we created previously. Then we initialize a new GraphQL server with typedefs
    and resolvers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码就是我们创建 GraphQL 入口点所需的全部内容。首先，我们导入必要的模块，包括我们之前创建的 GraphQL schema 和解析器。然后，我们使用
    typedefs 和 resolvers 初始化一个新的 GraphQL 服务器。
- en: We start the server and continue by creating the API handler. To do this, we
    use the Next.js integration helper to start the server and return the Next.js
    handler. The integration helper connects the serverless Apollo instance to the
    Next.js custom server. Before we define the default export as an async function
    that takes the API’s request and response objects as parameters, we create a wrapper
    to add the CORS headers to the request. The first block inside the function sets
    up the CORS headers, and we limit the allowed request to POST requests. We need
    the CORS headers here to make our GraphQL API publicly available. Otherwise, we
    wouldn’t be able to connect to the API from a website running on a different domain
    or even use the server’s built-in GraphQL sandbox.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动服务器并继续创建 API 处理程序。为此，我们使用 Next.js 集成助手来启动服务器并返回 Next.js 处理程序。集成助手将无服务器 Apollo
    实例连接到 Next.js 自定义服务器。在我们将默认导出定义为一个异步函数（该函数以 API 的请求和响应对象作为参数）之前，我们创建了一个包装器，将 CORS
    头部添加到请求中。函数中的第一块代码设置了 CORS 头部，并且我们将允许的请求限制为 POST 请求。我们在这里需要 CORS 头部，以使我们的 GraphQL
    API 对外公开。否则，我们将无法从运行在不同域上的网站连接到 API，甚至无法使用服务器内置的 GraphQL 沙盒。
- en: Part of the CORS setup here is that we immediately return *200* for any OPTIONS
    requests. The CORS patterns use OPTIONS requests as preflight checks. Here the
    browser requests only headers, and then checks the response’s CORS headers to
    verify that the domain from which it calls the API is allowed to access the resource
    before making the actual request.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 设置的一部分是在这里我们立即对任何 OPTIONS 请求返回 *200*。CORS 模式使用 OPTIONS 请求作为预检检查。在这里，浏览器仅请求头部，然后检查响应的
    CORS 头部，以验证从哪个域调用 API 是否被允许访问资源，然后再发起实际请求。
- en: 'However, our Apollo server allows only POST and GET requests and would return
    *405: Method Not Allowed* for the preflight OPTIONS request. So, instead of passing
    this request to the Apollo server, we end the request and return *200* with the
    previous CORS headers. The browser should then proceed with the CORS pattern.
    Finally, we start the server and create the API handler on the desired path, *api/graphql*.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，我们的 Apollo 服务器只允许 POST 和 GET 请求，并且会对预检的 OPTIONS 请求返回 *405: 方法不允许*。因此，我们不会将此请求传递给
    Apollo 服务器，而是结束该请求并返回 *200* 及之前的 CORS 头信息。浏览器应继续按照 CORS 模式处理。最后，我们启动服务器并在所需路径
    *api/graphql* 上创建 API 处理程序。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Apollo
    Sandbox</samp>
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 Apollo 沙盒</samp>
- en: Start your Next.js server with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp>. You should see the Next.js application running on *http://localhost:3000*.
    If you navigate to the GraphQL API at *http://localhost:3000/api/graphql*, you’ll
    find the Apollo sandbox interface for querying the API, as in [Figure 6-2](chapter6.xhtml#fig6-2).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> 启动你的 Next.js
    服务器。你应该能看到 Next.js 应用程序正在 *http://localhost:3000* 上运行。如果你导航到 GraphQL API 地址 *http://localhost:3000/api/graphql*，你将看到
    Apollo 沙盒接口，供查询 API，如 [图 6-2](chapter6.xhtml#fig6-2) 所示。
- en: '![](../images/Figure6-2.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 6-2: The Apollo sandbox’s
    API querying interface</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 6-2：Apollo 沙盒的 API 查询界面</samp>
- en: In the Documentation pane on the left side, we see the available queries as
    fields of the query object we defined earlier. As expected, we see the <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>
    query here, and when we click it, a new query appears in the Operation pane in
    the middle. At the same time, the interface changes, and we see the available
    arguments and fields. Clicking each provides more information. Using the plus
    (+) button, we can add fields to the Query pane and run them against the data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧的文档面板中，我们看到可用的查询作为我们之前定义的查询对象的字段。如预期所示，我们在这里看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>
    查询，点击它后，新的查询会出现在中间的操作面板中。同时，界面发生变化，我们可以看到可用的参数和字段，点击每个字段可以查看更多信息。使用加号 (+) 按钮，我们可以向查询面板添加字段并将其应用于数据。
- en: Try creating a <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>
    query that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> properties. This
    query requires a ZIP code as an argument; add it through the user interface on
    the left-hand side, and then add the ZIP code 96826 as a string to the JSON object
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">variables</samp> section
    of the lower pane. Now run the query by clicking the **Weather** button at the
    top of the Operation pane. You should receive the result for this ZIP code in
    the Response pane on the right as JSON. Compare your screen with [Figure 6-3](chapter6.xhtml#fig6-3).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    属性的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp> 查询。此查询需要一个邮政编码作为参数；通过左侧的用户界面添加该参数，然后将邮政编码
    96826 作为字符串添加到下方面板的 <samp class="SANS_TheSansMonoCd_W5Regular_11">variables</samp>
    部分中的 JSON 对象。现在点击操作面板顶部的 **Weather** 按钮来运行查询。你应该会在右侧的响应面板中看到该邮政编码的 JSON 结果。将你的屏幕与
    [图 6-3](chapter6.xhtml#fig6-3) 进行比较。
- en: '![](../images/Figure6-3.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 6-3: The GraphQL query
    and response from the server</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 6-3：从服务器返回的 GraphQL 查询和响应</samp>
- en: Play around with crafting queries, accessing properties, and creating errors
    with invalid arguments to get a feel for GraphQL before moving on to the next
    chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建查询、访问属性，并通过无效的参数创建错误，熟悉一下 GraphQL，然后再进入下一章。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter explored RESTful and GraphQL web APIs and their role in full-stack
    development. Although we used a REST design in previous chapters, you should now
    be familiar with the concept of stateless servers, as well as the five HTTP methods
    for performing CRUD operations in REST. You also practiced working with a public
    REST API to read and update data, then evaluated its requests and responses.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了RESTful和GraphQL Web API及其在全栈开发中的作用。虽然在前几章中我们使用了REST设计，但你现在应该已经熟悉了无状态服务器的概念，以及在REST中执行CRUD操作的五种HTTP方法。你还练习了使用公共REST
    API读取和更新数据，并评估其请求和响应。
- en: GraphQL APIs require a bit more work to implement, but they reduce the over-fetching
    and under-fetching issues often experienced in REST. You learned to define the
    API contract with a schema and implement its functionality with resolvers. Then
    you queried an API and defined the dataset to return in the request.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API的实现需要更多的工作，但它们减少了REST中常见的过度抓取和抓取不足的问题。你学习了如何通过架构定义API契约，并通过解析器实现其功能。然后，你查询了一个API并定义了请求中返回的数据集。
- en: Finally, you added a GraphQL API to your existing Next.js application by adding
    the Apollo server to it. You should now be able to create your own GraphQL API
    and consume third-party resources. To learn more about GraphQL, I recommend the
    tutorials at [*https://<wbr>www<wbr>.howtographql<wbr>.com*](https://www.howtographql.com)
    and the official GraphQL introduction at [*https://<wbr>graphql<wbr>.org<wbr>/learn<wbr>/*](https://graphql.org/learn/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你通过将Apollo服务器添加到现有的Next.js应用程序中，添加了一个GraphQL API。你现在应该能够创建自己的GraphQL API并消费第三方资源。想要了解更多关于GraphQL的信息，我推荐[*https://<wbr>www<wbr>.howtographql<wbr>.com*](https://www.howtographql.com)上的教程，以及[*https://<wbr>graphql<wbr>.org<wbr>/learn<wbr>/*](https://graphql.org/learn/)上的官方GraphQL介绍。
- en: In the next chapter, you’ll explore the MongoDB database and Mongoose, an object
    data modeling library, for storing data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索MongoDB数据库和用于存储数据的对象数据建模库Mongoose。
