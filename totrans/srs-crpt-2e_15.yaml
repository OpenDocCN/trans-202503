- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DIFFIE–HELLMAN</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: In November 1976, Stanford researchers Whitfield Diffie and Martin Hellman published
    a research paper titled “New Directions in Cryptography” that revolutionized cryptography
    forever. Their paper introduced the notion of public-key encryption and signatures,
    though they didn’t actually have any of those schemes; they simply had what they
    termed a *public-key cryptosystem*, a protocol that allows two parties to establish
    a shared secret by exchanging information visible to an eavesdropper. This is
    now known as the *Diffie–Hellman (DH) protocol*. Prior to Diffie–Hellman, establishing
    a shared secret required tedious procedures such as manually exchanging sealed
    envelopes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Once communicating parties establish a shared secret value with the DH protocol,
    they can use that secret to establish a *secure channel* by turning the secret
    into one or more symmetric keys that they then use to encrypt and authenticate
    subsequent communication. The DH protocol and its variants are therefore called
    *key agreement* protocols.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of this chapter, you’ll read about the mathematical foundations
    of the Diffie–Hellman protocol, including the computational problems that DH relies
    on to perform its magic. Then you’ll learn about different versions of the Diffie–Hellman
    protocol you can use to create secure channels. Finally, because Diffie–Hellman
    schemes are secure only when their parameters are well chosen, you’ll see scenarios
    where Diffie–Hellman can fail.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Diffie and Hellman received the prestigious Turing Award in 2015 for their
    invention of public-key cryptography and digital signatures, but others deserve
    credit as well. In 1974, while a computer science undergraduate, Ralph Merkle
    introduced the idea of public-key cryptography with* Merkle’s puzzles*. Around
    that same time, researchers at the British Government Communications Headquarters
    (GCHQ), the British equivalent of the NSA, discovered the principles behind Rivest–Shamir–Adleman
    (RSA) and Diffie–Hellman key agreement, though that fact was declassified only
    decades later.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Diffie–Hellman Function</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand DH key agreement protocols, you must understand their core operation,
    the *DH function*. Diffie and Hellman originally defined the DH function to work
    with groups denoted **Z**p^*, which consist of nonzero integer numbers modulo
    a prime number, which is usually denoted *p* (see [Chapter 9](chapter9.xhtml)).
    Another public parameter is the base number, or *generator*, *g*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The DH function involves two private values chosen randomly by the two communicating
    parties from the group **Z**p^*, which we’ll write *a* and *b*. A private value
    *a* is associated with the public value *A* = *g**^a* mod *p*, or *g* raised to
    the power *a* modulo *p*. This *A* is sent to the other party through a message
    visible to eavesdroppers. The public value associated with *b* is *B* = *g**^b*
    mod *p*, which is sent to the owner of *a*. An attacker can thus learn *A* and
    *B*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'DH works by combining either public value with the other private value, such
    that the result is the same in both cases: *A**^b* = (*g**^a*)*^b* = *g**^(ab)*
    and *B* *^a* = (*g**^b*)*^a* = *g**^(ba)* = *g**^(ab)*. The resulting value, *g**^(ab)*,
    is the *shared secret*; you then pass it to a *key derivation function (KDF)*
    to generate one or more shared symmetric keys. A KDF is a kind of hash function
    that returns a random-looking string the size of the desired key length.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it. Like many great scientific discoveries (gravity, relativity,
    quantum computing, or RSA), the Diffie–Hellman trick is relatively simple in hindsight.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Diffie–Hellman’s simplicity can be deceiving, however. For one, it won’t work
    with just any prime *p* or base number *g*. Some values of *g* restrict the shared
    secrets *g**^(ab)* to a small subset of possible values, whereas you’d expect
    to have about as many possible values as elements in **Z**p^* and therefore as
    many possible values for the shared secret. To ensure the highest security, safe
    DH parameters should work with a prime *p* such that (*p* – 1)/2 is also prime.
    Such a *safe prime* guarantees that the group doesn’t have small subgroups that
    would make DH easier to break. With a safe prime, DH can work with any element
    in **Z**p^*, excepting 1 and *p* – 1; notably, *g* = 2 makes computations slightly
    faster. But generating a safe prime *p* takes more time than generating a totally
    random one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dhparam</samp>
    command of the OpenSSL toolkit generates only safe DH parameters, but the extra
    checks built into the algorithm result increase the execution time considerably,
    as [Listing 11-1](chapter11.xhtml#Lis11-1) shows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Measuring the
    execution time of generating 2,048-bit Diffie–Hellman parameters with the OpenSSL
    toolkit</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: It took around eight seconds to generate the DH parameters using the OpenSSL
    toolkit (it’s common to observe generation times in the order of 30 seconds or
    even more than 1 minute).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of comparison, [Listing 11-2](chapter11.xhtml#Lis11-2) shows how
    long it takes on the same system to generate RSA parameters of the same size (that
    is, two prime numbers, *p* and *q*, each half the size of the *p* used for DH).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: Generating 2,048-bit
    RSA parameters while measuring the execution time</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating DH parameters took about 50 times longer than generating RSA parameters
    of the same security level, mainly due to the extra constraint imposed on the
    prime generated to create DH parameters.  ### <samp class="SANS_Futura_Std_Bold_B_11">The
    Diffie–Hellman Problems</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The security of DH protocols relies on the hardness of computational problems,
    especially on that of the discrete logarithm problem (DLP) from [Chapter 9](chapter9.xhtml).
    You can break DH by recovering the private value *a* from its public value *g**^a*,
    which boils down to solving a DLP instance. But we don’t care about just the discrete
    logarithm problem when using DH to compute shared secrets. We also care about
    two DH-specific problems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Computational
    Problem</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *computational Diffie–Hellman (CDH)* problem is that of computing the shared
    secret *g* *^(ab)* given only the public values *g* *^a* and *g* *^b*, without
    knowing the secret values *a* and *b*. The motivation is to ensure that even if
    an eavesdropper captures *g* *^a* and *g* *^b*, they shouldn’t be able to determine
    the shared secret *g* *^(ab)*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If you can solve DLP, then you can also solve CDH; that is, if you determine
    *a* and *b* given *g* *^a* and *g* *^b*, then you’ll be able to compute *g* *^(ab)*.
    In other words, DLP is *at least* as hard as CDH. But you don’t know for sure
    whether CDH is at least as hard as DLP, which would make the problems equally
    hard. In other words, DLP is to CDH what the factoring problem is to the RSA problem.
    (Recall that factoring allows you to solve the RSA problem but not necessarily
    the converse.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Diffie–Hellman shares another similarity with RSA in that DH delivers a similar
    security level as RSA for a given modulus size. For example, the DH protocol with
    a 2,048-bit prime *p* offers roughly 90-bit security, as RSA with a 2,048-bit
    modulus. Indeed, the fastest way to break CDH is to solve DLP using the *number
    field sieve* algorithm, a method similar but not identical to the general number
    field sieve (GNFS), which breaks RSA by factoring its modulus.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Decisional Problem</samp>
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you need a seemingly stronger assumption than CDH’s hardness, enter the
    *decisional Diffie–Hellman (DDH)* problem. Given *g* *^a*, *g* *^b*, and a value
    that’s either *g* *^(ab)* or *g* *^c* for some random *c* (each of the two with
    a chance of 1/2), the DDH problem consists of determining whether *g* *^(ab)*
    (the shared secret corresponding to *g* *^a* and *g* *^b*) was chosen.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Relying on DDH rather than CDH is relevant in the following case: imagine that
    an attacker can compute only the first 32 bits of *g* *^(ab)* given the 2,048-bit
    values of *g* *^a* and *g* *^b*. Although CDH remains unbroken because 32 bits
    may not be enough to completely recover *g* *^(ab)*, the attacker would’ve learned
    something about the shared secret, which might allow them to compromise an application’s
    security.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that an attacker can’t learn anything about the shared secret *g*
    *^(ab)*, this value needs to be *indistinguishable* from a random group element,
    just as an encryption scheme is secure when ciphertexts are indistinguishable
    from random strings. That is, an attacker shouldn’t be able to determine whether
    a given number is *g* *^(ab)* or *g**^c* for some random *c*, given *g**^a*, *g**^b*.
    The *decisional Diffie–Hellman assumption* assumes that no attacker can solve
    DDH efficiently.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'If DDH is hard, then so is CDH, and you can’t learn anything about *g* *^(ab)*.
    So if you can solve CDH, you can also solve DDH: given a triplet (*g* *^a*, *g*
    *^b*, *x*), you’d be able to derive *g* *^(ab)* from *g**^a* and *g* *^b* and
    check whether the result is equal to the given *x*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that DDH is fundamentally less hard than CDH (notably, DDH
    is not hard over **Z**p^*, contrarily to CDH), yet DDH hardness is a prime assumption
    in cryptography and one of the most studied.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variants of Diffie–Hellman</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes cryptographers devise new schemes and prove that they’re at least
    as hard to break as it is to solve some hard problem. But such hard problems are
    not always CDH or DDH but instead can be variants of them. We’d like to be able
    to demonstrate that breaking a cryptosystem is as hard as solving CDH or DDH,
    but this isn’t always possible with advanced cryptographic mechanisms, typically
    because such schemes involve more complex operations than basic Diffie–Hellman
    protocols.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: For example, in one DH-like problem, given *g**^a*, an attacker attempts to
    compute *g*^(1/)*^a*, where 1/*a* is the inverse of *a* in the group (typically
    **Z**p^* for some prime *p*). In another, an attacker might distinguish the pairs
    (*g**^a*, *g**^b*) from the pairs (*g**^a*, *g*^(1/)*^a*) for random *a* and *b*.
    Finally, in the *twin Diffie–Hellman problem*, given *g**^a*, *g**^b*, and *g**^c*,
    an attacker attempts to compute the two values *g**^(ab)* and *g**^(ac)*. Sometimes
    such DH variants turn out to be as hard as CDH or DDH, and sometimes they’re fundamentally
    easier—and therefore provide lower security guarantees. As an exercise, try to
    find connections between the hardness of these problems and that of CDH and DDH.
    (Twin Diffie–Hellman is actually *as hard* as CDH, but that isn’t easy to prove!)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Key Agreement Protocols</samp>
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Diffie–Hellman problem is designed to build secure key agreement protocols,
    which secure communication between two or more parties communicating over a network
    with the aid of a shared secret. The parties turn this secret into one or more
    *session keys*—symmetric keys that encrypt and authenticate the information exchanged
    for the duration of the session.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Before studying actual DH protocols, you should know what makes a key agreement
    protocol secure and how simpler protocols work. We’ll begin our discussion with
    a prevalent key agreement protocol that doesn’t rely on DH.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Non-DH Key Agreement</samp>
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To provide a sense of how a key agreement protocol works and what it means
    for it to be secure, let’s look at the protocol the 4G and 5G telecommunications
    standards use to establish communication between a SIM card and a telecom operator:
    *authenticated key agreement (AKA)*. It doesn’t use the Diffie–Hellman function
    but instead uses only symmetric-key operations. [Figure 11-1](chapter11.xhtml#fig11-1)
    details how the protocol works.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig11-1.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: The AKA protocol
    in 4G and 5G telecommunication</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: In this description of the protocol, the SIM card has a secret key, *K*, that
    the operator knows. The operator begins the session by selecting a random value,
    *R*, and then computes two values, *SK* and *V*[1], based on two pseudorandom
    functions, **PRF**0 and **PRF**1\. Next, the operator sends a message to the SIM
    card containing the values *R* and *V*[1], which are visible to attackers. Once
    the SIM card has *R*, it has what it needs to compute *SK* with **PRF**0, and
    it does. The two parties in this session end up with a shared key, *SK*, that
    attackers are unable to determine by simply looking at the messages exchanged
    between the parties, or even by modifying them or injecting new ones. The SIM
    card verifies that it’s talking to the operator by recomputing *V*[1] with **PRF**1,
    *K*, and *R*, and then checking to make sure that the calculated *V*[1] matches
    the *V*[1] sent by the operator. The SIM card then computes a verification value,
    *V*[2], with a new function, **PRF**2, with *K* and *R* as input, and sends *V*[2]
    to the operator. The operator verifies that the SIM card knows *K* by computing
    *V*[2] and checking that the computed value matches the received *V*[2].
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In the protocol as I described it, there’s a way to fool the SIM card with a
    replay attack. Essentially, if an attacker captures a pair (*R*, *V*[1]), they
    may send it to the SIM card and trick the SIM into believing that the pair came
    from a legitimate operator that knows *K*. To prevent this attack, the protocol
    includes additional checks to ensure the same *R* isn’t reused.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Problems arise if *K* is compromised. For example, an attacker who compromises
    *K* can perform a man-in-the-middle attack and listen to all cleartext communication.
    Such an attacker could send messages between the two parties while pretending
    to be both the legitimate SIM card operator and the SIM card. Even if *K* isn’t
    compromised at the time of a given communication, an attacker can record communications
    and any messages exchanged during the key agreement and later decrypt those communications
    by using the captured *R* values if they find *K*. An attacker could then determine
    the past session keys and use them to decrypt the recorded traffic—in that case,
    the protocol doesn’t offer *forward secrecy*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*K*被泄露，就会出现问题。例如，一个泄露了*K*的攻击者可以进行中间人攻击，监听所有明文通信。这样的攻击者可能在两个方之间发送消息，同时冒充合法的SIM卡运营商和SIM卡。即使*K*在某次通信时并没有被泄露，攻击者也可以记录通信和密钥协议期间交换的任何消息，并在找到*K*时使用捕获的*R*值解密这些通信。攻击者可以通过此方式确定过去的会话密钥，并用它们解密已录制的流量——在这种情况下，协议没有提供*前向保密性*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Attack Models for
    Key Agreement Protocols</samp>
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">密钥协议的攻击模型</samp>
- en: There is no single definition of security for key agreement protocols, and a
    key protocol is never completely secure without context and without considering
    the attack model and the security goals. You can, for example, argue that the
    previous 4G/5G protocol is secure because a passive attacker won’t find the session
    keys, but it’s also insecure because once the key *K* leaks, this compromises
    all previous and future communications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥协议没有单一的安全定义，且没有考虑攻击模型和安全目标的上下文情况下，任何密钥协议都不可能完全安全。例如，你可以认为之前的4G/5G协议是安全的，因为被动攻击者无法找到会话密钥，但它也不安全，因为一旦密钥*K*泄露，这会危及所有之前和之后的通信。
- en: 'There are different notions of security in key agreement protocols as well
    as three main attack models that depend on the information the protocol leaks.
    From weakest to strongest, these are the *network attacker*, the *data leak*,
    and the *breach*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥协议中有不同的安全概念，以及三个主要的攻击模型，这些模型取决于协议泄露的信息。从最弱到最强，这些模型是*网络攻击者*、*数据泄漏*和*突破*：
- en: '**The network attacker **This attacker observes the messages exchanged between
    the two legitimate parties running a key agreement protocol and can record, modify,
    drop, or inject messages. To protect against such an attacker, a key agreement
    protocol must not leak any information on the established shared secret.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络攻击者** 该攻击者观察两个合法方之间交换的消息，并且可以记录、修改、丢弃或注入消息。为了防范此类攻击者，密钥协议必须确保不会泄漏任何关于已建立共享秘密的信息。'
- en: '**The data leak **In this model, the attacker acquires the session key and
    all *temporary* secrets (such as *SK* in the telecom protocol example) from one
    or more executions of the protocol, but not the long-term secrets (like *K* in
    that same protocol).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据泄漏** 在这个模型中，攻击者通过一次或多次协议执行获得会话密钥和所有*临时*秘密（例如电信协议示例中的*SK*），但不会获得长期秘密（如该协议中的*K*）。'
- en: '**The breach (or corruption) **In this model, the attacker learns the long-term
    key of one or more of the parties. Once a breach occurs, security is no longer
    attainable because the attacker can impersonate one or both parties in subsequent
    sessions of the protocol, as it’s the only piece of information that identifies
    a party (at least in theory, since in practice mechanisms such as IP whitelisting
    can reduce the risk of impersonation). Nonetheless, the attacker shouldn’t be
    able to recover secrets from sessions executed before gathering the key.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**突破（或篡改）** 在这个模型中，攻击者获知一个或多个方的长期密钥。一旦发生突破，安全性就无法再保证，因为攻击者可以在后续的协议会话中冒充其中一个或两个方，因为这是唯一可以标识一个方的信息（至少在理论上如此，因为在实践中像IP白名单这样的机制可以降低冒充的风险）。尽管如此，攻击者不应该能够从发生在获取密钥之前的会话中恢复秘密。'
- en: 'Now that we’ve looked at the attack models and seen what an attacker can do,
    let’s explore the security goals—that is, the security guarantees that the protocol
    should offer. You can design a key agreement protocol to satisfy several security
    goals. The four most relevant ones are described here, from simplest to most sophisticated:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了攻击模型并看到了攻击者可能采取的行动，让我们来探讨一下安全目标——即协议应该提供的安全保障。你可以设计一个密钥协议来满足多个安全目标。这里描述了四个最相关的目标，按从简单到复杂的顺序排列：
- en: '**Authentication **The protocol should allow for *mutual authentication*, wherein
    each party can authenticate the other party. AKA occurs when a protocol authenticates
    both parties.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证** 协议应该允许*互相认证*，即每一方都能认证另一方。AKA是指协议认证双方。'
- en: '**Key control **Neither party should be able to choose the final shared secret
    or coerce it to be in a specific subset. The previously discussed 4G/5G key agreement
    protocol lacks this property because the operator chooses the value for *R* that
    entirely determines the final shared key.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥控制** 任何一方都不应能够选择最终的共享密钥或强迫其属于特定子集。前面讨论过的4G/5G密钥协商协议缺乏这一特性，因为运营商选择了完全决定最终共享密钥的*R*值。'
- en: '**Forward secrecy  **Even if all long-term secrets are exposed, an attacker
    should be unable to compute shared secrets from previous executions of the protocol,
    even if they record all previous executions or can inject or modify messages from
    previous executions. A *forward-secret*, or *forward-secure*, protocol guarantees
    that even if you have to deliver your devices and their secrets to some authority,
    they won’t be able to decrypt your prior encrypted communications. (The 4G/5G
    key agreement protocol doesn’t provide forward secrecy.)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**前向保密性** 即使所有长期密钥都被泄露，攻击者也应该无法从协议的先前执行中计算出共享密钥，即使他们记录了所有先前的执行或能够注入或修改先前执行中的消息。*前向保密*，或称为*前向安全*协议，保证即使你必须将设备及其密钥交给某个机构，他们也无法解密你之前加密的通讯。（4G/5G密钥协商协议不提供前向保密性。）'
- en: '**Resistance to key-compromise impersonation (KCI) **KCI occurs when an attacker
    compromises a party’s long-term key and can use it to impersonate another party.
    For example, the 4G/5G key agreement protocol allows trivial key-compromise impersonation
    because both parties share the same key *K*. A key agreement protocol ideally
    prevents this kind of attack.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**抵抗密钥泄露冒充（KCI）** KCI发生在攻击者泄露某一方的长期密钥，并利用该密钥冒充另一方。例如，4G/5G密钥协商协议允许轻易的密钥泄露冒充，因为双方共享相同的密钥*K*。理想的密钥协商协议应该防止这种攻击。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performance</samp>
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">性能</samp>
- en: To be useful, a key agreement protocol should be efficient as well as secure.
    You should take several factors into account when considering a key agreement
    protocol’s efficiency, including the number of messages exchanged, their length,
    the computational effort to implement the protocol, and whether precomputations
    can be made to save time. A protocol is generally more efficient when exchanging
    fewer, shorter messages, and it’s best if interactivity is kept minimal so that
    neither party has to wait to receive a message before sending the next one. You
    can typically measure a protocol’s efficiency through its duration in terms of
    *round trips*, or the time it takes to send a message and receive a response.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有用，密钥协商协议应该既高效又安全。在考虑一个密钥协商协议的效率时，你应该考虑多个因素，包括交换的消息数量、消息的长度、实现协议的计算工作量以及是否可以进行预计算以节省时间。协议通常在交换较少、较短的消息时更高效，如果能够最小化交互性，使得双方无需等待收到消息再发送下一个消息，那是最理想的。你通常可以通过协议的持续时间来衡量其效率，以*往返时间*为标准，即发送消息并接收响应所需的时间。
- en: Round-trip time is usually the main cause of latency in protocols, but the amount
    of computation to be carried out by the parties also counts; the fewer required
    computations, and the more precomputations that can be done in advance, the better.
    For example, the 4G/5G key agreement protocol exchanges two messages of a few
    hundred bits each, which must be sent in a certain order. You can use precomputation
    with this protocol to save time since the operator can pick many values of *R*
    in advance; precompute the matching values of *SK*, *V*[1], and *V*[2]; and store
    them all in a database. In this case, precomputation has the advantage of reducing
    the exposure of the long-term key.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 往返时间通常是协议延迟的主要原因，但双方需要执行的计算量也很重要；所需计算越少，能进行的预计算越多，效果越好。例如，4G/5G密钥协商协议交换两条每条几百比特的消息，且必须按照特定顺序发送。你可以使用预计算来节省时间，因为运营商可以提前选择多个*R*值；预计算与*SK*、*V*[1]、*V*[2]的匹配值，并将它们都存储在数据库中。在这种情况下，预计算的优点是减少了长期密钥的暴露。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Diffie–Hellman Protocols</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">Diffie–Hellman 协议</samp>'
- en: The Diffie–Hellman function is the core of most of the deployed public-key agreement
    protocols—for example, in TLS and SSH. However, there is no single Diffie–Hellman
    protocol but rather a variety of ways to use the DH function to establish a shared
    secret. We’ll review three protocols in the sections that follow. In each discussion,
    I’ll stick to the usual crypto placeholder names and call the two parties Alice
    and Bob, and the attacker Eve. I’ll write *g* as the generator of the group used
    for arithmetic operations, a value fixed and known in advance to Alice, Bob, and
    Eve.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anonymous Diffie–Hellman</samp>
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Anonymous Diffie–Hellman* is the simplest Diffie–Hellman protocol. It’s anonymous
    because it’s not authenticated; the participants have no cryptographic identity
    that either party can verify, and neither party holds a long-term key. Alice can’t
    prove to Bob that she’s Alice, and vice versa.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In anonymous Diffie–Hellman, each party picks a random value (*a* for Alice
    and *b* for Bob) to use as a private key and sends the corresponding public key
    to the other peer. [Figure 11-2](chapter11.xhtml#fig11-2) shows the process in
    more detail.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig11-2.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: The anonymous
    Diffie–Hellman protocol</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Alice uses her exponent *a* and the group basis *g* to compute *A* = *g**^a*,
    which she sends to Bob. Bob receives *A* and computes *A**^b*, which is equal
    to (*g**^a*)*^b*. Bob now obtains the value *g**^(ab)* and computes *B* from his
    random exponent *b* and the value *g*. He then sends *B* to Alice, which she uses
    to compute *g**^(ab)*. Alice and Bob end up with the same value, *g**^(ab)*, after
    performing similar operations that involve raising both *g* and the value received
    to their private exponent’s power. A simple protocol, secure against only the
    laziest of attackers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Attackers can take down anonymous DH with a man-in-the-middle attack. A network
    attacker simply needs to intercept messages and pretend to be Bob (to Alice) and
    pretend to be Alice (to Bob), as [Figure 11-3](chapter11.xhtml#fig11-3) depicts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig11-3.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: A man-in-the-middle
    attack on the anonymous Diffie–Hellman protocol</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous exchange, Alice and Bob pick random exponents, *a* and *b*.
    Alice now computes and sends *A*, but Eve intercepts and drops the message. Eve
    then picks a random exponent, *c*, and computes *C* = *g**^c* to send to Bob.
    Because this protocol has no authentication, Bob believes he is receiving *C*
    from Alice and goes on to compute *g**^(bc)*. Bob then computes *B* and sends
    that value to Alice, but Eve intercepts and drops the message again. Eve now computes
    *g**^(bc)*; picks a new exponent, *d*; computes *g**^(ad)*; computes *D* from
    *g**^d*; and sends *D* to Alice. Alice then computes *g**^(ad)* as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this attack, the attacker Eve shares a secret with Alice (*g**^(ad)*)
    and another secret with Bob (*g**^(bc)*), while Alice and Bob believe that they’re
    sharing a single secret with each other. After completing the protocol execution,
    Alice derives symmetric keys from *g**^(ad)* to encrypt data sent to Bob, but
    Eve intercepts the encrypted messages, decrypts them, and reencrypts them to Bob
    using another set of keys derived from *g**^(bc)*—after potentially modifying
    the cleartext. All of this happens with Alice and Bob unaware; they’re doomed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: To foil this attack, you need a way to authenticate the parties so Alice can
    prove she’s the real Alice and Bob can prove he’s the real Bob. Fortunately, there’s
    a way to do so.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authenticated Diffie–Hellman</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Authenticated Diffie–Hellman* addresses the man-in-the-middle attacks that
    can affect anonymous DH. Authenticated DH equips the two parties with both a private
    key and a public key, thereby allowing Alice and Bob to sign their messages to
    stop Eve from sending messages on their behalf. Here, the signatures aren’t computed
    with a DH function but with a public-key signature scheme such as RSA-PSS. As
    a result, to successfully send messages on behalf of Alice, an attacker needs
    to forge a valid signature, which is impossible with a secure signature scheme.
    [Figure 11-4](chapter11.xhtml#fig11-4) shows how authenticated DH works.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig11-4.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: The authenticated
    Diffie–Hellman protocol</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The label **Alice** (*priv*A, *pub*B) on the first line means that Alice holds
    her own private key, *priv*A, as well as Bob’s public key, *pub*B. This *priv*/*pub*
    key pair is called a *long-term key* because it’s fixed in advance and remains
    constant through consecutive runs of the protocol. Alice can use her key pair
    *priv*A/*pub*A with parties other than Bob, as long as they know *pub*A (*how*
    they know it is another question and one of the hardest operational problems in
    cryptography). These long-term private keys should be kept secret, while the public
    keys are considered to be known to an attacker.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Alice and Bob begin by picking random exponents, *a* and *b*, as in anonymous
    DH. Alice then calculates *A* and a signature *sig*A based on a combination of
    her signing function **sign**, her private key *priv*A, and *A*. Now Alice sends
    *A* and *sig*A to Bob, who verifies *sig*A with her public key *pub*A. If the
    signature is invalid, Bob knows that the message didn’t come from Alice, and he
    discards *A*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: If the signature is correct, Bob computes *g**^(ab)* from *A* and his random
    exponent *b*. He then computes *B* and his own signature from a combination of
    the **sign** function, his private key *priv*B, and *B*. He sends *B* and *sig*B
    to Alice, who attempts to verify *sig*B with Bob’s public key *pub*B. Alice computes
    *g**^(ab)* only if Bob’s signature is successfully verified.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Against Network Attackers</samp>
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Authenticated DH is secure against network attackers because they can’t learn
    any bit of information on the shared secret *g**^(ab)* since they ignore the DH
    exponents. Authenticated DH also provides forward secrecy: even if an attacker
    corrupts any of the parties at some point, as in the *breach* attack model discussed
    earlier, they’d learn the private signing keys but not any of the ephemeral DH
    exponents; hence, they’d be unable to learn the value of any previously shared
    secrets.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The authenticated variant of DH offers only partial protection against *key
    control*. Alice can’t craft special values of *a* to restrict the choice of shared
    secret *g**^(ab)*, because she doesn’t yet know *g**^b*, which influences the
    result as much as *a*. (One exception would be if Alice chose *a* = 0, in which
    case you’d have *g**^(ab)* = 1 for any *b*. The protocol should thus reject 0,
    though implementations may not do so in practice.) However, Bob can try several
    values of *b* until he finds one “that suits him”; for example, for which *g**^(ab)*
    has certain properties, such as its first 16 bits being 1.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: You can eliminate Bob’s power over the value of the secret by sending **Hash**(*g**^b*)
    from Bob to Alice as the first message, before Alice sends her *g**^a*. I’ll leave
    you to analyze this modification and understand why it works (the newly sent message
    is a *commitment* of Bob’s public key).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated DH has other limitations. For one, Eve can pretend to be Alice
    by recording previous values of *A* and *sig*A and replaying them to Bob. Bob
    mistakenly believes he’s sharing a secret with Alice, even though Eve isn’t able
    to learn that secret because she doesn’t know Alice’s secret *a*. She thus wouldn’t
    be able to compute *B**^a* from the *B* sent by Bob.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: You can eliminate this risk by adding a *key confirmation* procedure, wherein
    Alice and Bob prove to each other that they own the shared secret. For example,
    Alice and Bob may perform key confirmation by sending **Hash**(*pub*A || *pub*B
    || *g**^(ab)*) and **Hash**(*pub*B || *pub*A || *g**^(ab)*), respectively, for
    some hash function **Hash**. Both parties can verify the correctness of these
    hash values by recomputing its result. The different order of public keys *pub*A
    || *pub*B and *pub*B || *pub*A ensures that Alice and Bob will send different
    values and that an attacker can’t pretend to be Alice by copying Bob’s hash value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Against Data Leaks</samp>
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Authenticated DH’s vulnerability to data leak attackers is of greater concern.
    In this type of attack, the attacker learns the value of ephemeral, short-term
    secrets (namely, the exponents *a* and *b*) and uses that information to impersonate
    one of the communicating parties. If Eve learns the value of an exponent *a* along
    with the value of *sig*A sent to Bob, she could initiate a new execution of the
    protocol and impersonate Alice, as [Figure 11-5](chapter11.xhtml#fig11-5) illustrates.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig11-5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: An impersonation
    attack on the authenticated Diffie–Hellman protocol</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: In this attack scenario, Eve learns the value of an *a* and replays the corresponding
    *A* and its signature *sig*A, pretending to be Alice. Bob verifies the signature
    and computes *g**^(ab)* from *A* and sends *B* and *sig*B, which Eve then uses
    to compute *g**^(ab)*, using the stolen *a*. This results in the two having a
    shared secret. Bob now believes he’s talking to Alice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: You can protect authenticated DH against the leak of ephemeral secrets by integrating
    the long-term keys into the shared secret computation so that you can’t determine
    the shared secret without knowing the long-term secret.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Menezes–Qu–Vanstone</samp>
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Menezes–Qu–Vanstone (MQV)* protocol is a milestone in the history of DH-based
    protocols. Designed in 1998, MQV was approved to protect most critical assets
    when the NSA included it in its Suite B, a portfolio of algorithms designed to
    protect classified information. (NSA eventually dropped MQV, allegedly because
    it wasn’t used. I’ll discuss the reasons why shortly.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: MQV is Diffie–Hellman on steroids. It’s more secure than authenticated DH, and
    it improves on authenticated DH’s performance properties. In particular, MQV allows
    users to send only two messages, independently of each other, in arbitrary order.
    Users can also send shorter messages than with authenticated DH, and they don’t
    need to send explicit signature or verification messages. In other words, you
    don’t need to use a signature scheme in addition to the Diffie–Hellman function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'As with authenticated DH, in MQV Alice and Bob each hold a long-term private
    key as well as the long-term public key of the other party. The difference is
    that the MQV keys aren’t signing keys: they consist of a private exponent, *x*,
    and a public value, *g**^x*. [Figure 11-6](chapter11.xhtml#fig11-6) shows the
    operation of the MQV protocol.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig11-6.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: The MQV protocol</samp>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The *x* and *y* are Alice and Bob’s respective long-term private keys, and
    *X* and *Y* are their public keys. Bob and Alice start with their own private
    keys and each other’s public keys, which are *g* to the power of a private key.
    Each chooses a random exponent, and then Alice calculates *A* and sends it to
    Bob, who then calculates *B* and sends it to Alice. Once Alice gets Bob’s ephemeral
    public key *B*, she combines it with her long-term private key *x*, her ephemeral
    private key *a*, and Bob’s long-term public key *Y* by calculating the result
    of (*B* × *Y**^B*)*^a* ^+ *^(xA)*, as in [Figure 11-6](chapter11.xhtml#fig11-6).
    Developing this expression, you obtain the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg228-1.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'Meanwhile, Bob calculates the result of (*A* × *X**^A*)*^b* ^+ *^(yB)*, and
    you can verify that it’s equal to the value Alice calculated:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg228-2.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: You get the same value for both Alice and Bob, *g*^(*^b* ^+ *^(yB)*^()()*^a*
    ^+ *^(xA)*^), which tells you that Alice and Bob share the same secret.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Unlike authenticated DH, you can’t break MQV by a mere leak of the ephemeral
    secrets. Knowledge of *a* or *b* won’t let an attacker determine the final shared
    secret because they need the long-term private keys to compute it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: What happens in the strongest attack model, the breach model, when a long-term
    key is compromised? If Eve compromises Alice’s long-term private key *x*, the
    previously established shared secrets are safe because their computation also
    involved Alice’s ephemeral private keys.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: However, MQV doesn’t provide *perfect* forward secrecy because of the following
    attack. Say, for example, that Eve intercepts Alice’s *A* message and replaces
    it with her *A* = *g**^a* for some *a* that Eve chose. In the meantime, Bob sends
    *B* to Alice (and Eve records *B*’s value) and computes the shared key. If Eve
    later compromises Alice’s long-term private key *x*, she can determine the key
    that Bob computed during this session. This breaks forward secrecy since Eve has
    now recovered the shared secret of a previous execution of the protocol. In practice,
    however, you can eliminate the risk with a key-confirmation step in which Alice
    and Bob would realize that they don’t share the same key, and they’d abort the
    protocol before deriving any session keys.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Despite its elegance and security, MQV is rarely used in practice for a couple
    of reasons. It used to be encumbered by patents, which hampered its widespread
    adoption. It’s also harder than it looks to get MQV right. In fact, when weighed
    against its increased complexity, MQV’s security benefits are often perceived
    as low in comparison to the simpler authenticated DH.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Diffie–Hellman protocols can fail spectacularly in a variety of ways. The following
    sections highlight some cases often observed in practice.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Not Hashing the Shared
    Secret</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve alluded to the fact that the shared secret that concludes a DH session
    exchange (*g**^(ab)* in our examples) is taken as input to derive session keys
    but is not a key itself. And it shouldn’t be. A symmetric key should look random,
    and each bit should either be 0 or 1 with the same probability. But *g**^(ab)*
    is not a random string; it’s a random element within some mathematical group whose
    bits may be biased toward 0 or 1\. A random group element is different from a
    random string of bits.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine, for example, that you’re working within the multiplicative group **Z**[13]^*
    = {1, 2, 3, . . . , 12} using *g* = 2 as a generator of the group, meaning that
    *g**^i* spans all values of **Z**[13]^* for *i* in 1, 2, . . . 12: *g*¹ = 2, *g*²
    = 4, *g*³ = 8, *g*⁴ = 3, and so on. If *g*’s exponent is random, you’ll get a
    random element of **Z**[13]^*, but the encoding of a **Z**[13]^* element as a
    4-bit string won’t be uniformly random: not all bits will have the same probability
    of being a 0 or a 1\. In **Z**[13]^*, seven values have 0 as their most significant
    bit (the numbers from 1 to 7 in the group), but only five have 1 as their most
    significant bit (from 8 to 12). That is, this bit is 0 with probability 7/12 ≈
    0.58, whereas a random bit should ideally be 0 with probability 0.5\. Moreover,
    the 4-bit sequences 1101, 1110, and 1111 will never appear.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: To avoid such biases in the session keys derived from a DH shared secret, use
    a cryptographic hash function such as BLAKE3 or SHA-3—or, better yet, a key derivation
    function (KDF). An example of KDF construction is HKDF, or HMAC-based KDF (as
    specified in RFC 5869), but today BLAKE2 and SHA-3 feature dedicated modes to
    behave as KDFs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anonymous Diffie–Hellman
    from TLS 1.0</samp>
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The TLS protocol is the security behind HTTPS secure websites as well as many
    other protocols, such as email transfer with the Simple Mail Transfer Protocol
    (SMTP). TLS takes several parameters, including the type of Diffie–Hellman protocol
    it will use. For backward compatibility reasons, TLS supports anonymous DH since
    version 1.0 up to version 1.2 (that is, without any server authentication), though
    not in version 1.3\. As DH is secure against only passive attackers, it can give
    a false impression of security.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'The original documentation of TLS describes the risks of this protocol (*[https://<wbr>www<wbr>.rfc<wbr>-editor<wbr>.org<wbr>/rfc<wbr>/rfc2246](https://www.rfc-editor.org/rfc/rfc2246)*):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Completely anonymous connections only provide protection against passive eavesdropping.
    Unless an independent tamper-proof channel is used to verify that the finished
    messages were not replaced by an attacker, server authentication is required in
    environments where active man-in-the-middle attacks are a concern.
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsafe Group Parameters</samp>
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In January 2016, the maintainers of the OpenSSL toolkit fixed a high-severity
    vulnerability (CVE-2016-0701) that allowed an attacker to exploit unsafe Diffie–Hellman
    parameters. The root cause of the vulnerability was that OpenSSL allowed users
    to work with unsafe DH group parameters (namely, an unsafe prime *p*) instead
    of throwing an error and aborting the protocol altogether before performing any
    arithmetic operation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, OpenSSL accepted a prime number *p* whose multiplicative group
    **Z**p^* (where all DH operations happen) contained small subgroups. As you learned
    at the beginning of this chapter, the existence of small subgroups within a larger
    group in a cryptographic protocol is bad because it confines shared secrets to
    a much smaller set of possible values than if it were to use the whole group **Z**p^*.
    Worse still, an attacker can craft a DH exponent *x* that, when combined with
    the victim’s public key *g**^y*, reveals information on the private key *y* and
    eventually its entirety.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the actual vulnerability is from 2016, the principle the attack used
    dates back to the 1997 paper “A Key Recovery Attack on Discrete Log-based Schemes
    Using a Prime Order Subgroup” by Chae Hoon Lim and Pil Joong Lee. The fix for
    the vulnerability is simple: when accepting a prime *p* as group modulus, the
    protocol must check that *p* is a safe prime by verifying that (*p* – 1) / 2 is
    prime as well to ensure that the group **Z**p^* won’t have small subgroups and
    that an attack on this vulnerability will fail.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can dig deeper into the DH key agreement protocols by reading a number of
    standards and official publications, including ANSI X9.42, RFC 2631 and RFC 5114,
    IEEE 1363, and NIST SP 800-56A. These serve as references to ensure interoperability
    and to provide recommendations for group parameters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about advanced DH protocols (such as MQV and its cousins HMQV
    and OAKE, among others) and their security notions (including unknown-key share
    attacks and group representation attacks), read the 2005 article “HMQV: A High-Performance
    Secure Diffie–Hellman Protocol” by Hugo Krawczyk (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2005<wbr>/176](https://eprint.iacr.org/2005/176)*)
    and the 2011 article “A New Family of Implicitly Authenticated Diffie–Hellman
    Protocols” by Andrew C. Yao and Yunlei Zhao (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2011<wbr>/035](https://eprint.iacr.org/2011/035)*).
    These articles express Diffie–Hellman operations differently than in this chapter.
    For example, they represent the shared secret as *xP* instead of *g**^x*. Generally,
    you’ll find multiplication replaced with addition and exponentiation replaced
    with multiplication, because those protocols are usually not defined over groups
    of integers but over elliptic curves, as you’ll learn in [Chapter 12](chapter12.xhtml).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
