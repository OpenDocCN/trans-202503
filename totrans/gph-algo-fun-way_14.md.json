["```\nclass DFSTreeStats:\n    def __init__(self, num_nodes: int): \n      ❶ self.parent: list = [-1] * num_nodes\n        self.next_order_index: int = 0\n        self.order: list = [-1] * num_nodes\n        self.lowest: list = [-1] * num_nodes\n\n    def set_order_index(self, node_index: int):\n        self.order[node_index] = self.next_order_index\n        self.next_order_index += 1\n      ❷ self.lowest[node_index] = self.order[node_index] \n```", "```\ndef bridge_finding_dfs(g: Graph, index: int, stats: DFSTreeStats, results: list):\n  ❶ stats.set_order_index(index)\n\n    for edge in g.nodes[index].get_sorted_edge_list():\n        neighbor: int = edge.to_node\n      ❷ if stats.order[neighbor] == -1:\n            stats.parent[neighbor] = index\n            bridge_finding_dfs(g, neighbor, stats, results)\n          ❸ stats.lowest[index] = min(stats.lowest[index],\n                                      stats.lowest[neighbor])\n          ❹ if stats.lowest[neighbor] >= stats.order[neighbor]:\n                results.append(edge)\n        elif neighbor != stats.parent[index]:\n          ❺ stats.lowest[index] = min(stats.lowest[index],\n                                      stats.order[neighbor])\n\ndef find_bridges(g: Graph) -> list:\n    results: list = []\n    stats: DFSTreeStats = DFSTreeStats(g.num_nodes)\n    for index in range(g.num_nodes):\n        if stats.order[index] == -1:\n            bridge_finding_dfs(g, index, stats, results)\n    return results \n```", "```\ndef articulation_point_dfs(g: Graph, index: int, stats: DFSTreeStats,\n                           results: set): \n  ❶ stats.set_order_index(index)\n    for edge in g.nodes[index].get_edge_list():\n        neighbor: int = edge.to_node\n        if stats.order[neighbor] == -1:\n            stats.parent[neighbor] = index\n            articulation_point_dfs(g, neighbor, stats, results)\n          ❷ stats.lowest[index] = min(stats.lowest[index],\n                                      stats.lowest[neighbor])\n\n          ❸ if stats.lowest[neighbor] >= stats.order[index]:\n                results.add(index)\n\n        elif neighbor != stats.parent[index]:\n          ❹ stats.lowest[index] = min(stats.lowest[index],\n                                      stats.order[neighbor]) \n```", "```\ndef articulation_point_root(g: Graph, root: int,\n                            stats: DFSTreeStats, results: set): \n    stats.set_order_index(root)\n    num_subtrees: int = 0 for edge in g.nodes[root].get_edge_list():\n        neighbor: int = edge.to_node\n      ❶ if stats.order[neighbor] == -1:\n            stats.parent[neighbor] = root\n            articulation_point_dfs(g, neighbor, stats, results)\n            num_subtrees += 1\n\n  ❷ if num_subtrees >= 2:\n        results.add(root) \n```", "```\ndef find_articulation_points(g: Graph) -> set:\n    stats: DFSTreeStats = DFSTreeStats(g.num_nodes)\n    results: set = set()\n    for index in range(g.num_nodes):\n      ❶ if stats.order[index] == -1:\n            articulation_point_root(g, index, stats, results)\n    return results \n```"]