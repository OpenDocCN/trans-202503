- en: '**12**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SAVING BIRTHDAYS**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can add birthdays to your app and display them in a list, which is awesome!
    However, when you close the app, the birthdays disappear from your device. In
    this chapter, we’ll show you how to save your app’s data on your device so it’s
    there even after you quit the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**STORING BIRTHDAYS IN A DATABASE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data is stored on the iPhone in a *database* , which is a collection of data
    that can be quickly saved, updated, and retrieved. You can think of it as an electronic
    filing system where the data is stored in tables with rows and columns. In the
    database for our app, there will be a Birthday table to store the birthdays. This
    will look something like [Table 12-1](text00023.html#ch12tab1) .
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** A Birthday Table in a Database'
  prefs: []
  type: TYPE_NORMAL
- en: '| firstName | lastName | birthdate |'
  prefs: []
  type: TYPE_TB
- en: '| Jen | Marbury | October 8, 2004 |'
  prefs: []
  type: TYPE_TB
- en: '| Tezeta | Tulloch | April 28, 2003 |'
  prefs: []
  type: TYPE_TB
- en: '| Betsy | Nichols | January 27, 2005 |'
  prefs: []
  type: TYPE_TB
- en: '| Caroline | Greeven | June 12, 2004 |'
  prefs: []
  type: TYPE_TB
- en: Each row will contain one Birthday object, with the columns containing its firstName
    , lastName , and birthdate attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an Apple framework that you can use to save and retrieve data in
    a database. The objects stored in the Core Data database all have to come from
    subclasses of the NSManagedObject class. These subclasses are called *managed
    objects* because their lifecycles are managed by the Core Data framework. That
    means you can’t create a managed object using the init() methods that we covered
    in [Chapter 8](text00018.html#ch08) . Instead, you need to use a special NSManagedObject
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**SAVING BIRTHDAYS**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can add birthdays to your app and display them in a list, which is awesome!
    However, when you close the app, the birthdays disappear from your device. In
    this chapter, we’ll show you how to save your app’s data on your device so it’s
    there even after you quit the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**STORING BIRTHDAYS IN A DATABASE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data is stored on the iPhone in a *database* , which is a collection of data
    that can be quickly saved, updated, and retrieved. You can think of it as an electronic
    filing system where the data is stored in tables with rows and columns. In the
    database for our app, there will be a Birthday table to store the birthdays. This
    will look something like [Table 12-1](text00023.html#ch12tab1) .
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** A Birthday Table in a Database'
  prefs: []
  type: TYPE_NORMAL
- en: '| firstName | lastName | birthdate |'
  prefs: []
  type: TYPE_TB
- en: '| Jen | Marbury | October 8, 2004 |'
  prefs: []
  type: TYPE_TB
- en: '| Tezeta | Tulloch | April 28, 2003 |'
  prefs: []
  type: TYPE_TB
- en: '| Betsy | Nichols | January 27, 2005 |'
  prefs: []
  type: TYPE_TB
- en: '| Caroline | Greeven | June 12, 2004 |'
  prefs: []
  type: TYPE_TB
- en: Each row will contain one Birthday object, with the columns containing its firstName
    , lastName , and birthdate attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an Apple framework that you can use to save and retrieve data in
    a database. The objects stored in the Core Data database all have to come from
    subclasses of the NSManagedObject class. These subclasses are called *managed
    objects* because their lifecycles are managed by the Core Data framework. That
    means you can’t create a managed object using the init() methods that we covered
    in [Chapter 8](text00018.html#ch08) . Instead, you need to use a special NSManagedObject
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can add birthdays to your app and display them in a list, which is awesome!
    However, when you close the app, the birthdays disappear from your device. In
    this chapter, we’ll show you how to save your app’s data on your device so it’s
    there even after you quit the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**STORING BIRTHDAYS IN A DATABASE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data is stored on the iPhone in a *database* , which is a collection of data
    that can be quickly saved, updated, and retrieved. You can think of it as an electronic
    filing system where the data is stored in tables with rows and columns. In the
    database for our app, there will be a Birthday table to store the birthdays. This
    will look something like [Table 12-1](text00023.html#ch12tab1) .
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** A Birthday Table in a Database'
  prefs: []
  type: TYPE_NORMAL
- en: '| firstName | lastName | birthdate |'
  prefs: []
  type: TYPE_TB
- en: '| Jen | Marbury | October 8, 2004 |'
  prefs: []
  type: TYPE_TB
- en: '| Tezeta | Tulloch | April 28, 2003 |'
  prefs: []
  type: TYPE_TB
- en: '| Betsy | Nichols | January 27, 2005 |'
  prefs: []
  type: TYPE_TB
- en: '| Caroline | Greeven | June 12, 2004 |'
  prefs: []
  type: TYPE_TB
- en: Each row will contain one Birthday object, with the columns containing its firstName
    , lastName , and birthdate attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an Apple framework that you can use to save and retrieve data in
    a database. The objects stored in the Core Data database all have to come from
    subclasses of the NSManagedObject class. These subclasses are called *managed
    objects* because their lifecycles are managed by the Core Data framework. That
    means you can’t create a managed object using the init() methods that we covered
    in [Chapter 8](text00018.html#ch08) . Instead, you need to use a special NSManagedObject
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can add birthdays to your app and display them in a list, which is awesome!
    However, when you close the app, the birthdays disappear from your device. In
    this chapter, we’ll show you how to save your app’s data on your device so it’s
    there even after you quit the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**STORING BIRTHDAYS IN A DATABASE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data is stored on the iPhone in a *database* , which is a collection of data
    that can be quickly saved, updated, and retrieved. You can think of it as an electronic
    filing system where the data is stored in tables with rows and columns. In the
    database for our app, there will be a Birthday table to store the birthdays. This
    will look something like [Table 12-1](text00023.html#ch12tab1) .
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** A Birthday Table in a Database'
  prefs: []
  type: TYPE_NORMAL
- en: '| firstName | lastName | birthdate |'
  prefs: []
  type: TYPE_TB
- en: '| Jen | Marbury | October 8, 2004 |'
  prefs: []
  type: TYPE_TB
- en: '| Tezeta | Tulloch | April 28, 2003 |'
  prefs: []
  type: TYPE_TB
- en: '| Betsy | Nichols | January 27, 2005 |'
  prefs: []
  type: TYPE_TB
- en: '| Caroline | Greeven | June 12, 2004 |'
  prefs: []
  type: TYPE_TB
- en: Each row will contain one Birthday object, with the columns containing its firstName
    , lastName , and birthdate attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an Apple framework that you can use to save and retrieve data in
    a database. The objects stored in the Core Data database all have to come from
    subclasses of the NSManagedObject class. These subclasses are called *managed
    objects* because their lifecycles are managed by the Core Data framework. That
    means you can’t create a managed object using the init() methods that we covered
    in [Chapter 8](text00018.html#ch08) . Instead, you need to use a special NSManagedObject
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**STORING BIRTHDAYS IN A DATABASE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data is stored on the iPhone in a *database* , which is a collection of data
    that can be quickly saved, updated, and retrieved. You can think of it as an electronic
    filing system where the data is stored in tables with rows and columns. In the
    database for our app, there will be a Birthday table to store the birthdays. This
    will look something like [Table 12-1](text00023.html#ch12tab1) .
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** A Birthday Table in a Database'
  prefs: []
  type: TYPE_NORMAL
- en: '| firstName | lastName | birthdate |'
  prefs: []
  type: TYPE_TB
- en: '| Jen | Marbury | October 8, 2004 |'
  prefs: []
  type: TYPE_TB
- en: '| Tezeta | Tulloch | April 28, 2003 |'
  prefs: []
  type: TYPE_TB
- en: '| Betsy | Nichols | January 27, 2005 |'
  prefs: []
  type: TYPE_TB
- en: '| Caroline | Greeven | June 12, 2004 |'
  prefs: []
  type: TYPE_TB
- en: Each row will contain one Birthday object, with the columns containing its firstName
    , lastName , and birthdate attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an Apple framework that you can use to save and retrieve data in
    a database. The objects stored in the Core Data database all have to come from
    subclasses of the NSManagedObject class. These subclasses are called *managed
    objects* because their lifecycles are managed by the Core Data framework. That
    means you can’t create a managed object using the init() methods that we covered
    in [Chapter 8](text00018.html#ch08) . Instead, you need to use a special NSManagedObject
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Data is stored on the iPhone in a *database* , which is a collection of data
    that can be quickly saved, updated, and retrieved. You can think of it as an electronic
    filing system where the data is stored in tables with rows and columns. In the
    database for our app, there will be a Birthday table to store the birthdays. This
    will look something like [Table 12-1](text00023.html#ch12tab1) .
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** A Birthday Table in a Database'
  prefs: []
  type: TYPE_NORMAL
- en: '| firstName | lastName | birthdate |'
  prefs: []
  type: TYPE_TB
- en: '| Jen | Marbury | October 8, 2004 |'
  prefs: []
  type: TYPE_TB
- en: '| Tezeta | Tulloch | April 28, 2003 |'
  prefs: []
  type: TYPE_TB
- en: '| Betsy | Nichols | January 27, 2005 |'
  prefs: []
  type: TYPE_TB
- en: '| Caroline | Greeven | June 12, 2004 |'
  prefs: []
  type: TYPE_TB
- en: Each row will contain one Birthday object, with the columns containing its firstName
    , lastName , and birthdate attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an Apple framework that you can use to save and retrieve data in
    a database. The objects stored in the Core Data database all have to come from
    subclasses of the NSManagedObject class. These subclasses are called *managed
    objects* because their lifecycles are managed by the Core Data framework. That
    means you can’t create a managed object using the init() methods that we covered
    in [Chapter 8](text00018.html#ch08) . Instead, you need to use a special NSManagedObject
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** A Birthday Table in a Database'
  prefs: []
  type: TYPE_NORMAL
- en: '| firstName | lastName | birthdate |'
  prefs: []
  type: TYPE_TB
- en: '| Jen | Marbury | October 8, 2004 |'
  prefs: []
  type: TYPE_TB
- en: '| Tezeta | Tulloch | April 28, 2003 |'
  prefs: []
  type: TYPE_TB
- en: '| Betsy | Nichols | January 27, 2005 |'
  prefs: []
  type: TYPE_TB
- en: '| Caroline | Greeven | June 12, 2004 |'
  prefs: []
  type: TYPE_TB
- en: Each row will contain one Birthday object, with the columns containing its firstName
    , lastName , and birthdate attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an Apple framework that you can use to save and retrieve data in
    a database. The objects stored in the Core Data database all have to come from
    subclasses of the NSManagedObject class. These subclasses are called *managed
    objects* because their lifecycles are managed by the Core Data framework. That
    means you can’t create a managed object using the init() methods that we covered
    in [Chapter 8](text00018.html#ch08) . Instead, you need to use a special NSManagedObject
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '| firstName | lastName | birthdate |'
  prefs: []
  type: TYPE_TB
- en: '| Jen | Marbury | October 8, 2004 |'
  prefs: []
  type: TYPE_TB
- en: '| Tezeta | Tulloch | April 28, 2003 |'
  prefs: []
  type: TYPE_TB
- en: '| Betsy | Nichols | January 27, 2005 |'
  prefs: []
  type: TYPE_TB
- en: '| Caroline | Greeven | June 12, 2004 |'
  prefs: []
  type: TYPE_TB
- en: Each row will contain one Birthday object, with the columns containing its firstName
    , lastName , and birthdate attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an Apple framework that you can use to save and retrieve data in
    a database. The objects stored in the Core Data database all have to come from
    subclasses of the NSManagedObject class. These subclasses are called *managed
    objects* because their lifecycles are managed by the Core Data framework. That
    means you can’t create a managed object using the init() methods that we covered
    in [Chapter 8](text00018.html#ch08) . Instead, you need to use a special NSManagedObject
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Each row will contain one Birthday object, with the columns containing its firstName
    , lastName , and birthdate attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an Apple framework that you can use to save and retrieve data in
    a database. The objects stored in the Core Data database all have to come from
    subclasses of the NSManagedObject class. These subclasses are called *managed
    objects* because their lifecycles are managed by the Core Data framework. That
    means you can’t create a managed object using the init() methods that we covered
    in [Chapter 8](text00018.html#ch08) . Instead, you need to use a special NSManagedObject
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an Apple framework that you can use to save and retrieve data in
    a database. The objects stored in the Core Data database all have to come from
    subclasses of the NSManagedObject class. These subclasses are called *managed
    objects* because their lifecycles are managed by the Core Data framework. That
    means you can’t create a managed object using the init() methods that we covered
    in [Chapter 8](text00018.html#ch08) . Instead, you need to use a special NSManagedObject
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to add Core Data to your project is to have Xcode do it automatically.
    To do this, whenever you create a new project, start with a Single View Application
    and check the Use Core Data box in the new project options. You should have already
    completed this step when you created the BirthdayTracker project in [Chapter 9](text00020.html#ch09)
    . When you create a new project using Core Data, Xcode gives you a data model
    file and setup code in the *AppDelegate.swift* file. You need this code to save
    data, but you can adjust it to use for your own app.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Every iOS application has a special *application delegate* that is automatically
    created as an instance of the AppDelegate class. The application delegate is in
    charge of the *application lifecycle* , which refers to the various running states
    an app can be in. For the BirthdayTracker app, the application delegate will also
    manage the data storage. We’ll show you how to work with the application delegate
    to save and fetch data in “[Saving a Birthday](text00021.html#ch10lev1sec3) ”
    on [page 178](text00023.html#page_178) .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ENTITY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: In your app, you want to save and retrieve managed Birthday objects. To do this,
    you need to create a Birthday *entity* that will model the Birthday class. You
    can think of an entity as a table in the Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: In your Project navigator, you should see a data model file called *BirthdayTracker.xcdatamodeld*
    . Click that file and you’ll see an empty data model. In the lower-left corner
    of the model, click the **Add Entity** button. This will create a new entity,
    which appears under Entities with the default name Entity. Double-click its name
    to get an editable text field, and then change its name to Birthday (see [Figure
    12-1](text00023.html#ch12fig1) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-1: Double-click the entity to change its name.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll add attributes to the Birthday entity so that you can store a firstName
    , lastName , and birthdate for each Birthday object.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BIRTHDAY ATTRIBUTES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Just as a class has properties, an entity has attributes. A Core Data entity
    has to have a corresponding class in Swift with properties that match the entity’s
    attributes. Your Birthday class has three properties—firstName , lastName , and
    birthdate —which means that the Birthday entity needs to have three attributes
    with the same names. We’re also going to add a birthdayId attribute—a unique string
    to identify each birthday. We’ll need this in [Chapter 13](text00024.html#ch13)
    when we remove a birthday and its corresponding user notification from the app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the attributes now. Click the **Add Attribute** button to add a
    new attribute to the Birthday entity. Call it firstName by typing firstName in
    its editable text field under Attribute. Next, use the Type drop-down menu to
    set the type to **String** (see [Figure 12-2](text00023.html#ch12fig2) ).
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve done this, add the lastName and birthdayId attributes, also as **String**
    types. Finally, add the birthdate attribute, but make it a **Date** type. When
    you’re finished, your data model should look like the one shown in [Figure 12-3](text00023.html#ch12fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-2: Add a* firstName *attribute of type* String *to* Birthday *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-3: The BirthdayTracker data model with a* Birthday *entity*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Now that your data model is set up, Xcode has created a Birthday NSManagedObject
    subclass behind the scenes to go with it, which will be used to store birthdays.
    This means that we can remove our original Birthday class from the code. We have
    a new Birthday class that makes managed Birthday objects to store in the device’s
    database, so we no longer need the temporary Birthday class that we created.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click *Birthday.swift* in the Project navigator to bring up the menu
    shown in [Figure 12-4](text00023.html#ch12fig4) . Choose **Delete** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-4: Delete the* Birthday.swift *file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll see a dialog asking if you want to Remove Reference to the file
    or Move to Trash. Removing a reference to your file removes the file from your
    project but doesn’t actually delete the file in case you need to use it for something
    else. Since we won’t use *Birthday.swift* anymore, you can delete it entirely.
    Select **Move to Trash** .
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE APPLICATION DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to save birthdays on your device soon. To do this, you’ll
    need to access the application delegate in your code. Remember, in our app, the
    code to manage Core Data is inside the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new iOS application using Xcode, an *AppDelegate .swift* file
    is automatically created for you. This file contains the AppDelegate class, which
    implements the UIApplicationDelegate protocol, which in turn creates the application
    delegate for the app. Every app has only one application delegate, and the application
    delegate is in charge of the app’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: On an iOS device, a user typically sees and interacts with only one app at a
    time. This is called the *foreground* app. When the user hits the home button
    on their iOS device or switches to another app, the app they were using gets *backgrounded*
    . That means that the current app is no longer visible and another app can be
    brought to the foreground. A background app can still execute some code for a
    short time, but it will eventually be *suspended* , or paused. A backgrounded
    or suspended app can be brought back to the foreground quickly when the user switches
    back to it because it’s still in the device’s memory. When an app is fully closed,
    it is *terminated* . A terminated app must be relaunched from scratch if the user
    opens it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application delegate knows when the app has finished launching, been backgrounded,
    come back to the foreground, or been terminated. The AppDelegate class contains
    six callback functions that will be called when the application goes into its
    different lifecycle states:'
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: application(_:didFinishLaunchingWithOptions:) is called when the app is launched.
    If you want your application to do something as soon as it has launched, you can
    write code in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillResignActive(_:) is called when the app is leaving the foreground
    state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidEnterBackground(_:) is called when the app has entered the background
    state, where some code can be executed but the app can still be suspended at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillEnterForeground(_:) is called when the app is leaving the background
    state and about to go to the foreground state.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: applicationDidBecomeActive(_:) is called when the app is going to the foreground
    state and has become active again.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: applicationWillTerminate(_:) is called when the app is running in the foreground
    or background and is being closed. This won’t be called if the app is suspended
    when it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project using Core Data, Xcode will automatically have
    the AppDelegate class manage the data storage for you. In the *AppDelegate.swift*
    file, you’ll see that the AppDelegate class contains a persistentContainer property,
    which you’ll need to save and access data. On the persistentContainer is a NSManagedObjectContext
    property called viewContext . When we save and fetch birthdays in our code, we’ll
    need to access persistentContainer.viewContext directly. Let’s see how that is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the Managed Object Context**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE988]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE989]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *managed object context* is like a scratch-pad object that is used to create,
    save, and fetch data from the database. It temporarily stores the data you need.
    From anywhere in your application, you can access the managed object context using
    these two lines of code (we’ll tell you where to add them later, so for now, just
    focus on understanding what they do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE990]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE991]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE992]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE993]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE994]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE995]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE996]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE997]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE998]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1008]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1009]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1010]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1011]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1012]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1016]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1032]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1033]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this code is to get the managed object context for your application
    and to store it into a simple constant that you can use to create and save birthdays.
    At ➊ , you are creating a constant reference to your app’s application delegate.
    You do this by using the shared property of UIApplication to return your application
    instance (that is, your currently running app). Once you have the current application
    instance, you cast the delegate property in that instance as an AppDelegate and
    store it in the constant appDelegate . The line at ➋ retrieves the viewContext
    , which is in the persistentContainer of appDelegate , and stores it in a constant
    called context .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1041]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1042]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1043]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1044]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1045]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1046]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1047]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1048]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1049]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1050]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1051]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1052]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1053]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1054]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve accessed the managed object context, you’re ready to save some
    birthdays! You use the context to create a new birthday, and then when you want
    to save the birthday, you just save the context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1055]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1056]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1057]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1058]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1059]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1060]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1061]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1062]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1063]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1064]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1065]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1066]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1067]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1068]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1069]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1070]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1071]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1072]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1073]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1074]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1075]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving a Birthday**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1076]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1077]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1078]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1079]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1080]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1081]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1082]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1083]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1084]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1085]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1086]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1087]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1088]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1089]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1090]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1091]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1092]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1093]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1094]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1095]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1096]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s save a birthday on the iPhone! Open *AddBirthdayViewController.swift*
    . The first step is to import Core Data, which you need to do for any file in
    which you want to use Core Data. Add the following to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1097]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1098]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1099]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1100]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1101]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1102]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1103]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1104]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1105]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1106]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1107]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1108]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1109]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1110]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1111]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1112]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1113]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1114]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1115]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1116]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1117]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1118]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1119]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1120]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1121]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1122]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1123]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1124]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1125]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1126]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1127]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1128]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1130]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1131]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1132]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1133]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1134]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1135]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1136]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1137]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1138]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1139]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1140]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1141]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1142]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1143]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1144]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1145]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1146]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1147]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1148]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1149]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1150]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1151]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1152]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1153]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1154]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1155]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1156]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1157]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1158]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1159]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, take a look at the saveTapped(_:) method. Delete the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1160]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1161]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1162]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1163]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1164]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1165]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1166]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1167]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1168]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1169]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1170]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1171]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1172]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1173]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1174]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1175]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1176]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1177]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1178]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1179]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1180]'
  prefs: []
  type: TYPE_PRE
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1181]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1182]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1183]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1184]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1185]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1186]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1187]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1188]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1189]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1190]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1191]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1192]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1193]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1194]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1195]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1196]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1197]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1198]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1199]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not going to use the initializer to create newBirthday anymore, so you
    can get rid of the line at ➊ . In addition, we don’t need to use a delegate to
    pass a birthday to the Birthdays table view controller (you’ll see why shortly),
    so you can also get rid of the line at ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1200]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1201]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1202]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1203]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1204]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1205]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1206]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1207]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1208]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1209]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1210]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1211]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1212]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1213]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1214]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1215]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1216]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1217]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1218]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add code inside the saveTapped(_:) method. We need to get the managed
    object context to create and save a Birthday . First, add the two lines of code
    we talked about in “[Accessing the Managed Object Context](text00023.html#ch12lev3sec1)
    ” on [page 178](text00023.html#page_178) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1219]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1220]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1221]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1222]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1223]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1224]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1225]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1226]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1227]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1228]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1229]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1230]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1231]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1232]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1233]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1234]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1235]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1236]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1237]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1238]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1239]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1240]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1241]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1242]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1243]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1244]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1245]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1246]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1247]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1248]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1249]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1250]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1251]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1252]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1253]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1254]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1255]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1256]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve accessed the context, you can use it to create a Birthday . Add
    the following lines to saveTapped(_:) right after setting context .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1257]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1258]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1259]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1260]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1261]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1262]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1263]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1264]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1265]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1266]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1267]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1268]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1269]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1270]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1271]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1272]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1273]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1274]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1275]'
  prefs: []
  type: TYPE_PRE
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1276]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1277]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1278]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1279]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1280]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1281]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1282]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1283]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1284]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1285]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1286]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1287]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1288]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1289]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1290]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1291]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1292]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Each NSManagedObject subclass comes with a default initializer that takes a
    context and will create a new managed object. At ➊ , we create a birthday by using
    a new Birthday initializer and passing in the context created in the line above.
    After newBirthday is created, we can set its firstName ➋ , lastName ➌ , and birthdate
    ➍ properties. Notice how this is different from our old initializer, where we
    passed in all of the Birthday class’s properties. Here, we first create the newBirthday
    and then set its properties line by line. One extra thing that we have to do at
    ➍ (as of Xcode Version 8.2.1) is to cast the birthdate attribute to an NSDate
    object. NSDate was used in older versions of Swift and has been updated to Date
    . However, dates in Core Data have not yet been updated to use the new Date class,
    so we have to cast our birthdate attribute to NSDate to ensure we get the right
    value from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1293]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1294]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1295]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1296]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1297]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1298]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1299]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1300]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1301]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1302]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1303]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1304]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1305]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1306]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1307]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1308]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1309]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1310]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1311]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1312]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1313]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1314]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1315]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1316]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1317]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1318]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1319]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1320]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1321]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1322]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1323]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1324]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1325]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1326]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to set that birthdayId field to be a unique identifier for each
    birthday. This is kind of like how the United States government issues each of
    its citizens a Social Security number. No two people can have the same number.
    In computer programming, objects often need to have unique identifiers, which
    are called *universally unique identifiers (UUIDs)* . Swift has a UUID class that
    will make a UUID String for us. We use this class at ➎ when we set the birthdayId
    of newBirthday to UUID().uuidString . This property of the UUID class will return
    a new unique value every time it’s called. If you want to see the value of the
    birthdayId , you can add a print statement ➏ , and you’ll see something like the
    following printed every time you add a birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1327]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1328]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1329]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1330]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1331]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1332]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1333]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1334]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1335]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1336]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1337]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1338]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1339]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1340]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1341]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1342]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1343]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1344]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1345]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1346]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1347]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1348]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1349]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1350]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1351]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1352]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1353]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1354]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1355]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1356]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1357]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1358]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1359]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1360]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to save newBirthday . To do that, we call the save() method on
    the context . This is kind of like saving changes to a computer document after
    you’re done working on it. The managed object context is like your document, and
    you’ve added a birthday to it, so now you want to save that document. Add these
    lines after setting the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1361]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1362]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1363]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1364]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1365]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1366]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1367]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1368]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1369]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1370]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1371]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1372]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1373]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1374]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1375]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1376]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1377]'
  prefs: []
  type: TYPE_PRE
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1378]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1379]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1380]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1381]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1382]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1383]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1384]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1385]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1386]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1387]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1388]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1389]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1390]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1391]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1392]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Now this is something new! We’ve wrapped our method to save the context inside
    a do-try-catch block, which is used in Swift to handle errors. In most simple
    applications, you’ll only use the do-try-catch block around methods called on
    a managed object context, so this book will just cover how to use it in that situation.
    When you want to call a method such as save() on a context, you need to wrap the
    method in a block that starts with the keyword do ➊ . This tells Swift to run
    the code inside of the do block’s braces. Next, you need to put the keyword try
    in front of the method call ➋ . The try keyword tells Swift that it should *try*
    to run the method, but if the method doesn’t work, it will throw an error that
    Swift needs to *catch* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1393]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1394]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1395]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1396]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1397]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1398]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1399]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1400]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1401]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1402]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1403]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1404]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1405]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1406]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1407]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The try keyword is used only in front of methods that throw errors, like this
    context.save() method. A method that throws an error will have the keyword throws
    after the input parameters in its definition. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1408]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1409]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1410]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1411]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1412]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1413]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1414]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1415]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1416]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1417]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1418]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1419]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1420]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1421]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1422]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1423]'
  prefs: []
  type: TYPE_PRE
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1424]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1425]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1426]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1427]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1428]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1429]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1430]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1431]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1432]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1433]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1434]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1435]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1436]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1437]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to call the context.save() method without using do-try-catch , Xcode
    will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1438]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1439]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1440]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1441]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1442]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1443]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1444]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1445]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1446]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1447]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1448]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1449]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1450]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1451]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last part is a catch block, to catch any errors thrown by the context.save()
    method ➌ . If the context.save() method fails and you want to find out what happened,
    you can print the error that was thrown and then caught ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1452]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1453]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1454]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1455]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1456]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1457]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1458]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1459]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1460]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1461]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1462]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1463]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1464]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1465]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re saving all of the birthdays that are entered into the app. But before
    we run the app again, we still need to have our Birthdays table view controller
    grab all of the birthdays out of the database to display them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1466]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1467]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1468]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1469]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1470]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1471]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1472]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1473]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1474]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1475]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1476]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1477]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1478]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1479]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Birthdays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1480]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1481]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1482]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1483]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1484]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1485]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1486]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1487]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1488]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1489]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1490]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1491]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1492]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1493]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: The Add Birthday view controller saves each birthday that is added to your app
    onto your device. Now let’s *fetch* the birthdays—that is, get the Birthday objects
    out of Core Data—so that they can be displayed in the Birthdays table view controller.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1494]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1495]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1496]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1497]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1498]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1499]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1500]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1501]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1502]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1503]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1504]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1505]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1506]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1507]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: First, add import CoreData to the top of the BirthdaysTableViewController file,
    just like you did to the AddBirthdayViewController . This import statement must
    be included at the top of every file that uses the framework, or Xcode won’t recognize
    classes or methods used by Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1508]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1509]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1510]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1511]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1512]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1513]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1514]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1515]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1516]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1517]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1518]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1519]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1520]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1521]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to write the code to fetch the birthdays we want to display. The
    list of birthdays should be refreshed every time the Birthdays table view controller’s
    view appears on the screen. That way, when you add a birthday and then dismiss
    the Add Birthday view controller, the Birthdays table view controller will appear
    showing the new birthday as part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1522]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1523]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1524]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1525]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1526]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1527]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1528]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1529]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1530]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1531]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1532]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1533]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1534]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1535]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in method called viewWillAppear(_:) in the UIViewController
    class where we can fetch the birthdays and put them in the birthdays array each
    time the Birthdays table view controller comes onto the screen. Add the following
    code right after the viewDidLoad() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1536]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1537]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1538]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1539]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1540]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1541]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1542]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1543]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1544]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1545]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1546]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1547]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1548]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1549]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1550]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1551]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1552]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1553]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1554]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1555]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1556]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1557]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1558]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1559]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1560]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1561]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1562]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1563]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1564]'
  prefs: []
  type: TYPE_PRE
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1565]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1566]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1567]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1568]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1569]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1570]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1571]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1572]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1573]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1574]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1575]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1576]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1577]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: The function viewWillAppear(_:) ➊ is a UIViewController lifecycle method similar
    to viewDidLoad() . Whereas viewDidLoad() will be called only once when the view
    controller is first created, viewWillAppear(_:) will be called every time the
    view appears on the screen. This makes it a very useful place to put code that
    you want to execute each time a view appears or reappears.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1578]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1579]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1580]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1581]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1582]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1583]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1584]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1585]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1586]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1587]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1588]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1589]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1590]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to implement viewWillAppear(_:) , make sure to call super.viewWillAppear(_:)
    ➋ so that you still get the built-in functionality of the UIViewController ’s
    viewWillAppear(_:) method. In this case, you want to pass the animated parameter
    into that method as well. The animated parameter is a Boolean that tells the app
    whether the view will animate (that is, slide onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1591]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1592]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1593]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1594]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1595]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1596]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1597]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1598]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1599]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1600]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1601]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1602]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1603]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch data from the database, you need to access the managed object context
    of the app delegate. The lines at ➌ and ➍ get you the context that you’ll use
    to fetch the data. This is the same way that you got the context to save a Birthday
    in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1604]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1605]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1606]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1607]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1608]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1609]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1610]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1611]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1612]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1613]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1614]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1615]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1616]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to create an NSFetchRequest object. The line at ➎ creates an
    NSFetchRequest that will get all of the Birthday objects out of Core Data. It
    uses the class method fetchRequest() that Xcode created automatically in your
    *Birthday+CoreDataProperties.swift* file. Note that when you create the fetchRequest
    , you need to cast it as an NSFetchRequest<Birthday> data type so that it knows
    what type of objects to get out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1617]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1618]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1619]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1620]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1621]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1622]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1623]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1624]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1625]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1626]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1627]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1628]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1629]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fetchRequest , you can have your managed object context perform
    its fetch(_:) method with it. The fetch(_:) method ➏ will return an array of objects
    of the data type specified in the fetchRequest . In this case, we’ll get back
    an array of Birthday objects that we can assign to the birthdays array. This line
    is wrapped in a do-try-catch error-handling block, much like the one we used to
    save the birthday in the Add Birthday view controller. Swift uses this type of
    error handling when fetching objects out of Core Data so that the error can tell
    you what happened if the fetch doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1630]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1631]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1632]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1633]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1634]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1635]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1636]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1637]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1638]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1639]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1640]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1641]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1642]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the birthdays have been fetched, we need to reload the table
    view so that we can see the new birthdays ➐ .
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1643]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1644]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1645]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1646]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1647]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1648]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1649]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1650]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1651]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1652]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1653]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1654]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1655]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: We still have to take care of a few more things before we can run the app and
    test out our saved birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1656]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1657]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1658]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1659]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1660]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1661]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1662]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1663]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1664]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1665]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1666]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1667]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1668]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE CLEANUP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1669]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1670]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1671]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1672]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1673]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1674]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1675]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1676]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1677]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1678]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1679]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1680]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1681]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find that when you write your apps, it’s very common to do something
    one way and then figure out that there is a better way to do it. When you improve
    code you’ve already written, that’s called *refactoring* your code. Let’s start
    by cleaning up and getting rid of old code we don’t need anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1682]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1683]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1684]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1685]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1686]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1687]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1688]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1689]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1690]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1691]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1692]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1693]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1694]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1695]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1696]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1697]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1698]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1699]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1700]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1701]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1702]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1703]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1704]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1705]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1706]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1707]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](text00022.html#ch11) , we used delegation to have the Add Birthday
    view controller tell the Birthdays table view controller each time a Birthday
    was added so that it could be displayed. Now we don’t need to do that. Instead,
    we’ll have the Birthdays table view controller fill its birthdays array by pulling
    the saved Birthday objects out of the database every time it comes on the screen.
    This means that we can get rid of the AddBirthdayViewControllerDelegate and all
    of the code that goes with it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1708]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1709]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1710]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1711]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1712]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1713]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1714]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1715]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1716]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1717]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1718]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1719]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1720]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, delete the entire AddBirthdayViewControllerDelegate protocol and
    its function, addBirthdayViewController(_:didAddBirthday:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1721]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1722]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1723]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1724]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1725]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1726]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1727]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1728]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1729]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1730]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1731]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1732]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1733]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1734]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1735]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1736]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1737]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1738]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1739]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1740]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1741]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1742]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1743]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1744]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1745]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1746]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1747]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1748]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1749]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1750]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1751]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1752]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1753]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1754]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1755]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1756]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1757]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1758]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1759]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you delete this, you’ll see a red error next to the delegate property
    in the AddBirthdayViewController class. Delete that line of code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1760]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1761]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1762]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1763]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1764]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1765]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1766]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1767]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1768]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1769]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1770]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1771]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1772]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1773]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1774]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1775]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1776]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1777]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1778]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1779]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1780]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1781]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1782]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1783]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click the BirthdaysTableViewController to open that file. Because the
    AddBirthdayViewControllerDelegate protocol no longer exists, you can’t have the
    BirthdaysTableViewController class adopt this protocol, so there will be an error
    next to the BirthdaysTableViewController definition. Remove the comma and AddBirthdayViewControllerDelegate
    from this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1784]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1785]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1786]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1787]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1788]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1789]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1790]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1791]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1792]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1793]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1794]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1795]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1796]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1797]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1798]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1799]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1800]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1801]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1802]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1803]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1804]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1805]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1806]'
  prefs: []
  type: TYPE_PRE
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1807]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1808]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1809]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1810]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1811]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1812]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1813]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1814]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1815]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1816]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'so the BirthdaysTableViewController declaration should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1817]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1818]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1819]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1820]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1821]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1822]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1823]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1824]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1825]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1826]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1827]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1828]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1829]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1830]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1831]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1832]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1833]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1834]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1835]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1836]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can remove two sections in the *BirthdaysTableViewController.swift*
    file. Remove all of the code below and including the comment // MARK: -AddBirthdayViewControllerDelegate
    because AddBirthdayViewControllerDelegate no longer exists and its methods will
    never be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1837]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1838]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1839]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1840]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1841]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1842]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1843]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1844]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1845]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1846]'
  prefs: []
  type: TYPE_PRE
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1847]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1848]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1849]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1850]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1851]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1852]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1853]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1854]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then take a look at the Navigation section. In the prepare(for:sender:) function,
    all we are doing is setting the Birthdays table view controller as the delegate
    for the Add Birthday view controller. This is no longer necessary, so we can get
    rid of this method and the entire // MARK: - Navigation section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1855]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1856]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1857]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1858]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1859]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1860]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1861]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1862]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1863]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1864]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1865]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1866]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1867]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1868]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1869]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1870]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the properties in the Birthday NSManagedObject class are optionals, we’ll
    need to unwrap them before we can display a Birthday in UITableViewCell . Delete
    these two lines inside the method tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1871]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1872]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1873]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1874]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1875]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1876]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1877]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1878]'
  prefs: []
  type: TYPE_PRE
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1879]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1880]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1881]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1882]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1883]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1884]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next add the following to the same method, tableView(_:cellForRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1885]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1886]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1887]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1888]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1889]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1890]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1891]'
  prefs: []
  type: TYPE_PRE
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1892]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1893]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1894]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1895]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1896]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: We use the nil coalescing operator to set birthday.firstName as a constant firstName
    if it exists and to leave firstName as an empty string if there is no birthday.firstName
    ➊ . At ➋ , we do the same thing for lastName . Finally, to display the birthdate
    , we use optional binding in an if let statement to set the birthday.birthdate
    into a constant called date if it exists and to display this date in the cell.detailTextLabel
    at ➌ and ➍ . Note that at ➌ , we need to cast the NSDate birthdate to a Date object,
    which is easily done with as Date? . If the birthdate doesn’t exist, we just set
    the detailTextLabel?.text to an empty string ➎ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1897]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1898]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1899]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1900]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1901]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Now run your app and add some birthdays! Then stop the app and run it again.
    The birthdays you just added should show up the second time you run the app. They’ll
    stay in the app forever—that is, until you delete the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1902]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1903]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1904]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1905]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1906]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING MORE FEATURES TO OUR APP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1907]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1908]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1909]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1910]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1911]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Our app stores birthdays now, but it still seems incomplete. Even though our
    app does the basic thing we wanted it to do, it doesn’t function very well. For
    instance, the birthday list isn’t organized, so when a user wants to find a specific
    birthday, they have to search for it line by line. That’s annoying! And users
    can add as many birthdays as they want, but there isn’t any way for them to delete
    a birthday if they made a mistake. How frustrating!
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1912]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1913]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1914]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1915]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1916]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: To fix these issues, we’ll add more features to our app by building on top of
    our existing code. Once we’re done with that, you can even keep going and add
    more!
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1917]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1918]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1919]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1920]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1921]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHABETIZING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1922]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1923]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1924]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1925]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1926]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if the birthdays were in an alphabetical list? It’s very
    easy to have the fetchRequest return a sorted list of objects. To return an alphabetized
    list of Birthday objects, add the following three lines to viewWillAppear(_:)
    right after the code where you create the fetchRequest :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1927]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1928]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1929]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1930]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1931]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1932]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1933]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1934]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1935]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1936]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1937]'
  prefs: []
  type: TYPE_PRE
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1938]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1939]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1940]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1941]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll alphabetize the list of Birthday objects first by last name and then by
    first name, in case some people have the same last names. An NSFetchedRequest
    comes with a property just for this purpose called sortDescriptors . This is an
    array of NSSortDescriptor objects. You use the NSSortDescriptor class to create
    a sortDescriptor , which orders a group of items for you. Each sortDescriptor
    has a *key* and a Boolean for whether the list should be ascending (true ) or
    not, in which case it would be descending (false ). The key is the attribute you
    want your objects to be sorted by. At ➊ , we create sortDescriptor1 and pass in
    lastName for the key. To sort the last names in alphabetical order from A to Z,
    we pass in true for ascending . Similarly, the line at ➋ creates sortDescriptor2
    to sort by firstName from A to Z. If we pass in a string data type as our key,
    Swift knows we want the strings sorted alphabetically. If we passed in "birthdate"
    instead, Swift would sort the birthdays by date from oldest to youngest. At line
    ➌ , we set the sortDescriptors on the fetchRequest to be an array with sortDescriptor1
    as the first element, followed by sortDescriptor2 . The sortDescriptors will be
    sorted in the order they are listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1942]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1943]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1944]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1945]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00255.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1946]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1947]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1948]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1949]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*[Figure 12-5](text00023.html#ch12fig5) : An alphabetical list of birthdays*'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1950]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1951]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1952]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1953]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and let’s see what you get! You should see your friends’ birthdays
    in an alphabetized list like the one shown in [Figure 12-5](text00023.html#ch12fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1954]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1955]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1956]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1957]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Can you change the order of the list so that it’s sorted by the birthdates instead?
    Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1958]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1959]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1960]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1961]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1962]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1963]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1964]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1965]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING BIRTHDAYS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1966]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1967]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1968]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1969]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: If you get a birthday wrong, it would be nice to be able to remove it and then
    add it back in again with the correct information. Let’s add the capability to
    remove a birthday now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1970]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1971]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1972]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1973]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BirthdaysTableViewController class, we left in two commented-out methods
    toward the bottom of the file: tableView(_:canEditRowAt:) and tableView(_:commit:forRowAt:)
    . These methods allow us to enable the built-in “swipe to delete” functionality
    of a table view. We’ll make it so that when you run BirthdayTracker and look at
    a list of birthdays, you’ll be able to put your finger on one and slide to the
    left. This action will reveal a Delete button like the one shown in [Figure 12-6](text00023.html#ch12fig6)
    that you can tap to remove the birthday from the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1974]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1975]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1976]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1977]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment the methods tableView( _:canEditRowAt:) and tableView(_:commit :forRowAt:)
    by removing the /* and */ that surround them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1978]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1979]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1980]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1981]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that the method tableView(_:canEditRowAt:) returns true . This
    just means that you’ll be able to edit the table or, in our case, remove rows.
    If you have it return false , then you won’t be able to swipe the table to remove
    a row. The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1982]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1983]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1984]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1985]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1986]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1987]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1988]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1989]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-6: Swiping left to remove a birthday from BirthdayTracker*'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1990]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1991]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1992]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1993]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1994]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1995]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1996]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1997]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1998]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1999]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2000]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2001]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll have to add some code to the method tableView(_:commit:forRowAt:) to
    actually remove the row from the table and also remove the Birthday object from
    the database and the birthdays array. If you only removed the row from the table
    view, then the computer would be confused because the number of rows in the table
    would no longer match birthdays.count and the app would crash. First, remove the
    following lines that were provided by Xcode in tableView(_:commit:forRowAt:) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2002]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2003]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2004]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2005]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2006]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2007]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2008]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2009]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2010]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2011]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we first do a safety check to make sure that the birthdays array has
    at least as many birthdays in it as the row number of the indexPath that we are
    trying to remove. To do this, we use the > operator, not the >= operator, because
    the birthdays.count must be greater than indexPath.row . For example, if the birthdays
    array only has two birthdays and we are trying to get the birthday at birthdays[2]
    , which would be the third birthday, then the app will crash. Remember that the
    rows of indexPath start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2012]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ sets the birthday at the correct index in the birthdays array
    to birthday so that it can be deleted. Then we access the managed object context
    of the application delegate at ➌ and ➍ . At ➎ , the object gets deleted from the
    context. When we delete the object from the database, we also want to make sure
    to delete it from the birthdays array of the Birthdays table view controller ➏
    . Finally, the method deleteRows(at:with:) ➐ takes two parameters, an array of
    NSIndexPath s to know which rows to remove and a type of UITableViewRowAnimation
    . The animation specifies how you want the rows to look when they are being removed.
    You can choose from the options none, bottom, top, left, right, middle, or fade.
    We want to remove only the row that we deleted with a fade-out animation. To do
    this, we pass in an array with our indexpath as the first parameter enclosed with
    square brackets, [indexpath] , and .fade as our second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2013]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and delete some of your birthdays. You should see the rows removed
    from the table. However, if you quit the app and then run it again, the deleted
    birthdays reappear. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2014]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you deleted the birthdays from the managed object context, but those
    changes were not automatically saved. Whenever you add, update, or remove objects
    in the context, you also need to save the context or the changes won’t stay on
    the device. Remember that the context is like a computer document that needs to
    be saved. To do that, add the following lines right after you remove the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2015]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2016]'
  prefs: []
  type: TYPE_PRE
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Those lines should look familiar since they’re the same lines that saved the
    managed object context after you added a Birthday in the Add Birthday view controller.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: This time when you run the app and delete a Birthday , it should stay deleted!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to save, fetch, and remove Birthday objects
    in a database using the Core Data framework so that your birthdays will be there
    every time you run your app. Your birthdays also now display in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](text00024.html#ch13) , we’ll show you how to use local notifications
    to ping users on their friends’ birthdays.
  prefs: []
  type: TYPE_NORMAL
