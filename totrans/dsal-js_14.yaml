- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 11 BAGS, SETS, AND MAPS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11 袋、集合和映射
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In this chapter we’ll consider some widely used abstract data types (ADTs):
    bags, sets, and maps. A *bag* is just a collection of values (repeated or not),
    a *set* is a collection of *distinct* values, and a *map* is a set of key + data
    pairs. We’ll consider some new ways of implementing these ADTs, starting with
    JavaScript’s own objects, and then move on to bitmaps, lists, and *hashing*, a
    new method we haven’t yet explored.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑一些广泛使用的抽象数据类型（ADT）：袋、集合和映射。*袋*只是一个值的集合（无论是否重复），*集合*是一个*不同*值的集合，*映射*是由键+数据对组成的集合。我们将考虑一些实现这些ADT的新方法，从JavaScript的对象开始，然后继续讨论位图、列表和*哈希*，这是一种我们尚未探索过的新方法。
- en: Introducing Bags, Sets, and Maps
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入袋、集合和映射
- en: In [Chapter 3](chapter3.xhtml) we defined the ADT for bags with the set operations
    shown in [Table 11-1](chapter11.xhtml#tab11-1). (The use of the word *set* in
    this context is fully correct according to its mathematical definition.) When
    you need to store many (possibly repeated) values, you need a bag.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](chapter3.xhtml)中，我们定义了袋的抽象数据类型（ADT），并展示了[表11-1](chapter11.xhtml#tab11-1)中的集合操作。（在此上下文中使用“*集合*”一词完全符合其数学定义。）当你需要存储许多（可能重复的）值时，你需要一个袋。
- en: 'Table 11-1: Operations on Bags'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-1：袋的操作
- en: '| Operation | Signature | Description |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → bag | Create a new bag. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → bag | 创建一个新袋。 |'
- en: '| Empty? | bag → boolean | Given a bag, determine whether it is empty. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 空吗？ | bag → boolean | 给定一个袋，判断它是否为空。 |'
- en: '| Add | bag × value → bag | Given a new value, add it to the bag. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | bag × value → bag | 给定一个新值，添加到袋中。 |'
- en: '| Remove | bag × value → bag | Given a value, remove it from the bag. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | bag × value → bag | 给定一个值，从袋中删除它。 |'
- en: '| Find | bag × value → boolean | Given a value, check whether it exists in
    the bag. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | bag × value → boolean | 给定一个值，检查它是否存在于袋中。 |'
- en: In [Chapter 3](chapter3.xhtml) we had an extra operation to retrieve the greatest
    value from the bag, but that won’t be considered here because it’s not standard.
    You could also have an operation to find the current size of the bag, and possibly
    some more, but these are enough.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](chapter3.xhtml)中，我们有一个额外的操作来获取袋中的最大值，但在这里不考虑这个操作，因为它不是标准操作。你也可以有一个操作来查找袋的当前大小，可能还有其他一些操作，但这些已经足够。
- en: In some cases you want an actual set, so you don’t want to allow for repeated
    values, and that restriction calls for a slightly different set of operations,
    as shown in [Table 11-2](chapter11.xhtml#tab11-2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要一个实际的集合，因此你不想允许重复值，这种限制需要一组略有不同的操作，如[表11-2](chapter11.xhtml#tab11-2)所示。
- en: 'Table 11-2: Operations on Sets'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-2：集合的操作
- en: '| Operation | Signature | Description |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → set | Create a new set. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → set | 创建一个新集合。 |'
- en: '| Empty? | set → boolean | Given a set, determine whether it is empty. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 空吗？ | set → boolean | 给定一个集合，判断它是否为空。 |'
- en: '| Add | set × value → set &#124; error | Given a new value, add it to the set.
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | set × value → set &#124; 错误 | 给定一个新值，添加到集合中。 |'
- en: '| Remove | set × value → set | Given a value, remove it from the set. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | set × value → set | 给定一个值，从集合中删除它。 |'
- en: '| Find | set × value → boolean | Given a value, check whether it exists in
    the set. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | set × value → boolean | 给定一个值，检查它是否存在于集合中。 |'
- en: All operations are the same, except that when you try to add a new value and
    find that it is already there, you’ll do something different. One possibility
    is just to ignore the situation (after all, if you want to include a value in
    the set and the value is already there, everything is fine), or you could throw
    an error or perform some other action. You could always test beforehand whether
    the value to be added is in the set already, but it’s usually more efficient to
    do it when adding.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都是相同的，唯一的区别是，当你尝试添加一个新值并发现它已经存在时，你会做出不同的处理。一个可能的做法是直接忽略这种情况（毕竟，如果你想将一个值包含在集合中，而该值已经存在，那一切都正常），或者你可以抛出错误或执行其他操作。你也可以事先检查要添加的值是否已经存在于集合中，但通常在添加时进行检查更高效。
- en: Finally, in some cases you’ll want to store key + data pairs. For example, for
    an application that uses information about countries, the key might be an ISO
    3166 country code (such as CH for Switzerland, TV for Tuvalu, or UY for Uruguay),
    and the data could be the country name, its population, and so on. Having implemented
    sets, implementing maps is simple. Instead of storing single values, you would
    store objects with key + data and make changes so *find* and *remove* work with
    just keys; the former returns the data if found instead of a boolean. See [Table
    11-3](chapter11.xhtml#tab11-3) for all operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在某些情况下，你可能想要存储键+数据对。例如，对于一个使用国家信息的应用程序，键可能是 ISO 3166 国家代码（例如瑞士的 CH、图瓦卢的 TV
    或乌拉圭的 UY），数据可能是国家名称、人口等等。实现了集合之后，实现映射就很简单。你只需要存储带有键+数据的对象，并进行更改，使得*查找*和*删除*仅使用键来工作；前者如果找到，则返回数据而不是布尔值。有关所有操作，请参见[表
    11-3](chapter11.xhtml#tab11-3)。
- en: 'Table 11-3: Operations on Maps'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-3：映射的操作
- en: '| Operation | Signature | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → map | Create a new map. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → map | 创建一个新的映射。 |'
- en: '| Empty? | map → boolean | Given a map, determine if it is empty. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 是否为空？ | map → boolean | 给定一个映射，确定它是否为空。 |'
- en: '| Add | map × (key + data) → map &#124; error | Given a new key + data, add
    it to the map. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | map × (key + data) → map &#124; 错误 | 给定一个新的键+数据，将其添加到映射中。 |'
- en: '| Remove | map × key → map | Given a key, remove it from the map. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | map × key → map | 给定一个键，从映射中删除它。 |'
- en: '| Find | map × key → data &#124; undefined | Given a key, check whether it
    exists in the map, and if found, return the data or undefined instead. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | map × key → data &#124; undefined | 给定一个键，检查它是否存在于映射中，如果找到，返回数据或 undefined。
    |'
- en: All of these changes are fairly straightforward to do, so we’ll work with plain
    bags and sets. Let’s now consider specific implementations, starting with JavaScript’s
    own.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些更改都非常简单，所以我们将使用普通的袋和集合。现在让我们考虑具体的实现，从 JavaScript 自身的实现开始。
- en: JavaScript’s Solutions for Sets
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 的集合解决方案
- en: 'You learned how to implement a bag in [Chapter 3](chapter3.xhtml) using several
    different methods. With a few changes, you can implement sets instead of bags;
    all you need to do is before adding a new value, check whether it was already
    present. In this section we’ll consider two more ways to implement sets in JavaScript:
    using plain objects (which is not the best way) and using standard set objects.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第 3 章](chapter3.xhtml)中学到了如何使用几种不同的方法实现一个袋（bag）。只需做一些更改，你就可以实现集合而不是袋；你需要做的就是在添加一个新值之前，检查它是否已经存在。在本节中，我们将考虑使用
    JavaScript 实现集合的另外两种方式：使用普通对象（这不是最好的方式）和使用标准集合对象。
- en: Objects as Sets
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对象作为集合
- en: 'Even if objects aren’t designed to be used as sets (or maps), many developers
    use plain objects for them. If you can use values as attributes (mostly strings
    or numbers converted to strings), you can use them as property names:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对象并非设计为集合（或映射），许多开发人员仍然使用普通对象作为集合。如果你可以将值作为属性（通常是字符串或转换为字符串的数字），你就可以将它们用作属性名称：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In plain JavaScript, creating an object means assigning an empty object ❶ and
    adding values to it ❷. Here, you now have a set with two keys: one and two. (If
    you want a map, the values associated with those keys are the data.)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通 JavaScript 中，创建一个对象意味着分配一个空对象 ❶ 并向其中添加值 ❷。在这里，你现在有一个包含两个键的集合：one 和 two。（如果你想要一个映射，则这些键所关联的值就是数据。）
- en: 'You can test whether a key is in the object with the in operator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 in 操作符测试一个键是否在对象中：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, you can use delete to remove a key:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用 delete 来删除一个键：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As extra operations, you can get a list of all an object’s attributes with Object.keys(...),
    and you can even iterate over them with for...in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的操作，你可以使用 Object.keys(...) 获取对象的所有属性列表，甚至可以使用 for...in 对它们进行迭代。
- en: Using plain JavaScript objects obviously works, but you probably will want to
    make your intentions clearer for more understandable code and use a proper set,
    which, after all, directly represents the data structure you want.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用普通的 JavaScript 对象显然是可行的，但你可能更想让代码更具可读性，明确表达你的意图，使用一个合适的集合，它毕竟直接代表了你想要的数据结构。
- en: Set Objects
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合对象
- en: 'Sets are objects that let you store unique values. Creating a new JavaScript
    set and adding a couple of values is straightforward; try redoing the examples
    from the previous section:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是让你存储唯一值的对象。创建一个新的 JavaScript 集合并添加几个值是很简单的；试着重新做一下上一节的例子：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a set by producing a new instance of the Set class ❶ and add values
    to it with its .add(...) method ❷. By the way, you can chain calls, so you can
    write those two additions on a single line:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个新的 Set 类实例 ❶ 来创建集合，并使用其 .add(...) 方法 ❷ 向集合中添加值。顺便说一下，你可以链式调用，因此可以将这两个添加操作写在同一行：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To test whether a value is in the set, use a .has(...) method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试某个值是否在集合中，使用 .has(...) 方法：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, you can remove values with the .delete(...) method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用.delete(...)方法删除值：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: JavaScript’s sets have a couple of extra interesting methods. To remove all
    values, you can use set.clear(). You also can find the number of elements in a
    set using the .size property.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的集合有一些额外有趣的方法。要删除所有值，可以使用 set.clear()。你还可以使用 .size 属性来查找集合中的元素数量。
- en: Bitmaps
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位图
- en: In some cases you can implement sets by making do with bitmaps (recall the bitmap
    sort from [Chapter 6](chapter6.xhtml)). If the values to store are numbers with
    a restricted range of values, an array of boolean flags will suffice.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可以通过使用位图来实现集合（回想一下[第 6 章](chapter6.xhtml)中的位图排序）。如果要存储的值是具有有限范围的数字，使用布尔标志数组就足够了。
- en: We won’t see the code here, as it’s directly based upon the sorting you learned
    in [Chapter 6](chapter6.xhtml). The main idea is to set up an array filled with
    false values. The index to that array is the value itself. To add a value, set
    its flag to true; to remove it, reset its flag to false. Finally, to test whether
    a value is in the set, check the corresponding flag. You can’t do any better.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会看到代码，因为它直接基于你在[第 6 章](chapter6.xhtml)中学习的排序方法。主要思路是设置一个充满 false 值的数组，数组的索引就是值本身。要添加一个值，将其标志设置为
    true；要删除它，将其标志重置为 false。最后，要测试某个值是否在集合中，检查对应的标志。没有比这更简单的方法了。
- en: '### Using Lists'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用列表'
- en: 'We discussed lists in [Chapter 10](chapter10.xhtml), and you can adapt them
    to work as bags or sets. Consider three distinct possibilities:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 10 章](chapter10.xhtml)中讨论了列表，你可以将其改编为袋子或集合。考虑三种不同的可能性：
- en: '**Ordered lists **Plain lists that keep their values in ascending order'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**有序列表** 保持值按升序排列的普通列表'
- en: '**Skip lists **Two-dimensional structures with fast searches'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳表** 二维结构，具有快速搜索功能'
- en: '**Self-organizing lists **Interesting applications that work for caches and
    similar situations'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**自组织列表** 适用于缓存等类似情况的有趣应用'
- en: Note that some of the solutions you’ll consider in the “Hashing” section on
    page 218 will also use lists.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你在第 218 页“哈希”部分中考虑的一些解决方案也会使用列表。
- en: Ordered Lists
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有序列表
- en: 'As mentioned in [Chapter 10](chapter10.xhtml), the concept of an ordered list
    is simple: instead of always adding values at one extreme or the other, you’ll
    add them so the values remain in order. This practice slows down insertions (you
    have to look for the right place to add the new value), but it makes for faster
    searches on average (when you reach a higher value than the one you wanted, you
    can stop the search). Take a look at the implementation.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 10 章](chapter10.xhtml)中所述，有序列表的概念很简单：你不会总是将值添加到列表的两端，而是将它们按顺序添加。这个做法会减慢插入速度（因为你需要找到正确的插入位置），但它使得搜索平均速度更快（当你遇到一个比目标值大的值时，可以停止搜索）。来看一下实现方法。
- en: Searching for a Value in an Ordered List
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在有序列表中查找值
- en: 'The logic for searching is as direct as it gets: start at the beginning and
    follow the links until you reach the value or learn that the value isn’t there,
    because you either reached the end of the list or found a greater value than the
    one you wanted. [Figure 11-1](chapter11.xhtml#fig11-1) shows how you’d (successfully)
    look for value 22 in an ordered list.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索逻辑非常直接：从头开始，沿着链接查找，直到找到目标值或者确认该值不存在，因为你要么到达了列表的末尾，要么遇到了比目标值更大的值。[图 11-1](chapter11.xhtml#fig11-1)展示了如何在有序列表中（成功地）查找值
    22。
- en: '![](../images/Figure11-1.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-1.jpg)'
- en: 'Figure 11-1: A successful search for a value (22) in a list'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：在列表中成功查找值（22）
- en: This works the same way as linear searching ([Chapter 9](chapter9.xhtml)). Start
    at the head of the list and keep going. In this case you found the value you wanted,
    so you succeeded. If you were searching for 20 instead, at this same point you’d
    have given up the search. If you reach a value that’s higher than what you wanted,
    the search has failed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这与线性查找方式相同（见[第 9 章](chapter9.xhtml)）。从列表的头部开始，持续查找。在这种情况下，你找到了你想要的值，因此搜索成功。如果你原本要查找的是
    20，那么在这个点你就会放弃搜索。如果遇到一个比目标值更大的值，搜索就失败了。
- en: The other possibility for failure is searching past the end of the list; see
    [Figure 11-2](chapter11.xhtml#fig11-2), which shows a search for 86.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种失败的可能性是查找超出了列表的末尾；请参见[图11-2](chapter11.xhtml#fig11-2)，它展示了查找值86的过程。
- en: '![](../images/Figure11-2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-2.jpg)'
- en: 'Figure 11-2: A failed search for a value (86) in a list'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2：在列表中查找失败的值（86）
- en: 'The code for a linear search is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 线性查找的代码如下：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you got an empty list—either it was empty from the beginning or you traveled
    down it and reached its end (you saw the code for this in [Chapter 10](chapter10.xhtml))—you
    know the value isn’t there. It also isn’t there if the list isn’t empty but its
    first value is greater than the value you’re seeking ❶. If the list isn’t empty
    and its first element matches the value you want ❷, the value was found. Finally,
    if the list isn’t empty and the value you want is greater than the first element
    of the list ❸, continue the search starting at the next node of the list.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到了一个空列表——无论它是一开始就是空的，还是你遍历到它并到达了末尾（你在[第10章](chapter10.xhtml)中看到过这段代码）——你知道值不在其中。如果列表不为空，但其第一个值大于你正在寻找的值
    ❶，那么值也不在其中。如果列表不为空且第一个元素与你想要的值相等 ❷，那么值就找到了。最后，如果列表不为空并且你要找的值大于列表的第一个元素 ❸，则从列表的下一个节点继续查找。
- en: Adding a New Value to an Ordered List
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向有序列表中添加新值
- en: To add a new value, first do a search until you reach the place where the new
    value should go (meaning between a node with a smaller value and a node with a
    greater one), and then change a couple of pointers to include the new value in
    the list. [Figure 11-3](chapter11.xhtml#fig11-3) shows how to add 20 to the list.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个新值，首先进行查找，直到找到新值应该放置的位置（也就是说，在一个较小值的节点和一个较大值的节点之间），然后更改几个指针以将新值包含到列表中。[图11-3](chapter11.xhtml#fig11-3)展示了如何将20添加到列表中。
- en: '![](../images/Figure11-3.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-3.jpg)'
- en: 'Figure 11-3: Adding a new value (20) to an ordered list'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-3：向有序列表中添加新值（20）
- en: 'If you want to add a value that’s smaller than the one at the head of the list,
    you’ll need to change the pointer to the list itself. Another border case is adding
    a value greater than the last one in the list; you have to be careful when going
    down the list. You can use recursion to implement all of these cases more easily:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要添加一个比列表头部值小的值，你需要更改列表本身的指针。另一个边界情况是添加一个大于列表中最后一个值的值；你在遍历列表时需要小心。你可以使用递归来更轻松地实现所有这些情况：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The logic is similar to what you saw for the linear search. If the list is empty,
    or if it’s not empty but the first value is greater than the one you want to add
    ❶, create a single node with the new value whose next pointer points to the list
    you had. (This covers the case of adding a value past the end; can you see how?)
    If you want to make a set, add a test ❷, because if you find the value you want
    to add, you would throw an error or otherwise reject the operation. If you’re
    making a bag and the value to add is greater than the first of the list ❸, add
    it using recursion, after the first element.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这一逻辑与你在进行线性查找时看到的类似。如果列表为空，或者列表不为空但第一个值大于你想要添加的值 ❶，则创建一个新的节点，其值为新值，且其下一个指针指向你原来的列表。（这涵盖了将值添加到列表末尾的情况；你能理解吗？）如果你想创建一个集合，添加一个测试
    ❷，因为如果你找到你想添加的值，则会抛出错误或拒绝此操作。如果你在创建一个袋子，并且要添加的值大于列表中的第一个值 ❸，则使用递归在第一个元素之后添加它。
- en: Removing a Value from an Ordered List
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从有序列表中删除值
- en: Removing a value is a matter of finding it (which you already know how to do)
    and then modifying its predecessor’s link to point at the next value, as shown
    in [Figure 11-4](chapter11.xhtml#fig11-4).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个值的过程是找到它（你已经知道如何做），然后修改它的前一个节点的链接，使其指向下一个值，正如[图11-4](chapter11.xhtml#fig11-4)所示。
- en: '![](../images/Figure11-4.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-4.jpg)'
- en: 'Figure 11-4: Removing the value (22) from an ordered list'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-4：从有序列表中删除值（22）
- en: 'As mentioned, do a search, and if it’s successful, skip the value to be removed.
    The only unusual case is when you delete the head of the list, you need to modify
    the pointer to the list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，进行一次查找，如果成功，则跳过要删除的值。唯一不同的情况是当你删除列表头部时，需要修改指向列表的指针：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The logic fully matches the search, case by case. It’s also logical; you must
    first find the value before you can remove it from the list. If the list is empty
    or if its first value is greater than the value ❶, return the list as-is, because
    there’s nothing to remove. If the value to remove is at the head of the list ❷,
    return the list’s tail, skipping the value to be removed. Finally, if the value
    to be removed is greater than the head of the list ❸, proceed recursively to delete
    the value from the tail of the list and return the (updated) list.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑完全匹配搜索，逐个处理。它也是合乎逻辑的；您必须先找到该值，才能从列表中删除它。如果列表为空，或其第一个值大于要删除的值❶，则返回原列表，因为没有需要删除的内容。如果要删除的值位于列表头部❷，则返回列表的尾部，跳过要删除的值。最后，如果要删除的值大于列表头部的值❸，则递归地从列表尾部删除该值，并返回（更新后的）列表。
- en: Considering Performance for Ordered Lists
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考虑有序列表的性能
- en: There’s no way to speed up any of the processes, and if the list has *n* nodes,
    all functions are *O*(*n*). On average, all operations will visit half the nodes
    of the list. This implementation is good enough for small values of *n*, but for
    larger values, you’ll need something that allows you to move faster through the
    list—and in the next section we’ll see just that.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 无法加速任何过程，如果列表有*n*个节点，所有功能都是*O*(*n*)。平均来说，所有操作都会访问列表的一半节点。这个实现对于小值*n*已经足够好，但对于较大的值，您需要一种能够让您更快速地遍历列表的方法——接下来的章节将展示这种方法。
- en: Skip Lists
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跳跃列表
- en: As just mentioned, searching a list is an *O*(*n*) process, because there’s
    no way to speed things up and move faster. However, you can take a tip from the
    jump search method ([Chapter 9](chapter9.xhtml)). What would happen if you could
    take long jumps to skip many places quickly, and when you get closer to the needed
    value, start doing smaller jumps, and then even smaller ones, until you finish
    with a one-by-one search? In this section we’ll consider *skip lists*, which allow
    you to traverse a list much more quickly by providing ways to skip ahead faster.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，搜索一个列表是一个*O*(*n*)过程，因为没有办法加速，无法更快地移动。然而，您可以借鉴跳跃搜索方法（见[第9章](chapter9.xhtml)）。如果您能进行长跳跃，快速跳过许多位置，而当接近所需值时，开始进行更小的跳跃，再逐渐减小跳跃，直到最后进行逐一搜索，会发生什么呢？在本节中，我们将讨论*跳跃列表*，它通过提供更快的跳跃方式，使您能够更快速地遍历列表。
- en: Consider an ordered list as shown in [Figure 11-5](chapter11.xhtml#fig11-5)
    (for clarity, I haven’t included the arrows; all go from left to right).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如[图11-5](chapter11.xhtml#fig11-5)所示的有序列表（为了清晰起见，我没有包含箭头；所有箭头都从左到右）。
- en: '![](../images/Figure11-5.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-5.jpg)'
- en: 'Figure 11-5: Searching a long list is logically slower.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-5：搜索长列表在逻辑上较慢。
- en: As is, you can’t jump quickly as with a jump search, but with an auxiliary second
    list, doing so is possible, as shown in [Figure 11-6](chapter11.xhtml#fig11-6)
    (the vertical lines indicate pointers from top to bottom).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，您不能像跳跃搜索那样快速跳跃，但通过辅助的第二个列表，完全可以做到这一点，如[图11-6](chapter11.xhtml#fig11-6)所示（垂直线表示从上到下的指针）。
- en: '![](../images/Figure11-6.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-6.jpg)'
- en: 'Figure 11-6: Adding a second list to advance faster when searching the list'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-6：通过添加第二个列表加速列表搜索
- en: If you wanted to search for 42, you’d start at the topmost list and move right
    until you get past 42; then you’d go back and down and continue the search (see
    [Figure 11-7](chapter11.xhtml#fig11-7)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查找42，您将从最顶层的列表开始，向右移动，直到超过42；然后您会回退并向下继续搜索（见[图11-7](chapter11.xhtml#fig11-7)）。
- en: '![](../images/Figure11-7.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-7.jpg)'
- en: 'Figure 11-7: Searching for a value (42) with the aid of the second list'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-7：借助第二个列表查找值（42）
- en: The topmost list, which includes only a few values of the bottom list, allows
    you to make longer jumps, so the searches are speedier. Of course, for even faster
    processes, you could have three or more levels, as shown in [Figure 11-8](chapter11.xhtml#fig11-8).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最顶层的列表仅包含底层列表中的少数几个值，它允许您进行更长的跳跃，因此搜索速度更快。当然，为了实现更快的过程，您可以拥有三个或更多层次，如[图11-8](chapter11.xhtml#fig11-8)所示。
- en: '![](../images/Figure11-8.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-8.jpg)'
- en: 'Figure 11-8: A third list helps speed up the search even more.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-8：第三个列表有助于进一步加速搜索。
- en: This works well and provides better expected performance of *O*(log *n*). However,
    having all of these lists with repeated values everywhere isn’t good in practice.
    It would be better to have each value only once in a node with several pointers,
    according to the different levels, as shown in [Figure 11-9](chapter11.xhtml#fig11-9).
    (In reality, all nodes could have the same number of pointers, but [Figure 11-9](chapter11.xhtml#fig11-9)
    shows only the used ones.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法效果很好，并且提供了更好的期望性能 *O*(log *n*)。然而，实际操作中，在每个地方都有重复值的这些列表并不好。根据不同的层次，将每个值仅在一个节点中出现，并且节点有多个指针（如图
    [11-9](chapter11.xhtml#fig11-9) 所示）会更好。（实际上，所有节点可能具有相同数量的指针，但图 [11-9](chapter11.xhtml#fig11-9)
    仅显示了使用的指针。）
- en: '![](../images/Figure11-9.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-9.jpg)'
- en: 'Figure 11-9: An actual implementation of skip lists, with several pointers
    per node'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-9：跳表的实际实现，每个节点有多个指针
- en: We’ll use this style of search to simplify our work. We’ll also add some sentinel
    nodes at the beginning and end of the lists to simplify all logic. You won’t ever
    have cases like “adding at the beginning” or “adding at the end,” because no value
    can be lower than the first sentinel or higher than the last one. Also, you won’t
    have to deal with empty lists (at least the sentinels will be there), and you’ll
    never go past the last item of a list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这种搜索方式来简化我们的工作。我们还会在列表的开始和结束添加一些哨兵节点，以简化所有逻辑。您不会遇到“在开头添加”或“在结尾添加”之类的情况，因为没有任何值可以比第一个哨兵小或比最后一个哨兵大。此外，您也不必处理空列表（至少哨兵会存在），而且您永远不会超出列表的最后一个项目。
- en: Creating a Skip List
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建跳表
- en: 'An empty list will consist of a node with two sentinels: a minus infinity value
    and a single level with a plus infinity value. Implementing it is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表将由一个包含两个哨兵的节点组成：一个负无穷值和一个仅有一个正无穷值的单一层。其实现如下：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You have a list with just two values: -Infinity first and Infinity last. (You
    are working with numeric values here; for strings, you’d have to use appropriate
    low and high strings.) The skip list is flat, having just one level. (No next
    array has more than one element.) Knowing this, testing whether a skip list is
    empty is a tad more complex:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个只有两个值的列表：-Infinity 位于第一个，Infinity 位于最后。（这里您处理的是数值，对于字符串，您需要使用合适的低值和高值字符串。）跳表是平坦的，只有一层。（没有任何下一个数组有超过一个元素。）了解这一点后，测试跳表是否为空就稍微复杂一些：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If a skip list doesn’t have any values added to it, you’ll have the initial
    configuration, so your sentinels will be on the bottom level. In this data structure,
    the only value that has a null pointer to the next is the +Infinity sentinel;
    all other nodes have non-null pointers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果跳表中没有任何值，您将拥有初始配置，因此您的哨兵将位于底层。在这个数据结构中，唯一指向下一个节点的指针为 null 的是 +Infinity 哨兵；所有其他节点的指针都不是
    null。
- en: 'You can find how many levels a skip list has by simply looking at the length
    of the next arrays. Another function that will come in handy just returns the
    last index of the array of pointers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过简单地查看下一个数组的长度来判断跳表有多少层。另一个有用的函数只需返回指针数组的最后一个索引：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You have to subtract 1 because the array of pointers is zero indexed, as usual.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要减去 1，因为指针数组是从零开始索引的，像往常一样。
- en: Searching for a Value in a Skip List
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在跳表中搜索一个值
- en: You saw the general idea for searches earlier, but now consider how they’d work
    with the actual implementation. Searches begin at the topmost level and advance
    to the right unless they go past the searched-for value, in which case they go
    down a level. If there are no more levels, the search is a failure.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前已经看到了搜索的基本思路，但现在请考虑它们如何在实际实现中工作。搜索从最上层开始，向右推进，除非超出要搜索的值，在这种情况下，它会向下移到下一层。如果没有更多的层次，搜索将失败。
- en: 'The code isn’t very long, but dealing with multiple levels requires care:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码并不长，但处理多个层次需要小心：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’ll use an auxiliary recursive function for the search. This function has
    three arguments: a node (somewhere in the skip list), the level at which it is
    searching, and the value to find ❶. If you try to go below level 0 ❷, you’ve failed,
    as you were at the bottom level and couldn’t find the value there. If the node
    has the value that you want ❸, the search succeeded. If the value you want is
    greater than or equal to the next value at the same level ❹, keep going without
    changing level. Otherwise, if you’ve already reached a higher value ❺, go down
    to the next level. The implementation of a general search ❻ starts at the first
    node at the top level.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个辅助的递归函数进行搜索。这个函数有三个参数：一个节点（跳表中的某个位置）、它正在搜索的层级，以及要查找的值❶。如果你尝试搜索低于第0层❷的地方，表示搜索失败，因为你已经到了底层，无法在该层找到值。如果节点有你想要的值❸，则表示搜索成功。如果你想要的值大于或等于该层级下一个值❹，则继续前进而不改变层级。否则，如果你已经遇到一个更大的值❺，则下降到下一层级。一般搜索的实现❻是从顶层的第一个节点开始的。
- en: '##### Adding a Value to a Skip List'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 向跳表中添加一个值'
- en: We haven’t really discussed how to decide what values go at which levels. The
    solution we’ll use is based on random numbers. Obviously, all values will be at
    the bottom level, but they all won’t be at the other levels. We’ll decide whether
    a new value goes up one level by “flipping a coin”; we want approximately 50 percent
    of values to be in the next level. We’ll keep deciding randomly whether to move
    the value up one more level until the flip fails or you get a maximum level. In
    the code that follows, set MAX_LEVEL to 32, which implies that, on average, one
    value out of 2^(³²) will go that high—a really big structure!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有真正讨论如何决定哪些值放在哪些层级。我们将采用基于随机数的解决方案。显然，所有值都会处于最底层，但并不是所有值都会出现在其他层级。我们将通过“抛硬币”来决定一个新值是否上升一层；我们希望大约50%的值能出现在下一级层级。我们会继续随机决定是否再将该值提升一层，直到抛硬币失败或者达到最大层级。在接下来的代码中，设置MAX_LEVEL为32，这意味着平均每2^(³²)个值中，只有一个会达到这么高的层级——一个非常庞大的结构！
- en: 'We’ll require an auxiliary function to add a value at a certain level and all
    levels below it. An obvious question is why do you first add the value at a higher
    level and then at lower levels? Lists that are higher up have fewer elements,
    so insertions are faster there. Here’s the code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个辅助函数来在某一层级及其以下所有层级中添加一个值。一个显而易见的问题是，为什么要先在更高的层级添加值，然后再在较低的层级添加？因为更高层级的列表元素较少，所以在那里插入更快。以下是代码：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the new value is greater than the next value at this level ❶, you must advance;
    you’ll be able to add the new value when it lies between two consecutive values
    in the list. If you’re at a level lower than or equal to the maximum new level
    ❷, add the value and adjust the pointers to include the new value in the list
    ❸. Finally, if you haven’t reached bottom yet ❹, use recursion to add the value
    one level down ❺.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新值大于该层级下一个值❶，你必须前进；当新值位于两个连续值之间时，你就能将其添加到列表中。如果你处于一个低于或等于最大新层级的层级❷，则添加该值并调整指针，将新值包含到列表中❸。最后，如果你还没有到达底层❹，则使用递归将该值添加到下一层❺。
- en: 'With this function, adding a value is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，添加一个值的步骤如下：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, decide up to which level you’ll find the new node ❶. Going up one more
    level will depend on the “coin flip.” After deciding that ❷, create a node with
    the value and an array with the right number of pointers. There’s the possibility
    that you’re going “higher” than before ❸ and that the skip list will be taller.
    If so ❹, you’ll have to add new pointers to the rightmost value. After this is
    taken care of ❺, use the auxiliary function to add the value to all the corresponding
    lists.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，决定你要在哪个层级找到新节点❶。是否上升一层将取决于“抛硬币”的结果。决定好之后❷，创建一个带有该值的节点，并且创建一个包含正确数量指针的数组。如果你“上升”到了比之前更高的层级❸，跳表可能会变得更高。如果是这样的话❹，你需要为最右边的值添加新的指针。在解决了这个问题之后❺，使用辅助函数将该值添加到所有相应的列表中。
- en: Removing a Value from a Skip List
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从跳表中删除一个值
- en: 'Removing a value requires two steps: first, remove it from all the lists it’s
    in, which you’ll do with an auxiliary function, and than possibly make the skip
    list “shorter” because by removing the value, it may not be as tall as before.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个值需要两个步骤：首先，从它所在的所有列表中删除该值，你可以通过一个辅助函数来实现，然后可能需要使跳表“变短”，因为删除该值后，跳表可能不会像之前那样高。
- en: 'Here’s the logic for actually removing the value:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实际删除值的逻辑：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Advance down the list ❶ until you find where the value should be. If you actually
    found it ❷ (the user may be asking to remove a value that simply isn’t in the
    list), fix the pointers ❸. Then keep doing removals until you reach the bottom
    level ❹.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一直往下遍历列表❶，直到找到值应该在的位置。如果你实际上找到了它❷（用户可能要求移除一个根本不在列表中的值），修复指针❸。然后继续进行删除操作，直到到达最底层❹。
- en: 'Removing the value is the first step, as described; you may have to restructure
    multiple levels after that:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 移除值是第一步，如前所述；你可能需要在之后重构多个级别：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After removing the value ❶, go down all levels from the top ❷, and while the
    lists are basically empty (only the sentinels) ❸, you’ve made the list shorter
    ❹.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除值❶之后，从顶部❷开始逐级下降，尽管列表基本为空（只有哨兵节点）❸，你已将列表缩短❹。
- en: Considering Performance for Skip Lists
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考虑跳表的性能
- en: Skip lists are probabilistic in nature, and the average performance can be shown
    to be logarithmic (see [Table 11-4](chapter11.xhtml#tab11-4)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表的本质是概率性的，平均性能可以证明是对数级的（参见[表11-4](chapter11.xhtml#tab11-4)）。
- en: 'Table 11-4: Performance of Operations for Skip Lists'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-4：跳表操作的性能
- en: '| Operation | Average performance | Worst case |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 平均性能 | 最坏情况 |'
- en: '| --- | --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | O(1) | O(1) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) | O(1) |'
- en: '| Add | O(log n) | O(n) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log n) | O(n) |'
- en: '| Remove | O(log n) | O(n) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | O(log n) | O(n) |'
- en: '| Find | O(log n) | O(n) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | O(log n) | O(n) |'
- en: There is a quite low probability that the structure will behave badly (maybe
    having just a single level or having most values at all levels), but that’s not
    likely.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 结构表现不好的概率非常低（可能只有一个级别，或者大多数值分布在所有级别），但这种情况不太可能发生。
- en: As with hashing (which you’ll explore later in this chapter) and other structures,
    you can solve performance problems by restructuring the skip list; see question
    11.4 for a possible idea. You can also modify the list to allow retrieving a value
    by position; see question 11.5.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与哈希（你将在本章后面深入探讨）及其他结构类似，你可以通过重构跳表来解决性能问题；请参见问题11.4了解可能的思路。你也可以修改列表以允许通过位置检索值；参见问题11.5。
- en: Self-Organizing Lists
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自组织列表
- en: There’s a particular case for which you can use an “auto-modified” bag successfully.
    Think about a cache with a limited maximum size. It’s not infrequent that one
    may require a given element several times in a short interval and then for a long
    time may not require it at all. In that case you can use a self-organizing list
    that places the elements required most often near the beginning (for quicker searches)
    and the ones required less often near the end (allowing a slower search).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊情况，你可以成功地使用“自动修改”的包。考虑一个具有最大容量限制的缓存。常常会出现你在短时间内需要某个元素几次，而在较长时间内完全不需要它。在这种情况下，你可以使用一个自组织列表，将最常用的元素放在列表的前面（以便更快地搜索），而将较少使用的元素放在后面（允许较慢的搜索）。
- en: As an example, think of a mapping (Global Positioning System [GPS]–style) application.
    You can’t hold every street name in memory, but to optimize speed, you could have
    a small cache of street names. Traveling in a certain zone, one often requires
    a certain group of street names, and it’s more unlikely one will need to find
    streets much farther away. The idea of a self-organizing list is to always add
    new values at the front, and if you search for a value and find it, move it to
    the front with the idea that if you soon require it again, you’ll get to it in
    a few steps.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，想象一个映射（全球定位系统 [GPS] 风格）应用。你无法把每条街道名称都保存在内存中，但为了优化速度，你可以有一个小的街道名称缓存。在某个特定区域内旅行时，通常需要某一组街道名称，而且不太可能需要找到距离很远的街道。自组织列表的想法是始终将新值添加到前面，如果你搜索到一个值并找到了它，就把它移到前面，假设如果很快需要它，你可以通过几步操作找到它。
- en: Searching for a Value in a Self-Organizing List
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在自组织列表中搜索值
- en: Searching an unordered list is not hard; you just have to keep going until you
    either find the value or reach the end of the list. You saw how to do this kind
    of search in [Chapter 10](chapter10.xhtml) (see the section “Implementing Lists
    with Dynamic Memory” on page 180). The important detail is what to do if you find
    the element. Make it the head of the list and take it out of its original place.
    [Figure 11-10](chapter11.xhtml#fig11-10) shows an example search for 12.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索一个无序列表并不困难；你只需要一直进行下去，直到找到目标值或到达列表的末尾。你可以在[第10章](chapter10.xhtml)中看到如何进行这种搜索（参见第180页的“用动态内存实现列表”部分）。重要的细节是，如果找到了该元素该怎么做。将其设置为列表的头，并把它从原来的位置移除。[图11-10](chapter11.xhtml#fig11-10)展示了一个搜索12的示例。
- en: '![](../images/Figure11-10.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-10.jpg)'
- en: 'Figure 11-10: After a successful search in a self-organizing list, the found
    node is brought to the head of the list.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-10：在自组织列表中成功搜索后，找到的节点被移动到列表的头部。
- en: First, do a search for 12 (this is nothing new), but after finding it, there
    are some changes. Since the value wasn’t already at the head of the list, you’ll
    restructure the list so 12 is at the head, pointing to the old head of the list.
    If in the future you need to search for it again, those searches will be quite
    fast, because the value will be either at the head of the list or very close.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行一次搜索查找12（这没有什么新奇的），但在找到之后会有一些变化。由于该值原本不在列表的头部，你将重新结构化列表，使12位于头部，并指向旧的头部。如果将来你再次需要查找它，这些搜索将非常迅速，因为该值将位于列表的头部或者非常接近头部。
- en: 'The code is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you search now you’re also modifying the list, so you’ll have to return
    two values: the list itself (which was possibly updated if the value was found)
    and a boolean value with the result of the search. (Too much bother? See question
    11.3.) If the list is empty ❶, return the list and false, because trivially the
    value isn’t there. If the list isn’t empty and the value you want is at the list’s
    head ❷, you don’t have to change the list, so you return it as is, plus true because
    you succeeded. If the list isn’t empty and the value you want isn’t at the list’s
    head ❸, set up a loop in which prev and curr will point to consecutive nodes in
    the list. That loop will finish when either you get to the list’s end or you find
    the value you want ❹. In the case of the former condition ❺, return the list and
    a false value, just as when the list is empty ❶; if the latter ❻, change pointers
    and return the current node as the new list’s head, plus true.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行搜索时，你也在修改列表，因此你需要返回两个值：列表本身（如果找到值，可能已经更新）和一个布尔值表示搜索的结果。（太麻烦了？请参见问题11.3。）如果列表为空
    ❶，返回列表和 false，因为值显然不在其中。如果列表不为空，且你要找的值就在列表的头部 ❷，你不需要改变列表，因此直接返回它，并附带 true，表示成功。如果列表不为空，且你要找的值不在头部
    ❸，设置一个循环，其中 prev 和 curr 将分别指向列表中的连续节点。该循环会在以下两种情况之一结束：你要么到达列表末尾，要么找到了你要的值 ❹。在前一种情况
    ❺，返回列表和 false，就像列表为空时 ❶；如果是后一种情况 ❻，修改指针并返回当前节点作为新列表的头部，附带 true。
- en: Adding a Value to a Self-Organizing List
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向自组织列表中添加值
- en: 'Since these lists are unordered, you can add values anywhere, using the simple
    logic you’ve used before:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些列表是无序的，你可以将值添加到任何地方，使用你之前用过的简单逻辑：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Putting the new value at the top of the list, as its head, is as simple as can
    be. Make a new node that points to the old list ❶, and the new list has that node
    as its head. This code is functionally equivalent to the push(...) method that
    you wrote for stacks in [Chapter 10](chapter10.xhtml).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将新值放到列表的顶部作为头部是非常简单的。创建一个新的节点，指向旧的列表 ❶，新列表的头部就是这个新节点。这个代码与在[第10章](chapter10.xhtml)中为栈编写的
    push(...) 方法功能上是等效的。
- en: Removing a Value from a Self-Organizing List
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从自组织列表中删除值
- en: 'Earlier we saw how to remove a value from an ordered list. Doing the same with
    an unordered list is not very different, except that you may always have to go
    to the end of the list, because there’s no way to stop the search earlier. You
    already saw how to do the search in an iterative way, so now do this recursively:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到过如何从有序列表中删除一个值。从无序列表中删除的操作与此非常相似，唯一的区别是你可能总是需要遍历到列表的末尾，因为没有办法提前停止搜索。你已经学会了如何以迭代的方式进行搜索，现在可以用递归的方式来实现：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the list is empty ❶, just return it, because the value to be removed isn’t
    there. If the value you want to remove is the one the list points at ❷, returning
    the tail of the list (which list.next points to) causes the removal. Finally,
    if the head of the list doesn’t have the value you want ❸, make that node point
    to the result of removing the value from the tail of the list.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表为空 ❶，直接返回，因为要删除的值不在那里。如果你要删除的值就是列表当前指向的值 ❷，返回列表的尾部（即 list.next 指向的部分）就完成了删除。最后，如果列表的头部没有你想要的值
    ❸，让该节点指向删除尾部值后的结果。
- en: Considering Performance and Variants for Self-Organizing Lists
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考虑自组织列表的性能和变种
- en: This structure’s performance is *O*(*n*), as with common lists, and a search
    looks at *n*/2 elements on average. However, in actual experience with clustered
    requirements, it behaves much better, with far fewer looks at elements. It’s not
    a theoretical advantage, but a fully empirical, pragmatic one, and in the worst
    case, you are no worse off.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构的性能是*O*(*n*)，就像常见的列表一样，搜索时平均需要查看*n*/2个元素。然而，在实际的集群需求中，它表现得要好得多，需要查看的元素远少于预期。这不是一种理论优势，而是完全经验和务实的优势，而且在最坏的情况下，你的表现不会更差。
- en: There are other variants with similar performance. The “move to front” (MTF)
    solution is not the only possible one. Another possibility is “swap with previous”
    in which instead of moving the found element to the head of the list, you just
    swap it with the one before, making it closer to the head. If you make many searches
    for a given value, it eventually reaches the front of the list, but if the search
    was just a one-off case, then it stays around where it was.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类似性能的变体。“移到前面”（MTF）解决方案并不是唯一的选择。另一种可能性是“与前一个交换”，即不将找到的元素移到列表的头部，而是与它前面的元素交换，使其更接近头部。如果你多次搜索某个值，它最终会到达列表的前面；但如果这次搜索只是偶尔的，那么它将停留在原地。
- en: Another variant is to add a count of references to each value, increment it
    by 1 every time a value is searched for and found, and move it nearer the head
    of the list so that the values are in descending order of counts.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种变体是给每个值添加引用计数，每次搜索到并找到该值时，将计数加1，并将其移到列表的前面，使得这些值按照计数的降序排列。
- en: Hashing
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希
- en: 'In this section we’ll move on to a different concept that potentially provides
    the fastest possible searches: *hashing*. The idea of hashing is somewhat related
    to bitmaps. If the values to be stored in the set are taken from a small range,
    you can use a bitmap, which provides *O*(1) searches, as you saw. However, if
    the values are from a very large range (for instance, US Social Security Numbers,
    nine digits long, with 1,000,000,000 possible values), a bitmap becomes prohibitive
    because of the needed space. In addition, it’s most likely that you’ll be dealing
    with a very small percentage of all possible keys. The idea is to first use an
    array of *slots* to store values, but then instead of using the key as an index
    (as in bitmaps), you’ll compute a hash of the value and use that hash as the index.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将讨论一个不同的概念，它可能提供最快的搜索速度：*哈希*。哈希的概念与位图有一定的关系。如果要存储在集合中的值来自一个较小的范围，可以使用位图，这样可以提供*O*(1)的搜索时间，正如你所看到的那样。然而，如果值来自一个非常大的范围（例如，美国的社会保障号码，九位数字，总共有10亿个可能值），位图就变得不可行，因为它需要大量的空间。此外，你很可能只会处理所有可能键中的一个非常小的百分比。其基本思路是，首先使用一个*槽*数组来存储值，但随后不是像位图中那样将键用作索引，而是计算该值的哈希，并使用该哈希值作为索引。
- en: 'In reference to a hash, Ambrose Bierce said, “There’s no definition for this
    word—nobody knows what [a] hash is.” For us, a hash is any function that transforms
    a value—numeric, string, and so on—into a number in a given range. For the Social
    Security number example, to get a hash between 000 and 999, you could just take
    the three final numbers. To get a hash between 0 and a top number *K*, dividing
    values by *K* and taking the remainder would do. There are many ways to compute
    hashes, but we’ll use the remainder function, like the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈到哈希时，安布罗斯·比尔斯曾说：“这个词没有定义——没人知道哈希是什么。” 对我们来说，哈希是任何将一个值——无论是数字、字符串等——转换为一个给定范围内的数字的函数。以社会保障号码为例，要得到一个介于000和999之间的哈希值，你可以直接取后三个数字。要得到一个介于0和最大值*K*之间的哈希值，你可以通过将值除以*K*并取余数来实现。有很多计算哈希值的方法，但我们将使用余数函数，如下所示：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When using hashing to decide where to store (or look for) a value, we first
    compute the hash and then go to the corresponding slot in the array (see [Figure
    11-11](chapter11.xhtml#fig11-11)). It’s quite similar to what we did with bitmaps,
    but in that case, we used the key as an index; here we assume that the number
    of possible keys is exceedingly large, so we apply hashing to reduce it to a manageable
    value.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希来决定存储（或查找）值的位置时，我们首先计算哈希，然后去数组中对应的槽（见[图11-11](chapter11.xhtml#fig11-11)）。这与我们在位图中的做法非常相似，只是那时我们使用键作为索引；在这里，我们假设可能的键的数量极其庞大，因此我们应用哈希将其缩减为一个可管理的值。
- en: '![](../images/Figure11-11.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-11.jpg)'
- en: 'Figure 11-11: In hashing, a hash function is used to decide where a value should
    be stored in a table.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-11：在哈希中，使用哈希函数决定一个值应该存储在表中的位置。
- en: 'If the value you want occupies the slot, you’ve found it. If the slot is free,
    you know for sure that the value isn’t in the set. But how do you deal with different
    values that produce the same hash, so that all should go in the same slot? This
    situation is called a *collision*, and you must specify how to solve it. (If you
    think this isn’t likely, try searching for “Birthday Paradox” online; you’ll be
    surprised!) Different hashing strategies differ in how they handle collisions.
    This chapter will discuss three distinct strategies: buckets with chaining, open
    addressing, and double hashing. The implementations will be bags, but we’ll consider
    how to do sets in the questions at the end of the chapter.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要的值占用了该槽，那么你已经找到了它。如果该槽为空，则可以确定该值不在集合中。但是如何处理那些产生相同哈希值的不同值，以便它们都放入相同的槽中呢？这种情况叫做*碰撞*，你必须指定如何解决它。（如果你认为这种情况不太可能，试着在线搜索一下“生日悖论”；你会惊讶的！）不同的哈希策略在处理碰撞的方式上有所不同。本章将讨论三种不同的策略：带链式的桶法、开放地址法和双重哈希。实现方式将是集合（bag），但我们将在本章末尾的问题中讨论如何实现集合（set）。
- en: Hashing with Chaining
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带链式哈希
- en: 'A first solution to collisions is to consider each slot as a bucket into which
    you may place multiple values. The simplest way to implement this is by taking
    advantage of the ordered lists you saw earlier in the chapter, and most of the
    work will already be done for you. All values that go into the slot are placed
    in a list, and you’ll work with a small set of numbers for simplicity. [Figure
    11-12](chapter11.xhtml#fig11-12) shows slots at the left (slot #3 is unoccupied)
    and the lists at the right.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '解决碰撞的第一种方法是将每个槽看作一个桶，你可以将多个值放入其中。实现这一点的最简单方法是利用你在本章之前看到的有序列表，这样大部分工作就已经为你完成了。所有进入该槽的值都被放入一个列表中，为了简便，你将使用一小组数字。[图
    11-12](chapter11.xhtml#fig11-12)展示了左侧的槽（槽 #3 没有占用）和右侧的列表。'
- en: '![](../images/Figure11-12.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-12.jpg)'
- en: 'Figure 11-12: Hashing with chaining uses lists for values that hash to the
    same value.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-12：使用链式哈希的哈希值相同的元素会使用列表来存储。
- en: To search for a value, first compute in which slot to look for it (which in
    this case means finding the remainder of the value divided by 5, the table’s length)
    and then search the corresponding list. If the value is in the set, you should
    find it in the list. This implementation isn’t hard, considering you already saw
    how to use lists for bags or sets, so here are the details.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找一个值，首先计算它应该在什么槽中（在这种情况下，意味着计算值除以 5 的余数，即表的长度），然后搜索相应的列表。如果该值在集合中，你应该能够在列表中找到它。考虑到你已经了解如何使用列表来实现集合或袋子，这个实现并不难，以下是详细说明。
- en: Creating a Chained Hash Table
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个链式哈希表
- en: 'To create a new hash table for use with chaining, create an empty array and
    fill it with new lists (you’ll use ordered lists, as shown earlier in this chapter,
    as a refresher):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的哈希表以供链式使用，创建一个空数组，并将其填充为新的列表（你将使用本章之前展示的有序列表，作为复习）：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You are creating an object instead of an array in case of other solutions that
    will require extra fields—for instance, to keep track of how many slots are used
    or are free. (See question 11.6 for a common mistake.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他需要额外字段的解决方案中，你是创建一个对象，而不是一个数组——例如，追踪有多少槽是已使用的或空闲的。（参见问题 11.6，了解常见的错误。）
- en: Adding a Value to a Chained Hash Table
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向链式哈希表中添加一个值
- en: 'You can add a new value to this hash table easily; the code is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地将一个新值添加到这个哈希表中；代码如下：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You just have to compute into which slot the new value should go ❶ and then
    add it to the corresponding list ❷.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要计算新值应该放入哪个槽 ❶ ，然后将其添加到相应的列表 ❷ 。
- en: Searching for a Value in a Chained Hash Table
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在链式哈希表中查找一个值
- en: 'Searching for a value is also simple: after deciding in which slot the value
    should be, search the corresponding list. You could write the search in a single
    line, but it’s clearer as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 查找一个值也很简单：在决定值应该放在哪个槽之后，搜索相应的列表。你可以用一行代码来写查找，但下面的写法更清晰：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Calculate the corresponding slot ❶ and then search for it ❷. Note that you had
    to rename the find(...) method from lists to findInList(...) to avoid recursively
    calling the wrong function. Another possibility would be writing something like
    List.find(...).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 计算相应的槽 ❶ ，然后进行搜索 ❷ 。注意，你必须将 find(...) 方法从列表中的原名称改为 findInList(...)，以避免递归调用错误的函数。另一种可能是像
    List.find(...) 这样编写。
- en: '##### Removing a Value from a Chained Hash Table'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 从链式哈希表中移除一个值'
- en: 'Again, removing a value is easy because of all the code you developed earlier:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于之前开发的所有代码，删除一个值非常简单：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As when adding a value, first compute the correct slot ❶ and then remove the
    value from the list ❷ by using the removeFromList(...) method from lists, which
    is also renamed to avoid conflicts.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 和添加值时一样，首先计算正确的槽位❶，然后通过使用removeFromList(...)方法从列表中删除该值❷，该方法也已重命名以避免冲突。
- en: Considering Performance for Chaining
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考虑链式存储的性能
- en: The performance of the worst case of hashing with chaining is, obviously, *O*(*n*)
    if all values map to the very same slot. If the situation isn’t as extreme and
    there are *s* slots, each chain should be around *n/s* values long, so searches
    are *O*(*n/s*), which is actually *O*(*n*) but with a better expected constant.
    The more slots you have, the shorter the chains and the better the performance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链式哈希时的最坏情况性能显然是*O*(*n*)，如果所有的值都映射到同一个槽位。如果情况没有那么极端，并且有*s*个槽位，每个链的长度大约是*n/s*，因此查找的时间复杂度是*O*(*n/s*)，实际上是*O*(*n*)，但有一个更好的预期常数。槽位越多，链就越短，性能就越好。
- en: You could keep track of how many values are in the table (or of the lengths
    of the individual chains), and should those numbers exceed some limit, you could
    re-create the table with a larger number of slots to improve performance. We’ll
    study this kind of process in the next sections.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以跟踪表格中有多少值（或者各个链的长度），如果这些数字超过某个限制，你可以重新创建一个有更多槽位的表格来提高性能。我们将在接下来的章节中研究这种过程。
- en: Hashing with Open Addressing
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开放地址法哈希
- en: 'Another common solution to dealing with collisions is this: if the slot to
    use is already occupied, try the following place (and, if needed, the one after
    that, and the next, and so on, returning to the beginning cyclically after reaching
    the end of the table) until you find an empty slot. To do a search, apply the
    same scheme: first check the corresponding hash, and if the slot is empty, the
    search failed. If the slot is occupied and it’s the value you wanted, the search
    succeeded; otherwise, proceed to the (cyclically) next place and try again. You
    can see how this works with a simple example. Start with an empty hash table into
    which just 22 was added; see [Figure 11-13](chapter11.xhtml#fig11-13).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 处理碰撞的另一种常见解决方案是：如果要使用的槽位已经被占用，尝试下一个位置（如果需要，再尝试下下一个位置，以此类推，直到表格的末尾，达到末尾后再循环回开始）直到找到一个空槽位。进行查找时，应用相同的方案：首先检查对应的哈希槽，如果槽是空的，则查找失败。如果槽被占用且是你想要的值，则查找成功；否则，继续查找下一个（按循环方式）位置并重试。你可以通过一个简单的例子来理解这个过程。首先，使用一个空的哈希表并向其中添加了22，如[图11-13](chapter11.xhtml#fig11-13)所示。
- en: '![](../images/Figure11-13.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-13.jpg)'
- en: 'Figure 11-13: A hash table with just one element'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-13：只有一个元素的哈希表
- en: You could add 04, 75, 09, and 60, and each would go into its corresponding slot,
    as shown in [Figure 11-14](chapter11.xhtml#fig11-14).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加04、75、09和60，每个都会进入其对应的槽位，如[图11-14](chapter11.xhtml#fig11-14)所示。
- en: '![](../images/Figure11-14.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-14.jpg)'
- en: 'Figure 11-14: Four more elements were added, with no collisions so far.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-14：添加了四个元素，目前没有发生碰撞。
- en: The problem appears if you try to add 12, because the corresponding slot, the
    second one, is already occupied. You must start advancing, so 12 ends up in slot
    3, as shown in [Figure 11-15](chapter11.xhtml#fig11-15).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加12，就会出现问题，因为对应的槽位（第二个槽位）已经被占用。你必须开始向前推进，因此12最终会放入槽位3，如[图11-15](chapter11.xhtml#fig11-15)所示。
- en: '![](../images/Figure11-15.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-15.jpg)'
- en: 'Figure 11-15: A collision occurs when you try to add a value (12) to an occupied
    slot.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-15：当你尝试将一个值（12）添加到已占用的槽位时，发生碰撞。
- en: As the table becomes more and more full, it’s more likely that new values will
    end up far from their correct slot; for instance, if you add 63, it ends up at
    slot 6, as shown in [Figure 11-16](chapter11.xhtml#fig11-16).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 随着表格逐渐变满，新值更有可能远离其正确的槽位；例如，如果你添加63，它最终会位于槽位6，如[图11-16](chapter11.xhtml#fig11-16)所示。
- en: '![](../images/Figure11-16.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-16.jpg)'
- en: 'Figure 11-16: In a fuller table, values end up far from their corresponding
    slot.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-16：在一个更满的表格中，值最终会远离其对应的槽位。
- en: Of course, as defined, it becomes apparent that if the table becomes full, you’ll
    be in an infinite loop. The *load factor* is defined as the ratio between occupied
    slots and total slots. An empty hash table has a zero load, and a totally full
    one has a load factor of 1\. The result is intuitive, but you can show mathematically
    that as the load factor grows, insertions and searches will progressively become
    slower. As a rule of thumb, if the load factor gets above 0.75, you should move
    to a larger hash table.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When conducting searches, the process is exactly the same as for insertions.
    If you are looking for 63, you’d start at slot 3, and if it’s not there, advance
    by one until finding it at slot 6\. If you are looking for 73 instead, you’d advance
    until slot 7, which is empty, and then decide that 73 isn’t in the table.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Deletions are not a straightforward process. Consider removing 22, as shown
    in [Figure 11-17](chapter11.xhtml#fig11-17).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-17.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-17: The wrong way to delete a value (22) messes up other searches.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you want to search for 12, what happens? Finding that slot 2 is empty,
    you’d decide that 12 isn’t there, which is bad. We’ll have to do lazy deletions.
    Instead of actually emptying a slot when removing a value, we’ll mark it as available.
    We’ll treat deleted locations as empty when adding new values, but as occupied
    when searching. Deleting 12 would get the result shown in [Figure 11-18](chapter11.xhtml#fig11-18).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-18.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-18: The right way to delete a value (22) just marks the slot (#2)
    as “used but available.”'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: For searches, slot 2 is considered to be occupied, so when looking for 12, you
    won’t stop at slot 2, but will instead keep advancing. For insertions (suppose
    at a later time you wanted to add 42 to the table), slot 2 is considered available,
    so you could use it, as shown in [Figure 11-19](chapter11.xhtml#fig11-19).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-19.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-19: A “used but available” slot (#2) may be used for new insertions.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve explored how a hash table works with the important detail of
    how to deal with deletions, consider the actual code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Open-Addressed Hash Table
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For open addressing, all you need is a table, but you’ll also keep track of
    how many slots have been used in order to compute the load factor. You’ll start
    by defining, for ease of coding, a couple of constants:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The EMPTY value will be assigned to all as yet unused slots, and AVAILABLE will
    be used for slots that were occupied before but that are now available because
    you removed the original value that was there.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'A new hash table will be an object with 100 slots by default:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given the desired size for the hash table (defaulting to 100), create an empty
    array of that size, filled with the EMPTY value ❶, and set the initial count of
    used slots to 0 ❷.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Value to an Open-Addressed Hash Table
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You’ve already seen the logic for additions, and the code is somewhat long:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Start by calculating in which slot the value should go ❶. Then start a linear
    search ❷ that stops when you get to an EMPTY or AVAILABLE slot; note that using
    the modulus operation ❸ makes the search wrap to the beginning. After the search
    for an open slot succeeds, if the slot was empty ❹, add one to the count of used
    slots. If you’re wondering why you don’t do it if the slot was AVAILABLE instead,
    you’ll understand why when you look at removing a value. An important detail is
    that you assume the table has some free space. You’ll see how that works when
    you look at performance for hashing with open addresses.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: You’re actually implementing a bag here. To do a set instead, see question 11.7.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Searching for a Value in an Open-Addressed Hash Table
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As described previously, the search is similar to the insertion process. You’ll
    do the same kind of process as if you were looking to insert a new value, but
    you’ll skip the actual insertion. The code is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As when inserting, first decide in which slot the value should be found ❶, and
    if needed, loop ❷ until you either get the value or reach an EMPTY slot. Depending
    on how the loop ends, return true or false ❸. You’re ignoring AVAILABLE slots,
    for reasons that will become apparent.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Value from an Open-Addressed Hash Table
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Removing a value is strongly based on how you do searches. The key issue is
    that upon finding the value to be deleted, you’ll mark the slot as AVAILABLE,
    implying that the slot is free now for future insertions, but it isn’t really
    free, so for searches, consider it as filled and keep going.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first part ❶ is the same code as in the search function. The only difference
    with that code is that after exiting the loop, if the search succeeded, set the
    slot to AVAILABLE ❷.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'An important question is why you didn’t decrement the used count. A border
    case shows the problem: imagine you entered *n* values, from 1 to *n*, into a
    hash table of size *n*, then removed them all, and finally tried to add any new
    value. What would happen? An infinite loop when checking if the value was already
    in the table! The load factor considers all slots that are or were occupied; you’ll
    see what to do when that load becomes too high in the next section.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Hashing with Open Addressing
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As mentioned, the search performance degrades considerably when the load factor
    tends to 1, eventually becoming *O*(*n*). The worst case is always *O*(*n*); an
    example of this (not the only one, for sure) would be if all keys hash to the
    same slot. See [Table 11-5](chapter11.xhtml#tab11-5).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-5: Performance of Operations for Open-Addressed Hash Tables'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Average performance | Worst case |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) | O(1) |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| Add | O(1) | O(n) |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(1) | O(n) |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| Find | O(1) | O(n) |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: 'If you keep the load factor limited, you can expect good performance, but as
    you add more values to the table, it will degrade. There’s no way out of this,
    but you can modify the add(...) logic to produce a larger table automatically
    to avoid high loads. You just have to change the final return ht from the code
    for adding a value to the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保持负载因子在合理范围内，你可以期待良好的性能，但随着表中值的增加，性能会下降。对此没有解决办法，但你可以修改add(...)逻辑，使得表格在负载过高时自动增大。你只需要将添加值的代码中最终返回ht的部分修改为以下内容：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the load factor has exceeded the recommended 0.75 threshold ❶, create a new
    hash table, double the size ❷, and go through the original table slot by slot
    ❸. Every value you find ❹ will be added to the new table ❺. At the end, instead
    of returning the original table as you did before, you’ll return the new larger
    table ❻. Had the load factor been acceptable ❼, you’d return the original table
    as before. For an alternative technique, see question 11.9.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果负载因子超过了推荐的0.75阈值❶，则创建一个新的哈希表，大小翻倍❷，并逐槽遍历原表❸。你找到的每一个值❹都会被添加到新表中❺。最后，与你之前返回原表不同，你将返回新的、更大的表❻。如果负载因子是可接受的❼，你将像之前一样返回原表。关于另一种技术，请参见第11.9题。
- en: This sort of logic also comes in handy for the versions of hashing tables that
    we’ll consider next.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑对于接下来我们将考虑的哈希表版本也非常有用。
- en: Double Hashing
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双重哈希
- en: The logic you’ve been applying doesn’t really help much with collisions. Should
    two values coincide at a slot, they’ll also coincide at the following slot, and
    the next, and so on. This scheme is likely to produce long lengths of adjacent
    occupied slots that will slow down searches and insertions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你一直在应用的逻辑对碰撞的处理帮助不大。如果两个值在某个槽位发生冲突，它们也会在接下来的槽位发生冲突，依此类推。这种方案很可能会产生长时间的相邻占用槽位，从而减慢搜索和插入速度。
- en: 'An idea that helps in that situation is not always trying the next slot, but
    rather skip a number of slots and make that number depend on the value, so different
    values skip different numbers of slots. The concept of *double hashing* works
    this way: a first hashing function finds the first slot to try, but if that’s
    occupied, a second hashing function determines what size steps to take, instead
    of always jumping to the immediate next slot.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一种有用的思路是，不总是尝试下一个槽位，而是跳过若干个槽位，并使跳跃的槽位数依赖于值，这样不同的值跳过不同数量的槽位。*双重哈希*的概念就是这样工作的：第一个哈希函数确定第一个尝试的槽位，但如果该槽位已被占用，第二个哈希函数决定跳跃的步长，而不是总是跳到下一个槽位。
- en: If you return to the example from the “Hashing with Open Addressing” section
    on page 221, while there are no collisions, everything works the same way, so
    after the first five insertions, you’d have the situation shown in [Figure 11-20](chapter11.xhtml#fig11-20).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到“使用开放地址法的哈希”部分中的示例（第221页），虽然没有发生冲突，但一切运作相同，因此在第一次插入五个值后，你将看到[图11-20](chapter11.xhtml#fig11-20)中的情况。
- en: '![](../images/Figure11-20.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-20.jpg)'
- en: 'Figure 11-20: A hash table using double hashing, with no collisions so far'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-20：使用双重哈希的哈希表，目前没有发生冲突
- en: 'Now you want to add 12, and the #2 slot is occupied. In the previous section
    you used open addressing, so you tried slot #3, and if that also was occupied,
    you would have tried slots #4, #5, and so on, in succession, until finding an
    empty one. With double hashing, you’ll use a second function to decide how far
    to jump. Use the remainder of dividing the value by 9, plus 1, which is guaranteed
    to be a number between 1 and 9 inclusive. For value 12, the step would be 4, so
    the next attempt would be at slot #6, as shown in [Figure 11-21](chapter11.xhtml#fig11-21).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你想添加12，而第2号槽已经被占用。在前一节中，你使用了开放地址法，所以你尝试了第3号槽，如果它也被占用，你将依次尝试第4号槽、第5号槽，直到找到一个空槽。而使用双重哈希时，你将使用第二个哈希函数来决定跳跃多远。使用值对9取余数，再加1，这个值保证是在1到9之间的一个数。对于值12，步长将是4，因此下一个尝试的位置将是第6号槽，如[图11-21](chapter11.xhtml#fig11-21)所示。
- en: '![](../images/Figure11-21.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-21.jpg)'
- en: 'Figure 11-21: Double hashing uses a second function to work with collisions.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-21：双重哈希使用第二个函数来处理冲突。
- en: 'If slot #6 had been occupied, you’d have advanced four slots again (cyclically)
    and tried slot #0, and after that slot #4, and so on. There’s a possible problem
    here. If you wanted to add value 130 to the table in [Figure 11-21](chapter11.xhtml#fig11-21),
    what would happen? The first attempt would be at slot #0, and that fails. The
    second attempt would be at slot #5 (because the step for 130 would be 5), but
    that also fails. The third attempt would be at slot #0 again (because of the cyclical
    search), and you’d be in a loop.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: You’ll have to take care of detecting (and solving) these loops; there are two
    different ways to achieve this.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Table That Uses Double Hashing
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Creating a table for double hashing is exactly the same as for open addressing,
    so we don’t need special code here. Here’s the needed logic again for easier reference:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The key differences are in how you add, search for, and remove values.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '##### Adding a Value to a Table That Uses Double Hashing'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'You saw the procedure for adding a value in a double hash earlier in this section,
    so let’s get to the code. You’ll use two hashing functions: a first one to determine
    the initial slot to try and a second one to skip in the search. It’s very important
    that the second function must never return a zero value.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The logic to add a value needs careful attention to avoid infinite looping:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Start by using the first hash function ❶ to get the initial slot. If that slot
    isn’t empty ❷, use the second hash function ❸ to see how far to jump at every
    step. You’ll save the initial slot at i0 ❹ to detect a loop, and then start looking
    for an empty or available slot ❺. At each pass of the loop, advance step places
    ❻, and if you detect that you’re back at the initial i0 place, then advance just
    one place and save the new initial slot ❼. After finding where to put the new
    value ❽, the logic is as for the previous hash methods: update the count of used
    slots and save the value. You should regenerate the table in case of a high load
    factor, in the same way as in the open addressing section.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Searching for a Value in a Table That Uses Double Hashing
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The logic for searching for a value matches the way you add new values:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Start by deciding on the initial slot to test ❶ and the step amount to jump
    ❷. Then save the initial spot to detect a loop ❸ and start jumping until you find
    an empty slot or the desired value ❹; the logic for jumps is exactly the same
    as for insertions, including the loop detection ❺. At the end, return true or
    false ❻ depending on where you stopped the search.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Value from a Table That Uses Double Hashing
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'I won’t repeat the explanation here, but to remove a value, you’ll use the
    same technique as for open addressing. You won’t mark removed values as EMPTY,
    but rather as AVAILABLE. The code is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code is exactly the same as for the open addressing search, and you change
    only what to do after finishing the loop. If you found the value ❶, mark the slot
    as AVAILABLE; if it’s not found, don’t do anything.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和开放地址查找的代码完全相同，唯一不同的是在完成循环后要做什么。如果找到了值❶，将槽位标记为“可用”；如果没找到，不做任何操作。
- en: The logic for double hashing works well, but you can easily make it more streamlined,
    as we’ll see next.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 双重哈希的逻辑运行得很好，但你可以很容易地使其更加简洁，接下来我们将看到这一点。
- en: Double Hashing with Prime Lengths
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用质数长度的双重哈希
- en: 'The only problem with the logic that you saw with double hashing operations
    is the need to deal with possible loops. You’ll get a loop whenever the step size
    you choose happens to have some common factor with the table’s length. For instance,
    if the table size is 18 and the step is 12, after three steps you’ll be back where
    you started. If you could choose a table length that doesn’t have any common factors
    with all possible steps, the logic would be simpler. There’s an easy way to do
    that: if the table length is a prime number (divisible only by itself or by 1),
    no loops are possible, because a prime number has no common divisors with any
    lower number. Also, if the step is 1, everything is fine, because before returning
    to the initial slot, you’ll have gone through the complete array.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你在使用双重哈希操作时看到的逻辑唯一的问题是需要处理可能的循环。每当你选择的步长与表的长度有公共因子时，就会形成一个循环。例如，如果表的大小是18，步长是12，经过三步后你会回到原来的位置。如果你能选择一个与所有可能的步长没有公共因子的表长度，那么逻辑会更简单。有一个简单的方法可以做到这一点：如果表的长度是质数（仅能被1或它本身整除），就不可能有循环，因为质数与任何较小的数字都没有公共因子。而且，如果步长是1，一切都没问题，因为在回到初始位置之前，你会遍历整个数组。
- en: Creating a Table That Uses Double Hashing with Prime Lengths
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个使用质数长度的表
- en: 'You can create a new hash table exactly as before, except you must ensure that
    its length is a prime number. First you need to check whether a number is prime:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像以前一样创建一个新的哈希表，只是你必须确保它的长度是质数。首先你需要检查一个数字是否是质数：
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Small numbers are prime (and for the purposes here 1 works as a prime number,
    no matter what mathematicians may say) ❶. Even numbers (you excluded 2 in the
    previous if) aren’t prime ❷, so those cases are simple. For other numbers, test
    all odd possible divisors starting at 3 ❸ and stop when you find an exact division
    ❹ or when the tested possible divisor exceeds the square root of the number, in
    which case the number is prime ❺.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 小的数字是质数（在这里1也算作质数，不管数学家怎么说）❶。偶数（你在之前的if语句中排除了2）不是质数❷，所以这些情况比较简单。对于其他数字，从3开始测试所有可能的奇数除数❸，直到找到一个精确的除法❹，或者测试的除数超过了该数字的平方根，在这种情况下，这个数字就是质数❺。
- en: 'Next you need a simple function to find the first prime number greater than
    a given value, and you can write it simply by using the isPrime(...) function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你需要一个简单的函数来找到大于给定值的第一个质数，你可以通过使用isPrime(...)函数轻松编写：
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The logic is straightforward: given a number, if it’s not prime ❶, add 1 to
    it ❷ until the number becomes a prime.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑很简单：给定一个数字，如果它不是质数❶，就加1❷，直到数字变成质数。
- en: 'Now you can create a table. The logic is the same as before, except you make
    sure that the length of the table is a prime number:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建一个表，逻辑和之前一样，只是你要确保表的长度是质数：
- en: '[PRE40]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Whatever size you get, you find the next higher prime and use it as the table
    length.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你得到什么大小，都可以找到下一个更大的质数，并将其作为表的长度。
- en: Adding a Value to a Table That Uses Double Hashing with Prime Lengths
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向使用质数长度的表中添加一个值
- en: 'To add a value, work the same way as with the double hashing code, except you
    don’t have to test for loops; prime numbers have this covered:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个值时，和双重哈希代码的方式一样，只是你不需要测试循环；质数已经解决了这个问题：
- en: '[PRE41]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You’ll advance as before, but all the code related to i0 (which you used for
    loop detection) is now gone.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你会像之前一样继续，但与i0相关的所有代码（你用来检测循环的）现在已经删除。
- en: Searching for a Value in a Table That Uses Double Hashing with Prime Lengths
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在使用质数长度的双重哈希的表中查找值
- en: 'Searching is also simpler:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 查找也变得更简单：
- en: '[PRE42]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Again comparing this code with the code for common double hashing, the key difference
    is that you did away with all the loop detection and prevention.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 再次将这段代码与常见双重哈希代码进行比较，主要的区别在于你不再需要进行任何循环检测和预防。
- en: '##### Removing a Value from a Table That Uses Double Hashing with Prime Lengths'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 从使用质数长度的表中删除一个值'
- en: 'Finally, as expected, removing a value is also easier:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如预期的那样，删除一个值也变得更简单：
- en: '[PRE43]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once more, the code is the same as for common double hashing, but without checking
    for loops; it’s faster, simpler code.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter we’ve considered several ways to implement bags and sets, including
    the hashing technique that, when properly applied, can provide the fastest possible
    search times. The structures considered here were basically linear; in the next
    chapter we’ll start considering nonlinear ones such as trees to explore further
    implementations of bags and sets.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**11.1  Sentinels for Searches**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Show how an ordered list could benefit from a final +Infinity sentinel value
    for simpler code.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '**11.2  More Sentinels?**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Would adding an initial -Infinity sentinel help with ordered lists?
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '**11.3  A Simpler Search?**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you simplify the code to avoid having to return two values when searching
    a self-organizing list? A tip: if the search was successful, the list won’t be
    empty and its head will have the searched value.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '**11.4  Re-skipping Lists**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Can you sketch out an algorithm that will restructure a skip list to make sure
    it is well balanced?
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '**11.5  Skip to an Index**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: In the earlier definition you just wanted to search for a value, but what if
    you had an index *i* and wanted the *i*th value of the list? Can you think of
    a way to modify skip lists in order to find a value by index in an efficient way?
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '**11.6  Simpler Filling**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Why wouldn’t the following code work to create a hashing table with chaining?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**11.7  A Hashed Set**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: In the hash table code for insertions you allowed repeated values, so you’re
    doing bags instead of sets. Can you modify the code as efficiently as possible
    to implement sets instead? Obviously, you could start by doing a search, but if
    that search failed, you’d be redoing a lot of work for the addition.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**11.8  Wrong Seating**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: This puzzle will remind you of hashing. Imagine that 100 people were given tickets
    for a show. The theater has 100 seats, and each ticket is assigned to a different
    seat. There was a problem, though. The first person to arrive at the theater didn’t
    pay attention and sat in a random seat. All the other people tried to go to their
    seats, and if their seats were already occupied, they also took random seats.
    What’s the probability that the last person (the 100th one) will find that their
    seat is unoccupied?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**11.9  Progressive Resizing**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Doing a whole resizing operation (with the corresponding delay in time) may
    not be acceptable for some systems, so you need some kind of progressive resizing
    solution. Can you sketch a way to do the rehashing gradually, somehow working
    with two tables (an old one and a new one) but not rehashing the entire old table
    at once?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
