["```\n$ openssl rand *<number of bytes>* -out *<output file>*\n```", "```\n$ dd if=/dev/urandom of=*<output file>* bs=1M count=10\n```", "```\nint random_bytes_insecure(void *buf, size_t len)\n{\n    int fd = open(\"/dev/urandom\", O_RDONLY);\n    read(fd, buf, len);\n    close(fd);\n    return 0;\n}\n```", "```\nint random_bytes_safer(void *buf, size_t len)\n{\n    struct stat st;\n    size_t i;\n    int fd, cnt, flags;\n    int save_errno = errno;\n\nstart:\n    flags = O_RDONLY;\n#ifdef O_NOFOLLOW\n    flags |= O_NOFOLLOW;\n#endif\n#ifdef O_CLOEXEC\n    flags |= O_CLOEXEC;\n#endif\n    fd = ❶open(\"/dev/urandom\", flags, 0);\n    if (fd == -1) {\n        if (errno == EINTR)\n            goto start;\n        goto nodevrandom;\n    }\n#ifndef O_CLOEXEC\n    fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n#endif\n    /* Lightly verify that the device node looks sane */\n    if (fstat(fd, &st) == -1 || !S_ISCHR(st.st_mode)) {\n        close(fd);\n        goto nodevrandom;\n    }\n    if (ioctl(fd, RNDGETENTCNT, &cnt) == -1) {\n        close(fd);\n        goto nodevrandom;\n    }\n    for (i = 0; i < len; ) {\n        size_t wanted = len - i;\n        ssize_t ret = ❷read(fd, (char *)buf + i, wanted);\n        if (ret == -1) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            close(fd);\n            goto nodevrandom;\n        }\n        i += ret;\n    }\n    close(fd);\n    if (gotdata(buf, len) == 0) {\n        errno = save_errno;\n        return 0;                \t\t/* satisfied */\n    }\nnodevrandom:\n    errno = EIO;\n    return -1;\n}\n```", "```\n#!/bin/sh\nESTIMATE=/proc/sys/kernel/random/entropy_avail\ntimeout 3s dd if=/dev/random bs=4k count=1 2> /dev/null | base64\nent=`cat $ESTIMATE`\nwhile [ $ent -lt 128 ]\ndo\n    sleep 3\n    ent=`cat $ESTIMATE`\n    echo $ent\ndone\ndd if=/dev/random bs=8 count=1 2> /dev/null | base64\ncat $ESTIMATE\n```", "```\nxFNX/f2R87/zrrNJ6Ibr5R1L913tl+F4GNzKb60BC+qQnHQcyA==\n2\n18\n19\n27\n28\n72\n124\n193\njq8XWCt8\n129\n```", "```\nint random_bytes(unsigned char *out, size_t outlen)\n{\n    static HCRYPTPROV handle = 0; /* only freed when the program ends */\n    if(!handle) {\n        if(!CryptAcquireContext(&handle, 0, 0, PROV_RSA_FULL,\n                            CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n            return -1;\n        }\n    }\n    while(outlen > 0) {\n        const DWORD len = outlen > 1048576UL ? 1048576UL : outlen;\n        if(!CryptGenRandom(handle, len, out)) {\n            return -2;\n        }\n        out    += len;\n        outlen -= len;\n    }\n    return 0;\n}\n```", "```\n   global variable seed;\n\n   RNG_CreateContext()\n       (seconds, microseconds) = time of day; /* Time elapsed since 1970 */\n       pid = process ID;  ppid = parent process ID;\n       a = mklcpr(microseconds);\n    ➊ b = mklcpr(pid + seconds + (ppid << 12));\n      seed = MD5(a, b); /* Derivation of a 128-bit value using the hash MD5 */\n\n   mklcpr(x) /* not cryptographically significant; shown for completeness */\n       return ((0xDEECE66D * x + 0x2BBB62DC) >> 1);\n\n   MD5() /* a very good standard mixing function, source omitted */\n```", "```\nprng.seed(seed)\np = prng.generate_random_prime()\nq = prng.generate_random_prime()\nn = p*q\n```", "```\nprng.seed(seed)\np = prng.generate_random_prime()\nprng.add_entropy()\nq = prng.generate_random_prime()\nn = p*q\n```", "```\n        /**\n         * Generate a hex-y looking random token for various uses.\n         * Could be made more cryptographically sure if someone cares.\n         * @return string\n         */\nfunction generateToken( $salt = '' ) {\n    $token = dechex(mt_rand()).dechex(mt_rand());\n    return md5( $token . $salt );\n}\n```", "```\nCryptocat.random = function() {\n    var x, o = '';\n    while (o.length < 16) {\n         x = state.getBytes(1);\n         if (x[0] <= 250) {\n             o += x[0] % 10;\n         }\n     }\n    return parseFloat('0.' + o)\n}\n```"]