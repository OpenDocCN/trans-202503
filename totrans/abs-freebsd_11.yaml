- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE UNIX FILE SYSTEM**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FreeBSD’s filesystem, the Unix File System (UFS), is a direct descendant of
    the filesystem shipped with BSD 4.4\. One of the original UFS authors still develops
    the FreeBSD filesystem and has added many nifty features in recent years. FreeBSD
    is not the only operating system to still use the 4.4 BSD filesystem or a descendant
    thereof. A Unix vendor that doesn’t specifically tout its “improved and advanced”
    filesystem is probably running a UFS derivative.
  prefs: []
  type: TYPE_NORMAL
- en: UFS’s place as the primordial filesystem has given it leave to extend tendrils
    throughout FreeBSD. Many UFS concepts underlie FreeBSD’s support for other filesystems,
    from ZFS to optical disks. Even if you have no intention of ever using UFS, you
    must understand the basics of UFS to understand how FreeBSD manages filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Like the rest of Unix, UFS is designed to handle the most common situations
    effectively while reliably supporting unusual configurations. FreeBSD ships with
    UFS configured to be as widely useful as possible on relatively modern hardware,
    but you can choose to optimize a particular filesystem for trillions of small
    files or a half-dozen 1TB files if you must.
  prefs: []
  type: TYPE_NORMAL
- en: What we call UFS today is actually UFS version 2, or *UFS2*. Primordial UFS
    can’t handle modern disk sizes.
  prefs: []
  type: TYPE_NORMAL
- en: UFS is best suited for smaller systems, or applications that can’t handle the
    overhead of ZFS. Many people prefer UFS for virtual machines. I discuss choosing
    a filesystem in [Chapter 2](ch02.xhtml#ch02).
  prefs: []
  type: TYPE_NORMAL
- en: '**UFS Components**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UFS is built of two layers, one called the *Unix File System* and the other
    the *Fast File System (FFS)*. UFS handles items like filenames, attaching files
    to directories, permissions, and all of those petty details users care about.
    FFS does the real work in getting files written to disk and arranging them for
    quick access. The two work together to provide data storage.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Fast File System***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FFS is built of superblocks, blocks, fragments, and inodes.
  prefs: []
  type: TYPE_NORMAL
- en: A *superblock* records the filesystem’s characteristics. It contains a magic
    number that identifies the filesystem as UFS, as well as filesystem geometry information
    the kernel uses to optimize writing and reading files. A UFS filesystem keeps
    many backup copies of the superblock, in case the primary gets damaged.
  prefs: []
  type: TYPE_NORMAL
- en: '*Blocks* are segments of disk that contain data. FreeBSD defaults to 32KB blocks.
    FFS maps blocks onto specific sectors on the underlying disk or GEOM provider.
    Every stored file gets broken up into 32KB chunks, and each chunk is stored in
    its own block.'
  prefs: []
  type: TYPE_NORMAL
- en: Not all files are even multiples of 32KB, so FFS stores the leftovers in *fragments*.
    The standard is one-eighth of the block size, or 4KB. For example, a 39KB file
    would fill one block and two fragments. One of those fragments has only 3KB in
    it, so fragments do waste disk space—but they waste far less space than using
    full blocks everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: '***How UFS Uses FFS***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: UFS allocates certain FFS blocks as *inodes*, or *index nodes*, to map blocks
    and fragments to files. An inode contains each file’s size, permissions, and the
    list of blocks and fragments containing each file. Collectively, the data in an
    inode is known as *metadata*, or data about data.
  prefs: []
  type: TYPE_NORMAL
- en: Each filesystem has a certain number of inodes, proportional to the filesystem
    size. A modern disk probably has hundreds of thousands of inodes on each partition,
    enough to support hundreds of thousands of files. If you have a truly large number
    of very tiny files, however, you might need to rebuild your filesystem to support
    additional inodes. Use `df -i` to see how many inodes remain free on your filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, it was possible to run UFS on a storage layer other than FFS.
    That’s how many log-based or extent-based filesystems work. Over decades of development,
    though, UFS features like journaling and soft updates have so greatly entangled
    FreeBSD’s UFS and FFS that separating the two is no longer realistic or even vaguely
    plausible.
  prefs: []
  type: TYPE_NORMAL
- en: '***Vnodes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Inodes and blocks worked perfectly if the only filesystem you used was UFS and
    all your hard drives were permanently attached. These days, we routinely swap
    disks between different machines and even different operating systems. You probably
    need to read optical media and flash disks on your desktop, and servers might
    even need to accept hard drives formatted for a different operating system.
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD uses a storage abstraction layer—the *virtual node*, or *vnode*—to mediate
    between filesystems and the kernel. You’ll never directly manipulate a vnode,
    but the FreeBSD documentation frequently refers to them. Vnodes are a translation
    layer between the kernel and whatever filesystem you’ve mounted. If you’re an
    object-oriented programmer, think of a vnode like a base class that all storage
    classes inherit. When you write a file to a UFS filesystem, the kernel addresses
    the data to a vnode that, in turn, is mapped to a UFS inode and FFS blocks. When
    you write to a FAT32 filesystem, the kernel addresses data to a vnode that’s mapped
    to a specific part of the FAT32 filesystem. Use inodes only when dealing with
    UFS filesystems, but use vnodes when dealing with any filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mounting and Unmounting Filesystems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mount(8) program’s main function is attaching filesystems to a host’s filesystem
    tree. While FreeBSD mounts every filesystem listed in */etc/fstab* at boot time,
    you must understand how mount(8) works. If you’ve never played with mounting before,
    boot your FreeBSD test machine into the single-user mode (see [Chapter 4](ch04.xhtml#ch04))
    and follow along.
  prefs: []
  type: TYPE_NORMAL
- en: In single-user mode, FreeBSD has mounted the root partition read-only. On a
    traditional Unix-like system, the root partition contains just enough of the system
    to perform basic setup, get core services running, and find the rest of the filesystems.
    Other filesystems aren’t mounted, so their content is inaccessible. The current
    FreeBSD installer puts everything in the root partition, so you’d get the basic
    operating system, but any special filesystems, network mounts, and so on would
    be empty. You might need to mount other filesystems to perform your system maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: '***Mounting Standard Filesystems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To manually mount a filesystem listed in */etc/fstab*, such as */var* or */usr*,
    give mount(8) the name of the filesystem you want to mount.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This mounts the partition exactly as listed in */etc/fstab*, with all the options
    specified in that file. If you want to mount all the partitions listed in */etc/fstab*,
    except those labeled `noauto`, use mount’s `-a` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When you mount all filesystems, filesystems that are already mounted don’t get
    remounted.
  prefs: []
  type: TYPE_NORMAL
- en: '***Special Mounts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You might need to mount a filesystem at an unusual location or mount something
    temporarily. I most commonly mount disks manually when installing a new disk.
    Use the device node and the desired mount point. If my */var/db* partition is
    */dev/gpt/db* and I want to mount it on */mnt*, I would run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '***Unmounting a Partition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you want to disconnect a filesystem from the system, use umount(8) to tell
    the system to unmount the partition. (Note that the command is `umount`, not `u`n`mount`.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You cannot unmount filesystems that are in use by any program. If you cannot
    unmount a partition, you’re probably accessing it somehow. Even a command prompt
    in the mounted directory prevents you from unmounting the underlying partition.
    Running `fstat | grep /usr` (or whatever the partition is) can expose the blocking
    program.
  prefs: []
  type: TYPE_NORMAL
- en: '***UFS Mount Options***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FreeBSD supports several mount options that change filesystem behavior. When
    you manually mount a partition, you can specify any mount option with `-o`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can also specify mount options in `/etc/fstab` (see [Chapter 10](ch10.xhtml#ch10)).
    Here, I use the `ro` option on the */home* filesystem, just as in the preceding
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The mount(8) man page lists all of the UFS mount options, but here are the most
    commonly used ones.
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-Only Mounts**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you want to look at the contents of a disk but disallow changing them, mount
    the partition *read-only*. You cannot alter the data on the disk or write any
    new data. In most cases, this is the safest and the most useless way to mount
    a disk.
  prefs: []
  type: TYPE_NORMAL
- en: Many system administrators want to mount the root partition, and perhaps even
    */usr*, as read-only to minimize potential system damage from an intruder or malicious
    software. This maximizes system stability but vastly complicates maintenance.
    If you use an automatic deployment system, such as Ansible or Puppet, and habitually
    redeploy your servers from scratch rather than upgrading them, read-only mounts
    might be a good fit for you.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only mounts are especially valuable on a damaged computer. While FreeBSD
    won’t let you perform a standard read-write mount on a damaged or dirty filesystem,
    it will perform a read-only mount if the filesystem isn’t too badly fubar. This
    gives you a chance to recover data from a dying disk.
  prefs: []
  type: TYPE_NORMAL
- en: To mount a filesystem read-only, use either the `rdonly` or `ro` option. Both
    work identically.
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous Mounts**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Synchronous* (or *sync*) *mounts* are the old-fashioned way of mounting filesystems.
    When you write to a synchronously mounted disk, the kernel waits to see whether
    the write is actually completed before informing the program. If the write didn’t
    complete successfully, the program can choose to act accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous mounts provide the greatest data integrity in the case of a crash,
    but they’re also slow. Admittedly, “slow” is relative today, when even a cheap
    disk outperforms what was the high end several years ago. Consider using synchronous
    mounting when you wish to be truly pedantic on data integrity, but in almost all
    cases, it’s overkill.
  prefs: []
  type: TYPE_NORMAL
- en: To mount a partition synchronously, use the option `sync`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous Mounts**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While *asynchronous mounts* are pretty much supplanted by soft updates (see
    “[Soft Updates](ch11.xhtml#lev389)” on [page 237](ch11.xhtml#page_237)), you’ll
    still hear about them. For faster data access at higher risk, mount your partitions
    asynchronously. When a disk is asynchronously mounted, the kernel writes data
    to the disk and tells the writing program that the write succeeded without waiting
    for the disk to confirm that the data was actually written.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous mounting is fine on disposable filesystems, such as memory file
    systems that disappear at shutdown, but don’t use it with important data. The
    performance difference between asynchronous mounts and noasync with soft updates
    is minuscule. (I’ll cover noasync in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: To mount a partition asynchronously, use the option `async`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining Sync and Async**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: FreeBSD’s default UFS mount option combines sync and async mounts as *noasync*.
    With noasync, data that affects inodes is written to the disk synchronously, while
    actual data is handled asynchronously. Combined with soft updates (see later in
    this chapter), a noasync mount creates a very robust filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: As noasync mounts are the default, you don’t need to specify it when mounting,
    but when someone else does, don’t let it confuse you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disable Atime**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Every file in UFS includes an access-time stamp, called the *atime*, which records
    when the file was last accessed. If you have a large number of files and don’t
    need this data, you can mount the disk *noatime* so that UFS doesn’t update this
    timestamp. This is most useful for flash media or disks that suffer from heavy
    load, such as Usenet news spool drives. Some software uses the atime, though,
    so don’t disable it blindly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disable Execution**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Your policy might say that certain filesystems shouldn’t have executable programs.
    The `noexec` mount option prevents the system from executing any programs on the
    filesystem. Mounting */home* noexec can help prevent users from running their
    own programs, but for it to be effective, also mount */tmp*, */var/tmp*, and anywhere
    else users can write their own files noexec as well.
  prefs: []
  type: TYPE_NORMAL
- en: A noexec mount doesn’t prevent a user from running a shell script or an interpreted
    script in Perl or Python or whatever. While the script might be on a noexec filesystem,
    the interpreter usually isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Another common use for a noexec mount is when you have a filesystem that contains
    binaries for a different operating system or a different hardware architecture
    and you don’t want anyone to execute them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disable Suid**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Setuid programs allow users to run programs as if they’re another user. For
    example, programs such as login(1) must perform actions as root but must be run
    by regular users. Setuid programs obviously must be written carefully so that
    intruders can’t exploit them to get unauthorized access to your system. Many system
    administrators habitually disable all unneeded setuid programs.
  prefs: []
  type: TYPE_NORMAL
- en: The `nosuid` option disables setuid access from all programs on a filesystem.
    As with noexec, script wrappers can easily evade nosuid restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disable Clustering**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: FFS optimizes reads and writes on the physical media by clustering. Rather than
    scattering a file all over the hard drive, it writes out the whole thing in large
    chunks. Similarly, it makes sense to read files in larger chunks. You can disable
    this feature with the mount options `noclusterr` (for read clustering) and `noclusterw`
    (for write clustering).
  prefs: []
  type: TYPE_NORMAL
- en: '**Disable Symlinks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `nosymfollow` option disables symlinks, or aliases to files. *Symlinks*
    are mainly used to create aliases to files that reside on other partitions. To
    create an alias to another file on the same partition, use a regular link instead.
    See ln(1) for a discussion of links.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases to directories are always symlinks; you cannot use a hard link for those.
  prefs: []
  type: TYPE_NORMAL
- en: '**UFS Resiliency**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UFS dates from the age when a power loss meant data loss. After decades of use
    and debugging, UFS almost never loses data, especially when compared with other
    open source filesystems. UFS achieves this resiliency by careful integrity checking,
    especially after an unexpected shutdown like a power failure.
  prefs: []
  type: TYPE_NORMAL
- en: The point of resiliency isn’t to verify the data on disk—UFS is pretty good
    at that. It’s to speed integrity verification and filesystem recovery after that
    unexpected shutdown. The size of modern disks means that verification can take
    a long time without additional resiliency. An integrity check of a 100MB filesystem
    is much faster than the same integrity check of a multiterabyte filesystem! Adding
    resiliency improves recovery times.
  prefs: []
  type: TYPE_NORMAL
- en: UFS offers several ways to improve the resilience of a UFS filesystem, such
    as soft updates and journaling. Before creating a filesystem, choose one that
    fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Soft Updates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Soft updates* is a technology used to organize and arrange disk writes so
    that filesystem metadata remains consistent at all times, giving nearly the performance
    of an async mount with the reliability of a sync mount. That doesn’t mean that
    all data will be safely written to disk—a power failure at the wrong moment can
    still lose data. The file being written to disk at the exact millisecond the power
    dies can’t get to the disk no matter what the operating system does. But what’s
    actually on the disk will be internally consistent. Soft updates lets UFS quickly
    recover from failure.'
  prefs: []
  type: TYPE_NORMAL
- en: You can enable and disable soft updates when mounting or creating the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: As filesystems grow, soft updates show their limits. Multiterabyte filesystems
    still need quite a while to recover from an unplanned shutdown. The original soft
    updates journaling paper (*[http://www.mckusick.com/softdep/suj.pdf](http://www.mckusick.com/softdep/suj.pdf)*)
    mentions that a 92 percent full 14-drive array with a deliberately damaged filesystem
    needed 10 hours for integrity checking. You’ll need a journal well before then.
  prefs: []
  type: TYPE_NORMAL
- en: '***Soft Updates Journaling***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A journaling filesystem records any changes outside the actual filesystem. Changes
    get quickly dumped to storage and then inserted into the filesystem at a more
    leisurely pace. If the system dies unexpectedly, the filesystem automatically
    recovers any changes from the journal. This vastly reduces the requirement for
    rebuilding filesystem integrity at startup. When you install FreeBSD, it defaults
    to creating UFS partitions with soft update journaling.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than recording all transactions, the soft updates journal records all
    metadata updates so that the filesystem can always be restored to an internally
    consistent state. Benchmarks show that journaling adds only a tiny amount of load
    to soft updates. It does add I/O overhead, however, as the system must dump all
    changes to the journal and then replay them into the filesystem. It vastly reduces
    recovery time, however. That 14-drive array that needed 10 hours for integrity
    checking? It needed less than one minute to recover from the same damage using
    the journal.
  prefs: []
  type: TYPE_NORMAL
- en: Soft updates with journaling is very powerful. Why wouldn’t you always use journaling?
    Soft updates journaling disables UFS snapshots. If you need UFS snapshots, you
    can’t journal. If you need snapshots, though, you’re probably better off using
    ZFS anyway. FreeBSD’s version of dump(8) uses UFS snapshots to back up live filesystems.
    Only us old Unix hands use dump any more, and that’s mostly because we already
    know it, but if your organization mandates using dump(8), you need another resiliency
    option.
  prefs: []
  type: TYPE_NORMAL
- en: '***GEOM Journaling***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FreeBSD can also journal at the GEOM level with gjournal(8). Like any other
    filesystem journal, gjournal records filesystem transactions. At boot, FreeBSD
    checks the journal file for any changes not yet written to the filesystem and
    makes those changes, ensuring a consistent filesystem. Gjournal predates soft
    updates journaling.
  prefs: []
  type: TYPE_NORMAL
- en: While soft updates journals only metadata, gjournal journals all filesystem
    transactions. You’re less likely to lose data in a system failure, but everything
    gets written twice, which impacts performance. If you’re using gjournal, though,
    don’t use any type of soft updates. You should also mount the filesystem async.
    You can use snapshots on a gjournaled filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Gjournal uses 1GB of disk per filesystem. You can’t just turn it on and off—you
    must have space for the journal. You can use a separate partition for the journal
    or include the gigabyte in the partition if you leave space for it. If you decide
    to add gjournal to an existing partition, you need to find the space somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Should you use gjournal or soft updates journaling? I recommend using soft updates
    journaling if at all possible. If that isn’t an option, use plain soft updates.
    Use GEOM journaling if you need UFS snapshots, including dump(8) on snapshots.
    Personally, I no longer use gjournal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating and Tuning UFS Filesystems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last chapter, we partitioned and labeled your disks. Now let’s put a
    filesystem on those partitions. Create UFS filesystems with newfs(8), using a
    device node as the last argument. Here, I create a filesystem on the device */dev/gpt/var*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first line repeats the device node and prints the partition’s size ➊, along
    with the block ➋ and fragment sizes ➌. You’ll get filesystem geometry information
    ➍, a relic of the days when disk geometry bore some relationship to the hardware.
    Finally, newfs(8) prints a list of super-block backups ➎. The larger your filesystem,
    the more backup superblocks you get.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use soft updates journaling, add the `-j` flag. To use soft updates
    without journaling, add the `-U` flag. After you’ve created the filesystem, you
    can enable and disable soft updates journaling, and plain soft updates, with tunefs(8).
  prefs: []
  type: TYPE_NORMAL
- en: '***UFS Labeling***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Device nodes can change, but labels remain constant. Best practice is to label
    GPT partitions, but you can’t label MBR partitions. UFS filesystems on an MBR
    can use a UFS label with the `-L` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The labels appear in */dev/ufs*. Use them in */etc/fstab* and other configuration
    files to avoid disk renaming mayhem. You can’t apply UFS labels to non-UFS filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using UFS on GPT partitions, choose either GPT or UFS labels. Thanks
    to withering, you’ll see only one label at a time and probably confuse yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '***Block and Fragment Size***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: UFS’s efficiency is proportional to the number of blocks and fragments read
    or written. Generally, FreeBSD can read a 10-block file in half the time it needs
    to read a 20-block file. The FreeBSD developers chose the default block and fragment
    sizes to accommodate the widest variety of files.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a special-purpose filesystem that overwhelmingly contains either
    large or small files, you might consider changing the block size when creating
    the filesystem. While you can change the block size of an existing filesystem,
    it’s a terrible idea. Block sizes must be a power of 2\. The assumption that a
    fragment is one-eighth the size of a block is hardcoded in many places, so let
    newfs(8) compute the fragment size from the block size.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose I have a filesystem dedicated to large files, and I want to increase
    the block size. The default block size is 32KB, so the next larger block size
    would be 64KB. Specify the new block size with `-b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you’re going to have many small files, you might consider using a smaller
    block size. One thing to watch out for is a fragment size smaller than the underlying
    disk’s physical sector size. FreeBSD defaults to 4KB fragments. If your disk has
    4KB sectors, don’t use a smaller fragment size. If you’re absolutely certain that
    your disk has 512-byte physical sectors, you can consider creating a filesystem
    with a 16KB (or even 8KB) block size and the corresponding 2KB or 1KB fragment
    size.
  prefs: []
  type: TYPE_NORMAL
- en: In my sysadmin career, I have needed^([1](footnote.xhtml#ch11fn1)) a custom
    block size only twice. Don’t use one until you experience a performance issue.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using GEOM Journaling***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before using gjournal(8), decide where you’re putting the 1GB journal. If possible,
    I’d recommend including that gigabyte in the filesystem partition. That means
    if you want a 50GB filesystem, put it in a 51GB partition. Otherwise, use a separate
    partition.
  prefs: []
  type: TYPE_NORMAL
- en: Load the geom_journal kernel module with `gjournal load` or in */boot/loader.conf*
    before performing any gjournal operations.
  prefs: []
  type: TYPE_NORMAL
- en: To create a gjournal provider while including the partition in the journal,
    use the `gjournal label` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you want to have a separate provider be the journal, add that provider as
    a second argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These commands run silently if successful. They create a new device node with
    the same name as your journaled device, but with *.journal* added to the end.
    Running `gjournal label da3p5` creates */dev/da3p5.journal*. From this point on,
    do all work on the journaled device node.
  prefs: []
  type: TYPE_NORMAL
- en: Create your new UFS filesystem on the journaled device. Use the `-J` flag to
    tell UFS it’s running on top of gjournal. Do not enable any sort of soft updates,
    including soft updates journaling. It seems to work for a time . . . then it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Mount your gjournal filesystems async. The normal warnings that apply to async
    mounts don’t apply to gjournal, however. The gjournal GEOM module handles the
    verification and integrity checking normally managed by the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The documentation says that you can convert an existing partition to use gjournal,
    provided that you have a separate partition for the journal and that the last
    sector of the existing filesystem is empty. In practice, I find that the last
    sector of the existing filesystem is always full, but if you want to, try to read
    gjournal(8) for the details.
  prefs: []
  type: TYPE_NORMAL
- en: '***Tuning UFS***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can view and change the settings on each UFS filesystem by using tunefs(8).
    This lets you enable and disable features; plus, you can adjust how UFS writes
    files, manages free space, and uses filesystem labels.
  prefs: []
  type: TYPE_NORMAL
- en: '**View Current Settings**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: View a filesystem’s current settings with the `-p` flag and the partition’s
    current mount point or underlying provider.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Many of the available settings relate to specific security functionality we
    don’t cover. Topics like MAC restrictions ➋ and all the different types of ACL
    ➊ fill entire books. But we can see that this filesystem uses soft updates ➌ and
    soft updates journaling ➍, though it doesn’t use gjournal ➎. We get the minimum
    amount of free space ➏. At the end, we have the nonexistent UFS label ➐. We get
    a bunch of information on filesystem geometry and block size.
  prefs: []
  type: TYPE_NORMAL
- en: Use tunefs(8) to change any of these settings on an unmounted filesystem. Conveniently,
    tunefs(8) shows the command line flag to address each. I normally boot into single-user
    mode before changing a filesystem’s settings.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that you can adjust all sorts of filesystem internals, such
    as block arrangements and filesystem geometry. Don’t. In over two decades of FreeBSD
    use, I have never seen anyone improve their situation by twiddling these knobs.
    I have repeatedly seen people twiddle these knobs and ruin their day.
  prefs: []
  type: TYPE_NORMAL
- en: But let’s look at the settings you might actually need to enable and disable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Soft Updates and Journaling**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use the `-j` flag to enable or disable soft updates journaling on a filesystem.
    This automatically enables soft updates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To disable soft updates journaling, use the `disable` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A soft updates journal on a nonjournaled filesystem can only confuse matters.
    Mount the filesystem and remove the *.sujournal* file in the filesystem’s root
    directory. Note that turning off journaling leaves soft updates still in place.
    Use `-n enable` and `-n disable` to turn soft updates (without journaling) on
    and off.
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimum Free Space**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: UFS holds back 8 percent of each partition so that it has space to rearrange
    files for better performance. I discuss this further in “[UFS Space Reservations](ch11.xhtml#lev417)”
    on [page 249](ch11.xhtml#page_249). If you want to change this percentage, use
    the `-m` flag. Here, I tell the filesystem to reserve only 5 percent of the disk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You should now have more usable disk space. Also, UFS will run more slowly because
    it always packs the filesystem as tightly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**SSD TRIM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Solid-state disks use wear-leveling to extend their lifespan. Wear-leveling
    works best if the filesystem notifies the SSD when each block is no longer in
    use. The TRIM protocol handles this notification. Enable TRIM support on your
    SSD-backed filesystem with the `-t` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For the best results, enable TRIM for every partition on a solid-state drive.
    Enable TRIM at filesystem creation with `newfs -E`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Labeling UFS Filesystems**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can apply a UFS label to an existing filesystem with the `-L` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Don’t mix UFS and GPT labels—you’ll only confuse yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '***Expanding UFS Filesystems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your virtual machine runs out of space? Make the disk bigger, and expand the
    last partition to cover that space, as discussed in [Chapter 10](ch10.xhtml#ch10).
    But what about the filesystem on that partition? That’s where growfs(8) comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: The growfs(8) command expands an existing UFS filesystem to fill the partition
    it’s in. Give growfs one argument, the filesystem’s device node. Use labels if
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When growfs(8) requests confirmation ➊, you must enter the full word `yes`.
    Any other answer, including a plain `y` like many other programs accept, cancels
    the operation. Confirm the operation and growfs(8) will add additional blocks,
    superblocks, and inodes as needed to fill the partition.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want the filesystem to fill the entire partition, you can specify
    a size with `-s`. Here, I expand this same partition to 80GB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I strongly encourage you to make filesystems the same size as the underlying
    partitions, unless you’re looking to make your coworkers slap you.^([2](footnote.xhtml#ch11fn2))
  prefs: []
  type: TYPE_NORMAL
- en: '**UFS Snapshots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can take an image of a UFS filesystem at a moment in time; this is called
    a *snapshot*. You can snapshot a filesystem, erase and change some files, and
    then copy the unchanged files from the snapshot. Tools like dump(8) use snapshots
    to ensure consistent backups. UFS snapshots are not as powerful or flexible as
    ZFS snapshots, but they’re a solid, reliable tool within their limits.
  prefs: []
  type: TYPE_NORMAL
- en: UFS snapshots require soft updates but are incompatible with soft updates journaling.
    Each filesystem can have up to 20 snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshots let you get at the older version of an edited or removed file. Access
    the contents of a snapshot by mounting the file as a memory device. I’ll discuss
    memory devices in [Chapter 13](ch13.xhtml#ch13).
  prefs: []
  type: TYPE_NORMAL
- en: '***Taking and Destroying Snapshots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Create snapshots with mksnap_ffs(8). This program assumes you want to make
    a snapshot of the filesystem your current working directory is in. Give the snapshot
    location as an argument. Snapshots traditionally go in the *.snap* directory at
    the filesystem root. If you’re using a tool that automatically creates and removes
    snapshots, like dump(8), check there for your snapshot files. If you don’t like
    that location, though, you can put them anywhere on the filesystem you’re taking
    the snapshot of. Here, I took a snapshot of the */home* filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Snapshots use disk space. You can’t take a snapshot of a full filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: A snapshot is just a file. Remove the file and you destroy the snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding Snapshots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Snapshots are files, and you can put them anywhere on the filesystem. This means
    it’s easy to lose them. Use find(1) with the `-flags snapshot` option to find
    all snapshots on a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There’s my stray snapshot!
  prefs: []
  type: TYPE_NORMAL
- en: '***Snapshot Disk Usage***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A snapshot records the differences between the current filesystem and the filesystem
    as it existed when the snapshot was taken. Every filesystem change after taking
    a snapshot increases the size of the snapshot. If you remove a file, the snapshot
    retains a copy of that file so you can recover it later.
  prefs: []
  type: TYPE_NORMAL
- en: This means deleting data from a filesystem with snapshots doesn’t actually free
    up space. If you have a snapshot of your */home* partition and you delete a file,
    the deleted file gets added to the snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that filesystems with snapshots always have plenty of free space.
    If you try to take a snapshot and mksnap_ffs(8) complains that it can’t because
    there’s no space, you might already have 20 snapshots of that filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '**UFS Recovery and Repair**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everything from faulty hardware to improper systems administration^([3](footnote.xhtml#ch11fn3))
    can damage your filesystems. All of UFS’s resilience technologies are designed
    to quickly restore data integrity, but nothing can completely guarantee integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss how FreeBSD keeps each UFS filesystem tidy.
  prefs: []
  type: TYPE_NORMAL
- en: '***System Shutdown: The Syncer***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you shut down a FreeBSD system, the kernel synchronizes all its data to
    the hard drive, marks the disks clean, and shuts down. This is done by a kernel
    process called the *syncer*. During a system shutdown, the syncer reports on its
    progress in synchronizing the hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see odd things from the syncer during shutdown. The syncer walks the
    list of vnodes that need synchronizing to disk, allowing it to support all filesystems,
    not just UFS. Thanks to soft updates, writing one vnode to disk can generate another
    dirty vnode that needs updating. You can see the number of buffers being written
    to disk rapidly drop from a high value to a low value and perhaps bounce between
    zero and a low number once or twice as the system really, truly synchronizes the
    hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: If the syncer doesn’t get a chance to finish, or if the syncer doesn’t run at
    all thanks to your ham-fisted fumbling, you get a dirty filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '***Dirty Filesystems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: No, disks don’t get muddy with use (although dust on a platter will quickly
    damage it, and adding water won’t help). A dirty UFS partition is in a kind of
    limbo; the operating system has asked for information to be written to the disk,
    but the data is not yet completely on the physical media. Part of the data blocks
    might have been written, the inode might have been edited but the data not written
    out, or any combination of the two. Live filesystems are almost always dirty.
  prefs: []
  type: TYPE_NORMAL
- en: If a host with dirty filesystems fails—say, due to a panic or Bert tripping
    over the power cable, the filesystem is still dirty when the system boots again.
    The kernel refuses to mount a dirty filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning the filesystem restores data integrity but doesn’t necessarily mean
    that all your data is on the disk. If a file was half-written to disk when the
    system died, the file is lost. Nothing can restore the missing half of the file,
    and the half on disk is essentially useless.
  prefs: []
  type: TYPE_NORMAL
- en: Journaled filesystems should automatically recover when FreeBSD tries to mount
    them. If the filesystem can’t recover, or if you don’t have a journal, you’ll
    need to use the legendary fsck(8).
  prefs: []
  type: TYPE_NORMAL
- en: '***File System Checking: fsck(8)***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fsck(8) program examines a UFS filesystem and tries to verify that every
    file is attached to the proper inodes and in the correct directory. It’s like
    verifying a database’s referential integrity. If the filesystem suffered only
    minor damage, fsck(8) can automatically restore integrity and put the filesystem
    back in service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repairing a damaged filesystem takes time and memory. A fsck(8) run requires
    about 700MB of RAM to analyze a 1TB filesystem. Most computer systems have fairly
    proportional memory and storage systems: very few hosts have 512MB RAM and petabytes
    of disk. But you should know it’s possible to create a UFS filesystem so large
    that the system doesn’t have enough memory to repair it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual fscks Runs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Occasionally this automated fsck-on-reboot fails to work. When you check the
    console, you’ll be looking at a single-user mode prompt and a request to run fsck(8)
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: Start by *preening* the filesystem with `fsck -p`. This automatically corrects
    a bunch of less severe errors without asking for your approval. Preening causes
    data loss only rarely. This is frequently successful, but if it doesn’t work,
    it will ask you to run a “full fsck.”
  prefs: []
  type: TYPE_NORMAL
- en: If you enter `fsck` at the command prompt, fsck(8) verifies every block and
    inode on the disk. It finds any blocks that have become disassociated from their
    inodes and guesses how they fit together and how they should be attached. However,
    fsck(8) might not be able to identify which directory these files belong in.
  prefs: []
  type: TYPE_NORMAL
- en: Then, fsck(8) asks whether you want to perform these reattachments. If you answer
    `n`, it deletes the damaged files. If you answer `y`, it adds the lost file to
    a *lost+found* directory in the root of the partition, with a number as a filename.
    For example, the *lost+found* directory on your */usr* partition is */usr/lost+found*.
    If there are only a few files, you can identify them manually; if you have many
    files and are looking for particular ones, tools such as file(1) and grep(1) can
    help you identify them by content.
  prefs: []
  type: TYPE_NORMAL
- en: If you answer `n`, those nuggets of unknown data remain detached from the filesystem.
    The filesystem remains dirty until you fix them by some other means.
  prefs: []
  type: TYPE_NORMAL
- en: '**Trusting fsck(8)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If fsck(8) can’t figure out where a file goes . . . can you? If not, you really
    have no choice but to trust fsck(8) to recover your system or restore from backup.
  prefs: []
  type: TYPE_NORMAL
- en: A full fsck(8) run inspects every block, inode, and superblock, and identifies
    every inconsistency. It asks you to type `y` or `n` to approve or reject every
    single correction. Any change you reject you must fix yourself, through some other
    means. You might spend hours at the console typing `y`, `y`, `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So I’ll ask again: if fsck(8) can’t fix a problem, can you?'
  prefs: []
  type: TYPE_NORMAL
- en: If you can’t, consider `fsck -y`. The `-y` flag tells fsck(8) to reassemble
    these files as best it can, without prompting you. It assumes you answer all its
    questions “yes,” even the really dangerous ones. Using `-y` automatically triggers
    `-R`, which tells fsck(8) to retry cleaning each filesystem until it succeeds
    or it’s had 10 consecutive failures. It’s cure or kill. You *do* have backups,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: '**DANGER!**'
  prefs: []
  type: TYPE_NORMAL
- en: Running `fsck -y` is not guaranteed safe. At times, when running -current or
    when doing other daft things, I’ve had `fsck -y` migrate the entire contents of
    a filesystem to *lost+found*. Recovery becomes difficult at that point. Having
    said that, in a production system running FreeBSD-stable with a standard UFS filesystem,
    I’ve never had a problem.
  prefs: []
  type: TYPE_NORMAL
- en: You can set your system to try `fsck -y` automatically on boot. I don’t recommend
    this, however, because if there’s the faintest chance my filesystem will wind
    up in digital nirvana, I want to know about it. I want to type the offending command
    myself and feel the trepidation of hearing my disks churn. Besides, it’s always
    unpleasant to discover that your system is trashed without having the faintest
    clue how it got that way. If you’re braver than I, set `fsck_y_enable="YES"` in
    *rc.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoiding fsck -y**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What options do you have if you don’t want to use `fsck -y`? Well, fsdb(8) and
    clri(8) allow you to debug the filesystem and redirect files to their proper locations.
    You can restore files to their correct directories and names. This is difficult,^([4](footnote.xhtml#ch11fn4))
    however, and is recommended only for Secret Ninja Filesystem Masters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Background fsck**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Background fsck gives UFS some of the benefits of a journaled filesystem without
    actually requiring journaling. You must be using soft updates without journaling
    to use background fsck. (Soft updates with journaling is far, far preferable to
    background fsck.) When FreeBSD sees that a background fsck is in process after
    a reboot, it mounts the dirty disk read-write. While the server is running, fsck(8)
    runs in the background, identifying loose bits of files and tidying them up behind
    the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: A background fsck actually has two major stages. When FreeBSD finds dirty disks
    during the initial boot process, it runs a preliminary fsck(8) assessment of the
    disks. The fsck(8) program decides whether the damage can be repaired while the
    system is running or whether a full single-user mode fsck run is required. Most
    frequently, fsck thinks it can proceed and lets the system boot. After the system
    reaches single-user mode, the background fsck runs at a low priority, checking
    the partitions one by one. The results of the fsck process appear in */var/log/messages*.
  prefs: []
  type: TYPE_NORMAL
- en: You can expect performance of any applications requiring disk activity to be
    lousy during a background fsck. The fsck(8) program occupies a large portion of
    the disk’s possible activity. While your system might be slow, it will at least
    be up.
  prefs: []
  type: TYPE_NORMAL
- en: You *must* check */var/log/messages* for errors after a background fsck. The
    preliminary fsck assessment can make an error, and perhaps a full single-user
    mode’s fsck on a partition really is required. If you find such a message, schedule
    downtime within a few hours to correct the problem. While inconvenient, having
    the system down for a scheduled period is better than the unscheduled downtime
    caused by a power outage and the resulting single-user mode’s `fsck -y`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Forcing Read-Write Mounts on Dirty Disks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you really want to force FreeBSD to mount a dirty disk read-write without
    using a background fsck, you can. You won’t like the results. At all. But, as
    it’s described in mount(8), some reader will think it’s a good idea unless they
    know why. Use the `-w` (read-write) and `-f` (force) flags to mount(8).
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a dirty partition read-write corrupts data. Note the absence of words
    like *might* and *could* from that sentence. Also note I didn’t use *recoverable*.
    Mounting a dirty filesystem may panic your computer. It might destroy all remaining
    data on the partition or even shred the underlying filesystem. Forcing a read-write
    mount of a dirty filesystem is seriously bad juju. Don’t do it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Background fsck, fsck -y, Foreground fsck, Oy Vey!***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All these different fsck(8) problems and situations can occur, but when does
    FreeBSD use each command? FreeBSD uses the following conditions to decide when
    and how to fsck(8) on a filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: If the filesystem is clean, it is mounted without fsck(8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a journaled filesystem is dirty at boot, FreeBSD recovers the data from the
    journal and continues the boot. A journaled filesystem rarely needs fsck(8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a filesystem without soft updates is dirty at boot, FreeBSD runs fsck(8)
    on it. If the filesystem damage is severe, FreeBSD stops checking and requests
    your intervention. You can either run `fsck -y` or manually approve each correction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a filesystem with soft updates is dirty at boot, FreeBSD performs a very
    basic fsck(8) check. If the damage is mild, FreeBSD can use a background fsck(8)
    in multiuser mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the damage is severe, or you don’t want background fsck(8), FreeBSD interrupts
    the boot and requests a manual fsck(8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the recovery path when configuring your UFS filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: '**UFS Space Reservations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A UFS filesystem is never quite as large as you think it should be. UFS holds
    back 8 percent of the filesystem space for on-the-fly optimization. Only root
    can write over that limit. That’s why a filesystem can seem to use more than 100
    percent of the available space. Why 8 percent? That number’s the result of many
    years of experience and real-world testing. That 8 percent holdback isn’t a big
    deal on average filesystems, but as the filesystem grows, it can be considerable.
    On a 1PB disk array, UFS holds 80TB in reserve.
  prefs: []
  type: TYPE_NORMAL
- en: UFS behaves differently depending on how full a filesystem gets. On an empty
    filesystem, it optimizes for speed. Once the filesystem hits 92 percent full (85
    percent of the total size, including the 8 percent reserve), it switches to optimize
    space utilization. Most people do the same thing—once you mostly fill up the laundry
    hamper, you can jam more dirty clothes in, but it takes a little more time and
    effort. UFS fragments files to use space more effectively. Fragments reduce disk
    performance. As free space shrinks, UFS works harder and harder to improve space
    utilization. A full UFS filesystem runs at about one-third the normal speed.
  prefs: []
  type: TYPE_NORMAL
- en: You might want to use tunefs(8) to reduce the amount of disk space FreeBSD holds
    in reserve. It won’t help as much as you think. Reducing the reserve to 5 percent
    or less tells UFS to always use space optimization and pack the filesystem as
    tightly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the reserved space percentage doesn’t improve performance. If you
    increase the reserved space percentage so that your filesystem appears full, regular
    users won’t be able to write files.^([5](footnote.xhtml#ch11fn5))
  prefs: []
  type: TYPE_NORMAL
- en: The reserved space can confuse tools such as NFS. Some other operating systems
    that can mount UFS over NFS see that a filesystem is 100 percent full and tell
    the user they can’t write files, despite local clients being able to write files.
    Remember this when troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing to do is to keep your partition from filling up.
  prefs: []
  type: TYPE_NORMAL
- en: '**How Full Is a Partition?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get an overview of how much space each UFS partition has left, use df(1).
    This lists the partitions on your system, the amount of space each uses, and where
    it’s mounted. (Don’t use df(1) with ZFS; we’ll discuss why in the next chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: '**$BLOCKSIZE**'
  prefs: []
  type: TYPE_NORMAL
- en: One annoying thing about FreeBSD’s disk utilities, including df(1), is that
    they default to providing information in 512-byte blocks. Blocks were fine with
    tiny disks that used 512-byte physical blocks, but it’s not a useful measurement
    today. The environment variable `$BLOCKSIZE` controls what unit df(1) provides
    output in. The default *.cshrc* and *.profile* set `$BLOCKSIZE` to 1KB, which
    makes df(1) show kilobytes instead of blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The `-h` and `-H` flags tell df(1) to produce human-readable output rather than
    using blocks. The small `-h` uses base 2 to create a 1,024-byte megabyte, while
    the large `-H` uses base 10 for a 1,000-byte megabyte. Typically, network administrators
    and disk manufacturers use base 10, while system administrators use base 2\. Either
    works so long as you know which you’ve chosen. I’m a network administrator, so
    you get to suffer through my prejudices in these examples, despite what my tech
    editor thinks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first line shows us column headers ➊ for the provider name, the size of
    the partition, the amount of space used, the amount of space available, the percent
    of space used, and the mount point. We can see that the partition labeled */dev/gpt/root*
    ➋ is only 1GB in size but has only 171MB on it, leaving 785MB free. It’s 18 percent
    full and mounted on */*.
  prefs: []
  type: TYPE_NORMAL
- en: If your systems are like mine, disk usage somehow keeps growing for no apparent
    reason. Look at the */usr* partition ➌ here. It’s 98 percent full. You can identify
    individual large files with `ls -l`, but recursively doing this on every directory
    in the system is impractical.
  prefs: []
  type: TYPE_NORMAL
- en: 'The du(1) program displays disk usage in a single directory. Its initial output
    is intimidating and can scare off inexperienced users. Here, we use du(1) to find
    out what’s taking up all the space in my home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This goes on and on, displaying every subdirectory and giving its size in blocks.
    The total of each subdirectory is given—for example, the contents of *$HOME/bin*
    totals 53,336 blocks, or roughly 53MB. I could sit and let du(1) list every directory
    and subdirectory, but then I’d have to dig through much more information than
    I really want to. And blocks aren’t that convenient a measurement, especially
    not when they’re printed left-justified.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s clean this up. First, du(1) supports an `-h` flag much like df. Also,
    I don’t need to see the recursive contents of each subdirectory. We can control
    the number of directories we display with du’s `-d` flag. This flag takes one
    argument, the number of directories you want to explicitly list. For example,
    `-d0` goes one directory deep and gives a simple subtotal of the files in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: I have 14 gigs of data in my home directory? Let’s look a layer deeper and identify
    the biggest subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Apparently I must look elsewhere for storage space, as the data in my home directory
    is too important to delete. Maybe I should just grow the virtual disk under this
    host.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not too attached to the `-h` flag, you can use sort(1) to find the
    largest directory with a command like `du -kxd 1 | sort -n`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding New UFS storage**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No matter how much planning you do, eventually your hard drives will fill up.
    You’ll need to add disks. Before you can use a new hard drive, you must partition
    the drive, create filesystems, mount those filesystems, and move data to them.
  prefs: []
  type: TYPE_NORMAL
- en: Give the design of your new disk partitioning and filesystems as much thought
    as you did the initial install. It’s much easier to partition disks correctly
    at install than to go back and repartition disks with data on them.
  prefs: []
  type: TYPE_NORMAL
- en: '**BACK UP, BACK UP, BACK UP!**'
  prefs: []
  type: TYPE_NORMAL
- en: Before doing anything with disks, be sure that you have a complete backup. A
    single dumb fat-finger mistake can destroy your system! While you rarely plan
    to reformat your root filesystem, if it happens, you want to recover really, really
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '***Partitioning the Disk***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While you can partition the disk any way you like, I recommend that new disks
    use the same partitioning scheme as the rest of the host. Having one disk partitioned
    with MBR and one with GPT is annoying. I’ll use GPT for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Decide how you want to divide the disk. This is a 1TB disk. 100GB will go to
    an expanded */tmp*. I’ll dedicate 500GB to my new database partition. The remaining
    space gets partitioned off but labeled *emergency*. I won’t put a filesystem in
    that space; it’s there in case I need to do a full memory dump or have to put
    some files somewhere. I’m putting it right next to the database partition so I
    can grow the database partition if needed. I could leave the emergency space unpartitioned,
    but I want it to have a GPT label so that my fellow sysadmins realize this free
    space isn’t accidental.
  prefs: []
  type: TYPE_NORMAL
- en: Start by destroying any partitioning scheme on the disk and creating a GPT scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now create your 100GB */tmp* and 500GB data partitions, and dump the rest into
    the emergency partition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Check your work with `gpart show`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Create filesystems on each partition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As */tmp* gets emptied at every boot, I would prefer not to use soft updates
    journaling on */tmp*. Instead, I’d mount */tmp* async and run `newfs /dev/gpt/tmp`
    at boot. Many times, newfs(8) is faster than rm(1).
  prefs: []
  type: TYPE_NORMAL
- en: '***Configuring /etc/fstab***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now tell */etc/fstab* about your filesystems. We discuss the format of */etc/fstab*
    in [Chapter 10](ch10.xhtml#ch10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: FreeBSD will recognize the filesystems at boot, or you can mount these new partitions
    at the command line. Don’t reboot or mount the partitions just yet, though. First
    you’ll want to move files to those filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing Existing Files onto New Disks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Chances are that you intend your new disk to replace or subdivide an existing
    partition. You’ll need to mount your new partition on a temporary mount point,
    move files to the new disk, then remount the partition at the desired location.
    While */tmp* doesn’t have any files, if we’re installing a new database filesystem,
    we presumably have database files to put there.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving files, shut down any process using them. You cannot successfully
    copy files that are being changed as you copy them. If you’re moving your database
    files, shut down your database. If you’re moving your mail spool, shut down all
    of your mail programs. This is a big part of why I recommend doing all new disk
    installations in single-user mode.
  prefs: []
  type: TYPE_NORMAL
- en: Now mount your new partition on a temporary mount point. That’s exactly what
    */mnt* is for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now you must move the files from their current location to the new disk without
    changing their permissions. This is fairly simple with tar(1). You can simply
    tar up your existing data to a tape or a file and untar it in the new location,
    but that’s kind of clumsy. Pipe one `tar` into another to avoid the middle step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t speak Unix at parties, this looks fairly stunning. Let’s dismantle
    it. First, we go to the old directory and tar up everything. Then, pipe the output
    to a second command, which extracts the backup in the new directory. When this
    command finishes, your files are installed on their new disk. For example, to
    move */usr/local/etc/postgres* onto a new partition temporarily mounted at */mnt*,
    you would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the temporary mount point to be sure that your files are actually there.
    Once you’re confident that the files are properly moved, remove the files from
    the old directory and mount the disk in the new location. For example, after duplicating
    your files from */usr/local/etc/postgres*, you’d run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can now resume normal operation. I recommend rebooting to verify that everything
    comes back exactly as you intended.
  prefs: []
  type: TYPE_NORMAL
- en: '***Stackable Mounts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Maybe you don’t care about your old data; you want to split an existing filesystem
    only to get more space and you intend to recover your data from backup. That’s
    fine. All FreeBSD filesystems are *stackable*. This is an advanced idea that’s
    not terribly useful in day-to-day system administration, but it can bite you when
    you try to split one partition into two.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, for example, that you have data in */usr/src*. See how much space is
    used on your disk, and then mount a new empty partition on */usr/src*. If you
    look in the directory afterward, you’ll see that it’s empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the problem: the old filesystem still has all its original data on it.
    The new filesystem is mounted “above” the old filesystem, so you see only the
    new filesystem. The old filesystem has no more free space than before you moved
    the data. If you unmount the new filesystem and check the directory again, you’ll
    see the data miraculously restored! The new filesystem obscured the lower filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can’t see the data, data on the old filesystem still takes up
    space. If you’re adding a filesystem to gain space, and you mount a new filesystem
    over part of the old, you won’t free any space on your original filesystem. The
    moral is: even if you’re restoring your data from backup, make sure that you remove
    that data from your original disk to recover disk space.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can talk UFS, let’s explore ZFS.
  prefs: []
  type: TYPE_NORMAL
