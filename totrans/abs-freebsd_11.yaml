- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: THE UNIX FILE SYSTEM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**UNIX文件系统**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: FreeBSD’s filesystem, the Unix File System (UFS), is a direct descendant of
    the filesystem shipped with BSD 4.4\. One of the original UFS authors still develops
    the FreeBSD filesystem and has added many nifty features in recent years. FreeBSD
    is not the only operating system to still use the 4.4 BSD filesystem or a descendant
    thereof. A Unix vendor that doesn’t specifically tout its “improved and advanced”
    filesystem is probably running a UFS derivative.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的文件系统——Unix文件系统（UFS）是BSD 4.4自带文件系统的直接后代。原UFS的作者之一仍然在开发FreeBSD的文件系统，并在近年来增加了许多有用的功能。FreeBSD并不是唯一一个仍在使用4.4
    BSD文件系统或其后代的操作系统。如果一个Unix供应商没有特别宣传其“改进和高级”的文件系统，那么它很可能正在使用UFS衍生系统。
- en: UFS’s place as the primordial filesystem has given it leave to extend tendrils
    throughout FreeBSD. Many UFS concepts underlie FreeBSD’s support for other filesystems,
    from ZFS to optical disks. Even if you have no intention of ever using UFS, you
    must understand the basics of UFS to understand how FreeBSD manages filesystems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: UFS作为最初的文件系统，使其有机会在FreeBSD中扩展。许多UFS的概念为FreeBSD支持其他文件系统提供了基础，从ZFS到光盘。即使你不打算使用UFS，了解UFS的基本知识也是理解FreeBSD如何管理文件系统的关键。
- en: Like the rest of Unix, UFS is designed to handle the most common situations
    effectively while reliably supporting unusual configurations. FreeBSD ships with
    UFS configured to be as widely useful as possible on relatively modern hardware,
    but you can choose to optimize a particular filesystem for trillions of small
    files or a half-dozen 1TB files if you must.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 像Unix的其他部分一样，UFS旨在有效地处理最常见的情况，同时可靠地支持不常见的配置。FreeBSD自带的UFS配置旨在尽可能在现代硬件上广泛使用，但如果需要，你可以选择为数万亿个小文件或几块1TB的大文件优化特定的文件系统。
- en: What we call UFS today is actually UFS version 2, or *UFS2*. Primordial UFS
    can’t handle modern disk sizes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天所称的UFS实际上是UFS版本2，或称*UFS2*。原始UFS无法处理现代的磁盘容量。
- en: UFS is best suited for smaller systems, or applications that can’t handle the
    overhead of ZFS. Many people prefer UFS for virtual machines. I discuss choosing
    a filesystem in [Chapter 2](ch02.xhtml#ch02).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: UFS最适合较小的系统或无法处理ZFS开销的应用程序。许多人更喜欢在虚拟机中使用UFS。我在[第2章](ch02.xhtml#ch02)中讨论了选择文件系统的问题。
- en: '**UFS Components**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**UFS组件**'
- en: UFS is built of two layers, one called the *Unix File System* and the other
    the *Fast File System (FFS)*. UFS handles items like filenames, attaching files
    to directories, permissions, and all of those petty details users care about.
    FFS does the real work in getting files written to disk and arranging them for
    quick access. The two work together to provide data storage.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: UFS由两层构成，一层叫做*Unix文件系统*，另一层是*快速文件系统（FFS）*。UFS处理文件名、将文件附加到目录、权限以及用户关心的所有琐碎细节。FFS则负责将文件写入磁盘并对其进行排列，以便快速访问。这两者协同工作提供数据存储。
- en: '***The Fast File System***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***快速文件系统***'
- en: FFS is built of superblocks, blocks, fragments, and inodes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: FFS由超级块、块、碎片和索引节点组成。
- en: A *superblock* records the filesystem’s characteristics. It contains a magic
    number that identifies the filesystem as UFS, as well as filesystem geometry information
    the kernel uses to optimize writing and reading files. A UFS filesystem keeps
    many backup copies of the superblock, in case the primary gets damaged.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*超级块*记录了文件系统的特征。它包含一个魔术数字，用于识别文件系统为UFS，以及内核用于优化文件读写的文件系统几何信息。UFS文件系统会保留多个超级块的备份，以防主块损坏。'
- en: '*Blocks* are segments of disk that contain data. FreeBSD defaults to 32KB blocks.
    FFS maps blocks onto specific sectors on the underlying disk or GEOM provider.
    Every stored file gets broken up into 32KB chunks, and each chunk is stored in
    its own block.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*块*是存储数据的磁盘片段。FreeBSD默认使用32KB的块。FFS将块映射到底层磁盘或GEOM提供者的特定扇区。每个存储的文件都会被分割成32KB的块，每个块都会存储在自己的块中。'
- en: Not all files are even multiples of 32KB, so FFS stores the leftovers in *fragments*.
    The standard is one-eighth of the block size, or 4KB. For example, a 39KB file
    would fill one block and two fragments. One of those fragments has only 3KB in
    it, so fragments do waste disk space—but they waste far less space than using
    full blocks everywhere.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有文件都是32KB的整数倍，因此FFS将剩余部分存储在*碎片*中。标准为块大小的八分之一，即4KB。例如，一个39KB的文件将填满一个块和两个碎片。一个碎片只有3KB，因此碎片确实浪费了磁盘空间——但它们浪费的空间比到处使用完整块要少得多。
- en: '***How UFS Uses FFS***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***UFS如何使用FFS***'
- en: UFS allocates certain FFS blocks as *inodes*, or *index nodes*, to map blocks
    and fragments to files. An inode contains each file’s size, permissions, and the
    list of blocks and fragments containing each file. Collectively, the data in an
    inode is known as *metadata*, or data about data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: UFS 将某些 FFS 块分配为 *inode*，或 *索引节点*，用来将块和碎片映射到文件。一个 inode 包含每个文件的大小、权限以及包含该文件的块和碎片列表。总的来说，inode
    中的数据被称为 *元数据*，即关于数据的数据。
- en: Each filesystem has a certain number of inodes, proportional to the filesystem
    size. A modern disk probably has hundreds of thousands of inodes on each partition,
    enough to support hundreds of thousands of files. If you have a truly large number
    of very tiny files, however, you might need to rebuild your filesystem to support
    additional inodes. Use `df -i` to see how many inodes remain free on your filesystem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件系统有一定数量的 inode，与文件系统的大小成比例。现代磁盘每个分区可能有数十万个 inode，足以支持数十万个文件。然而，如果你有大量非常小的文件，你可能需要重建文件系统来支持更多的
    inode。使用 `df -i` 查看文件系统中剩余的 inode 数量。
- en: Theoretically, it was possible to run UFS on a storage layer other than FFS.
    That’s how many log-based or extent-based filesystems work. Over decades of development,
    though, UFS features like journaling and soft updates have so greatly entangled
    FreeBSD’s UFS and FFS that separating the two is no longer realistic or even vaguely
    plausible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，UFS 可以在除 FFS 以外的存储层上运行。这也是许多基于日志或基于区块的文件系统的工作原理。然而，经过数十年的发展，UFS 和 FFS 的特性，如日志和软更新，已经深度交织在一起，以至于分离这两者变得不再现实，甚至连稍微可行的可能性都没有。
- en: '***Vnodes***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Vnodes***'
- en: Inodes and blocks worked perfectly if the only filesystem you used was UFS and
    all your hard drives were permanently attached. These days, we routinely swap
    disks between different machines and even different operating systems. You probably
    need to read optical media and flash disks on your desktop, and servers might
    even need to accept hard drives formatted for a different operating system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只使用 UFS 文件系统，并且所有硬盘都永久附加，那么 inode 和块的工作是完美的。然而，现如今我们通常会在不同的机器之间甚至不同的操作系统之间交换磁盘。你可能需要在桌面上读取光盘和闪存磁盘，服务器甚至可能需要接受为不同操作系统格式化的硬盘。
- en: FreeBSD uses a storage abstraction layer—the *virtual node*, or *vnode*—to mediate
    between filesystems and the kernel. You’ll never directly manipulate a vnode,
    but the FreeBSD documentation frequently refers to them. Vnodes are a translation
    layer between the kernel and whatever filesystem you’ve mounted. If you’re an
    object-oriented programmer, think of a vnode like a base class that all storage
    classes inherit. When you write a file to a UFS filesystem, the kernel addresses
    the data to a vnode that, in turn, is mapped to a UFS inode and FFS blocks. When
    you write to a FAT32 filesystem, the kernel addresses data to a vnode that’s mapped
    to a specific part of the FAT32 filesystem. Use inodes only when dealing with
    UFS filesystems, but use vnodes when dealing with any filesystem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 使用存储抽象层——*虚拟节点*，或 *vnode*——在文件系统和内核之间进行调解。你永远不会直接操作 vnode，但 FreeBSD
    文档经常提到它们。Vnode 是内核与已挂载文件系统之间的翻译层。如果你是面向对象编程的开发者，可以把 vnode 想象成所有存储类继承的基类。当你写文件到
    UFS 文件系统时，内核将数据定向到一个 vnode，这个 vnode 又映射到一个 UFS inode 和 FFS 块。当你写入 FAT32 文件系统时，内核将数据定向到一个
    vnode，该 vnode 映射到 FAT32 文件系统的特定部分。只有在处理 UFS 文件系统时才使用 inode，但在处理任何文件系统时都使用 vnode。
- en: '**Mounting and Unmounting Filesystems**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挂载和卸载文件系统**'
- en: The mount(8) program’s main function is attaching filesystems to a host’s filesystem
    tree. While FreeBSD mounts every filesystem listed in */etc/fstab* at boot time,
    you must understand how mount(8) works. If you’ve never played with mounting before,
    boot your FreeBSD test machine into the single-user mode (see [Chapter 4](ch04.xhtml#ch04))
    and follow along.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: mount(8) 程序的主要功能是将文件系统附加到主机的文件系统树上。虽然 FreeBSD 在启动时会挂载 */etc/fstab* 中列出的每个文件系统，但你必须理解
    mount(8) 的工作原理。如果你之前从未操作过挂载，可以将你的 FreeBSD 测试机启动到单用户模式（参见 [第 4 章](ch04.xhtml#ch04)）并跟随操作。
- en: In single-user mode, FreeBSD has mounted the root partition read-only. On a
    traditional Unix-like system, the root partition contains just enough of the system
    to perform basic setup, get core services running, and find the rest of the filesystems.
    Other filesystems aren’t mounted, so their content is inaccessible. The current
    FreeBSD installer puts everything in the root partition, so you’d get the basic
    operating system, but any special filesystems, network mounts, and so on would
    be empty. You might need to mount other filesystems to perform your system maintenance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在单用户模式下，FreeBSD 会将根分区挂载为只读。在传统的类 Unix 系统中，根分区只包含足够的系统文件来执行基本的设置、启动核心服务并找到其余的文件系统。其他文件系统没有被挂载，因此它们的内容无法访问。当前的
    FreeBSD 安装程序将所有内容放在根分区中，因此你可以得到基本的操作系统，但任何特殊的文件系统、网络挂载等都会是空的。你可能需要挂载其他文件系统来进行系统维护。
- en: '***Mounting Standard Filesystems***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***挂载标准文件系统***'
- en: To manually mount a filesystem listed in */etc/fstab*, such as */var* or */usr*,
    give mount(8) the name of the filesystem you want to mount.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动挂载在 */etc/fstab* 中列出的文件系统，例如 */var* 或 */usr*，可以给 mount(8) 命令指定你想要挂载的文件系统名称。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This mounts the partition exactly as listed in */etc/fstab*, with all the options
    specified in that file. If you want to mount all the partitions listed in */etc/fstab*,
    except those labeled `noauto`, use mount’s `-a` flag.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这会按照 */etc/fstab* 中列出的方式挂载分区，并带有该文件中指定的所有选项。如果你想挂载 */etc/fstab* 中列出的所有分区，除了那些标记为
    `noauto` 的分区，可以使用 mount 命令的 `-a` 标志。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you mount all filesystems, filesystems that are already mounted don’t get
    remounted.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你挂载所有文件系统时，已经挂载的文件系统不会被重新挂载。
- en: '***Special Mounts***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***特殊挂载***'
- en: 'You might need to mount a filesystem at an unusual location or mount something
    temporarily. I most commonly mount disks manually when installing a new disk.
    Use the device node and the desired mount point. If my */var/db* partition is
    */dev/gpt/db* and I want to mount it on */mnt*, I would run:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要将文件系统挂载到不寻常的位置或临时挂载某个东西。我通常在安装新磁盘时手动挂载磁盘。使用设备节点和期望的挂载点。如果我的 */var/db* 分区是
    */dev/gpt/db*，并且我想将其挂载到 */mnt*，我会运行：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***Unmounting a Partition***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***卸载分区***'
- en: When you want to disconnect a filesystem from the system, use umount(8) to tell
    the system to unmount the partition. (Note that the command is `umount`, not `u`n`mount`.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要从系统中断开文件系统时，可以使用 umount(8) 命令告知系统卸载该分区。（注意命令是 `umount`，而不是 `u`n`mount`。）
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You cannot unmount filesystems that are in use by any program. If you cannot
    unmount a partition, you’re probably accessing it somehow. Even a command prompt
    in the mounted directory prevents you from unmounting the underlying partition.
    Running `fstat | grep /usr` (or whatever the partition is) can expose the blocking
    program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能卸载正在被任何程序使用的文件系统。如果你无法卸载某个分区，可能是你正在以某种方式访问它。即使是命令行提示符在挂载目录中，也会阻止你卸载底层分区。运行
    `fstat | grep /usr`（或其他分区）可以显示阻止操作的程序。
- en: '***UFS Mount Options***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***UFS 挂载选项***'
- en: FreeBSD supports several mount options that change filesystem behavior. When
    you manually mount a partition, you can specify any mount option with `-o`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 支持几种挂载选项来改变文件系统的行为。当你手动挂载分区时，可以使用 `-o` 参数来指定任何挂载选项。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also specify mount options in `/etc/fstab` (see [Chapter 10](ch10.xhtml#ch10)).
    Here, I use the `ro` option on the */home* filesystem, just as in the preceding
    command line.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `/etc/fstab` 中指定挂载选项（见 [第 10 章](ch10.xhtml#ch10)）。在这里，我对 */home* 文件系统使用
    `ro` 选项，就像在前面的命令行中一样。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The mount(8) man page lists all of the UFS mount options, but here are the most
    commonly used ones.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: mount(8) 手册页列出了所有 UFS 挂载选项，但这里是最常用的一些。
- en: '**Read-Only Mounts**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**只读挂载**'
- en: If you want to look at the contents of a disk but disallow changing them, mount
    the partition *read-only*. You cannot alter the data on the disk or write any
    new data. In most cases, this is the safest and the most useless way to mount
    a disk.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看磁盘的内容，但不允许更改它们，可以将分区挂载为 *只读*。你不能修改磁盘上的数据或写入任何新数据。在大多数情况下，这种方式是最安全但最没有用的挂载方式。
- en: Many system administrators want to mount the root partition, and perhaps even
    */usr*, as read-only to minimize potential system damage from an intruder or malicious
    software. This maximizes system stability but vastly complicates maintenance.
    If you use an automatic deployment system, such as Ansible or Puppet, and habitually
    redeploy your servers from scratch rather than upgrading them, read-only mounts
    might be a good fit for you.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统管理员希望将根分区，甚至 */usr*，挂载为只读，以最小化来自入侵者或恶意软件对系统的潜在损害。这最大化了系统的稳定性，但极大地增加了维护的复杂性。如果你使用自动部署系统，如
    Ansible 或 Puppet，并且习惯性地从零开始重新部署服务器，而不是进行升级，那么只读挂载可能适合你。
- en: Read-only mounts are especially valuable on a damaged computer. While FreeBSD
    won’t let you perform a standard read-write mount on a damaged or dirty filesystem,
    it will perform a read-only mount if the filesystem isn’t too badly fubar. This
    gives you a chance to recover data from a dying disk.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只读挂载在损坏的计算机上尤其有价值。当 FreeBSD 检测到文件系统损坏或脏文件系统时，它不会允许执行标准的读写挂载，但如果文件系统没有严重损坏，它会执行只读挂载。这为从濒临崩溃的磁盘中恢复数据提供了机会。
- en: To mount a filesystem read-only, use either the `rdonly` or `ro` option. Both
    work identically.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要以只读方式挂载文件系统，请使用 `rdonly` 或 `ro` 选项。两者效果相同。
- en: '**Synchronous Mounts**'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**同步挂载**'
- en: '*Synchronous* (or *sync*) *mounts* are the old-fashioned way of mounting filesystems.
    When you write to a synchronously mounted disk, the kernel waits to see whether
    the write is actually completed before informing the program. If the write didn’t
    complete successfully, the program can choose to act accordingly.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*同步*（或 *sync*）*挂载*是挂载文件系统的老式方式。当你向同步挂载的磁盘写入数据时，内核会等待写入是否实际完成，然后才告知程序。如果写入没有成功完成，程序可以选择相应地采取措施。'
- en: Synchronous mounts provide the greatest data integrity in the case of a crash,
    but they’re also slow. Admittedly, “slow” is relative today, when even a cheap
    disk outperforms what was the high end several years ago. Consider using synchronous
    mounting when you wish to be truly pedantic on data integrity, but in almost all
    cases, it’s overkill.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同步挂载在崩溃时提供最大的数据信用度，但它也比较慢。诚然，如今“慢”是相对的，因为即使是便宜的磁盘也能超越几年前的高端产品。如果你希望在数据完整性方面表现得极为谨慎，可以考虑使用同步挂载，但在几乎所有情况下，它都是过度的。
- en: To mount a partition synchronously, use the option `sync`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要同步挂载分区，请使用 `sync` 选项。
- en: '**Asynchronous Mounts**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**异步挂载**'
- en: While *asynchronous mounts* are pretty much supplanted by soft updates (see
    “[Soft Updates](ch11.xhtml#lev389)” on [page 237](ch11.xhtml#page_237)), you’ll
    still hear about them. For faster data access at higher risk, mount your partitions
    asynchronously. When a disk is asynchronously mounted, the kernel writes data
    to the disk and tells the writing program that the write succeeded without waiting
    for the disk to confirm that the data was actually written.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *异步挂载* 很大程度上被软更新取代（参见[软更新](ch11.xhtml#lev389)章节，第[237页](ch11.xhtml#page_237)），你仍然会听到关于它们的讨论。为了更快的数据访问但伴随更高的风险，可以选择异步挂载分区。当磁盘以异步方式挂载时，内核会将数据写入磁盘，并在不等待磁盘确认数据已实际写入的情况下告诉写入程序写入成功。
- en: Asynchronous mounting is fine on disposable filesystems, such as memory file
    systems that disappear at shutdown, but don’t use it with important data. The
    performance difference between asynchronous mounts and noasync with soft updates
    is minuscule. (I’ll cover noasync in the next section.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 异步挂载适用于一次性文件系统，如在关机时消失的内存文件系统，但不要用于重要数据。异步挂载和结合软更新的 noasync 之间的性能差异微乎其微。（下一节将讲解
    noasync。）
- en: To mount a partition asynchronously, use the option `async`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要异步挂载分区，请使用 `async` 选项。
- en: '**Combining Sync and Async**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**同步和异步结合**'
- en: FreeBSD’s default UFS mount option combines sync and async mounts as *noasync*.
    With noasync, data that affects inodes is written to the disk synchronously, while
    actual data is handled asynchronously. Combined with soft updates (see later in
    this chapter), a noasync mount creates a very robust filesystem.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的默认 UFS 挂载选项将同步和异步挂载组合为 *noasync*。使用 noasync 时，影响 inode 的数据会同步写入磁盘，而实际数据则异步处理。结合软更新（本章后面会介绍），noasync
    挂载创建了一个非常稳健的文件系统。
- en: As noasync mounts are the default, you don’t need to specify it when mounting,
    but when someone else does, don’t let it confuse you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 noasync 挂载是默认选项，挂载时无需指定它，但当别人使用时，不要让它困扰你。
- en: '**Disable Atime**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**禁用 Atime**'
- en: Every file in UFS includes an access-time stamp, called the *atime*, which records
    when the file was last accessed. If you have a large number of files and don’t
    need this data, you can mount the disk *noatime* so that UFS doesn’t update this
    timestamp. This is most useful for flash media or disks that suffer from heavy
    load, such as Usenet news spool drives. Some software uses the atime, though,
    so don’t disable it blindly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: UFS中的每个文件都包含一个访问时间戳，称为*atime*，记录文件最后一次被访问的时间。如果您有大量文件且不需要这些数据，可以将磁盘挂载为*noatime*，以便UFS不更新此时间戳。这对于闪存介质或负载较重的磁盘（如Usenet新闻缓冲驱动器）最为有用。不过，某些软件会使用atime，因此不要盲目禁用它。
- en: '**Disable Execution**'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**禁用执行**'
- en: Your policy might say that certain filesystems shouldn’t have executable programs.
    The `noexec` mount option prevents the system from executing any programs on the
    filesystem. Mounting */home* noexec can help prevent users from running their
    own programs, but for it to be effective, also mount */tmp*, */var/tmp*, and anywhere
    else users can write their own files noexec as well.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您的策略可能要求某些文件系统不应有可执行程序。`noexec`挂载选项防止系统在文件系统上执行任何程序。挂载*/home*为noexec可以帮助防止用户运行自己的程序，但为了有效性，还应将*/tmp*、*/var/tmp*以及用户可以写入自己文件的任何地方挂载为noexec。
- en: A noexec mount doesn’t prevent a user from running a shell script or an interpreted
    script in Perl or Python or whatever. While the script might be on a noexec filesystem,
    the interpreter usually isn’t.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: noexec挂载并不会阻止用户运行shell脚本或解释型脚本（如Perl或Python等）。虽然脚本可能位于noexec文件系统上，但解释器通常不在该文件系统上。
- en: Another common use for a noexec mount is when you have a filesystem that contains
    binaries for a different operating system or a different hardware architecture
    and you don’t want anyone to execute them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: noexec挂载的另一个常见用途是，当您有一个包含不同操作系统或硬件架构的二进制文件的文件系统时，您不希望任何人执行它们。
- en: '**Disable Suid**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**禁用SUID**'
- en: Setuid programs allow users to run programs as if they’re another user. For
    example, programs such as login(1) must perform actions as root but must be run
    by regular users. Setuid programs obviously must be written carefully so that
    intruders can’t exploit them to get unauthorized access to your system. Many system
    administrators habitually disable all unneeded setuid programs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Setuid程序允许用户以另一个用户的身份运行程序。例如，像login(1)这样的程序必须作为root执行某些操作，但必须由普通用户运行。显然，setuid程序必须小心编写，以防止入侵者利用它们获取未经授权的系统访问权限。许多系统管理员习惯性地禁用所有不必要的setuid程序。
- en: The `nosuid` option disables setuid access from all programs on a filesystem.
    As with noexec, script wrappers can easily evade nosuid restrictions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`nosuid`选项禁用文件系统中所有程序的setuid访问。与noexec一样，脚本包装器可以轻松绕过nosuid限制。'
- en: '**Disable Clustering**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**禁用聚集**'
- en: FFS optimizes reads and writes on the physical media by clustering. Rather than
    scattering a file all over the hard drive, it writes out the whole thing in large
    chunks. Similarly, it makes sense to read files in larger chunks. You can disable
    this feature with the mount options `noclusterr` (for read clustering) and `noclusterw`
    (for write clustering).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: FFS通过聚集优化物理介质上的读写操作。它不是将文件分散到硬盘的各个位置，而是将整个文件以大块的形式写入。同样，读取文件时以较大块的形式读取是有意义的。您可以使用挂载选项`noclusterr`（用于读取聚集）和`noclusterw`（用于写入聚集）来禁用此功能。
- en: '**Disable Symlinks**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**禁用符号链接**'
- en: The `nosymfollow` option disables symlinks, or aliases to files. *Symlinks*
    are mainly used to create aliases to files that reside on other partitions. To
    create an alias to another file on the same partition, use a regular link instead.
    See ln(1) for a discussion of links.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`nosymfollow`选项禁用符号链接，或文件的别名。*符号链接*主要用于创建指向位于其他分区的文件的别名。要创建指向同一分区上另一个文件的别名，请使用常规链接。有关链接的讨论，请参见ln(1)。'
- en: Aliases to directories are always symlinks; you cannot use a hard link for those.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 指向目录的别名始终是符号链接；对于这些，您不能使用硬链接。
- en: '**UFS Resiliency**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**UFS的弹性**'
- en: UFS dates from the age when a power loss meant data loss. After decades of use
    and debugging, UFS almost never loses data, especially when compared with other
    open source filesystems. UFS achieves this resiliency by careful integrity checking,
    especially after an unexpected shutdown like a power failure.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: UFS起源于当时断电意味着数据丢失的时代。经过数十年的使用和调试，UFS几乎永远不会丢失数据，尤其是与其他开源文件系统相比。UFS通过仔细的完整性检查来实现这一弹性，特别是在像断电这样的意外关机后。
- en: The point of resiliency isn’t to verify the data on disk—UFS is pretty good
    at that. It’s to speed integrity verification and filesystem recovery after that
    unexpected shutdown. The size of modern disks means that verification can take
    a long time without additional resiliency. An integrity check of a 100MB filesystem
    is much faster than the same integrity check of a multiterabyte filesystem! Adding
    resiliency improves recovery times.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性恢复的重点不是验证磁盘上的数据——UFS 在这方面表现相当好。它的目的是加速在意外关机后完整性验证和文件系统恢复。现代硬盘的容量意味着没有额外的弹性机制，验证可能需要很长时间。对一个100MB文件系统的完整性检查要比对一个多TB的文件系统进行相同的检查要快得多！增加弹性机制可以提高恢复时间。
- en: UFS offers several ways to improve the resilience of a UFS filesystem, such
    as soft updates and journaling. Before creating a filesystem, choose one that
    fits your needs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: UFS 提供了几种方法来提高 UFS 文件系统的可靠性，如软更新和日志记录。在创建文件系统之前，选择一个适合您需求的文件系统。
- en: '***Soft Updates***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***软更新***'
- en: '*Soft updates* is a technology used to organize and arrange disk writes so
    that filesystem metadata remains consistent at all times, giving nearly the performance
    of an async mount with the reliability of a sync mount. That doesn’t mean that
    all data will be safely written to disk—a power failure at the wrong moment can
    still lose data. The file being written to disk at the exact millisecond the power
    dies can’t get to the disk no matter what the operating system does. But what’s
    actually on the disk will be internally consistent. Soft updates lets UFS quickly
    recover from failure.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*软更新* 是一种技术，用于组织和安排磁盘写入操作，以确保文件系统的元数据始终保持一致，从而提供几乎与异步挂载相当的性能，并具备同步挂载的可靠性。这并不意味着所有数据都会安全地写入磁盘——在错误时刻发生的电源故障仍然可能导致数据丢失。无论操作系统如何处理，在电源断开的那一刻，正在写入磁盘的文件都无法到达磁盘。但磁盘上的实际内容将是内部一致的。软更新使得
    UFS 能够在故障后快速恢复。'
- en: You can enable and disable soft updates when mounting or creating the filesystem.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在挂载或创建文件系统时启用或禁用软更新。
- en: As filesystems grow, soft updates show their limits. Multiterabyte filesystems
    still need quite a while to recover from an unplanned shutdown. The original soft
    updates journaling paper (*[http://www.mckusick.com/softdep/suj.pdf](http://www.mckusick.com/softdep/suj.pdf)*)
    mentions that a 92 percent full 14-drive array with a deliberately damaged filesystem
    needed 10 hours for integrity checking. You’ll need a journal well before then.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着文件系统的增长，软更新会显示出其局限性。多达数TB的文件系统在非计划性关机后仍需要相当长的时间来恢复。原始的软更新日志论文 (*[http://www.mckusick.com/softdep/suj.pdf](http://www.mckusick.com/softdep/suj.pdf)*)
    提到，一个92%满的14盘阵列，在故意损坏文件系统后，完成完整性检查需要10小时。你需要在此之前就拥有日志记录。
- en: '***Soft Updates Journaling***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***软更新日志***'
- en: A journaling filesystem records any changes outside the actual filesystem. Changes
    get quickly dumped to storage and then inserted into the filesystem at a more
    leisurely pace. If the system dies unexpectedly, the filesystem automatically
    recovers any changes from the journal. This vastly reduces the requirement for
    rebuilding filesystem integrity at startup. When you install FreeBSD, it defaults
    to creating UFS partitions with soft update journaling.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个日志文件系统记录所有实际文件系统之外的更改。这些更改会迅速写入存储设备，然后以更为从容的速度插入文件系统中。如果系统意外死机，文件系统会自动从日志中恢复任何更改。这大大减少了启动时重建文件系统完整性的需求。当你安装
    FreeBSD 时，默认会创建带有软更新日志的 UFS 分区。
- en: Rather than recording all transactions, the soft updates journal records all
    metadata updates so that the filesystem can always be restored to an internally
    consistent state. Benchmarks show that journaling adds only a tiny amount of load
    to soft updates. It does add I/O overhead, however, as the system must dump all
    changes to the journal and then replay them into the filesystem. It vastly reduces
    recovery time, however. That 14-drive array that needed 10 hours for integrity
    checking? It needed less than one minute to recover from the same damage using
    the journal.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 软更新日志并不是记录所有事务，而是记录所有元数据更新，以确保文件系统始终能够恢复到一个内部一致的状态。基准测试显示，日志记录对软更新的负载影响极小。然而，它确实增加了I/O开销，因为系统必须将所有更改转储到日志中，然后再将它们重新播放到文件系统中。然而，它极大地减少了恢复时间。那个需要10小时才能完成完整性检查的14盘阵列？使用日志后，它在相同的损坏情况下恢复的时间不到一分钟。
- en: Soft updates with journaling is very powerful. Why wouldn’t you always use journaling?
    Soft updates journaling disables UFS snapshots. If you need UFS snapshots, you
    can’t journal. If you need snapshots, though, you’re probably better off using
    ZFS anyway. FreeBSD’s version of dump(8) uses UFS snapshots to back up live filesystems.
    Only us old Unix hands use dump any more, and that’s mostly because we already
    know it, but if your organization mandates using dump(8), you need another resiliency
    option.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 带日志的软更新非常强大。为什么不总是使用日志呢？软更新日志会禁用 UFS 快照。如果你需要 UFS 快照，就不能使用日志。但如果你需要快照，实际上使用
    ZFS 可能会更好。FreeBSD 版的 dump(8) 使用 UFS 快照来备份实时文件系统。现在只有我们这些老派 Unix 用户还在使用 dump，主要是因为我们已经熟悉它，但如果你的组织要求使用
    dump(8)，你需要另一种容错选项。
- en: '***GEOM Journaling***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GEOM 日志***'
- en: FreeBSD can also journal at the GEOM level with gjournal(8). Like any other
    filesystem journal, gjournal records filesystem transactions. At boot, FreeBSD
    checks the journal file for any changes not yet written to the filesystem and
    makes those changes, ensuring a consistent filesystem. Gjournal predates soft
    updates journaling.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 也可以在 GEOM 层级使用 gjournal(8) 进行日志记录。像任何其他文件系统日志一样，gjournal 记录文件系统事务。在启动时，FreeBSD
    检查日志文件中是否有尚未写入文件系统的更改，并执行这些更改，以确保文件系统的一致性。Gjournal 在软更新日志之前就已经存在。
- en: While soft updates journals only metadata, gjournal journals all filesystem
    transactions. You’re less likely to lose data in a system failure, but everything
    gets written twice, which impacts performance. If you’re using gjournal, though,
    don’t use any type of soft updates. You should also mount the filesystem async.
    You can use snapshots on a gjournaled filesystem.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然软更新日志只记录元数据，但 gjournal 记录所有文件系统事务。在系统故障时，你丢失数据的可能性较小，但一切都会被写入两次，从而影响性能。不过，如果你使用
    gjournal，不要使用任何类型的软更新。你还应该以异步方式挂载文件系统。你可以在 gjournaled 文件系统上使用快照。
- en: Gjournal uses 1GB of disk per filesystem. You can’t just turn it on and off—you
    must have space for the journal. You can use a separate partition for the journal
    or include the gigabyte in the partition if you leave space for it. If you decide
    to add gjournal to an existing partition, you need to find the space somewhere.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Gjournal 每个文件系统使用 1GB 的磁盘空间。你不能随便开关它——必须为日志提供空间。你可以为日志使用单独的分区，或者如果留出空间，可以将这个一GB包含在分区内。如果决定将
    gjournal 添加到现有的分区，你需要找到空间。
- en: Should you use gjournal or soft updates journaling? I recommend using soft updates
    journaling if at all possible. If that isn’t an option, use plain soft updates.
    Use GEOM journaling if you need UFS snapshots, including dump(8) on snapshots.
    Personally, I no longer use gjournal.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用 gjournal 还是软更新日志？如果可能的话，我建议使用软更新日志。如果这不是一个选项，就使用普通的软更新。如果你需要 UFS 快照，包括在快照上的
    dump(8)，那么使用 GEOM 日志。就我个人而言，我已经不再使用 gjournal 了。
- en: '**Creating and Tuning UFS Filesystems**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建和调优 UFS 文件系统**'
- en: 'In the last chapter, we partitioned and labeled your disks. Now let’s put a
    filesystem on those partitions. Create UFS filesystems with newfs(8), using a
    device node as the last argument. Here, I create a filesystem on the device */dev/gpt/var*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们对你的磁盘进行了分区和标签操作。现在让我们在这些分区上创建文件系统。使用 newfs(8) 创建 UFS 文件系统，设备节点作为最后一个参数。在这里，我在设备
    */dev/gpt/var* 上创建了一个文件系统：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line repeats the device node and prints the partition’s size ➊, along
    with the block ➋ and fragment sizes ➌. You’ll get filesystem geometry information
    ➍, a relic of the days when disk geometry bore some relationship to the hardware.
    Finally, newfs(8) prints a list of super-block backups ➎. The larger your filesystem,
    the more backup superblocks you get.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行重复设备节点并打印分区的大小 ➊，以及块 ➋ 和碎片大小 ➌。你将获得文件系统几何信息 ➍，这是一种遗留信息，源自硬盘几何曾与硬件有某种关系的时代。最后，newfs(8)
    打印出超级块备份列表 ➎。你的文件系统越大，备份超级块就越多。
- en: If you want to use soft updates journaling, add the `-j` flag. To use soft updates
    without journaling, add the `-U` flag. After you’ve created the filesystem, you
    can enable and disable soft updates journaling, and plain soft updates, with tunefs(8).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用软更新日志，请添加 `-j` 标志。要使用没有日志的软更新，请添加 `-U` 标志。在创建文件系统后，你可以通过 tunefs(8) 启用或禁用软更新日志，或使用普通的软更新。
- en: '***UFS Labeling***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***UFS 标签***'
- en: Device nodes can change, but labels remain constant. Best practice is to label
    GPT partitions, but you can’t label MBR partitions. UFS filesystems on an MBR
    can use a UFS label with the `-L` flag.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设备节点可以改变，但标签保持不变。最佳实践是为 GPT 分区添加标签，但不能为 MBR 分区添加标签。MBR 上的 UFS 文件系统可以使用 `-L`
    标志添加 UFS 标签。
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The labels appear in */dev/ufs*. Use them in */etc/fstab* and other configuration
    files to avoid disk renaming mayhem. You can’t apply UFS labels to non-UFS filesystems.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签会出现在 */dev/ufs* 中。在 */etc/fstab* 和其他配置文件中使用它们，以避免磁盘重命名的混乱。你不能将 UFS 标签应用到非
    UFS 文件系统。
- en: If you’re using UFS on GPT partitions, choose either GPT or UFS labels. Thanks
    to withering, you’ll see only one label at a time and probably confuse yourself.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 GPT 分区上使用 UFS，请选择 GPT 或 UFS 标签。由于衰退，你每次只能看到一个标签，这可能会让你感到困惑。
- en: '***Block and Fragment Size***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***块大小和碎片大小***'
- en: UFS’s efficiency is proportional to the number of blocks and fragments read
    or written. Generally, FreeBSD can read a 10-block file in half the time it needs
    to read a 20-block file. The FreeBSD developers chose the default block and fragment
    sizes to accommodate the widest variety of files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: UFS 的效率与读取或写入的块和碎片数量成正比。通常，FreeBSD 读取一个 10 块的文件的时间是读取一个 20 块文件的一半。FreeBSD 开发人员选择默认的块和碎片大小是为了适应最广泛种类的文件。
- en: If you have a special-purpose filesystem that overwhelmingly contains either
    large or small files, you might consider changing the block size when creating
    the filesystem. While you can change the block size of an existing filesystem,
    it’s a terrible idea. Block sizes must be a power of 2\. The assumption that a
    fragment is one-eighth the size of a block is hardcoded in many places, so let
    newfs(8) compute the fragment size from the block size.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个专用文件系统，主要包含大文件或小文件，你可以考虑在创建文件系统时更改块大小。虽然可以更改现有文件系统的块大小，但这是一个糟糕的主意。块大小必须是
    2 的幂。碎片是块大小的八分之一这一假设在许多地方是硬编码的，因此让 newfs(8) 根据块大小来计算碎片大小。
- en: Suppose I have a filesystem dedicated to large files, and I want to increase
    the block size. The default block size is 32KB, so the next larger block size
    would be 64KB. Specify the new block size with `-b`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个专门用于大文件的文件系统，我想增加块大小。默认的块大小是 32KB，那么下一个较大的块大小就是 64KB。使用 `-b` 指定新的块大小。
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you’re going to have many small files, you might consider using a smaller
    block size. One thing to watch out for is a fragment size smaller than the underlying
    disk’s physical sector size. FreeBSD defaults to 4KB fragments. If your disk has
    4KB sectors, don’t use a smaller fragment size. If you’re absolutely certain that
    your disk has 512-byte physical sectors, you can consider creating a filesystem
    with a 16KB (or even 8KB) block size and the corresponding 2KB or 1KB fragment
    size.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将有很多小文件，可能需要考虑使用更小的块大小。需要注意的一点是，碎片大小不应小于底层磁盘的物理扇区大小。FreeBSD 默认使用 4KB 的碎片。如果你的磁盘有
    4KB 的扇区，千万不要使用更小的碎片大小。如果你完全确定你的磁盘有 512 字节的物理扇区，可以考虑创建一个 16KB（甚至 8KB）块大小的文件系统，并使用相应的
    2KB 或 1KB 碎片大小。
- en: In my sysadmin career, I have needed^([1](footnote.xhtml#ch11fn1)) a custom
    block size only twice. Don’t use one until you experience a performance issue.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统管理员生涯中，我只需要^([1](footnote.xhtml#ch11fn1))定制块大小两次。在遇到性能问题之前不要使用定制块大小。
- en: '***Using GEOM Journaling***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 GEOM 日志***'
- en: Before using gjournal(8), decide where you’re putting the 1GB journal. If possible,
    I’d recommend including that gigabyte in the filesystem partition. That means
    if you want a 50GB filesystem, put it in a 51GB partition. Otherwise, use a separate
    partition.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 gjournal(8) 之前，决定将 1GB 日志放在哪里。如果可能，我建议将这一千兆字节包含在文件系统分区中。这意味着如果你想要一个 50GB
    的文件系统，就将它放入一个 51GB 的分区。否则，使用一个单独的分区。
- en: Load the geom_journal kernel module with `gjournal load` or in */boot/loader.conf*
    before performing any gjournal operations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何 gjournal 操作之前，通过 `gjournal load` 或在 */boot/loader.conf* 中加载 geom_journal
    内核模块。
- en: To create a gjournal provider while including the partition in the journal,
    use the `gjournal label` command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 gjournal 提供者，同时将分区包含在日志中，请使用 `gjournal label` 命令。
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you want to have a separate provider be the journal, add that provider as
    a second argument.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让一个独立的提供者作为日志，请将该提供者作为第二个参数添加。
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These commands run silently if successful. They create a new device node with
    the same name as your journaled device, but with *.journal* added to the end.
    Running `gjournal label da3p5` creates */dev/da3p5.journal*. From this point on,
    do all work on the journaled device node.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，这些命令会静默执行。它们会创建一个新设备节点，名称与您的日志设备相同，只是末尾加上 *.journal*。运行 `gjournal label
    da3p5` 会创建 */dev/da3p5.journal*。从此以后，所有工作都将在日志设备节点上进行。
- en: Create your new UFS filesystem on the journaled device. Use the `-J` flag to
    tell UFS it’s running on top of gjournal. Do not enable any sort of soft updates,
    including soft updates journaling. It seems to work for a time . . . then it doesn’t.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志设备上创建新的 UFS 文件系统。使用 `-J` 标志告诉 UFS 它是在 gjournal 上运行的。不要启用任何形式的软更新，包括软更新日志功能。这似乎有效一段时间……然后它就不行了。
- en: Mount your gjournal filesystems async. The normal warnings that apply to async
    mounts don’t apply to gjournal, however. The gjournal GEOM module handles the
    verification and integrity checking normally managed by the filesystem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将 gjournal 文件系统挂载为异步模式。适用于异步挂载的常规警告并不适用于 gjournal。然而，gjournal GEOM 模块会处理通常由文件系统管理的验证和完整性检查。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The documentation says that you can convert an existing partition to use gjournal,
    provided that you have a separate partition for the journal and that the last
    sector of the existing filesystem is empty. In practice, I find that the last
    sector of the existing filesystem is always full, but if you want to, try to read
    gjournal(8) for the details.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 文档中说，你可以将现有分区转换为使用 gjournal，只要你为日志设置了一个单独的分区，且现有文件系统的最后一个扇区为空。实际上，我发现现有文件系统的最后一个扇区总是已满，但如果你愿意，试着阅读
    gjournal(8) 来获取详细信息。
- en: '***Tuning UFS***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调整 UFS 设置***'
- en: You can view and change the settings on each UFS filesystem by using tunefs(8).
    This lets you enable and disable features; plus, you can adjust how UFS writes
    files, manages free space, and uses filesystem labels.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 tunefs(8) 查看和更改每个 UFS 文件系统的设置。这可以让你启用和禁用特性；此外，你还可以调整 UFS 如何写入文件、管理空闲空间以及使用文件系统标签。
- en: '**View Current Settings**'
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查看当前设置**'
- en: View a filesystem’s current settings with the `-p` flag and the partition’s
    current mount point or underlying provider.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-p` 标志和分区的当前挂载点或底层提供者查看文件系统的当前设置。
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Many of the available settings relate to specific security functionality we
    don’t cover. Topics like MAC restrictions ➋ and all the different types of ACL
    ➊ fill entire books. But we can see that this filesystem uses soft updates ➌ and
    soft updates journaling ➍, though it doesn’t use gjournal ➎. We get the minimum
    amount of free space ➏. At the end, we have the nonexistent UFS label ➐. We get
    a bunch of information on filesystem geometry and block size.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 许多可用的设置与特定的安全功能相关，而这些我们并未涉及。像 MAC 限制 ➋ 和各种 ACL 类型 ➊ 的话题充满了整本书。但我们可以看到，这个文件系统使用了软更新
    ➌ 和软更新日志功能 ➍，但并未使用 gjournal ➎。我们获得了最小的空闲空间 ➏。最后，我们有一个不存在的 UFS 标签 ➐。我们得到了关于文件系统几何结构和块大小的一堆信息。
- en: Use tunefs(8) to change any of these settings on an unmounted filesystem. Conveniently,
    tunefs(8) shows the command line flag to address each. I normally boot into single-user
    mode before changing a filesystem’s settings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 tunefs(8) 在未挂载的文件系统上更改任何这些设置。方便的是，tunefs(8) 会显示每个设置对应的命令行标志。我通常会在更改文件系统设置之前启动单用户模式。
- en: You might notice that you can adjust all sorts of filesystem internals, such
    as block arrangements and filesystem geometry. Don’t. In over two decades of FreeBSD
    use, I have never seen anyone improve their situation by twiddling these knobs.
    I have repeatedly seen people twiddle these knobs and ruin their day.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，你可以调整各种文件系统内部设置，如块排列和文件系统几何结构。但请不要这么做。在超过二十年的 FreeBSD 使用过程中，我从未见过有人通过调整这些设置来改善他们的情况。反而，我见过很多人调整这些设置并最终让自己陷入困境。
- en: But let’s look at the settings you might actually need to enable and disable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们来看看你实际上可能需要启用和禁用的设置。
- en: '**Soft Updates and Journaling**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**软更新和日志功能**'
- en: Use the `-j` flag to enable or disable soft updates journaling on a filesystem.
    This automatically enables soft updates.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-j` 标志启用或禁用文件系统上的软更新日志功能。启用该功能会自动启用软更新。
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To disable soft updates journaling, use the `disable` keyword.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 若要禁用软更新日志功能，请使用 `disable` 关键字。
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A soft updates journal on a nonjournaled filesystem can only confuse matters.
    Mount the filesystem and remove the *.sujournal* file in the filesystem’s root
    directory. Note that turning off journaling leaves soft updates still in place.
    Use `-n enable` and `-n disable` to turn soft updates (without journaling) on
    and off.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个未启用日志的文件系统上启用软更新日志只会让问题变得更加复杂。挂载该文件系统并删除文件系统根目录中的 *.sujournal* 文件。请注意，关闭日志功能并不会移除软更新功能。使用
    `-n enable` 和 `-n disable` 可以开启和关闭软更新（没有日志功能）。
- en: '**Minimum Free Space**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**最小空闲空间**'
- en: UFS holds back 8 percent of each partition so that it has space to rearrange
    files for better performance. I discuss this further in “[UFS Space Reservations](ch11.xhtml#lev417)”
    on [page 249](ch11.xhtml#page_249). If you want to change this percentage, use
    the `-m` flag. Here, I tell the filesystem to reserve only 5 percent of the disk.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: UFS 会保留每个分区的 8% 空间，以便它有空间重新排列文件以提高性能。我在 “[UFS 空间保留](ch11.xhtml#lev417)” 章节中进一步讨论了这一点，见
    [第 249 页](ch11.xhtml#page_249)。如果你想更改此百分比，可以使用 `-m` 标志。在这里，我告诉文件系统仅保留 5% 的磁盘空间。
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should now have more usable disk space. Also, UFS will run more slowly because
    it always packs the filesystem as tightly as possible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该有更多可用的磁盘空间了。同时，由于 UFS 总是尽可能紧密地打包文件系统，它会运行得更慢。
- en: '**SSD TRIM**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SSD TRIM**'
- en: Solid-state disks use wear-leveling to extend their lifespan. Wear-leveling
    works best if the filesystem notifies the SSD when each block is no longer in
    use. The TRIM protocol handles this notification. Enable TRIM support on your
    SSD-backed filesystem with the `-t` flag.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 固态硬盘使用磨损平衡来延长其使用寿命。磨损平衡在文件系统通知 SSD 每个块不再使用时效果最佳。TRIM 协议负责此通知。通过 `-t` 标志在你的 SSD
    支持的文件系统上启用 TRIM。
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the best results, enable TRIM for every partition on a solid-state drive.
    Enable TRIM at filesystem creation with `newfs -E`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳效果，请为固态硬盘上的每个分区启用 TRIM。使用 `newfs -E` 在文件系统创建时启用 TRIM。
- en: '**Labeling UFS Filesystems**'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**为 UFS 文件系统添加标签**'
- en: You can apply a UFS label to an existing filesystem with the `-L` flag.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `-L` 标志为现有的文件系统添加 UFS 标签。
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Don’t mix UFS and GPT labels—you’ll only confuse yourself.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混合使用 UFS 和 GPT 标签——这样只会让自己更混淆。
- en: '***Expanding UFS Filesystems***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***扩展 UFS 文件系统***'
- en: Your virtual machine runs out of space? Make the disk bigger, and expand the
    last partition to cover that space, as discussed in [Chapter 10](ch10.xhtml#ch10).
    But what about the filesystem on that partition? That’s where growfs(8) comes
    in.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你的虚拟机磁盘空间不足？扩大磁盘，并扩展最后一个分区来覆盖那个空间，正如在[第 10 章](ch10.xhtml#ch10)中讨论的那样。那么，那个分区上的文件系统怎么办？这就是
    growfs(8) 发挥作用的地方。
- en: The growfs(8) command expands an existing UFS filesystem to fill the partition
    it’s in. Give growfs one argument, the filesystem’s device node. Use labels if
    you like.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: growfs(8) 命令将现有的 UFS 文件系统扩展到填充其所在的分区。给 growfs 提供一个参数，即文件系统的设备节点。你也可以使用标签。
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When growfs(8) requests confirmation ➊, you must enter the full word `yes`.
    Any other answer, including a plain `y` like many other programs accept, cancels
    the operation. Confirm the operation and growfs(8) will add additional blocks,
    superblocks, and inodes as needed to fill the partition.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当 growfs(8) 请求确认 ➊ 时，你必须输入完整的 `yes`。任何其他回答，包括许多程序接受的简单 `y`，都会取消操作。确认操作后，growfs(8)
    将根据需要添加额外的块、超级块和 inode 来填充分区。
- en: If you don’t want the filesystem to fill the entire partition, you can specify
    a size with `-s`. Here, I expand this same partition to 80GB.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想让文件系统填满整个分区，你可以使用 `-s` 指定一个大小。在这里，我将这个分区扩展到 80GB。
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I strongly encourage you to make filesystems the same size as the underlying
    partitions, unless you’re looking to make your coworkers slap you.^([2](footnote.xhtml#ch11fn2))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你将文件系统的大小设置为与底层分区相同，除非你想让你的同事打你一巴掌。^([2](footnote.xhtml#ch11fn2))
- en: '**UFS Snapshots**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**UFS 快照**'
- en: You can take an image of a UFS filesystem at a moment in time; this is called
    a *snapshot*. You can snapshot a filesystem, erase and change some files, and
    then copy the unchanged files from the snapshot. Tools like dump(8) use snapshots
    to ensure consistent backups. UFS snapshots are not as powerful or flexible as
    ZFS snapshots, but they’re a solid, reliable tool within their limits.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在某一时刻对 UFS 文件系统进行快照；这被称为 *快照*。你可以对文件系统进行快照，删除并更改一些文件，然后从快照中复制未更改的文件。像 dump(8)
    这样的工具使用快照来确保备份的一致性。UFS 快照不如 ZFS 快照那样强大或灵活，但在其限制范围内，它们是一个稳定、可靠的工具。
- en: UFS snapshots require soft updates but are incompatible with soft updates journaling.
    Each filesystem can have up to 20 snapshots.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: UFS 快照需要软更新，但与软更新日志不兼容。每个文件系统最多可以有 20 个快照。
- en: Snapshots let you get at the older version of an edited or removed file. Access
    the contents of a snapshot by mounting the file as a memory device. I’ll discuss
    memory devices in [Chapter 13](ch13.xhtml#ch13).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 快照让你访问编辑或删除的文件的旧版本。通过将文件作为内存设备挂载，你可以访问快照的内容。我将在[第 13 章](ch13.xhtml#ch13)中讨论内存设备。
- en: '***Taking and Destroying Snapshots***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拍摄和销毁快照***'
- en: 'Create snapshots with mksnap_ffs(8). This program assumes you want to make
    a snapshot of the filesystem your current working directory is in. Give the snapshot
    location as an argument. Snapshots traditionally go in the *.snap* directory at
    the filesystem root. If you’re using a tool that automatically creates and removes
    snapshots, like dump(8), check there for your snapshot files. If you don’t like
    that location, though, you can put them anywhere on the filesystem you’re taking
    the snapshot of. Here, I took a snapshot of the */home* filesystem:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 mksnap_ffs(8) 创建快照。该程序假设你想创建当前工作目录所在文件系统的快照。将快照位置作为参数传入。传统上，快照会存放在文件系统根目录下的
    *.snap* 目录中。如果你使用的是自动创建和删除快照的工具，比如 dump(8)，可以在这里找到你的快照文件。不过，如果你不喜欢这个位置，你可以将它们放在任何你想要的位置。这里，我对
    */home* 文件系统创建了一个快照：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Snapshots use disk space. You can’t take a snapshot of a full filesystem.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 快照会占用磁盘空间。你不能对一个已满的文件系统进行快照。
- en: A snapshot is just a file. Remove the file and you destroy the snapshot.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 快照其实就是文件。删除文件就意味着删除快照。
- en: '***Finding Snapshots***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找快照***'
- en: Snapshots are files, and you can put them anywhere on the filesystem. This means
    it’s easy to lose them. Use find(1) with the `-flags snapshot` option to find
    all snapshots on a filesystem.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 快照就是文件，你可以将它们放在文件系统的任何位置。这意味着很容易丢失它们。使用 find(1) 命令和 `-flags snapshot` 选项，可以在文件系统中查找所有快照。
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There’s my stray snapshot!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的遗留快照！
- en: '***Snapshot Disk Usage***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***快照磁盘使用情况***'
- en: A snapshot records the differences between the current filesystem and the filesystem
    as it existed when the snapshot was taken. Every filesystem change after taking
    a snapshot increases the size of the snapshot. If you remove a file, the snapshot
    retains a copy of that file so you can recover it later.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 快照记录了当前文件系统与快照创建时文件系统之间的差异。每次在创建快照之后对文件系统进行的更改都会增加快照的大小。如果你删除了一个文件，快照会保留该文件的副本，以便你以后可以恢复它。
- en: This means deleting data from a filesystem with snapshots doesn’t actually free
    up space. If you have a snapshot of your */home* partition and you delete a file,
    the deleted file gets added to the snapshot.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着从包含快照的文件系统中删除数据并不会真正释放空间。如果你有一个 */home* 分区的快照，并删除了一个文件，那么删除的文件会被添加到快照中。
- en: Make sure that filesystems with snapshots always have plenty of free space.
    If you try to take a snapshot and mksnap_ffs(8) complains that it can’t because
    there’s no space, you might already have 20 snapshots of that filesystem.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用快照的文件系统始终有足够的空闲空间。如果你尝试创建快照并且 mksnap_ffs(8) 报告因为没有足够空间而无法创建，你可能已经有了 20 个该文件系统的快照。
- en: '**UFS Recovery and Repair**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**UFS 恢复与修复**'
- en: Everything from faulty hardware to improper systems administration^([3](footnote.xhtml#ch11fn3))
    can damage your filesystems. All of UFS’s resilience technologies are designed
    to quickly restore data integrity, but nothing can completely guarantee integrity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从硬件故障到系统管理不当^([3](footnote.xhtml#ch11fn3))都可能损坏你的文件系统。UFS 的所有弹性技术旨在快速恢复数据完整性，但没有任何技术能完全保证完整性。
- en: Let’s discuss how FreeBSD keeps each UFS filesystem tidy.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讨论 FreeBSD 如何保持每个 UFS 文件系统的整洁。
- en: '***System Shutdown: The Syncer***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***系统关机：同步器***'
- en: When you shut down a FreeBSD system, the kernel synchronizes all its data to
    the hard drive, marks the disks clean, and shuts down. This is done by a kernel
    process called the *syncer*. During a system shutdown, the syncer reports on its
    progress in synchronizing the hard drive.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你关闭 FreeBSD 系统时，内核会将所有数据同步到硬盘，标记磁盘为干净状态，然后关机。这个过程是由一个名为 *syncer* 的内核进程完成的。在系统关机过程中，同步器会报告它在同步硬盘过程中的进度。
- en: You’ll see odd things from the syncer during shutdown. The syncer walks the
    list of vnodes that need synchronizing to disk, allowing it to support all filesystems,
    not just UFS. Thanks to soft updates, writing one vnode to disk can generate another
    dirty vnode that needs updating. You can see the number of buffers being written
    to disk rapidly drop from a high value to a low value and perhaps bounce between
    zero and a low number once or twice as the system really, truly synchronizes the
    hard drive.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在关机过程中，你会看到同步器做出一些奇怪的操作。同步器会遍历需要同步到磁盘的 vnode 列表，使其能够支持所有文件系统，而不仅仅是 UFS。由于软更新的存在，写入一个
    vnode 到磁盘可能会生成另一个脏 vnode，需进行更新。你会看到写入磁盘的缓冲区数量迅速从一个较高的值下降到一个较低的值，并且在系统真正同步硬盘时，可能会在零和一个较低的数字之间反复波动一两次。
- en: If the syncer doesn’t get a chance to finish, or if the syncer doesn’t run at
    all thanks to your ham-fisted fumbling, you get a dirty filesystem.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同步器没有机会完成工作，或者由于你的笨拙操作同步器根本没有运行，那么你就会得到一个脏的文件系统。
- en: '***Dirty Filesystems***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***脏文件系统***'
- en: No, disks don’t get muddy with use (although dust on a platter will quickly
    damage it, and adding water won’t help). A dirty UFS partition is in a kind of
    limbo; the operating system has asked for information to be written to the disk,
    but the data is not yet completely on the physical media. Part of the data blocks
    might have been written, the inode might have been edited but the data not written
    out, or any combination of the two. Live filesystems are almost always dirty.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不，磁盘在使用时并不会变脏（尽管盘片上的灰尘会迅速损坏它，水也无济于事）。一个脏的UFS分区处于某种“中间状态”；操作系统已经请求写入数据到磁盘，但数据尚未完全写入物理介质。部分数据块可能已经写入，inode可能已经编辑，但数据没有写入，或者两者的任意组合。实时文件系统几乎总是脏的。
- en: If a host with dirty filesystems fails—say, due to a panic or Bert tripping
    over the power cable, the filesystem is still dirty when the system boots again.
    The kernel refuses to mount a dirty filesystem.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机的文件系统出现问题——例如由于系统崩溃或Bert绊倒电源线，系统再次启动时文件系统仍然是脏的。内核会拒绝挂载脏的文件系统。
- en: Cleaning the filesystem restores data integrity but doesn’t necessarily mean
    that all your data is on the disk. If a file was half-written to disk when the
    system died, the file is lost. Nothing can restore the missing half of the file,
    and the half on disk is essentially useless.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 清理文件系统可以恢复数据完整性，但并不一定意味着你所有的数据都已经写入磁盘。如果文件在系统崩溃时只写了一半，那么这部分文件就丢失了。没有什么可以恢复文件丢失的那一半，而磁盘上剩下的那一半基本上也没有用处。
- en: Journaled filesystems should automatically recover when FreeBSD tries to mount
    them. If the filesystem can’t recover, or if you don’t have a journal, you’ll
    need to use the legendary fsck(8).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 日志化文件系统应该在FreeBSD尝试挂载它时自动恢复。如果文件系统无法恢复，或者你没有日志文件，你将需要使用传奇的fsck(8)。
- en: '***File System Checking: fsck(8)***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件系统检查：fsck(8)***'
- en: The fsck(8) program examines a UFS filesystem and tries to verify that every
    file is attached to the proper inodes and in the correct directory. It’s like
    verifying a database’s referential integrity. If the filesystem suffered only
    minor damage, fsck(8) can automatically restore integrity and put the filesystem
    back in service.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: fsck(8)程序检查UFS文件系统，并尝试验证每个文件是否附加到正确的inode并且位于正确的目录。这就像验证数据库的引用完整性。如果文件系统只遭受了轻微损坏，fsck(8)可以自动恢复完整性并将文件系统重新投入使用。
- en: 'Repairing a damaged filesystem takes time and memory. A fsck(8) run requires
    about 700MB of RAM to analyze a 1TB filesystem. Most computer systems have fairly
    proportional memory and storage systems: very few hosts have 512MB RAM and petabytes
    of disk. But you should know it’s possible to create a UFS filesystem so large
    that the system doesn’t have enough memory to repair it.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 修复一个损坏的文件系统需要时间和内存。一个fsck(8)操作需要大约700MB的内存来分析一个1TB的文件系统。大多数计算机系统都有相对比例的内存和存储系统：很少有主机拥有512MB内存和PB级别的磁盘。但是你应该知道，有可能创建一个UFS文件系统大到系统没有足够的内存来修复它。
- en: '**Manual fscks Runs**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**手动fsck操作**'
- en: Occasionally this automated fsck-on-reboot fails to work. When you check the
    console, you’ll be looking at a single-user mode prompt and a request to run fsck(8)
    manually.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这个自动的重启时fsck检查会失败。当你检查控制台时，你会看到一个单用户模式提示符，并且系统要求你手动运行fsck(8)。
- en: Start by *preening* the filesystem with `fsck -p`. This automatically corrects
    a bunch of less severe errors without asking for your approval. Preening causes
    data loss only rarely. This is frequently successful, but if it doesn’t work,
    it will ask you to run a “full fsck.”
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 先用`fsck -p`来*修整*文件系统。这个命令会自动修复一些较轻微的错误，不会询问你的确认。修整操作通常不会造成数据丢失，虽然偶尔会发生。这通常会成功，但如果不行，系统会要求你运行“完全fsck”。
- en: If you enter `fsck` at the command prompt, fsck(8) verifies every block and
    inode on the disk. It finds any blocks that have become disassociated from their
    inodes and guesses how they fit together and how they should be attached. However,
    fsck(8) might not be able to identify which directory these files belong in.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行中输入`fsck`，fsck(8)会验证磁盘上的每一个块和inode。它会找到任何与其inode脱节的块，并猜测它们如何拼接以及应该如何附加。然而，fsck(8)可能无法识别这些文件属于哪个目录。
- en: Then, fsck(8) asks whether you want to perform these reattachments. If you answer
    `n`, it deletes the damaged files. If you answer `y`, it adds the lost file to
    a *lost+found* directory in the root of the partition, with a number as a filename.
    For example, the *lost+found* directory on your */usr* partition is */usr/lost+found*.
    If there are only a few files, you can identify them manually; if you have many
    files and are looking for particular ones, tools such as file(1) and grep(1) can
    help you identify them by content.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，fsck(8)会询问你是否要执行这些重新附加操作。如果你回答`n`，它会删除损坏的文件。如果你回答`y`，它会将丢失的文件添加到分区根目录下的*lost+found*目录中，文件名为一个数字。例如，你的*/usr*分区上的*lost+found*目录是*/usr/lost+found*。如果只有几个文件，你可以手动识别它们；如果有很多文件并且你在寻找特定的文件，像file(1)和grep(1)这样的工具可以帮助你按内容识别它们。
- en: If you answer `n`, those nuggets of unknown data remain detached from the filesystem.
    The filesystem remains dirty until you fix them by some other means.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回答`n`，那些未知数据将从文件系统中脱离。文件系统会保持脏状态，直到你通过其他方式修复它们。
- en: '**Trusting fsck(8)**'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**信任fsck(8)**'
- en: If fsck(8) can’t figure out where a file goes . . . can you? If not, you really
    have no choice but to trust fsck(8) to recover your system or restore from backup.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果fsck(8)无法弄清楚文件该去哪儿……你能吗？如果不能，你别无选择，只能信任fsck(8)来恢复你的系统或从备份中恢复。
- en: A full fsck(8) run inspects every block, inode, and superblock, and identifies
    every inconsistency. It asks you to type `y` or `n` to approve or reject every
    single correction. Any change you reject you must fix yourself, through some other
    means. You might spend hours at the console typing `y`, `y`, `y`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的fsck(8)运行会检查每一个块、inode和超级块，识别出每一个不一致之处。它会要求你输入`y`或`n`来批准或拒绝每一个修正。任何你拒绝的更改，你必须通过其他方式自行修复。你可能会花上几个小时在控制台上不断输入`y`、`y`、`y`。
- en: 'So I’ll ask again: if fsck(8) can’t fix a problem, can you?'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我再问一遍：如果fsck(8)无法修复问题，你能吗？
- en: If you can’t, consider `fsck -y`. The `-y` flag tells fsck(8) to reassemble
    these files as best it can, without prompting you. It assumes you answer all its
    questions “yes,” even the really dangerous ones. Using `-y` automatically triggers
    `-R`, which tells fsck(8) to retry cleaning each filesystem until it succeeds
    or it’s had 10 consecutive failures. It’s cure or kill. You *do* have backups,
    right?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能，考虑使用`fsck -y`。`-y`标志告诉fsck(8)尽可能自动重组这些文件，而无需你确认。它假设你会对所有问题回答“是”，即使是那些非常危险的问题。使用`-y`会自动触发`-R`，这告诉fsck(8)重新尝试清理每个文件系统，直到成功或连续10次失败为止。这是治愈还是毁灭。你*有*备份吧？
- en: '**DANGER!**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**危险！**'
- en: Running `fsck -y` is not guaranteed safe. At times, when running -current or
    when doing other daft things, I’ve had `fsck -y` migrate the entire contents of
    a filesystem to *lost+found*. Recovery becomes difficult at that point. Having
    said that, in a production system running FreeBSD-stable with a standard UFS filesystem,
    I’ve never had a problem.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`fsck -y`并不能保证安全。有时，在运行-current或做其他愚蠢的事情时，我曾让`fsck -y`将整个文件系统的内容迁移到*lost+found*。那时恢复就变得很困难。话虽如此，在运行FreeBSD-stable和标准UFS文件系统的生产系统中，我从未遇到过问题。
- en: You can set your system to try `fsck -y` automatically on boot. I don’t recommend
    this, however, because if there’s the faintest chance my filesystem will wind
    up in digital nirvana, I want to know about it. I want to type the offending command
    myself and feel the trepidation of hearing my disks churn. Besides, it’s always
    unpleasant to discover that your system is trashed without having the faintest
    clue how it got that way. If you’re braver than I, set `fsck_y_enable="YES"` in
    *rc.conf*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以设置系统在启动时自动尝试`fsck -y`。然而，我不推荐这样做，因为如果我的文件系统有一丝机会进入数字涅槃，我希望知道。我要亲自输入这条命令，并感受听到磁盘转动时的忐忑不安。此外，发现你的系统被搞砸了却完全不知道是怎么回事，总是让人不愉快。如果你比我勇敢，可以在*rc.conf*中设置`fsck_y_enable="YES"`。
- en: '**Avoiding fsck -y**'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**避免使用fsck -y**'
- en: What options do you have if you don’t want to use `fsck -y`? Well, fsdb(8) and
    clri(8) allow you to debug the filesystem and redirect files to their proper locations.
    You can restore files to their correct directories and names. This is difficult,^([4](footnote.xhtml#ch11fn4))
    however, and is recommended only for Secret Ninja Filesystem Masters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用`fsck -y`，你还有哪些选择？好吧，fsdb(8)和clri(8)允许你调试文件系统，并将文件重定向到它们的正确位置。你可以将文件恢复到正确的目录和名称。然而，这很困难，^([4](footnote.xhtml#ch11fn4))，因此只推荐给秘密忍者文件系统大师使用。
- en: '**Background fsck**'
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**后台fsck**'
- en: Background fsck gives UFS some of the benefits of a journaled filesystem without
    actually requiring journaling. You must be using soft updates without journaling
    to use background fsck. (Soft updates with journaling is far, far preferable to
    background fsck.) When FreeBSD sees that a background fsck is in process after
    a reboot, it mounts the dirty disk read-write. While the server is running, fsck(8)
    runs in the background, identifying loose bits of files and tidying them up behind
    the scenes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 后台 fsck 为 UFS 提供了一些类似日志文件系统的好处，而无需实际使用日志记录。你必须在没有日志记录的情况下使用软更新才能使用后台 fsck。（有日志记录的软更新远远优于后台
    fsck。）当 FreeBSD 看到重启后后台 fsck 正在进行时，它会将脏磁盘挂载为读写模式。当服务器运行时，fsck(8) 会在后台运行，识别文件的松散部分并在幕后整理它们。
- en: A background fsck actually has two major stages. When FreeBSD finds dirty disks
    during the initial boot process, it runs a preliminary fsck(8) assessment of the
    disks. The fsck(8) program decides whether the damage can be repaired while the
    system is running or whether a full single-user mode fsck run is required. Most
    frequently, fsck thinks it can proceed and lets the system boot. After the system
    reaches single-user mode, the background fsck runs at a low priority, checking
    the partitions one by one. The results of the fsck process appear in */var/log/messages*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 后台 fsck 实际上有两个主要阶段。当 FreeBSD 在初始启动过程中发现脏磁盘时，它会对磁盘进行初步的 fsck(8) 评估。fsck(8) 程序会决定是否可以在系统运行时修复损坏，或者是否需要进行完整的单用户模式
    fsck 运行。通常情况下，fsck 认为可以继续，并允许系统启动。系统进入单用户模式后，后台 fsck 会以低优先级运行，逐个检查分区。fsck 过程的结果会出现在
    */var/log/messages* 中。
- en: You can expect performance of any applications requiring disk activity to be
    lousy during a background fsck. The fsck(8) program occupies a large portion of
    the disk’s possible activity. While your system might be slow, it will at least
    be up.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以预期在后台 fsck 期间，任何需要磁盘活动的应用程序的性能都会很差。fsck(8) 程序占用了磁盘大部分的活动空间。虽然你的系统可能会变慢，但至少它会保持运行。
- en: You *must* check */var/log/messages* for errors after a background fsck. The
    preliminary fsck assessment can make an error, and perhaps a full single-user
    mode’s fsck on a partition really is required. If you find such a message, schedule
    downtime within a few hours to correct the problem. While inconvenient, having
    the system down for a scheduled period is better than the unscheduled downtime
    caused by a power outage and the resulting single-user mode’s `fsck -y`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你 *必须* 在后台 fsck 后检查 */var/log/messages* 以查找错误。初步的 fsck 评估可能会出错，也许确实需要对分区进行完整的单用户模式
    fsck。如果你发现这样的消息，请在几小时内安排停机时间来修复问题。尽管不方便，但安排定期停机比由于停电导致的非计划停机以及由此产生的单用户模式 `fsck
    -y` 要好。
- en: '***Forcing Read-Write Mounts on Dirty Disks***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***强制读写挂载脏磁盘***'
- en: If you really want to force FreeBSD to mount a dirty disk read-write without
    using a background fsck, you can. You won’t like the results. At all. But, as
    it’s described in mount(8), some reader will think it’s a good idea unless they
    know why. Use the `-w` (read-write) and `-f` (force) flags to mount(8).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想强制 FreeBSD 在不使用后台 fsck 的情况下将脏磁盘挂载为读写模式，你是可以这么做的。你不会喜欢结果的，真的不会。正如在 mount(8)
    中所描述的那样，某些读者会认为这是个好主意，除非他们知道为什么。使用 `-w`（读写）和 `-f`（强制）标志来挂载(8)。
- en: Mounting a dirty partition read-write corrupts data. Note the absence of words
    like *might* and *could* from that sentence. Also note I didn’t use *recoverable*.
    Mounting a dirty filesystem may panic your computer. It might destroy all remaining
    data on the partition or even shred the underlying filesystem. Forcing a read-write
    mount of a dirty filesystem is seriously bad juju. Don’t do it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载一个脏分区进行读写会损坏数据。注意这句话中没有出现像 *可能* 和 *也许* 这样的词。还要注意我没有使用 *可恢复*。挂载脏文件系统可能会让你的计算机崩溃。它可能会摧毁分区上剩余的所有数据，甚至可能彻底破坏底层文件系统。强制挂载脏文件系统进行读写是非常危险的。不要这么做。
- en: '***Background fsck, fsck -y, Foreground fsck, Oy Vey!***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***后台 fsck，fsck -y，前台 fsck，哎呀！***'
- en: 'All these different fsck(8) problems and situations can occur, but when does
    FreeBSD use each command? FreeBSD uses the following conditions to decide when
    and how to fsck(8) on a filesystem:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不同的 fsck(8) 问题和情况可能会发生，但 FreeBSD 何时使用每个命令呢？FreeBSD 使用以下条件来决定何时以及如何对文件系统执行
    fsck(8)：
- en: If the filesystem is clean, it is mounted without fsck(8).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件系统是干净的，它会在没有 fsck(8) 的情况下挂载。
- en: If a journaled filesystem is dirty at boot, FreeBSD recovers the data from the
    journal and continues the boot. A journaled filesystem rarely needs fsck(8).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个日志文件系统在启动时是脏的，FreeBSD 会从日志中恢复数据并继续启动。日志文件系统很少需要 fsck(8)。
- en: If a filesystem without soft updates is dirty at boot, FreeBSD runs fsck(8)
    on it. If the filesystem damage is severe, FreeBSD stops checking and requests
    your intervention. You can either run `fsck -y` or manually approve each correction.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个没有软更新的文件系统在启动时处于脏状态，FreeBSD 会对其运行 fsck(8)。如果文件系统损坏严重，FreeBSD 会停止检查并要求你介入。你可以选择运行
    `fsck -y` 或手动批准每个修复。
- en: If a filesystem with soft updates is dirty at boot, FreeBSD performs a very
    basic fsck(8) check. If the damage is mild, FreeBSD can use a background fsck(8)
    in multiuser mode.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个启用了软更新的文件系统在启动时处于脏状态，FreeBSD 会执行一个非常基础的 fsck(8) 检查。如果损坏较轻，FreeBSD 可以在多用户模式下使用后台
    fsck(8)。
- en: If the damage is severe, or you don’t want background fsck(8), FreeBSD interrupts
    the boot and requests a manual fsck(8).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果损坏严重，或者你不希望后台运行 fsck(8)，FreeBSD 会中断启动并请求手动运行 fsck(8)。
- en: Consider the recovery path when configuring your UFS filesystems.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置你的 UFS 文件系统时，考虑恢复路径。
- en: '**UFS Space Reservations**'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**UFS 空间保留**'
- en: A UFS filesystem is never quite as large as you think it should be. UFS holds
    back 8 percent of the filesystem space for on-the-fly optimization. Only root
    can write over that limit. That’s why a filesystem can seem to use more than 100
    percent of the available space. Why 8 percent? That number’s the result of many
    years of experience and real-world testing. That 8 percent holdback isn’t a big
    deal on average filesystems, but as the filesystem grows, it can be considerable.
    On a 1PB disk array, UFS holds 80TB in reserve.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 UFS 文件系统的大小永远不会如你预期的那样大。UFS 会预留 8% 的文件系统空间用于即时优化。只有 root 用户可以写入超过这个限制的空间。这就是为什么一个文件系统似乎使用了超过
    100% 可用空间的原因。为什么是 8%？这个数字来源于多年的经验和实际测试。在大多数文件系统上，8% 的预留空间不会造成太大问题，但随着文件系统的增大，这个数值会变得相当可观。在一个
    1PB 的磁盘阵列上，UFS 会预留 80TB 空间。
- en: UFS behaves differently depending on how full a filesystem gets. On an empty
    filesystem, it optimizes for speed. Once the filesystem hits 92 percent full (85
    percent of the total size, including the 8 percent reserve), it switches to optimize
    space utilization. Most people do the same thing—once you mostly fill up the laundry
    hamper, you can jam more dirty clothes in, but it takes a little more time and
    effort. UFS fragments files to use space more effectively. Fragments reduce disk
    performance. As free space shrinks, UFS works harder and harder to improve space
    utilization. A full UFS filesystem runs at about one-third the normal speed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: UFS 的表现取决于文件系统的填充程度。在空文件系统上，它优化速度。一旦文件系统达到 92% 的容量（包括 8% 保留空间，占总大小的 85%），它会切换到优化空间利用率。大多数人也会做同样的事——一旦洗衣篮快满了，你还可以再塞些脏衣服进去，不过需要更多的时间和力气。UFS
    会将文件碎片化，以更有效地利用空间。碎片会降低磁盘性能。随着空闲空间的减少，UFS 会越来越努力地提高空间利用率。一个满载的 UFS 文件系统运行速度大约是正常速度的三分之一。
- en: You might want to use tunefs(8) to reduce the amount of disk space FreeBSD holds
    in reserve. It won’t help as much as you think. Reducing the reserve to 5 percent
    or less tells UFS to always use space optimization and pack the filesystem as
    tightly as possible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想使用 tunefs(8) 来减少 FreeBSD 保留的磁盘空间量。它的效果可能没有你想象的那么大。将保留空间减少到 5% 或更低，告诉 UFS
    始终使用空间优化，并尽可能紧密地压缩文件系统。
- en: Increasing the reserved space percentage doesn’t improve performance. If you
    increase the reserved space percentage so that your filesystem appears full, regular
    users won’t be able to write files.^([5](footnote.xhtml#ch11fn5))
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 增加保留空间百分比并不会提高性能。如果你增加保留空间百分比，导致文件系统显示已满，普通用户将无法写入文件。^([5](footnote.xhtml#ch11fn5))
- en: The reserved space can confuse tools such as NFS. Some other operating systems
    that can mount UFS over NFS see that a filesystem is 100 percent full and tell
    the user they can’t write files, despite local clients being able to write files.
    Remember this when troubleshooting.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 保留空间可能会干扰像 NFS 这样的工具。某些可以通过 NFS 挂载 UFS 的操作系统会发现文件系统已满，并告知用户无法写入文件，尽管本地客户端可以写入文件。在故障排除时要记住这一点。
- en: The best thing to do is to keep your partition from filling up.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是避免你的分区被填满。
- en: '**How Full Is a Partition?**'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分区有多满？**'
- en: To get an overview of how much space each UFS partition has left, use df(1).
    This lists the partitions on your system, the amount of space each uses, and where
    it’s mounted. (Don’t use df(1) with ZFS; we’ll discuss why in the next chapter.)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每个 UFS 分区剩余的空间，使用 df(1) 命令。它会列出你系统中的分区、每个分区使用的空间以及挂载点。（不要在 ZFS 上使用 df(1)；我们将在下一章讨论原因。）
- en: '**$BLOCKSIZE**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**$BLOCKSIZE**'
- en: One annoying thing about FreeBSD’s disk utilities, including df(1), is that
    they default to providing information in 512-byte blocks. Blocks were fine with
    tiny disks that used 512-byte physical blocks, but it’s not a useful measurement
    today. The environment variable `$BLOCKSIZE` controls what unit df(1) provides
    output in. The default *.cshrc* and *.profile* set `$BLOCKSIZE` to 1KB, which
    makes df(1) show kilobytes instead of blocks.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 FreeBSD 的磁盘工具（包括 df(1)）有一个让人烦恼的地方，那就是它们默认以 512 字节块的形式提供信息。块在使用 512 字节物理块的微小磁盘上是没问题的，但今天它并不是一个有用的度量单位。环境变量
    `$BLOCKSIZE` 控制 df(1) 输出的单位。默认的 *.cshrc* 和 *.profile* 文件将 `$BLOCKSIZE` 设置为 1KB，这使得
    df(1) 显示千字节而不是块。
- en: The `-h` and `-H` flags tell df(1) to produce human-readable output rather than
    using blocks. The small `-h` uses base 2 to create a 1,024-byte megabyte, while
    the large `-H` uses base 10 for a 1,000-byte megabyte. Typically, network administrators
    and disk manufacturers use base 10, while system administrators use base 2\. Either
    works so long as you know which you’ve chosen. I’m a network administrator, so
    you get to suffer through my prejudices in these examples, despite what my tech
    editor thinks.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`-h` 和 `-H` 标志告诉 df(1) 生成人类可读的输出，而不是使用块。小的 `-h` 使用基 2 来生成 1,024 字节的兆字节，而大的
    `-H` 使用基 10 来生成 1,000 字节的兆字节。通常，网络管理员和磁盘制造商使用基 10，而系统管理员使用基 2。只要你知道你选择的是哪一个，任意一种都可以。我是网络管理员，所以你得忍受我在这些示例中的偏见，尽管我的技术编辑不这么认为。'
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line shows us column headers ➊ for the provider name, the size of
    the partition, the amount of space used, the amount of space available, the percent
    of space used, and the mount point. We can see that the partition labeled */dev/gpt/root*
    ➋ is only 1GB in size but has only 171MB on it, leaving 785MB free. It’s 18 percent
    full and mounted on */*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行向我们展示了列标题➊，包括提供者名称、分区大小、已用空间、可用空间、已用空间的百分比以及挂载点。我们可以看到，标记为 */dev/gpt/root*
    ➋ 的分区只有 1GB 大，但仅使用了 171MB，剩下 785MB 可用。它已满 18%，并挂载在 */* 上。
- en: If your systems are like mine, disk usage somehow keeps growing for no apparent
    reason. Look at the */usr* partition ➌ here. It’s 98 percent full. You can identify
    individual large files with `ls -l`, but recursively doing this on every directory
    in the system is impractical.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统像我的一样，磁盘使用情况似乎总是在没有明显原因的情况下不断增加。看看这里的 */usr* 分区 ➌。它已满 98%。你可以使用 `ls -l`
    来识别单个大文件，但在系统的每个目录中递归地执行这个操作是不可行的。
- en: 'The du(1) program displays disk usage in a single directory. Its initial output
    is intimidating and can scare off inexperienced users. Here, we use du(1) to find
    out what’s taking up all the space in my home directory:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: du(1) 程序在单一目录中显示磁盘使用情况。它的初始输出令人畏惧，可能会吓跑没有经验的用户。在这里，我们使用 du(1) 来找出占用我主目录所有空间的原因：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This goes on and on, displaying every subdirectory and giving its size in blocks.
    The total of each subdirectory is given—for example, the contents of *$HOME/bin*
    totals 53,336 blocks, or roughly 53MB. I could sit and let du(1) list every directory
    and subdirectory, but then I’d have to dig through much more information than
    I really want to. And blocks aren’t that convenient a measurement, especially
    not when they’re printed left-justified.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这会一直显示下去，列出每个子目录并给出其以块为单位的大小。每个子目录的总和都会显示——例如，*$HOME/bin* 的内容总共占用了 53,336 块，约为
    53MB。我可以坐着让 du(1) 列出每个目录和子目录，但那样我将不得不浏览比我真正需要的更多的信息。而且，块这种单位并不是特别方便，尤其是当它们被左对齐打印时。
- en: Let’s clean this up. First, du(1) supports an `-h` flag much like df. Also,
    I don’t need to see the recursive contents of each subdirectory. We can control
    the number of directories we display with du’s `-d` flag. This flag takes one
    argument, the number of directories you want to explicitly list. For example,
    `-d0` goes one directory deep and gives a simple subtotal of the files in a directory.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们整理一下这个输出。首先，du(1) 支持类似于 df 的 `-h` 标志。此外，我不需要查看每个子目录的递归内容。我们可以通过 du 的 `-d`
    标志来控制显示的目录数量。这个标志接受一个参数，即你想要明确列出的目录数量。例如，`-d0` 只深入一层目录，并给出该目录中文件的简单小计。
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I have 14 gigs of data in my home directory? Let’s look a layer deeper and identify
    the biggest subdirectory.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我的主目录里有 14GB 的数据？让我们深入一层，找出最大的子目录。
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Apparently I must look elsewhere for storage space, as the data in my home directory
    is too important to delete. Maybe I should just grow the virtual disk under this
    host.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我必须去别处寻找存储空间，因为我主目录中的数据太重要，不能删除。也许我应该在这个主机下扩展虚拟磁盘。
- en: If you’re not too attached to the `-h` flag, you can use sort(1) to find the
    largest directory with a command like `du -kxd 1 | sort -n`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太依赖于`-h`标志，可以使用sort(1)来查找最大目录，命令如下：`du -kxd 1 | sort -n`。
- en: '**Adding New UFS storage**'
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加新的UFS存储**'
- en: No matter how much planning you do, eventually your hard drives will fill up.
    You’ll need to add disks. Before you can use a new hard drive, you must partition
    the drive, create filesystems, mount those filesystems, and move data to them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你做多少规划，最终你的硬盘空间都会填满。你将需要添加新磁盘。在你能使用新硬盘之前，必须对其进行分区、创建文件系统、挂载这些文件系统，并将数据迁移到它们上面。
- en: Give the design of your new disk partitioning and filesystems as much thought
    as you did the initial install. It’s much easier to partition disks correctly
    at install than to go back and repartition disks with data on them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 和初次安装时一样，给你新的磁盘分区和文件系统设计足够的思考。安装时正确分区要比安装后再去重新分区（带有数据的）容易得多。
- en: '**BACK UP, BACK UP, BACK UP!**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**备份，备份，再备份！**'
- en: Before doing anything with disks, be sure that you have a complete backup. A
    single dumb fat-finger mistake can destroy your system! While you rarely plan
    to reformat your root filesystem, if it happens, you want to recover really, really
    quickly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何磁盘操作之前，务必确保你有完整的备份。一个粗心的错误就可能摧毁你的系统！虽然你不常计划重格式化根文件系统，但如果发生这种情况，你希望能够快速恢复。
- en: '***Partitioning the Disk***'
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***磁盘分区***'
- en: While you can partition the disk any way you like, I recommend that new disks
    use the same partitioning scheme as the rest of the host. Having one disk partitioned
    with MBR and one with GPT is annoying. I’ll use GPT for this example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以随意分区磁盘，但我建议新磁盘使用与主机其他磁盘相同的分区方案。一个磁盘使用MBR而另一个使用GPT会很麻烦。这个例子中我将使用GPT。
- en: Decide how you want to divide the disk. This is a 1TB disk. 100GB will go to
    an expanded */tmp*. I’ll dedicate 500GB to my new database partition. The remaining
    space gets partitioned off but labeled *emergency*. I won’t put a filesystem in
    that space; it’s there in case I need to do a full memory dump or have to put
    some files somewhere. I’m putting it right next to the database partition so I
    can grow the database partition if needed. I could leave the emergency space unpartitioned,
    but I want it to have a GPT label so that my fellow sysadmins realize this free
    space isn’t accidental.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 决定如何划分磁盘。这是一个1TB的磁盘。100GB将分配给扩展后的*/tmp*。我会为我的新数据库分区分配500GB。剩余的空间将划分并标记为*emergency*。我不会在这个空间上创建文件系统；它是为了防止需要做完全内存转储或存放某些文件时用的。我将它放在数据库分区旁边，以便需要时可以扩展数据库分区。我可以选择不对紧急空间进行分区，但我希望它有一个GPT标签，这样我的同事系统管理员就知道这个空闲空间不是意外的。
- en: Start by destroying any partitioning scheme on the disk and creating a GPT scheme.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从销毁磁盘上的任何分区方案开始，并创建一个GPT方案。
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now create your 100GB */tmp* and 500GB data partitions, and dump the rest into
    the emergency partition.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建你的100GB */tmp*和500GB数据分区，并将剩余空间放入紧急分区。
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Check your work with `gpart show`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gpart show`检查你的工作。
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Create filesystems on each partition.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个分区上创建文件系统。
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As */tmp* gets emptied at every boot, I would prefer not to use soft updates
    journaling on */tmp*. Instead, I’d mount */tmp* async and run `newfs /dev/gpt/tmp`
    at boot. Many times, newfs(8) is faster than rm(1).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*/tmp*在每次启动时都会被清空，我更倾向于不在*/tmp*上使用软更新日志。相反，我会将*/tmp*挂载为异步，并在启动时运行`newfs /dev/gpt/tmp`。很多时候，newfs(8)比rm(1)更快。
- en: '***Configuring /etc/fstab***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置/etc/fstab***'
- en: Now tell */etc/fstab* about your filesystems. We discuss the format of */etc/fstab*
    in [Chapter 10](ch10.xhtml#ch10).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，告诉*/etc/fstab*关于你的文件系统。我们在[第10章](ch10.xhtml#ch10)中讨论了*/etc/fstab*的格式。
- en: '[PRE30]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: FreeBSD will recognize the filesystems at boot, or you can mount these new partitions
    at the command line. Don’t reboot or mount the partitions just yet, though. First
    you’ll want to move files to those filesystems.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD将在启动时识别这些文件系统，或者你可以在命令行上挂载这些新分区。不过，暂时不要重启或挂载分区。首先，你需要将文件迁移到这些文件系统中。
- en: '***Installing Existing Files onto New Disks***'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将现有文件安装到新磁盘***'
- en: Chances are that you intend your new disk to replace or subdivide an existing
    partition. You’ll need to mount your new partition on a temporary mount point,
    move files to the new disk, then remount the partition at the desired location.
    While */tmp* doesn’t have any files, if we’re installing a new database filesystem,
    we presumably have database files to put there.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你打算让新的磁盘替换或细分现有分区。你需要将新分区挂载到临时挂载点，将文件移动到新磁盘，然后在所需位置重新挂载分区。虽然*/tmp*没有任何文件，但如果我们正在安装新的数据库文件系统，我们大概有数据库文件需要放在那里。
- en: Before moving files, shut down any process using them. You cannot successfully
    copy files that are being changed as you copy them. If you’re moving your database
    files, shut down your database. If you’re moving your mail spool, shut down all
    of your mail programs. This is a big part of why I recommend doing all new disk
    installations in single-user mode.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动文件之前，关闭任何正在使用它们的进程。你不能成功地复制正在被更改的文件。如果你要移动数据库文件，请关闭数据库。如果你要移动邮件队列，请关闭所有邮件程序。这也是我推荐在单用户模式下进行所有新磁盘安装的主要原因之一。
- en: Now mount your new partition on a temporary mount point. That’s exactly what
    */mnt* is for.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将你的新分区挂载到一个临时挂载点。这正是*/mnt*的用途所在。
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now you must move the files from their current location to the new disk without
    changing their permissions. This is fairly simple with tar(1). You can simply
    tar up your existing data to a tape or a file and untar it in the new location,
    but that’s kind of clumsy. Pipe one `tar` into another to avoid the middle step.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你必须将文件从当前位置移动到新磁盘，而不更改它们的权限。这用tar(1)非常简单。你可以将现有数据打包到磁带或文件中，并在新位置解包，但这有点笨重。通过将一个`tar`管道传递给另一个来避免中间步骤。
- en: '[PRE32]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you don’t speak Unix at parties, this looks fairly stunning. Let’s dismantle
    it. First, we go to the old directory and tar up everything. Then, pipe the output
    to a second command, which extracts the backup in the new directory. When this
    command finishes, your files are installed on their new disk. For example, to
    move */usr/local/etc/postgres* onto a new partition temporarily mounted at */mnt*,
    you would do the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在派对上不讲Unix，这看起来相当惊人。让我们拆解一下。首先，我们进入旧目录并将所有内容打包（tar）。然后，将输出通过管道传输到第二个命令，该命令在新目录中提取备份。当此命令完成时，你的文件将安装到新的磁盘上。例如，要将*/usr/local/etc/postgres*移动到临时挂载在*/mnt*的新分区，你可以执行以下操作：
- en: '[PRE33]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Check the temporary mount point to be sure that your files are actually there.
    Once you’re confident that the files are properly moved, remove the files from
    the old directory and mount the disk in the new location. For example, after duplicating
    your files from */usr/local/etc/postgres*, you’d run:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 检查临时挂载点，确保你的文件确实在那里。一旦你确认文件已正确移动，删除旧目录中的文件，并将磁盘挂载到新位置。例如，在将文件从*/usr/local/etc/postgres*复制后，你将运行：
- en: '[PRE34]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can now resume normal operation. I recommend rebooting to verify that everything
    comes back exactly as you intended.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以恢复正常操作了。我建议重启以验证一切是否按照你的预期恢复。
- en: '***Stackable Mounts***'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可堆叠挂载***'
- en: Maybe you don’t care about your old data; you want to split an existing filesystem
    only to get more space and you intend to recover your data from backup. That’s
    fine. All FreeBSD filesystems are *stackable*. This is an advanced idea that’s
    not terribly useful in day-to-day system administration, but it can bite you when
    you try to split one partition into two.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你不关心你的旧数据；你只想分割现有的文件系统以获得更多空间，并打算从备份中恢复数据。那也没问题。所有FreeBSD文件系统都是*可堆叠*的。这是一个高级概念，日常系统管理中并不特别有用，但当你尝试将一个分区分割成两个时，它可能会让你措手不及。
- en: Suppose, for example, that you have data in */usr/src*. See how much space is
    used on your disk, and then mount a new empty partition on */usr/src*. If you
    look in the directory afterward, you’ll see that it’s empty.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你的数据在*/usr/src*中。查看磁盘上已使用的空间，然后在*/usr/src*上挂载一个新的空分区。如果你之后查看该目录，你会发现它是空的。
- en: 'Here’s the problem: the old filesystem still has all its original data on it.
    The new filesystem is mounted “above” the old filesystem, so you see only the
    new filesystem. The old filesystem has no more free space than before you moved
    the data. If you unmount the new filesystem and check the directory again, you’ll
    see the data miraculously restored! The new filesystem obscured the lower filesystem.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于：旧的文件系统仍然保留着原始数据。新的文件系统被挂载在“上方”，因此你只看到新的文件系统。旧的文件系统在你移动数据之前没有更多的可用空间。如果你卸载新的文件系统并再次检查目录，你会惊讶地发现数据奇迹般恢复！新的文件系统遮盖了下层的文件系统。
- en: 'Although you can’t see the data, data on the old filesystem still takes up
    space. If you’re adding a filesystem to gain space, and you mount a new filesystem
    over part of the old, you won’t free any space on your original filesystem. The
    moral is: even if you’re restoring your data from backup, make sure that you remove
    that data from your original disk to recover disk space.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你看不见数据，但旧文件系统上的数据仍然占用空间。如果你添加了一个文件系统来获取空间，并且将一个新文件系统挂载到旧文件系统的某一部分上，你将无法释放原始文件系统上的空间。这个教训是：即使你正在从备份中恢复数据，也要确保将原始磁盘上的数据移除，以便回收磁盘空间。
- en: Now that you can talk UFS, let’s explore ZFS.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经掌握了 UFS，让我们来探索一下 ZFS。
