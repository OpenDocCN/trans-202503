<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;BIT MANIPULATION"><div class="titlepage"><div><div><h1 class="title"><a id="bit_manipulation"/>Chapter 10. BIT MANIPULATION</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject10_d1e49540"/><img alt="BIT MANIPULATION" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p>Manipulating bits in memory is, perhaps, the feature for which assembly language is most famous. Indeed, one of the reasons people claim that the C programming language is a medium-level language rather than a high-level language is because of the vast array of bit-manipulation operators that C provides. Even with this wide array of bit-manipulation operations, the C programming language doesn't provide as complete a set of bit-manipulation operations as assembly language.<a class="indexterm" id="IDX-CHP-10-0001"/><a class="indexterm" id="IDX-CHP-10-0002"/></p><p>This chapter discusses how to manipulate strings of bits in memory and registers using 80x86 assembly language. It begins with a review of the bit-manipulation instructions covered thus far, and it also introduces a few new instructions. This chapter reviews information on packing and unpacking bit strings in memory because this is the basis for many bit-manipulation operations. Finally, this chapter discusses several bit-centric algorithms and their implementation in assembly language.</p><div class="sect1" title="10.1 What Is Bit Data, Anyway?"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_bit_data_comma_anyway_question"/>10.1 What Is Bit Data, Anyway?</h1></div></div></div><p>Before describing how to manipulate bits, it might not be a bad idea to define exactly what this text means by <span class="emphasis"><em>bit data</em></span>. Most readers probably assume that bit-manipulation programs twiddle individual bits in memory. While programs that do this are definitely bit-manipulation programs, we're not going to limit our definition to just those programs. For our purposes, <span class="emphasis"><em>bit manipulation</em></span> refers to working with data types that consist of strings of bits that are noncontiguous or are not a multiple of 8 bits long. Generally, such bit objects will not represent numeric integers, although we will not place this restriction on our bit strings.<a class="indexterm" id="IDX-CHP-10-0003"/><a class="indexterm" id="IDX-CHP-10-0004"/><a class="indexterm" id="IDX-CHP-10-0005"/><a class="indexterm" id="IDX-CHP-10-0006"/><a class="indexterm" id="IDX-CHP-10-0007"/><a class="indexterm" id="IDX-CHP-10-0008"/></p><p>A <span class="emphasis"><em>bit string</em></span> is some contiguous sequence of one or more bits. Note that a bit string does not have to start or end at any special point. For example, a bit string could start in bit 7 of one byte in memory and continue through to bit 6 of the next byte in memory. Likewise, a bit string could begin in bit 30 of EAX, consume the upper 2 bits of EAX, and then continue from bit 0 through bit 17 of EBX. In memory, the bits must be physically contiguous (that is, the bit numbers are always increasing except when crossing a byte boundary, and at byte boundaries the memory address increases by 1 byte). In registers, if a bit string crosses a register boundary, the application defines the continuation register, but the bit string always continues in bit 0 of that second register.</p><p>A <span class="emphasis"><em>bit set</em></span> is a collection of bits, not necessarily contiguous, within some larger data structure. For example, bits 0..3, 7, 12, 24, and 31 from some double word form a set of bits. Usually, we will limit bit sets to some reasonably sized <span class="emphasis"><em>container object</em></span> (the data structure that encapsulates the bit set), but the definition doesn't specifically limit the size. Normally, we will deal with bit sets that are part of an object no more than about 32 or 64 bits in size, though this limit is completely artificial. Note that bit strings are special cases of bit sets.<a class="indexterm" id="IDX-CHP-10-0009"/></p><p>A <span class="emphasis"><em>bit run</em></span> is a sequence of bits with all the same value. A <span class="emphasis"><em>run of zeros</em></span> is a bit string that contains all zeros, and a <span class="emphasis"><em>run of ones</em></span> is a bit string containing all ones. The <span class="emphasis"><em>first set bit</em></span> in a bit string is the bit position of the first bit containing a 1 in a bit string, that is, the first 1 bit following a possible run of zeros. A similar definition exists for the <span class="emphasis"><em>first clear bit</em></span>. The <span class="emphasis"><em>last set bit</em></span> is the last bit position in a bit string that contains 1; the remainder of the string forms an uninterrupted run of zeros. A similar definition exists for the <span class="emphasis"><em>last clear bit</em></span>.<a class="indexterm" id="IDX-CHP-10-0010"/><a class="indexterm" id="IDX-CHP-10-0011"/><a class="indexterm" id="IDX-CHP-10-0012"/></p><p>A <span class="emphasis"><em>bit offset</em></span> is the number of bits from some boundary position (usually a byte boundary) to the specified bit. As noted in <a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a>, we number the bits starting from 0 at the boundary location.<a class="indexterm" id="IDX-CHP-10-0013"/></p><p>A <span class="emphasis"><em>mask</em></span> is a sequence of bits that we'll use to manipulate certain bits in another value. For example, the bit string %0000_1111_0000, when it's used with the and instruction, can mask away (clear) all the bits except bits 4 through 7. Likewise, if you use the same value with the or instruction, it can force bits 4 through 7 to ones in the destination operand. The term <span class="emphasis"><em>mask</em></span> comes from the use of these bit strings with the <code class="literal">and</code> instruction; in those situations the 1 and 0 bits behave like masking tape when you're painting something; they pass through certain bits unchanged while masking out (clearing) the other bits.<a class="indexterm" id="IDX-CHP-10-0014"/></p><p>Armed with these definitions, we're ready to start manipulating some bits!</p></div></div>
<div class="sect1" title="10.2 Instructions That Manipulate Bits"><div class="titlepage"><div><div><h1 class="title"><a id="instructions_that_manipulate_bits"/>10.2 Instructions That Manipulate Bits</h1></div></div></div><p>Bit manipulation generally consists of six activities: setting bits, clearing bits, inverting bits, testing and comparing bits, extracting bits from a bit string, and inserting bits into a bit string. By now you should be familiar with most of the instructions we'll use to perform these operations; their introduction started way back in the earliest chapters of this text. Nevertheless, it's worthwhile to review the old instructions here as well as present the few bit-manipulation instructions we've yet to consider.<a class="indexterm" id="IDX-CHP-10-0015"/><a class="indexterm" id="IDX-CHP-10-0016"/><a class="indexterm" id="IDX-CHP-10-0017"/><a class="indexterm" id="IDX-CHP-10-0018"/><a class="indexterm" id="IDX-CHP-10-0019"/><a class="indexterm" id="IDX-CHP-10-0020"/><a class="indexterm" id="IDX-CHP-10-0021"/><a class="indexterm" id="IDX-CHP-10-0022"/><a class="indexterm" id="IDX-CHP-10-0023"/><a class="indexterm" id="IDX-CHP-10-0024"/><a class="indexterm" id="IDX-CHP-10-0025"/><a class="indexterm" id="IDX-CHP-10-0026"/><a class="indexterm" id="IDX-CHP-10-0027"/><a class="indexterm" id="IDX-CHP-10-0028"/><a class="indexterm" id="IDX-CHP-10-0029"/><a class="indexterm" id="IDX-CHP-10-0030"/><a class="indexterm" id="IDX-CHP-10-0031"/></p><p>The most basic bit-manipulation instructions are the <code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">xor</code>, <code class="literal">not</code>, <code class="literal">test</code>, and shift and rotate instructions. Indeed, on the earliest 80x86 processors, these were the only instructions available for bit manipulation. The following paragraphs review these instructions, concentrating on how you could use them to manipulate bits in memory or registers.<a class="indexterm" id="IDX-CHP-10-0032"/><a class="indexterm" id="IDX-CHP-10-0033"/><a class="indexterm" id="IDX-CHP-10-0034"/></p><p>The <code class="literal">and</code> instruction provides the ability to strip away unwanted bits from some bit sequence, replacing the unwanted bits with zeros. This instruction is especially useful for isolating a bit string or a bit set that is merged with other, unrelated data (or, at least, data that is not part of the bit string or bit set). For example, suppose that a bit string consumes bit positions 12 through 24 of the EAX register; we can isolate this bit string by setting all other bits in EAX to 0 by using the following instruction:</p><a id="I_programlisting10_d1e49788"/><pre class="programlisting">and( %1_1111_1111_1111_0000_0000_0000, eax );</pre><p>Most programs use the <code class="literal">and</code> instruction to clear bits that are not part of the desired bit string. In theory, you could use the <code class="literal">or</code> instruction to mask all unwanted bits to ones rather than zeros, but later comparisons and operations are often easier if the unneeded bit positions contain 0 (see <a class="xref" href="ch10s02.html#isolating_a_bit_string_using_the_and_ins" title="Figure 10-1. Isolating a bit string using the and instruction">Figure 10-1</a>).</p><div class="figure"><a id="isolating_a_bit_string_using_the_and_ins"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e49806"/><img alt="Isolating a bit string using the and instruction" src="tagoreillycom20100401nostarchimages578069.png.jpg"/></div></div><p class="title">Figure 10-1. Isolating a bit string using the <code class="literal">and</code> instruction</p></div><p>Once you've cleared the unneeded bits in a set of bits, you can often operate on the bit set in place. For example, to see if the string of bits in positions 12 through 24 of EAX contains $12F3, you could use the following code:</p><a id="I_programlisting10_d1e49813"/><pre class="programlisting">and( %1_1111_1111_1111_0000_0000_0000, eax );
  cmp( eax, %1_0010_1111_0011_0000_0000_0000 );</pre><p>Here's another solution, using constant expressions, that's a little easier to digest:<a class="indexterm" id="IDX-CHP-10-0035"/><a class="indexterm" id="IDX-CHP-10-0036"/><a class="indexterm" id="IDX-CHP-10-0037"/><a class="indexterm" id="IDX-CHP-10-0038"/></p><a id="I_programlisting10_d1e49837"/><pre class="programlisting">and( %1_1111_1111_1111_0000_0000_0000, eax );
  cmp( eax, $12F3 &lt;&lt; 12 );  // "&lt;&lt;12" shifts $12F3 to the left 12 bits.</pre><p>Most of the time, however, you'll want (or need) the bit string aligned with bit 0 in EAX prior to any operations you would want to perform. Of course, you can use the <code class="literal">shr</code> instruction to properly align the value after you've masked it, like this:</p><a id="I_programlisting10_d1e49845"/><pre class="programlisting">and( %1_1111_1111_1111_0000_0000_0000, eax );
     shr( 12, eax );
     cmp( eax, $12F3 );
     &lt;&lt; Other operations that require the bit string at bit #0 &gt;&gt;</pre><p>Now that the bit string is aligned to bit 0, the constants and other values you use in conjunction with this value are easier to deal with.</p><p>You can also use the <code class="literal">or</code> instruction to mask unwanted bits. However, the <code class="literal">or</code> instruction does not let you clear bits; it allows you to set bits to ones. In some instances setting all the bits around your bit set may be desirable; most software, however, is easier to write if you clear the surrounding bits rather than set them.</p><p>The <code class="literal">or</code> instruction is especially useful for inserting a bit set into some other bit string. To do this, there are several steps you must go through:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Clear all the bits surrounding your bit set in the source operand.</p></li><li class="listitem"><p>Clear all the bits in the destination operand where you wish to insert the bit set.</p></li><li class="listitem"><p><code class="literal">or</code> the bit set and destination operand together.</p></li></ul></div><p>For example, suppose you have a value in bits 0..12 of EAX that you wish to insert into bits 12..24 of EBX without affecting any of the other bits in EBX. You would begin by stripping out bits 13 and above from EAX; then you would strip out bits 12..24 in EBX. Next, you would shift the bits in EAX so the bit string occupies bits 12..24 of EAX. Finally, you would <code class="literal">or</code> the value in EAX into EBX (see <a class="xref" href="ch10s02.html#inserting_bits_0..12_of_eax_into_bits_12" title="Figure 10-2. Inserting bits 0..12 of EAX into bits 12..24 of EBX">Figure 10-2</a>), as shown here:</p><a id="I_programlisting10_d1e49881"/><pre class="programlisting">and( $1FFF, eax );      // Strip all but bits 0..12 from eax.
     and( $FE00_0FFF, ebx ); // Clear bits 12..24 in ebx.
     shl( 12, eax );         // Move bits 0..12 to 12..24 in eax.
     or( eax, ebx );         // Merge the bits into ebx.</pre><div class="figure"><a id="inserting_bits_0..12_of_eax_into_bits_12"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e49886"/><img alt="Inserting bits 0..12 of EAX into bits 12..24 of EBX" src="tagoreillycom20100401nostarchimages578071.png.jpg"/></div></div><p class="title">Figure 10-2. Inserting bits 0..12 of EAX into bits 12..24 of EBX</p></div><p>In this figure the desired bits (AAAAAAAAAAAAA) formed a bit string. However, this algorithm still works fine even if you're manipulating a noncontiguous set of bits. All you have to do is to create an appropriate bit mask you can use for <code class="literal">and</code>ing that has ones in the appropriate places.</p><p>When working with bit masks, it is incredibly poor programming style to use literal numeric constants as in the past few examples. You should always create symbolic constants in the HLA <code class="literal">const</code> (or <code class="literal">val</code>) section for your bit masks. Combined with some constant expressions, you can produce code that is much easier to read and maintain. The current example code is more properly written as the following:<a class="indexterm" id="IDX-CHP-10-0039"/><a class="indexterm" id="IDX-CHP-10-0040"/></p><a id="I_programlisting10_d1e49913"/><pre class="programlisting">const
     StartPosn := 12;
     BitMask: dword := $1FFF &lt;&lt; StartPosn; // Mask occupies bits 12..24.
          .
          .
          .
          shl( StartPosn, eax );  // Move into position.
          and( BitMask, eax );    // Strip all but bits 12..24 from eax.
          and( !BitMask, ebx );   // Clear bits 12..24 in ebx.
          or( eax, ebx );         // Merge the bits into ebx.</pre><p>Notice the use of the compile time <code class="literal">not</code> operator (<code class="literal">!</code>) to invert the bit mask in order to clear the bit positions in EBX where the code inserts the bits from EAX. This saves having to create another constant in the program that has to be changed anytime you modify the <code class="literal">BitMask</code> constant. Having to maintain two separate symbols whose values are dependent on one another is not a good thing in a program.</p><p>Of course, in addition to merging one bit set with another, the <code class="literal">or</code> instruction is also useful for forcing bits to 1 in a bit string. By setting various bits in a source operand to 1, you can force the corresponding bits in the destination operand to 1 by using the <code class="literal">or</code> instruction.</p><p>The <code class="literal">xor</code> instruction allows you to invert selected bits in a bit set. Although inverting bits isn't as common as setting or clearing them, the <code class="literal">xor</code> instruction often appears in bit-manipulation programs. Of course, if you want to invert all the bits in some destination operand, the <code class="literal">not</code> instruction is probably more appropriate than the <code class="literal">xor</code> instruction; however, to invert selected bits while not affecting others, the <code class="literal">xor</code> is the way to go.<a class="indexterm" id="IDX-CHP-10-0041"/></p><p>One interesting fact about <code class="literal">xor</code>'s operation is that it lets you manipulate known data in just about any way imaginable. For example, if you know that a field contains %1010, you can force that field to 0 by <code class="literal">xor</code>ing it with %1010. Similarly, you can force it to %1111 by <code class="literal">xor</code>ing it with %0101. Although this might seem like a waste, because you can easily force this 4-bit string to 0 or all ones using <code class="literal">and</code>/<code class="literal">or</code>, the <code class="literal">xor</code> instruction has two advantages: (1) You are not limited to forcing the field to all zeros or all ones; you can actually set these bits to any of the 16 valid combinations via <code class="literal">xor</code>; and (2) if you need to manipulate other bits in the destination operand at the same time, <code class="literal">and</code>/<code class="literal">or</code> may not be able to accommodate you. For example, suppose that you know that one field contains %1010 that you want to force to 0 and another field contains %1000 and you wish to increment that field by 1 (i.e., set the field to %1001). You cannot accomplish both operations with a single <code class="literal">and</code> or <code class="literal">or</code> instruction, but you can do this with a single <code class="literal">xor</code> instruction; just <code class="literal">xor</code> the first field with %1010 and the second field with <code class="literal">%0001</code>. Remember, however, that this trick works only if you know the current value of a bit set within the destination operand. Of course, while you're adjusting the values of bit fields containing known values, you can invert bits in other fields simultaneously.</p><p>In addition to setting, clearing, and inverting bits in some destination operand, the <code class="literal">and</code>, <code class="literal">or</code>, and <code class="literal">xor</code> instructions also affect various condition codes in the flags register. These instructions affect the flags as follows:<a class="indexterm" id="IDX-CHP-10-0042"/><a class="indexterm" id="IDX-CHP-10-0043"/><a class="indexterm" id="IDX-CHP-10-0044"/><a class="indexterm" id="IDX-CHP-10-0045"/><a class="indexterm" id="IDX-CHP-10-0046"/><a class="indexterm" id="IDX-CHP-10-0047"/><a class="indexterm" id="IDX-CHP-10-0048"/><a class="indexterm" id="IDX-CHP-10-0049"/><a class="indexterm" id="IDX-CHP-10-0050"/><a class="indexterm" id="IDX-CHP-10-0051"/><a class="indexterm" id="IDX-CHP-10-0052"/><a class="indexterm" id="IDX-CHP-10-0053"/><a class="indexterm" id="IDX-CHP-10-0054"/><a class="indexterm" id="IDX-CHP-10-0055"/><a class="indexterm" id="IDX-CHP-10-0056"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>These instructions always clear the carry and overflow flags.</p></li><li class="listitem"><p>These instructions set the sign flag if the result has a 1 in the H.O. bit; they clear it otherwise. That is, these instructions copy the H.O. bit of the result into the sign flag.</p></li><li class="listitem"><p>These instructions set/clear the zero flag if the result is 0.</p></li><li class="listitem"><p>These instructions set the parity flag if there is an even number of set bits in the L.O. byte of the destination operand; they clear the parity flag if there is an odd number of 1 bits in the L.O. byte of the destination operand.</p></li></ul></div><p>The first thing to note is that these instructions always clear the carry and overflow flags. This means that you cannot expect the system to preserve the state of these two flags across the execution of these instructions. A very common mistake in many assembly language programs is the assumption that these instructions do not affect the carry flag. Many people will execute an instruction that sets/clears the carry flag, execute an <code class="literal">and</code>/<code class="literal">or</code>/<code class="literal">xor</code> instruction, and then attempt to test the state of the carry from the previous instruction. This simply will not work.</p><p>One of the more interesting aspects to these instructions is that they copy the H.O. bit of their result into the sign flag. This means that you can easily test the setting of the H.O. bit of the result by testing the sign flag (using <code class="literal">sets/setns</code> or <code class="literal">js</code>/<code class="literal">jns</code> instructions, or using the <code class="literal">@s</code>/<code class="literal">@ns</code> flags in a boolean expression). For this reason, many assembly language programmers will often place an important boolean variable in the H.O. bit of some operand so they can easily test the state of that bit using the sign flag after a logical operation.</p><p>We haven't talked much about the parity flag in this text. We're not going to get into a big discussion of this flag and what you use it for because the primary purpose for this flag has been taken over by hardware.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-1" id="CHP-10-FN-1">126</a>]</sup> However, because this is a chapter on bit manipulation, and parity computation is a bit-manipulation operation, it seems only fitting to provide a brief discussion of the parity flag at this time.</p><p>Parity is a very simple error-detection scheme originally employed by telegraphs and other serial communication protocols. The idea was to count the number of set bits in a character and include an extra bit in the transmission to indicate whether that character contained an even or odd number of set bits. The receiving end of the transmission would also count the bits and verify that the extra "parity" bit indicated a successful transmission. We're not going to explore the information-theory aspects of this error-checking scheme at this point other than to point out that the purpose of the parity flag is to help compute the value of this extra bit.</p><p>The 80x86 <code class="literal">and</code>, <code class="literal">or</code>, and <code class="literal">xor</code> instructions set the parity bit if the L.O. byte of their operand contains an even number of set bits. An important fact bears repeating here: The parity flag reflects only the number of set bits in the L.O. byte of the destination operand; it does not include the H.O. bytes in a word, double-word, or other-sized operand. The instruction set uses the L.O. byte only to compute the parity because communication programs that use parity are typically character-oriented transmission systems (there are better error-checking schemes if you transmit more than 8 bits at a time).<a class="indexterm" id="IDX-CHP-10-0057"/></p><p>The zero flag setting is one of the more important results the <code class="literal">and</code>/<code class="literal">or</code>/<code class="literal">xor</code> instructions produce. Indeed, programs reference this flag so often after the <code class="literal">and</code> instruction that Intel added a separate instruction, <code class="literal">test</code>, whose main purpose is to logically <code class="literal">and</code> two results and set the flags without otherwise affecting either instruction operand.<a class="indexterm" id="IDX-CHP-10-0058"/><a class="indexterm" id="IDX-CHP-10-0059"/></p><p>There are three main uses of the zero flag after the execution of an <code class="literal">and</code> or <code class="literal">test</code> instruction: (1) checking to see if a particular bit in an operand is set, (2) checking to see if at least one of several bits in a bit set is 1, and (3) checking to see if an operand is 0. Using (1) is actually a special case of (2) in which the bit set contains only a single bit. We'll explore each of these uses in the following paragraphs.</p><p>A common use for the <code class="literal">and</code> instruction, and also the original reason for the inclusion of the <code class="literal">test</code> instruction in the 80x86 instruction set, is to test to see if a particular bit is set in a given operand. To perform this type of test, you would normally <code class="literal">and</code>/<code class="literal">test</code> a constant value containing a single set bit with the operand you wish to test. This clears all the other bits in the second operand, leaving a 0 in the bit position under <code class="literal">test</code> if the operand contains a 0 in that bit position. <code class="literal">and</code>ing with a 1 leaves a 1 in that position if it originally contained a 1. Because all of the other bits in the result are 0, the entire result will be 0 if that particular bit is 0; the entire result will be nonzero if that bit position contains a 1. The 80x86 reflects this status in the zero flag (Z = 1 indicates a 0 bit; Z = 0 indicates a 1 bit). The following instruction sequence demonstrates how to test to see if bit 4 is set in EAX:</p><a id="I_programlisting10_d1e50204"/><pre class="programlisting">test( %1_0000, eax ); // Check bit #4 to see if it is 0/1.
     if( @nz ) then

          &lt;&lt; Do this if the bit is set. &gt;&gt;

     else

          &lt;&lt; Do this if the bit is clear. &gt;&gt;

     endif;</pre><p>You can also use the <code class="literal">and</code>/<code class="literal">test</code> instructions to see if any one of several bits is set. Simply supply a constant that has a 1 in all the positions you want to test (and zeros everywhere else). <code class="literal">and</code>ing such a value with an unknown quantity will produce a nonzero value if one or more of the bits in the operand under test contain a 1. The following example tests to see if the value in EAX contains a 1 in bit positions 1, 2, 4, and 7:<a class="indexterm" id="IDX-CHP-10-0060"/><a class="indexterm" id="IDX-CHP-10-0061"/><a class="indexterm" id="IDX-CHP-10-0062"/></p><a id="I_programlisting10_d1e50234"/><pre class="programlisting">test( %1001_0110, eax );
     if( @nz ) then // At least one of the bits is set.

          &lt;&lt; Do whatever needs to be done if one of the bits is set. &gt;&gt;

     endif;</pre><p>Note that you cannot use a single <code class="literal">and</code> or <code class="literal">test</code> instruction to see if all the corresponding bits in the bit set are equal to 1. To accomplish this, you must first mask out the bits that are not in the set and then compare the result against the mask itself. If the result is equal to the mask, then all the bits in the bit set contain ones. You must use the <code class="literal">and</code> instruction for this operation because the <code class="literal">test</code> instruction does not mask out any bits. The following example checks to see if all the bits in a bit set (<code class="literal">bitMask</code>) are equal to 1:</p><a id="I_programlisting10_d1e50253"/><pre class="programlisting">and( bitMask, eax );
     cmp( eax, bitMask );
     if( @e ) then

          // All the bit positions in eax corresponding to the set
          // bits in bitMask are equal to 1 if we get here.

          &lt;&lt; Do whatever needs to be done if the bits match. &gt;&gt;

     endif;</pre><p>Of course, once we stick the <code class="literal">cmp</code> instruction in there, we don't really have to check to see if all the bits in the bit set contain ones. We can check for any combination of values by specifying the appropriate value as the operand to the <code class="literal">cmp</code> instruction.</p><p>Note that the <code class="literal">test</code>/<code class="literal">and</code> instructions will set the zero flag in the above code sequences only if all the bits in EAX (or other destination operand) have zeros in the positions where ones appear in the constant operand. This suggests another way to check for all ones in the bit set: Invert the value in EAX prior to using the <code class="literal">and</code> or <code class="literal">test</code> instruction. Then if the zero flag is set, you know that there were all ones in the (original) bit set. For example:</p><a id="I_programlisting10_d1e50278"/><pre class="programlisting">not( eax );
 test( bitMask, eax );
 if( @z ) then
   // At this point, eax contained all ones in the bit positions
   // occupied by ones in the bitMask constant.

   &lt;&lt; Do whatever needs to be done at this point. &gt;&gt;

 endif;</pre><p>The previous paragraphs all suggest that the <code class="literal">bitMask</code> (the source operand) is a constant. This was for purposes of example only. In fact, you can use a variable or other register here, if you prefer. Simply load that variable or register with the appropriate bit mask before you execute the <code class="literal">test</code>, <code class="literal">and</code>, or <code class="literal">cmp</code> instructions in the examples above.<a class="indexterm" id="IDX-CHP-10-0063"/><a class="indexterm" id="IDX-CHP-10-0064"/><a class="indexterm" id="IDX-CHP-10-0065"/><a class="indexterm" id="IDX-CHP-10-0066"/><a class="indexterm" id="IDX-CHP-10-0067"/><a class="indexterm" id="IDX-CHP-10-0068"/><a class="indexterm" id="IDX-CHP-10-0069"/><a class="indexterm" id="IDX-CHP-10-0070"/></p><p>Another set of instructions we've already seen that we can use to manipulate bits are the bit test instructions. These instructions include <code class="literal">bt</code> (bit test), <code class="literal">bts</code> (bit test and set), <code class="literal">btc</code> (bit test and complement), and <code class="literal">btr</code> (bit test and reset). We've used these instructions to manipulate bits in HLA character-set variables; we can also use them to manipulate bits in general. The <code class="literal">bt</code><em class="replaceable"><code>x</code></em> instructions allow the following syntactical forms:</p><a id="I_programlisting10_d1e50346"/><pre class="programlisting">bt<em class="replaceable"><code>x</code></em>( <em class="replaceable"><code>BitNumber</code></em>, <em class="replaceable"><code>BitsToTest</code></em> );
bt<em class="replaceable"><code>x</code></em>( <em class="replaceable"><code>reg16</code></em>, <em class="replaceable"><code>reg16</code></em> );
bt<em class="replaceable"><code>x</code></em>( <em class="replaceable"><code>reg32</code></em>, <em class="replaceable"><code>reg32</code></em> );
bt<em class="replaceable"><code>x</code></em>( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>reg16</code></em> );
bt<em class="replaceable"><code>x</code></em>( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>reg32</code></em> );
bt<em class="replaceable"><code>x</code></em>( <em class="replaceable"><code>reg16</code></em>, <em class="replaceable"><code>mem16</code></em> );
bt<em class="replaceable"><code>x</code></em>( <em class="replaceable"><code>reg32</code></em>, <em class="replaceable"><code>mem32</code></em> );
bt<em class="replaceable"><code>x</code></em>( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>mem16</code></em> );
bt<em class="replaceable"><code>x</code></em>( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>mem32</code></em> );</pre><p>The <code class="literal">btx</code> instruction's first operand is a bit number that specifies which bit to check in the second operand. If the second operand is a register, then the first operand must contain a value between 0 and the size of the register (in bits) minus 1; because the 80x86's largest registers are 32 bits, this value has the maximum value 31 (for 32-bit registers). If the second operand is a memory location, then the bit count is not limited to values in the range 0..31. If the first operand is a constant, it can be any 8-bit value in the range 0..255. If the first operand is a register, it has no limitation.</p><p>The <code class="literal">bt</code> instruction copies the specified bit from the second operand into the carry flag. For example, the <code class="literal">bt( 8, eax );</code> instruction copies bit 8 of the EAX register into the carry flag. You can test the carry flag after this instruction to determine whether bit 8 was set or clear in EAX.</p><p>The <code class="literal">bts</code>, <code class="literal">btc</code>, and <code class="literal">btr</code> instructions manipulate the bit they test while they are testing it. These instructions may be slow (depending on the processor you're using), and you should avoid them if performance is your primary concern and you're using an older CPU. If performance (versus convenience) is an issue, you should always try two different algorithms—one that uses these instructions, one that uses <code class="literal">and</code>/<code class="literal">or</code> instructions—and measure the performance difference; then choose the best of the two approaches.</p><p>The shift and rotate instructions are another group of instructions you can use to manipulate and test bits. These instructions move the H.O. (left shift/rotate) or L.O. (right shift/rotate) bits into the carry flag. Therefore, you can test the carry flag after you execute one of these instructions to determine the original setting of the operand's H.O. or L.O. bit. The shift and rotate instructions are invaluable for aligning bit strings and packing and unpacking data. <a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a> has several examples of this, and some earlier examples in this chapter also use the shift instructions for this purpose.<a class="indexterm" id="IDX-CHP-10-0071"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-1" id="ftn.CHP-10-FN-1">126</a>] </sup>Serial communications chips and other communications hardware that use parity for error checking normally compute the parity in hardware; you don't have to use software for this purpose.</p></div></div></div>
<div class="sect1" title="10.3 The Carry Flag as a Bit Accumulator"><div class="titlepage"><div><div><h1 class="title"><a id="the_carry_flag_as_a_bit_accumulator"/>10.3 The Carry Flag as a Bit Accumulator</h1></div></div></div><p>The <code class="literal">bt</code><em class="replaceable"><code>x</code></em>, shift, and rotate instructions set or clear the carry flag depending on the operation and selected bit. Because these instructions place their "bit result" in the carry flag, it is often convenient to think of the carry flag as a 1-bit register or accumulator for bit operations. In this section we will explore some of the operations possible with this bit result in the carry flag.<a class="indexterm" id="IDX-CHP-10-0072"/><a class="indexterm" id="IDX-CHP-10-0073"/><a class="indexterm" id="IDX-CHP-10-0074"/><a class="indexterm" id="IDX-CHP-10-0075"/><a class="indexterm" id="IDX-CHP-10-0076"/><a class="indexterm" id="IDX-CHP-10-0077"/><a class="indexterm" id="IDX-CHP-10-0078"/><a class="indexterm" id="IDX-CHP-10-0079"/><a class="indexterm" id="IDX-CHP-10-0080"/><a class="indexterm" id="IDX-CHP-10-0081"/><a class="indexterm" id="IDX-CHP-10-0082"/><a class="indexterm" id="IDX-CHP-10-0083"/><a class="indexterm" id="IDX-CHP-10-0084"/><a class="indexterm" id="IDX-CHP-10-0085"/><a class="indexterm" id="IDX-CHP-10-0086"/><a class="indexterm" id="IDX-CHP-10-0087"/><a class="indexterm" id="IDX-CHP-10-0088"/><a class="indexterm" id="IDX-CHP-10-0089"/></p><p>Instructions that will be useful for manipulating bit results in the carry flag are those that use the carry flag as some sort of input value. The following is a sampling of such instructions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">adc</code>, <code class="literal">sbb</code><a class="indexterm" id="IDX-CHP-10-0090"/></p></li><li class="listitem"><p><code class="literal">rcl</code>, <code class="literal">rcr</code><a class="indexterm" id="IDX-CHP-10-0091"/><a class="indexterm" id="IDX-CHP-10-0092"/></p></li><li class="listitem"><p><code class="literal">cmc</code> (We'll throw in <code class="literal">clc</code> and <code class="literal">stc</code> even though they don't use the carry as input.)<a class="indexterm" id="IDX-CHP-10-0093"/></p></li><li class="listitem"><p><code class="literal">jc</code>, <code class="literal">jnc</code><a class="indexterm" id="IDX-CHP-10-0094"/><a class="indexterm" id="IDX-CHP-10-0095"/><a class="indexterm" id="IDX-CHP-10-0096"/><a class="indexterm" id="IDX-CHP-10-0097"/></p></li><li class="listitem"><p><code class="literal">setc</code>, <code class="literal">setnc</code><a class="indexterm" id="IDX-CHP-10-0098"/><a class="indexterm" id="IDX-CHP-10-0099"/></p></li></ul></div><p>The <code class="literal">adc</code> and <code class="literal">sbb</code> instructions add or subtract their operands along with the carry flag. So if you've computed some bit result into the carry flag, you can figure that result into an addition or subtraction using these instructions.</p><p>To merge a bit result into the carry flag, you most often use the rotate through carry instructions (<code class="literal">rcl</code> and <code class="literal">rcr</code>). These instructions move the carry flag into the L.O. or H.O. bits of their destination operand. These instructions are very useful for packing a set of bit results into a byte, word, or double-word value.</p><p>The <code class="literal">cmc</code> (complement carry) instruction lets you easily invert the result of some bit operation. You can also use the <code class="literal">clc</code> and <code class="literal">stc</code> instructions to initialize the carry flag prior to some string of bit operations involving the carry flag.</p><p>Instructions that test the carry flag are going to be very popular after a calculation that leaves a bit result in the carry flag. The <code class="literal">jc</code>, <code class="literal">jnc</code>, <code class="literal">setc</code>, and <code class="literal">setnc</code> instructions are quite useful here. You can also use the HLA <code class="literal">@c</code> and <code class="literal">@nc</code> operands in a boolean expression to test the result in the carry flag.</p><p>If you have a sequence of bit calculations and you would like to test to see if the calculations produce a specific set of 1-bit results, the easiest way to do this is to clear a register or memory location and use the <code class="literal">rcl</code> or <code class="literal">rcr</code> instruction to shift each result into that location. Once the bit operations are complete, then you can compare the register or memory location holding the result against a constant value. If you want to test a sequence of results involving conjunction and disjunction (that is, strings of results involving <code class="literal">and</code>s and <code class="literal">or</code>s), then you could use the <code class="literal">setc</code> and <code class="literal">setnc</code> instruction to set a register to 0 or 1 and then use the <code class="literal">and</code>/<code class="literal">or</code> instructions to merge the results.</p></div>
<div class="sect1" title="10.4 Packing and Unpacking Bit Strings"><div class="titlepage"><div><div><h1 class="title"><a id="packing_and_unpacking_bit_strings"/>10.4 Packing and Unpacking Bit Strings</h1></div></div></div><p>A common bit operation is inserting a bit string into an operand or extracting a bit string from an operand. <a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a> provided simple examples of packing and unpacking such data; now it is time to formally describe how to do this.</p><p>For our purposes we will assume that we're dealing with bit strings—that is, a contiguous sequence of bits. In <a class="xref" href="ch10s11.html" title="10.11 Extracting Bit Strings">10.11 Extracting Bit Strings</a> we'll look at how to extract and insert bit sets. Another simplification we'll make is that the bit string completely fits within a byte, word, or double-word operand. Large bit strings that cross object boundaries require additional processing; a discussion of bit strings that cross double-word boundaries appears later in this section.</p><p>A bit string has two attributes that we must consider when packing and unpacking that bit string: a starting bit position and a length. The starting bit position is the bit number of the L.O. bit of the string in the larger operand. The length is the number of bits in the operand. To insert (pack) data into a destination operand, you start with a bit string of the appropriate length that is right justified (that is, starts in bit position 0) and is zero extended to 8, 16, or 32 bits. The task is to insert this data at the appropriate starting position in some other operand that is 8-, 16-, or 32-bits wide. There is no guarantee that the destination bit positions contain any particular value.</p><p>The first two steps (which can occur in any order) are to clear out the corresponding bits in the destination operand and to shift (a copy of) the bit string so that the L.O. bit begins at the appropriate bit position. The third step is to <code class="literal">or</code> the shifted result with the destination operand. This inserts the bit string into the destination operand (see <a class="xref" href="ch10s04.html#inserting_a_bit_string_into_a_destinatio" title="Figure 10-3. Inserting a bit string into a destination operand">Figure 10-3</a>).</p><div class="figure"><a id="inserting_a_bit_string_into_a_destinatio"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e50735"/><img alt="Inserting a bit string into a destination operand" src="tagoreillycom20100401nostarchimages578073.png"/></div></div><p class="title">Figure 10-3. Inserting a bit string into a destination operand</p></div><p>It takes only three instructions to insert a bit string of known length into a destination operand. The following three instructions demonstrate how to handle the insertion operation in <a class="xref" href="ch10s04.html#inserting_a_bit_string_into_a_destinatio" title="Figure 10-3. Inserting a bit string into a destination operand">Figure 10-3</a>. These instructions assume that the source operand is in BX and the destination operand is AX:</p><a id="I_programlisting10_d1e50744"/><pre class="programlisting">shl( 5, bx );
     and( %111111000011111, ax );
     or( bx, ax );</pre><p>If the length and the starting position aren't known when you're writing the program (that is, you have to calculate them at runtime), then bit-string insertion is a little more difficult. However, with the use of a lookup table it's still an easy operation to accomplish. Let's assume that we have two 8-bit values: a starting bit position for the field we're inserting and a nonzero 8-bit length value. Also assume that the source operand is in EBX and the destination operand is in EAX. The code to insert one operand into another could take the following form:</p><a id="I_programlisting10_d1e50748"/><pre class="programlisting">readonly
     // The index into the following table specifies the length
     // of the bit string at each position:

     MaskByLen: dword[ 33 ] :=
           [
               0,  $1,  $3,  $7, $f, $1f, $3f, $7f,
               $ff, $1ff, $3ff, $7ff, $fff, $1fff, $3fff, $7fff, $ffff,
               $1_ffff, $3_ffff, $7_ffff, $f_ffff,
               $1f_ffff, $3f_ffff, $7f_ffff, $ff_ffff,
               $1ff_ffff, $3ff_ffff, $7ff_ffff, $fff_ffff,
               $1fff_ffff, $3fff_ffff, $7fff_ffff, $ffff_ffff
          ];
               .
               .
               .
     movzx( <em class="replaceable"><code>Length</code></em>, edx );
     mov( MaskByLen[ edx*4 ], edx );
     mov( <em class="replaceable"><code>StartingPosition</code></em>, cl );
     shl( cl, edx );
     not( edx );
     shl( cl, ebx );
     and( edx, eax );
     or( ebx, eax );</pre><p>Each entry in the <code class="literal">MaskByLen</code> table contains the number of 1 bits specified by the index into the table. Using the <em class="replaceable"><code>Length</code></em> value as an index into this table fetches a value that has as many 1 bits as the <em class="replaceable"><code>Length</code></em> value. The code above fetches an appropriate mask, shifts it to the left so that the L.O. bit of this run of ones matches the starting position of the field into which we want to insert the data, and then inverts the mask and uses the inverted value to clear the appropriate bits in the destination operand.</p><p>Extracting a bit string from a larger operand is just as easy as inserting a bit string into some larger operand. All you have to do is mask out the unwanted bits and then shift the result until the L.O. bit of the bit string is in bit 0 of the destination operand. For example, to extract the 4-bit field starting at bit position 5 in EBX and leave the result in EAX, you could use the following code:<a class="indexterm" id="IDX-CHP-10-0100"/><a class="indexterm" id="IDX-CHP-10-0101"/><a class="indexterm" id="IDX-CHP-10-0102"/><a class="indexterm" id="IDX-CHP-10-0103"/></p><a id="I_programlisting10_d1e50790"/><pre class="programlisting">mov( ebx, eax );            // Copy data to destination.
     and( %1_1110_0000, eax );   // Strip unwanted bits.
     shr( 5, eax );              // Right justify to bit position 0.</pre><p>If you do not know the bit string's length and starting position when you're writing the program, you can still extract the desired bit string. The code is very similar to insertion (though a little simpler). Assuming you have the <em class="replaceable"><code>Length</code></em> and <em class="replaceable"><code>StartingPosition</code></em> values we used when inserting a bit string, you can extract the corresponding bit string using the following code (assuming source = EBX and dest = EAX):</p><a id="I_programlisting10_d1e50800"/><pre class="programlisting">movzx( <em class="replaceable"><code>Length</code></em>, edx );
     mov( MaskByLen[ edx*4 ], edx );
     mov( <em class="replaceable"><code>StartingPosition</code></em>, cl );
     mov( ebx, eax );
     shr( cl, eax );
     and( edx, eax );</pre><p>The examples up to this point all assume that the bit string appears completely within a double-word (or smaller) object. This will always be the case if the bit string is less than or equal to 32 bits in length. However, if the length of the bit string plus its starting position (modulo 8) within an object is greater than 32, then the bit string will cross a double-word boundary within the object. Extracting such bit strings requires up to three operations: one operation to extract the start of the bit string (up to the first double-word boundary), an operation that copies whole double words (assuming the bit string is so long that it consumes several double words), and a final operation that copies leftover bits in the last double word at the end of the bit string. The actual implementation of this operation is left as an exercise for the reader.</p></div>
<div class="sect1" title="10.5 Coalescing Bit Sets and Distributing Bit Strings"><div class="titlepage"><div><div><h1 class="title"><a id="coalescing_bit_sets_and_distributing_bit"/>10.5 Coalescing Bit Sets and Distributing Bit Strings</h1></div></div></div><p>Inserting and extracting bit sets is little different than inserting and extract bit strings if the "shape" of the bit set you're inserting (or resulting bit set you're extracting) is the same as the bit set in the main object. The shape of a bit set is the distribution of the bits in the set, ignoring the starting bit position of the set. So a bit set that includes bits 0, 4, 5, 6, and 7 has the same shape as a bit set that includes bits 12, 16, 17, 18, and 19 because the distribution of the bits is the same. The code to insert or extract this bit set is nearly identical to that of the previous section; the only difference is the mask value you use. For example, to insert this bit set starting at bit 0 in EAX into the corresponding bit set starting at position 12 in EBX, you could use the following code:</p><a id="I_programlisting10_d1e50815"/><pre class="programlisting">and( !%1111_0001_0000_0000_0000, ebx );// Mask out destination bits.
 shl( 12, eax );                        // Move source bits into position.
 or( eax, ebx );                        // Merge the bit set into ebx.</pre><p>However, suppose you have 5 bits in bit positions 0 through 4 in EAX and you want to merge them into bits 12, 16, 17, 18, and 19 in EBX. Somehow you have to distribute the bits in EAX prior to logically <code class="literal">or</code>ing the values into EBX. Given the fact that this particular bit set has only two runs of 1 bits, the process is somewhat simplified. The following code achieves this in a somewhat sneaky fashion:</p><a id="I_programlisting10_d1e50822"/><pre class="programlisting">and( !%1111_0001_0000_0000_0000, ebx );
 shl( 3, eax );   // Spread out the bits: 1-4 goes to 4-7 and 0 to 3.
 btr( 3, eax );   // Bit 3-&gt;carry and then clear bit 3.
 rcl( 12, eax );  // Shift in carry and put bits into final position.
 or( eax, ebx );  // Merge the bit set into ebx.</pre><p>This trick with the <code class="literal">btr</code> (bit test and reset) instruction worked well because we had only 1 bit out of place in the original source operand. Alas, had the bits all been in the wrong location relative to one another, this scheme might not have worked quite as well. We'll see a more general solution in just a moment.</p><p>Extracting this bit set and collecting ("coalescing") the bits into a bit string is not quite as easy. However, there are still some sneaky tricks we can pull. Consider the following code that extracts the bit set from EBX and places the result into bits 0..4 of EAX:</p><a id="I_programlisting10_d1e50831"/><pre class="programlisting">mov( ebx, eax );
 and( %1111_0001_0000_0000_0000, eax );  // Strip unwanted bits.
 shr( 5, eax );                          // Put bit 12 into bit 7, etc.
 shr( 3, ah );                           // Move bits 11..14 to 8..11.
 shr( 7, eax );                          // Move down to bit 0.</pre><p>This code moves (original) bit 12 into bit position 7, the H.O. bit of AL. At the same time it moves bits 16..19 down to bits 11..14 (bits 3..6 of AH). Then the code shifts bits 3..6 in AH down to bit 0. This positions the H.O. bits of the bit set so that they are adjacent to the bit left in AL. Finally, the code shifts all the bits down to bit 0. Again, this is not a general solution, but it shows a clever way to attack this problem if you think about it carefully.</p><p>The problem with the coalescing and distribution algorithms above is that they are not general. They apply only to their specific bit sets. Usually specific solutions will provide the most efficient solution. A generalized solution (perhaps one that lets you specify a mask, and the code distributes or coalesces the bits accordingly) is going to be a bit more difficult. The following code demonstrates how to distribute the bits in a bit string according to the values in a bit mask:</p><a id="I_programlisting10_d1e50837"/><pre class="programlisting">// eax- Originally contains some value into which we
//        insert bits from ebx.
// ebx- L.O. bits contain the values to insert into eax.
// edx- Bitmap with ones indicating the bit positions in eax to insert.
// cl-  Scratchpad register.

          mov( 32, cl );   // Count number of bits we rotate.
          jmp DistLoop;

CopyToEAX:rcr( 1, ebx );   // Don't use SHR here, must preserve Z-flag.
          rcr( 1, eax );
          jz  Done;
DistLoop: dec( cl );
          shr( 1, edx );
          jc CopyToEAX;
          ror( 1, eax );   // Keep current bit in eax.
          jnz DistLoop;

Done:     ror( cl, eax );  // Reposition remaining bits.</pre><p>In the code above, if we load EDX with %1100_1001, then this code will copy bits 0..3 to bits 0, 3, 6, and 7 in EAX. Notice the short-circuit test that checks to see if we've exhausted the values in EDX (by checking for a 0 in EDX). Note that the rotate instructions do not affect the zero flag but the shift instructions do. Hence the <code class="literal">shr</code> instruction above will set the zero flag when there are no more bits to distribute (when EDX becomes 0).</p><p>The general algorithm for coalescing bits is a tad more efficient than distribution. Here's the code that will extract bits from EBX via the bit mask in EDX and leave the result in EAX:</p><a id="I_programlisting10_d1e50847"/><pre class="programlisting">// eax- Destination register.
// ebx- Source register.
// edx- Bitmap with ones representing bits to copy to eax.
// ebx and edx are not preserved.
     sub( eax, eax );  // Clear destination register.
     jmp ShiftLoop;

ShiftInEAX:
     rcl( 1, ebx );   // Up here we need to copy a bit from
     rcl( 1, eax );   // ebx to eax.
ShiftLoop:
     shl( 1, edx );   // Check mask to see if we need to copy a bit.
     jc ShiftInEAX;   // If carry set, go copy the bit.
     rcl( 1, ebx );   // Current bit is uninteresting, skip it.
     jnz ShiftLoop;   // Repeat as long as there are bits in edx.</pre><p>This sequence takes advantage of a sneaky trait of the shift and rotate instructions: the shift instructions affect the zero flag, whereas the rotate instructions do not. Therefore, the <code class="literal">shl( 1, edx );</code> instruction sets the zero flag when EDX becomes 0 (after the shift). If the carry flag was also set, the code will make one additional pass through the loop in order to shift a bit into EAX, but the next time the code shifts EDX 1 bit to the left, EDX is still 0 and so the carry will be clear. On this iteration, the code falls out of the loop.<a class="indexterm" id="IDX-CHP-10-0104"/><a class="indexterm" id="IDX-CHP-10-0105"/></p><p>Another way to coalesce bits is via table lookup. By grabbing a byte of data at a time (so your tables don't get too large), you can use that byte's value as an index into a lookup table that coalesces all the bits down to bit 0. Finally, you can merge the bits at the low end of each byte together. This might produce a more efficient coalescing algorithm in certain cases. The implementation is left to the reader.</p></div>
<div class="sect1" title="10.6 Packed Arrays of Bit Strings"><div class="titlepage"><div><div><h1 class="title"><a id="packed_arrays_of_bit_strings"/>10.6 Packed Arrays of Bit Strings</h1></div></div></div><p>Although it is far more efficient to create arrays whose elements have an integral number of bytes, it is quite possible to create arrays of elements whose size is not a multiple of 8 bits. The drawback is that calculating the "address" of an array element and manipulating that array element involves a lot of extra work. In this section we'll take a look at a few examples of packing and unpacking array elements in an array whose elements are an arbitrary number of bits long.<a class="indexterm" id="IDX-CHP-10-0106"/></p><p>Before proceeding, it's probably worthwhile to discuss why you would want to bother with arrays of bit objects. The answer is simple: space. If an object consumes only 3 bits, you can get 2.67 times as many elements into the same space if you pack the data rather than allocating a whole byte for each object. For very large arrays, this can be a substantial savings. Of course, the cost of this space savings is speed: You have to execute extra instructions to pack and unpack the data, thus slowing down access to the data.</p><p>The calculation for locating the bit offset of an array element in a large block of bits is almost identical to the standard array access; it is:</p><a id="I_programlisting10_d1e50880"/><pre class="programlisting"><em class="replaceable"><code>Element_Address_in_bits</code></em> =
        <em class="replaceable"><code>Base_address_in_bits</code></em> + <em class="replaceable"><code>index</code></em> * <em class="replaceable"><code>element_size_in_bits</code></em></pre><p>Once you calculate the element's address in bits, you need to convert it to a byte address (because we have to use byte addresses when accessing memory) and extract the specified element. Because the base address of an array element (almost) always starts on a byte boundary, we can use the following equations to simplify this task:</p><a id="I_programlisting10_d1e50894"/><pre class="programlisting"><em class="replaceable"><code>Byte_of_1st_bit</code></em> =
    <em class="replaceable"><code>Base_Address</code></em> + (<em class="replaceable"><code>index</code></em> * <em class="replaceable"><code>element_size_in_bits</code></em> )/8

<em class="replaceable"><code>Offset_to_1st_bit</code></em> =
    (<em class="replaceable"><code>index</code></em> * <em class="replaceable"><code>element_size_in_bits</code></em>) % 8 (note "%" = MOD)</pre><p>For example, suppose we have an array of 200 3-bit objects that we declare as follows:</p><a id="I_programlisting10_d1e50919"/><pre class="programlisting">static
     AO3Bobjects: byte[ int32((200*3)/8 + 2) ];  // "+2" handles
                                                 // truncation.</pre><p>The constant expression in the dimension above reserves space for enough bytes to hold 600 bits (200 elements, each 3 bits long). As the comment notes, the expression adds 2 extra bytes at the end to ensure we don't lose any odd bits (that won't happen in this example because 600 is evenly divisible by 8, but in general you can't count on this; one extra byte usually won't hurt things) and also to allow us to access 1 byte beyond the end of the array (when storing data to the array).</p><p>Now suppose you want to access the <span class="emphasis"><em>i</em></span>th 3-bit element of this array. You can extract these bits by using the following code:</p><a id="I_programlisting10_d1e50929"/><pre class="programlisting">// Extract the ith group of 3 bits in AO3Bobjects
// and leave this value in eax.

    sub( ecx, ecx );         // Put i/8 remainder here.
    mov( i, eax );           // Get the index into the array.
    lea( eax, [eax+eax*2] ); // eax := eax * 3 (3 bits/element).
    shrd( 3, eax, ecx );     // eax/8 -&gt; eax and eax mod 8 -&gt; ecx
                             // (H.O. bits).
    shr( 3, eax );           // Remember, shrd doesn't modify eax.
    rol( 3, ecx );           // Put remainder into L.O. 3
                             // bits of ecx.

    // Okay, fetch the word containing the 3 bits we want to
    // extract. We have to fetch a word because the last bit or two
    // could wind up crossing the byte boundary (i.e., bit offset 6
    // and 7 in the byte).

    mov( (type word AO3Bobjects[eax]), ax );
    shr( cl, ax );           // Move bits down to bit 0.
    and( %111, eax );        // Remove the other bits.</pre><p>Inserting an element into the array is a bit more difficult. In addition to computing the base address and bit offset of the array element, you also have to create a mask to clear out the bits in the destination where you're going to insert the new data. The following code inserts the L.O. 3 bits of EAX into the <span class="emphasis"><em>i</em></span>th element of the <code class="literal">AO3Bobjects</code> array.</p><a id="I_programlisting10_d1e50939"/><pre class="programlisting">// Insert the L.O. 3 bits of ax into the ith element
// of AO3Bobjects:

readonly
     Masks:
        word[8] :=
        [
            !%0111,             !%0011_1000,
            !%0001_1100_0000,   !%1110,
            !%0111_0000,        !%0011_1000_0000,
            !%0001_1100,        !%1110_0000
        ];
                    .
                    .
                    .

        mov( i, ebx );              // Get the index into the array.
        mov( ebx, ecx );            // Use L.O. 3 bits as index
        and( %111, ecx );           // into Masks table.
        mov( Masks[ecx*2], dx );    // Get bit mask.

        // Convert index into the array into a bit index.
        // To do this, multiply the index by 3:

        lea( ebx, [ebx+ebx*2]);

        // Divide by 8 to get the byte index into ebx
        // and the bit index (the remainder) into ecx:

        shrd( 3,ebx, ecx );
        shr( 3, ebx );
        rol( 3, ecx );

        // Grab the bits and clear those we're inserting.

        and( (type word AO3Bobjects[ ebx ]), dx );

        // Put our 3 bits in their proper location.

        shl( cl, ax );

        // Merge bits into destination.

        or( ax, dx );

        // Store back into memory.

        mov( dx, (type word AO3Bobjects[ ebx ]) );</pre><p>Notice the use of a lookup table to generate the masks needed to clear out the appropriate position in the array. Each element of this array contains all ones except for three zeros in the position we need to clear for a given bit offset (note the use of the <code class="literal">!</code> operator to invert the constants in the table).<a class="indexterm" id="IDX-CHP-10-0107"/><a class="indexterm" id="IDX-CHP-10-0108"/></p></div>
<div class="sect1" title="10.7 Searching for a Bit"><div class="titlepage"><div><div><h1 class="title"><a id="searching_for_a_bit"/>10.7 Searching for a Bit</h1></div></div></div><p>A very common bit operation is to locate the end of some run of bits. A special case of this operation is to locate the first (or last) set or clear bit in a 16- or 32-bit value. In this section we'll explore ways to accomplish this.</p><p>Before describing how to search for the first or last bit of a given value, perhaps it's wise to discuss exactly what the terms <span class="emphasis"><em>first</em></span> and <span class="emphasis"><em>last</em></span> mean in this context. The term <span class="emphasis"><em>first set bit</em></span> means the first bit in a value, scanning from bit 0 toward the high-order bit, which contains a 1. A similar definition exists for the <span class="emphasis"><em>first clear bit</em></span>. The <span class="emphasis"><em>last set bit</em></span> is the first bit in a value, scanning from the high-order bit toward bit 0, which contains a 1. A similar definition exists for the <span class="emphasis"><em>last clear bit</em></span>.<a class="indexterm" id="IDX-CHP-10-0109"/><a class="indexterm" id="IDX-CHP-10-0110"/><a class="indexterm" id="IDX-CHP-10-0111"/><a class="indexterm" id="IDX-CHP-10-0112"/><a class="indexterm" id="IDX-CHP-10-0113"/><a class="indexterm" id="IDX-CHP-10-0114"/><a class="indexterm" id="IDX-CHP-10-0115"/><a class="indexterm" id="IDX-CHP-10-0116"/></p><p>One obvious way to scan for the first or last bit is to use a shift instruction in a loop and count the number of iterations before you shift out a 1 (or 0) into the carry flag. The number of iterations specifies the position. Here's some sample code that checks for the first set bit in EAX and returns that bit position in ECX:</p><a id="I_programlisting10_d1e51010"/><pre class="programlisting">mov( −32, ecx );  // Count off the bit positions in ecx.
TstLp:    shr( 1, eax );    // Check to see if current bit
                            // position contains a 1.
          jc Done;          // Exit loop if it does.
          inc( ecx );       // Bump up our bit counter by 1.
          jnz TstLp;        // Exit if we execute this loop 32 times.

Done:     add( 32, cl );    // Adjust loop counter so it holds
                            // the bit position.

// At this point, ecx contains the bit position of the first set bit.
// ecx contains 32 if eax originally contained 0 (no set bits).</pre><p>The only thing tricky about this code is the fact that it runs the loop counter from −32 up to 0 rather than 32 down to 0. This makes it slightly easier to calculate the bit position once the loop terminates.</p><p>The drawback to this particular loop is that it's expensive. This loop repeats as many as 32 times depending on the original value in EAX. If the values you're checking often have lots of zeros in the L.O. bits of EAX, this code runs rather slowly.</p><p>Searching for the first (or last) set bit is such a common operation that Intel added a couple of instructions on the 80386 specifically to accelerate this process. These instructions are <code class="literal">bsf</code> (bit scan forward) and <code class="literal">bsr</code> (bit scan reverse). Their syntax is as follows:<a class="indexterm" id="IDX-CHP-10-0117"/></p><a id="I_programlisting10_d1e51029"/><pre class="programlisting">bsr( <em class="replaceable"><code>source</code></em>, <em class="replaceable"><code>destReg</code></em> );
          bsf( <em class="replaceable"><code>source</code></em>, <em class="replaceable"><code>destReg</code></em> );</pre><p>The source and destinations operands must be the same size, and they must both be 16- or 32-bit objects. The destination operand has to be a register. The source operand can be a register or a memory location.</p><p>The <code class="literal">bsf</code> instruction scans for the first set bit (starting from bit position 0) in the source operand. The <code class="literal">bsr</code> instruction scans for the last set bit in the source operand by scanning from the H.O. bit toward the L.O. bit. If these instructions find a bit that is set in the source operand, then they clear the zero flag and put the bit position into the destination register. If the source register contains 0 (that is, there are no set bits), then these instructions set the zero flag and leave an indeterminate value in the destination register. Note that you should test the zero flag immediately after the execution of these instructions to validate the destination register's value. Here's an example:</p><a id="I_programlisting10_d1e51054"/><pre class="programlisting">mov( <em class="replaceable"><code>SomeValue</code></em>, ebx );  // Value whose bits we want to check.
      bsf( ebx, eax );        // Put position of first set bit in eax.
      jz <em class="replaceable"><code>NoBitsSet</code></em>;           // Branch if <em class="replaceable"><code>SomeValue</code></em> contains 0.
      mov( eax, <em class="replaceable"><code>FirstBit</code></em> );   // Save location of first set bit.
                .
                .
                .</pre><p>You use the <code class="literal">bsr</code> instruction in an identical fashion except that it computes the bit position of the last set bit in an operand (that is, the first set bit it finds when scanning from the H.O. bit toward the L.O. bit).</p><p>The 80x86 CPUs do not provide instructions to locate the first bit containing a 0. However, you can easily scan for a 0 bit by first inverting the source operand (or a copy of the source operand if you must preserve the source operand's value) and then search for the first 1 bit; this corresponds to the first 0 bit in the original operand value.</p><p>The <code class="literal">bsf</code> and <code class="literal">bsr</code> instructions are very complex 80x86 instructions. Therefore, these instructions may be slower than other instructions. Indeed, in some circumstances it may be faster to locate the first set bit using discrete instructions. However, because the execution time of these instructions varies widely from CPU to CPU, you should test the performance of these instructions prior to using them in time-critical code.</p><p>Note that the <code class="literal">bsf</code> and <code class="literal">bsr</code> instructions do not affect the source operand. A common operation is to extract the first (or last) set bit you find in some operand. That is, you might want to clear the bit once you find it. If the source operand is a register (or you can easily move it into a register), then you can use the <code class="literal">btr</code> (or <code class="literal">btc</code>) instruction to clear the bit once you've found it. Here's some code that achieves this result:</p><a id="I_programlisting10_d1e51097"/><pre class="programlisting">bsf( eax, ecx );       // Locate first set bit in eax.
          if( @nz ) then         // If we found a bit, clear it.

               btr( ecx, eax );  // Clear the bit we just found.

          endif;</pre><p>At the end of this sequence, the zero flag indicates whether we found a bit (note that <code class="literal">btr</code> does not affect the zero flag). Alternately, you could add an <code class="literal">else</code> section to the <code class="literal">if</code> statement above that handles the case when the source operand (EAX) contains 0 at the beginning of this instruction sequence.</p><p>Because the <code class="literal">bsf</code> and <code class="literal">bsr</code> instructions support only 16- and 32-bit operands, you will have to compute the first bit position of an 8-bit operand a little differently. There are a couple of reasonable approaches. First, of course, you can usually zero extend an 8-bit operand to 16 or 32 bits and then use the <code class="literal">bsf</code> or <code class="literal">bsr</code> instruction on this operand. Another alternative is to create a lookup table where each entry in the table contains the number of bits in the value you use as an index into the table; then you can use the <code class="literal">xlat</code> instruction to "compute" the first bit position in the value (note that you will have to handle the value 0 as a special case). Another solution is to use the shift algorithm appearing at the beginning of this section; for an 8-bit operand, this is not an entirely inefficient solution.</p><p>One interesting use of the <code class="literal">bsf</code> and <code class="literal">bsr</code> instructions is to fill in a character set with all the values from the lowest valued character in the set through the highest valued character. For example, suppose a character set contains the values <code class="literal">{'A', 'M', 'a'..'n', 'z'}</code>; if we filled in the gaps in this character set we would have the values <code class="literal">{'A'..'z'}</code>. To compute this new set we can use <code class="literal">bsf</code> to determine the ASCII code of the first character in the set and <code class="literal">bsr</code> to determine the ASCII code of the last character in the set. After doing this, we can feed those two ASCII codes to the HLA Standard Library <code class="literal">cs.rangeChar</code> function to compute the new set.</p><p>You can also use the <code class="literal">bsf</code> and <code class="literal">bsr</code> instructions to determine the size of a run of bits, assuming that you have a single run of bits in your operand. Simply locate the first and last bits in the run (as above) and then compute the difference (plus 1) of the two values. Of course, this scheme is valid only if there are no intervening zeros between the first and last set bits in the value.</p></div>
<div class="sect1" title="10.8 Counting Bits"><div class="titlepage"><div><div><h1 class="title"><a id="counting_bits"/>10.8 Counting Bits</h1></div></div></div><p>The last example in the previous section demonstrates a specific case of a very general problem: counting bits. Unfortunately, that example has a severe limitation: It only counts a single run of 1 bits appearing in the source operand. This section discusses a more general solution to this problem.<a class="indexterm" id="IDX-CHP-10-0118"/><a class="indexterm" id="IDX-CHP-10-0119"/></p><p>Hardly a week goes by that someone doesn't ask on one of the Internet newsgroups how to count the number of bits in a register operand. This is a common request, undoubtedly, because many assembly language course instructors assign this task as a project to their students as a way to teach them about the shift and rotate instructions. Undoubtedly, the solution these instructors expect is something like the following:</p><a id="I_programlisting10_d1e51175"/><pre class="programlisting">// BitCount1:
//
// Counts the bits in the eax register, returning the count in ebx.

          mov( 32, cl );   // Count the 32 bits in eax.
          sub( ebx, ebx ); // Accumulate the count here.
CntLoop:  shr( 1, eax );   // Shift next bit out of eax and into Carry.
          adc( 0, bl );    // Add the carry into the ebx register.
          dec( cl );       // Repeat 32 times.
          jnz CntLoop;</pre><p>The "trick" worth noting here is that this code uses the <code class="literal">adc</code> instruction to add the value of the carry flag into the BL register. Because the count is going to be less than 32, the result will fit comfortably into BL.</p><p>Tricky code or not, this instruction sequence is not particularly fast. As you can tell with just a small amount of analysis, the loop above always executes 32 times, so this code sequence executes 130 instructions (4 instructions per iteration plus 2 extra instructions). You might ask if there is a more efficient solution; the answer is yes. The following code, taken from the AMD Athlon optimization guide, provides a faster solution (see the comments for a description of the algorithm):</p><a id="I_programlisting10_d1e51184"/><pre class="programlisting">// bitCount
     //
     //  Counts the number of "1" bits in a dword value.
     //  This function returns the dword count value in eax.

     procedure bitCount( BitsToCnt:dword ); @nodisplay;

     const
          EveryOtherBit        := $5555_5555;
          EveryAlternatePair   := $3333_3333;
          EvenNibbles          := $0f0f_0f0f;

     begin bitCount;

          push( edx );
          mov( BitsToCnt, eax );
          mov( eax, edx );

          // Compute sum of each pair of bits
          // in eax. The algorithm treats
          // each pair of bits in eax as a
          // 2-bit number and calculates the
          // number of bits as follows (description
          // is for bits 0 and 1, it generalizes
          // to each pair):
          //
          // edx =   Bit1 Bit0
          // eax = 0 Bit1
          //
          // edx-eax =   00 if both bits were 0.
          // 01 if Bit0=1 and Bit1=0.
          // 01 if Bit0=0 and Bit1=1.
          // 10 if Bit0=1 and Bit1=1.
          //
          // Note that the result is left in edx.

          shr( 1, eax );
          and( EveryOtherBit, eax );
          sub( eax, edx );

          // Now sum up the groups of 2 bits to
          // produces sums of 4 bits. This works
          // as follows:
          //
          // edx = bits 2,3, 6,7, 10,11, 14,15, ..., 30,31
          // in bit positions 0,1, 4,5, ..., 28,29 with
          // zeros in the other positions.
          //
          // eax = bits 0,1, 4,5, 8,9, ... 28,29 with zeros
          // in the other positions.
          //
          // edx+eax produces the sums of these pairs of bits.

          // The sums consume bits 0,1,2, 4,5,6, 8,9,10, ... 28,29,30
          // in eax with the remaining bits all containing 0.

          mov( edx, eax );
          shr( 2, edx );
          and( EveryAlternatePair, eax );
          and( EveryAlternatePair, edx );
          add( edx, eax );

          // Now compute the sums of the even and odd nibbles in the
          // number. Because bits 3, 7, 11, etc. in eax all contain
          // 0 from the above calculation, we don't need to AND
          // anything first, just shift and add the two values.
          // This computes the sum of the bits in the 4 bytes
          // as four separate values in eax (al contains number of
          // bits in original al, ah contains number of bits in
          // original ah, etc.)

          mov( eax, edx );
          shr( 4, eax );
          add( edx, eax );
          and( EvenNibbles, eax );

          // Now for the tricky part.
          // We want to compute the sum of the 4 bytes
          // and return the result in eax. The following
          // multiplication achieves this. It works
          // as follows:
          // (1) the $01 component leaves bits 24..31
          //     in bits 24..31.
          //
          // (2) the $100 component adds bits 17..23
          //     into bits 24..31.
          //
          // (3) the $1_0000 component adds bits 8..15
          //     into bits 24..31.
          //
          // (4) the $1000_0000 component adds bits 0..7
          //     into bits 24..31.
          //
          // Bits 0..23 are filled with garbage, but bits
          // 24..31 contain the actual sum of the bits
          // in eax's original value. The shr instruction
          // moves this value into bits 0..7 and zeros
          // out the H.O. bits of eax.

          intmul( $0101_0101, eax );
          shr( 24, eax );

          pop( edx );

     end bitCount;</pre></div>
<div class="sect1" title="10.9 Reversing a Bit String"><div class="titlepage"><div><div><h1 class="title"><a id="reversing_a_bit_string"/>10.9 Reversing a Bit String</h1></div></div></div><p>Another common programming project instructors assign, and a useful function in its own right, is a program that reverses the bits in an operand. That is, it swaps the L.O. bit with the H.O. bit, bit 1 with the next-to-H.O. bit, and so on. The typical solution an instructor probably expects for this assignment is the following:<a class="indexterm" id="IDX-CHP-10-0120"/><a class="indexterm" id="IDX-CHP-10-0121"/></p><a id="I_programlisting10_d1e51201"/><pre class="programlisting">// Reverse the 32-bits in eax, leaving the result in ebx:

               mov( 32, cl );
RvsLoop:       shr( 1, eax );  // Move current bit in eax to
                               // the carry flag.
               rcl( 1, ebx );  // Shift the bit back into
                               // ebx, backwards.
               dec( cl );
               jnz RvsLoop;</pre><p>As with the previous examples, this code suffers from the fact that it repeats the loop 32 times, for a grand total of 129 instructions. By unrolling the loop you can get it down to 64 instructions, but this is still somewhat expensive.</p><p>As usual, the best solution to an optimization problem is often a better algorithm rather than attempting to tweak your code by trying to choose faster instructions to speed up some code. However, a little intelligence goes a long way when manipulating bits. In the last section, for example, we were able to speed up counting the bits in a string by substituting a more complex algorithm for the simplistic "shift and count" algorithm. In the example above, we are once again faced with a very simple algorithm with a loop that repeats for 1 bit in each number. The question is "Can we discover an algorithm that doesn't execute 129 instructions to reverse the bits in a 32-bit register?" The answer is yes, and the trick is to do as much work as possible in parallel.</p><p>Suppose that all we wanted to do was swap the even and odd bits in a 32-bit value. We can easily swap the even and odd bits in EAX using the following code:</p><a id="I_programlisting10_d1e51209"/><pre class="programlisting">mov( eax, edx );         // Make a copy of the odd bits.
     shr( 1, eax );           // Move even bits to the odd positions.
     and( $5555_5555, edx );  // Isolate the odd bits.
     and( $5555_5555, eax );  // Isolate the even bits.
     shl( 1, edx );           // Move odd bits to even positions.
     or( edx, eax );          // Merge the bits and complete the swap.</pre><p>Of course, swapping the even and odd bits, while somewhat interesting, does not solve our larger problem of reversing all the bits in the number. But it does take us part of the way there. For example, if after executing the preceding code sequence you swap adjacent pairs of bits, you've managed to swap the bits in all the nibbles in the 32-bit value. Swapping adjacent pairs of bits is done in a manner very similar to the above; the code is:</p><a id="I_programlisting10_d1e51213"/><pre class="programlisting">mov( eax, edx );  // Make a copy of the odd-numbered bit pairs.
     shr( 2, eax );    // Move the even bit pairs to the odd position.
     and( $3333_3333, edx ); // Isolate the odd pairs.
     and( $3333_3333, eax ); // Isolate the even pairs.
     shl( 2, edx );    // Move the odd pairs to the even positions.
     or( edx, eax );   // Merge the bits and complete the swap.</pre><p>After completing the preceding sequence, you swap the adjacent nibbles in the 32-bit register. Again, the only difference is the bit mask and the length of the shifts. Here's the code:</p><a id="I_programlisting10_d1e51217"/><pre class="programlisting">mov( eax, edx );  // Make a copy of the odd-numbered nibbles.
     shr( 4, eax );    // Move the even nibbles to the odd position.
     and( $0f0f_0f0f, edx );  // Isolate the odd nibbles.
     and( $0f0f_0f0f, eax );  // Isolate the even nibbles.
     shl( 4, edx );    // Move the odd pairs to the even positions.
     or( edx, eax );   // Merge the bits and complete the swap.</pre><p>You can probably see the pattern developing and can figure out that in the next two steps you have to swap the bytes and then the words in this object. You can use code like the above, but there is a better way: Use the <code class="literal">bswap</code> instruction. The <code class="literal">bswap</code> (byte swap) instruction uses the following syntax:</p><a id="I_programlisting10_d1e51228"/><pre class="programlisting">bswap( <em class="replaceable"><code>reg32</code></em> );</pre><p>This instruction swaps bytes 0 and 3, and it swaps bytes 1 and 2 in the specified 32-bit register. The principle use of this instruction is to convert data between the so-called little-endian and big-endian data formats.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-2" id="CHP-10-FN-2">127</a>]</sup> Although you don't specifically use this instruction for this purpose here, the bswap instruction does swap the bytes and words in a 32-bit object exactly the way you want them when reversing bits. Rather than sticking in another 12 instructions to swap the bytes and then the words, you can simply use a <code class="literal">bswap( eax );</code> instruction to complete the job after the instructions above. The final code sequence is:</p><a id="I_programlisting10_d1e51245"/><pre class="programlisting">mov( eax, edx );    // Make a copy of the odd bits in the data.
 shr( 1, eax );      // Move the even bits to the odd positions.
 and( $5555_5555, edx ); // Isolate the odd bits.
 and( $5555_5555, eax ); // Isolate the even bits.
 shl( 1, edx );      // Move the odd bits to the even positions.
 or( edx, eax );     // Merge the bits and complete the swap.

 mov( eax, edx );    // Make a copy of the odd numbered bit pairs.
 shr( 2, eax );      // Move the even bit pairs to the odd position.
 and( $3333_3333, edx ); // Isolate the odd pairs.
 and( $3333_3333, eax ); // Isolate the even pairs.
 shl( 2, edx );      // Move the odd pairs to the even positions.
 or( edx, eax );     // Merge the bits and complete the swap.

 mov( eax, edx );   // Make a copy of the odd numbered nibbles.
 shr( 4, eax );     // Move the even nibbles to the odd position.
 and( $0f0f_0f0f, edx ); // Isolate the odd nibbles.
 and( $0f0f_0f0f, eax ); // Isolate the even nibbles.
 shl( 4, edx );     // Move the odd pairs to the even positions.
 or( edx, eax );    // Merge the bits and complete the swap.

 bswap( eax );      // Swap the bytes and words.</pre><p>This algorithm requires only 19 instructions, and it executes much faster than the bit-shifting loop appearing earlier. Of course, this sequence does consume a little more memory. If you're trying to save memory rather than clock cycles, the loop is probably a better solution.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-2" id="ftn.CHP-10-FN-2">127</a>] </sup>In the little-endian system, which is the native 80x86 format, the L.O. byte of an object appears at the lowest address in memory. In the big-endian system, which various RISC processors use, the H.O. byte of an object appears at the lowest address in memory. The <code class="literal">bswap</code> instruction converts between these two data formats.</p></div></div></div>
<div class="sect1" title="10.10 Merging Bit Strings"><div class="titlepage"><div><div><h1 class="title"><a id="merging_bit_strings"/>10.10 Merging Bit Strings</h1></div></div></div><p>Another common bit string operation is producing a single bit string by merging, or interleaving, bits from two different sources. The following example code sequence creates a 32-bit string by merging alternate bits from two 16-bit strings:<a class="indexterm" id="IDX-CHP-10-0122"/></p><a id="I_programlisting10_d1e51261"/><pre class="programlisting">// Merge two 16-bit strings into a single 32-bit string.
// ax - Source for even numbered bits.
// bx - Source for odd numbered bits.
// cl - Scratch register.
// edx- Destination register.

          mov( 16, cl );
MergeLp:  shrd( 1, eax, edx );     // Shift a bit from eax into edx.
          shrd( 1, ebx, edx );     // Shift a bit from ebx into edx.
          dec( cl );
          jne MergeLp;</pre><p>This particular example merged two 16-bit values together, alternating their bits in the result value. For a faster implementation of this code, unrolling the loop is probably your best bet because this eliminates half the instructions.</p><p>With a few slight modifications, we could also have merged four 8-bit values together, or we could have generated the result using other bit sequences. For example, the following code copies bits 0..5 from EAX, then bits 0..4 from EBX, then bits 6..11 from EAX, then bits 5..15 from EBX, and finally bits 12..15 from EAX:<a class="indexterm" id="IDX-CHP-10-0123"/><a class="indexterm" id="IDX-CHP-10-0124"/><a class="indexterm" id="IDX-CHP-10-0125"/></p><a id="I_programlisting10_d1e51282"/><pre class="programlisting">shrd( 6, eax, edx );
          shrd( 5, ebx, edx );
          shrd( 6, eax, edx );
          shrd( 11, ebx, edx );
          shrd( 4, eax, edx );</pre></div>
<div class="sect1" title="10.11 Extracting Bit Strings"><div class="titlepage"><div><div><h1 class="title"><a id="extracting_bit_strings"/>10.11 Extracting Bit Strings</h1></div></div></div><p>Of course, we can easily accomplish the converse of merging two bit streams; that is, we can extract and distribute bits in a bit string among multiple destinations. The following code takes the 32-bit value in EAX and distributes alternate bits among the BX and DX registers:</p><a id="I_programlisting10_d1e51289"/><pre class="programlisting">mov( 16, cl );   // Count the loop iterations.
ExtractLp: shr( 1, eax );   // Extract even bits to (e)bx.
           rcr( 1, ebx );
           shr( 1, eax );   // Extract odd bits to (e)dx.
           rcr( 1, edx );
           dec( cl );       // Repeat 16 times.
           jnz ExtractLp;
           shr( 16, ebx );  // Need to move the results from the H.O.
           shr( 16, edx );  // bytes of ebx/edx to the L.O. bytes.</pre><p>This sequence executes 99 instructions. This isn't terrible, but we can probably do a little better by using an algorithm that extracts bits in parallel. Employing the technique we used to reverse bits in a register, we can come up with the following algorithm that relocates all the even bits to the L.O. word of EAX and all the odd bits to the H.O. word of EAX.</p><a id="I_programlisting10_d1e51293"/><pre class="programlisting">// Swap bits at positions (1,2), (5,6), (9,10), (13,14), (17,18),
// (21,22), (25,26), and (29, 30).

     mov( eax, edx );
     and( $9999_9999, eax );  // Mask out the bits we'll keep for now.
     mov( edx, ecx );
     shr( 1, edx );           // Move 1st bits in tuple above to the
     and( $2222_2222, ecx );  // correct position and mask out the
     and( $2222_2222, edx );  // unneeded bits.
     shl( 1, ecx );           // Move 2nd bits in tuples above.
     or( edx, ecx );          // Merge all the bits back together.
     or( ecx, eax );

// Swap bit pairs at positions ((2,3), (4,5)),
// ((10,11), (12,13)), etc.

     mov( eax, edx );
     and( $c3c3_c3c3, eax ); // The bits we'll leave alone.
     mov( edx, ecx );
     shr( 2, edx );
     and( $0c0c_0c0c, ecx );
     and( $0c0c_0c0c, edx );
     shl( 2, ecx );
     or( edx, ecx );
     or( ecx, eax );

// Swap nibbles at nibble positions (1,2), (5,6), (9,10), etc.

     mov( eax, edx );
     and( $f00f_f00f, eax );
     mov( edx, ecx );
     shr(4, edx );
     and( $0f0f_0f0f, ecx );
     and( $0f0f_0f0f, ecx );
     shl( 4, ecx );
     or( edx, ecx );
     or( ecx, eax );

// Swap bits at positions 1 and 2.

     ror( 8, eax );
     xchg( al, ah );
     rol( 8, eax );</pre><p>This sequence requires 30 instructions. At first blush it looks like a winner because the original loop executes 64 instructions. However, this code isn't quite as good as it looks. After all, if we're willing to write this much code, why not unroll the loop above 16 times? That sequence requires only 64 instructions. So the complexity of the previous algorithm may not gain much on instruction count. As to which sequence is faster, well, you'll have to time them to figure this out. However, the <code class="literal">shrd</code> instructions are not particularly fast on all processors and neither are the instructions in the other sequence. This example appears here not to show you a better algorithm but rather to demonstrate that writing really tricky code doesn't always provide a big performance boost.<a class="indexterm" id="IDX-CHP-10-0126"/><a class="indexterm" id="IDX-CHP-10-0127"/></p><p>Extracting other bit combinations is left as an exercise for the reader.</p></div>
<div class="sect1" title="10.12 Searching for a Bit Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="searching_for_a_bit_pattern"/>10.12 Searching for a Bit Pattern</h1></div></div></div><p>Another bit-related operation you may need is the ability to search for a particular bit pattern in a string of bits. For example, you might want to locate the bit index of the first occurrence of %1011 starting at some particular position in a bit string. In this section we'll explore some simple algorithms to accomplish this task.</p><p>To search for a particular bit pattern we're going to need to know four things: (1) the pattern to search for (the <span class="emphasis"><em>pattern</em></span>), (2) the length of the pattern we're searching for, (3) the bit string that we're going to search through (the <span class="emphasis"><em>source</em></span>), and (4) the length of the bit string to search through. The basic idea behind the search is to create a mask based on the length of the pattern and mask a copy of the source with this value. Then we can directly compare the pattern with the masked source for equality. If they are equal, you're finished; if they're not equal, then increment a bit position counter, shift the source one position to the right, and try again. You repeat this operation <code class="literal">length(</code><em class="replaceable"><code>source</code></em><code class="literal">) - length(</code><em class="replaceable"><code>pattern</code></em><code class="literal">)</code> times. The algorithm fails if it does not detect the bit pattern after this many attempts (because we will have exhausted all the bits in the source operand that could match the pattern's length). Here's a simple algorithm that searches for a 4-bit pattern throughout the EBX register:<a class="indexterm" id="IDX-CHP-10-0128"/></p><a id="I_programlisting10_d1e51340"/><pre class="programlisting">mov( 28, cl );      // 28 attempts because 32−4 = 28
                              // (len(src) - len(pat)).
          mov( %1111, ch );   // Mask for the comparison.
          mov( <em class="replaceable"><code>pattern</code></em>, al ); // Pattern to search for.
          and( ch, al );      // Mask unnecessary bits in al.
          mov( <em class="replaceable"><code>source</code></em>, ebx ); // Get the source value.
ScanLp:   mov( bl, dl );      // Copy the L.O. 4 bits of ebx
          and( ch, dl );      // Mask unwanted bits.
          cmp( dl, al );      // See if we match the pattern.
          jz Matched;
          dec( cl );          // Repeat the specified number of times.
          shl( 1, ebx );
          jnz ScanLp;

// Do whatever needs to be done if we failed to match the bit string.

          jmp Done;

Matched:

// If we get to this point, we matched the bit string. We can compute
// the position in the original source as 28-cl.

Done:</pre><p>Bit-string scanning is a special case of string matching. String matching is a well-studied problem in computer science, and many of the algorithms you can use for string matching are applicable to bit-string matching as well. Such algorithms are beyond the scope of this chapter, but to give you a preview of how this works, you compute some function (like <code class="literal">xor</code> or <code class="literal">sub</code>) between the pattern and the current source bits and use the result as an index into a lookup table to determine how many bits you can skip. Such algorithms let you skip several bits rather than shifting only once for each iteration of the scanning loop (as is done by the previous algorithm).</p></div>
<div class="sect1" title="10.13 The HLA Standard Library Bits Module"><div class="titlepage"><div><div><h1 class="title"><a id="the_hla_standard_library_bits_module"/>10.13 The HLA Standard Library Bits Module</h1></div></div></div><p>The HLA Standard Library provides the <code class="literal">bits.hhf</code> module that provides several bit-related functions, including built-in functions for many of the algorithms we've studied in this chapter. This section describes some of the functions available in the HLA Standard Library.</p><a id="I_programlisting10_d1e51364"/><pre class="programlisting">procedure bits.cnt( b:dword ); @returns( "eax" );</pre><p>This procedure returns the number of 1 bits present in the <code class="literal">b</code> parameter. It returns the count in the EAX register. To count the number of 0 bits in the parameter value, invert the value of the parameter before passing it to <code class="literal">bits.cnt</code>. If you want to count the number of bits in a 16-bit operand, simply zero extend it to 32 bits prior to calling this function. Here are a couple of examples:<a class="indexterm" id="IDX-CHP-10-0129"/><a class="indexterm" id="IDX-CHP-10-0130"/></p><a id="I_programlisting10_d1e51384"/><pre class="programlisting">// Compute the number of bits in a 16-bit register:

     pushw( 0 );
     push( ax );
     call bits.cnt;

// If you prefer to use a higher-level syntax, try the following:

     bits.cnt( #{ pushw(0); push(ax); }# );

// Compute the number of bits in a 16-bit memory location:

     pushw( 0 );
     push( <em class="replaceable"><code>mem16</code></em> );
     call bits.cnt;</pre><p>If you want to compute the number of bits in an 8-bit operand, it's probably faster to write a simple loop that rotates all the bits in the source operand and adds the carry into the accumulating sum. Of course, if performance isn't an issue, you can zero extend the byte to 32 bits and call the <code class="literal">bits.cnt</code> procedure.</p><a id="I_programlisting10_d1e51394"/><pre class="programlisting">procedure bits.distribute( source:dword; mask:dword; dest:dword );
     @returns( "eax" );</pre><p>This function takes the L.O. <span class="emphasis"><em>n</em></span> bits of <code class="literal">source</code>, where <span class="emphasis"><em>n</em></span> is the number of 1 bits in <code class="literal">mask</code>, and inserts these bits into <code class="literal">dest</code> at the bit positions specified by the 1 bits in <code class="literal">mask</code> (that is, the same as the distribute algorithm appearing earlier in this chapter). This function does not change the bits in <code class="literal">dest</code> that correspond to the zeros in the <code class="literal">mask</code> value. This function does not affect the value of the actual <code class="literal">dest</code> parameter; it returns the new value in the EAX register.</p><a id="I_programlisting10_d1e51426"/><pre class="programlisting">procedure bits.coalesce( source:dword; mask:dword );
     @returns( "eax" );</pre><p>This function is the converse of <code class="literal">bits.distribute</code>. It extracts all the bits in source whose corresponding positions in <code class="literal">mask</code> contain a 1. This function coalesces (right justifies) these bits in the L.O. bit positions of the result and returns the result in EAX.<a class="indexterm" id="IDX-CHP-10-0131"/></p><a id="I_programlisting10_d1e51441"/><pre class="programlisting">procedure bits.extract( var d:dword );
     @returns( "eax" ); // Really a macro.</pre><p>This function extracts the first set bit in <code class="literal">d</code> searching from bit 0 and returns the index of this bit in the EAX register; the function also returns the zero flag clear in this case. This function also clears that bit in the operand. If <code class="literal">d</code> contains 0, then this function returns the zero flag set and EAX will contain −1.<a class="indexterm" id="IDX-CHP-10-0132"/><a class="indexterm" id="IDX-CHP-10-0133"/><a class="indexterm" id="IDX-CHP-10-0134"/></p><p>Note that HLA actually implements this function as a macro, not a procedure. This means that you can pass any double-word operand as a parameter (a memory or a register operand). However, the results are undefined if you pass EAX as the parameter (because this function computes the bit number in EAX).</p><a id="I_programlisting10_d1e51469"/><pre class="programlisting">procedure bits.reverse32( d:dword ); @returns( "eax" );
procedure bits.reverse16( w:word ); @returns( "ax" );
procedure bits.reverse8( b:byte ); @returns( "al" );</pre><p>These three routines return their parameter value with its bits reversed in the accumulator register (AL/AX/EAX). Call the routine appropriate for your data size.</p><a id="I_programlisting10_d1e51473"/><pre class="programlisting">procedure bits.merge32( even:dword; odd:dword ); @returns( "edx:eax" );
procedure bits.merge16( even:word; odd:word ); @returns( "eax" );
procedure bits.merge8( even:byte; odd:byte ); @returns( "ax" );</pre><p>These routines merge two streams of bits to produce a value whose size is the combination of the two parameters. The bits from the <code class="literal">even</code> parameter occupy the even bit positions in the result; the bits from the <code class="literal">odd</code> parameter occupy the odd bit positions in the result. Notice that these functions return 16, 32, or 64 bits based on byte, word, and double-word parameter values.</p><a id="I_programlisting10_d1e51483"/><pre class="programlisting">procedure bits.nibbles32( d:dword ); @returns( "edx:eax" );
procedure bits.nibbles16( w:word ); @returns( "eax" );
procedure bits.nibbles8( b:byte ); @returns( "ax" );</pre><p>These routines extract each nibble from the parameter and place those nibbles into individual bytes. The <code class="literal">bits.nibbles8</code> function extracts the two nibbles from the <code class="literal">b</code> parameter and places the L.O. nibble in AL and the H.O. nibble in AH. The <code class="literal">bits.nibbles16</code> function extracts the four nibbles in <code class="literal">w</code> and places them in each of the 4 bytes of EAX. You can use the <code class="literal">bswap</code> or rox instructions to gain access to the nibbles in the H.O. word of EAX. The <code class="literal">bits.nibbles32</code> function extracts the eight nibbles in EAX and distributes them through the 8 bytes in EDX:EAX. Nibble 0 winds up in AL and nibble 7 winds up in the H.O. byte of EDX. Again, you can use <code class="literal">bswap</code> or the rotate instructions to access the upper bytes of EAX and EDX.</p></div>
<div class="sect1" title="10.14 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information-id9"/>10.14 For More Information</h1></div></div></div><p>The electronic edition of The Art of Assembly Language at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> and <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a> contains some additional information you may find useful when developing bit-manipulation algorithms. In particular, the chapter on digital design discusses boolean algebra, a subject that you will find essential when working with bits. The HLA Standard Library reference manual contains more information about the HLA Standard Library bit-manipulation routines. See that documentation on the website for more information about those functions. As noted in the section on bit counting, the AMD Athlon optimization guide contains some useful algorithms for bit-based computations. Finally, to learn more about bit searching algorithms, you should pick up a textbook on data structures and algorithms and study the section on string-matching algorithms.</p></div></body></html>