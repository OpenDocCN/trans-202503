<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="37" id="Page_37"/>3</span><br/>
<span class="ChapterTitle">Designing Interfaces</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<p class="ChapterIntro">Every project, no matter how large or small, has an API. In fact, it usually has several. Some of these are user-facing, like an HTTP endpoint or a command line interface, and some are developer-facing, like a library’s public interface. On top of these, Rust crates also have a number of internal interfaces: every type, trait, and module boundary has its own miniature API that the rest of your code interfaces with. As your codebase grows in size and complexity, you’ll find it worthwhile to invest some thought and care into how you design even the internal APIs to make the experience of using and maintaining the code over time as pleasant as possible. </p>
<p>In this chapter we’ll look at some of the most important considerations for writing idiomatic interfaces in Rust, whether the users of those interfaces are your own code or other developers using your library. These essentially boil down to four principles: your interfaces should be <em>unsurprising</em>, <em>flexible</em>, <em>obvious</em>, and <em>constrained</em>. I’ll discuss each of these principles in turn, to provide some guidance for writing reliable and usable interfaces.</p>
<p><span epub:type="pagebreak" title="38" id="Page_38"/>I highly recommend taking a look at the Rust API Guidelines (<a href="https://rust-lang.github.io/api-guidelines/" class="LinkURL">https://rust-lang.github.io/api-guidelines/</a>) after you’ve read this chapter. There’s an excellent checklist you can follow, with a detailed run-through of each recommendation. Many of the recommendations in this chapter are also checked by the <code>cargo clippy</code> tool, which you should start running on your code if you aren’t already. I also encourage you to read through Rust RFC 1105 (<a href="https://rust-lang.github.io/rfcs/1105-api-evolution.html" class="LinkURL">https://rust-lang.github.io/rfcs/1105-api-evolution.html</a>) and the chapter of <em>The Cargo Book</em> on SemVer compatibility (<a href="https://doc.rust-lang.org/cargo/reference/semver.html" class="LinkURL">https://doc.rust-lang.org/cargo/reference/semver.html</a>), which cover what is and is not a breaking change in Rust.</p>
<h2 id="h1-123456c01-0001">Unsurprising</h2>
<p class="BodyFirst">The Principle of Least Surprise, otherwise known as the Law of Least Astonishment, comes up a lot in software engineering, and it holds true for Rust interfaces as well. Where possible, your interfaces should be intuitive enough that if the user has to guess, they usually guess correctly. Of course, not everything about your application is going to be immediately intuitive in this way, but anything that <em>can</em> be unsurprising should be. The core idea here is to stick close to things the user is likely to already know so that they don’t have to relearn concepts in a different way than they’re used to. That way you can save their brain power for figuring out the things that are actually specific to your interface.</p>
<p>There are a variety of ways you can make your interfaces predictable. Here, we’ll look at how you can use naming, common traits, and ergonomic trait tricks to help the user out.</p>
<h3 id="h2-123456c01-0001">Naming Practices</h3>
<p class="BodyFirst">A user of your interface will encounter it first through its names; they will immediately start to infer things from the names of types, methods, variables, fields, and libraries they come across. If your interface reuses names for things—say, methods and types—from other (perhaps common) interfaces, the user will know they can make certain assumptions about your methods and types. A method called <code>iter</code> probably takes <code>&amp;self</code>, and probably gives you an iterator. A method called <code>into_inner</code> probably takes <code>self</code> and likely returns some kind of wrapped type. A type called <code>SomethingError</code> probably implements <code>std::error::Error</code> and appears in various <code>Result</code>s. By reusing common names for the same purpose, you make it easier for the user to guess what things do and allow them to more easily understand the things that are different about your interface.</p>
<p>A corollary to this is that things that share a name <em>should</em> in fact work the same way. Otherwise—for example, if your <code>iter</code> method takes <code>self</code>, or if your <code>SomethingError</code> type does not implement <code>Error</code>—the user will likely write incorrect code based on how they expect the interface to work. They will be surprised and frustrated and will have to spend time digging into how your interface differs from their expectations. When we can save the user this kind of friction, we should.</p>
<h3 id="h2-123456c01-0002"><span epub:type="pagebreak" title="39" id="Page_39"/>Common Traits for Types</h3>
<p class="BodyFirst">Users in Rust will also make the major assumption that everything in the interface “just works.” They expect to be able to print any type with <code>{:?}</code> and send anything and everything to another thread, and they expect that every type is <code>Clone</code>. Where possible, we should again avoid surprising the user and eagerly implement most of the standard traits even if we do not need them immediately.</p>
<p>Because of the coherence rules discussed in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, the compiler will not allow users to implement these traits when they need them. Users aren’t allowed to implement a foreign trait (like <code>Clone</code>) for a foreign type like one from your interface. They would instead need to wrap your interface type in their own type, and even then it may be quite difficult to write a reasonable implementation without access to the type’s internals.</p>
<p>First among these standard traits is the <code>Debug</code> trait. Nearly every type can, and should, implement <code>Debug</code>, even if it only prints the type’s name. Using <code>#[derive(Debug)]</code> is often the best way to implement the <code>Debug</code> trait in your interface, but keep in mind that all derived traits automatically add the same bound for any generic parameters. You could also simply write your own implementation by leveraging the various <code>debug_</code> helpers on <code>fmt::Formatter</code>.</p>
<p>Tied in close second are the Rust auto-traits <code>Send</code> and <code>Sync</code> (and, to a lesser extent, <code>Unpin</code>). If a type does not implement one of these traits, it should be for a very good reason. A type that is not <code>Send</code> can’t be placed in a <code>Mutex</code> and can’t be used even transitively in an application that contains a thread pool. A type that is not <code>Sync</code> can’t be shared through an <code>Arc</code> or placed in a static variable. Users have come to expect that types <em>just work</em> in these contexts, especially in the asynchronous world where nearly everything runs on a thread pool, and will become frustrated if you don’t ensure that your types implement these traits. If your types cannot implement them, make sure that fact, and the reason why, is well documented!</p>
<p>The next set of nearly universal traits you should implement is <code>Clone</code> and <code>Default</code>. These traits can be derived or implemented easily and make sense to implement for most types. If your type cannot implement these traits, make sure to call it out in your documentation, as users will usually expect to be able to easily create more (and new) instances of types as they see fit. If they cannot, they will be surprised.</p>
<p>One step further down in the hierarchy of expected traits is the comparison traits: <code>PartialEq</code>, <code>PartialOrd</code>, <code>Hash</code>, <code>Eq</code>, and <code>Ord</code>. The <code>PartialEq</code> trait is particularly desirable, because users will at some point inevitably have two instances of your type that they wish to compare with <code>==</code> or <code>assert_eq!</code>. Even if your type would compare equal for only the same instance of the type, it’s worth implementing <code>PartialEq</code> to enable your users to use <code>assert_eq!</code>.</p>
<p><code>PartialOrd</code> and <code>Hash</code> are more specialized, and may not apply quite as broadly, but where possible you will want to implement them too. This is especially true for types a user might use as the key in a map, or a type they may deduplicate using any of the <code>std::collection</code> set types, since they tend to require these bounds. <code>Eq</code> and <code>Ord</code> come with additional semantic requirements on the implementing type’s comparison operations beyond those of <code>PartialEq</code> and <code>PartialOrd</code>. These are well documented in the documentation <span epub:type="pagebreak" title="40" id="Page_40"/>for those traits, and you should implement them <em>only</em> if you’re sure those semantics actually apply to your type.</p>
<p>Finally, for most types, it makes sense to implement the <code>serde</code> crate’s <code>Serialize</code> and <code>Deserialize</code> traits. These can be easily derived, and the <code>serde_derive</code> crate even comes with mechanisms for overwriting the serialization for just one field or enum variant. Since <code>serde</code> is a third-party crate, you may not wish to add a required dependency on it. Most libraries therefore choose to provide a <code>serde</code> feature that adds support for <code>serde</code> only when the user opts into it.</p>
<p>You might be wondering why I haven’t included the derivable trait <code>Copy</code> in this section. There are two things that set <code>Copy</code> apart from the other traits mentioned. The first is that users do not generally expect types to be <code>Copy</code>; quite to the contrary, they tend to expect that if they want two copies of something, they have to call <code>clone</code>. <code>Copy</code> changes the semantics of moving a value of the given type, which might surprise the user. This ties in to the second observation: it is very easy for a type to <em>stop</em> being <code>Copy</code>, because <code>Copy</code> types are highly restricted. A type that starts out simple can easily end up having to hold a <code>String</code>, or some other non-<code>Copy</code> type. Should that happen, and you have to remove the <code>Copy</code> implementation, that’s a backward incompatible change. In contrast, you rarely have to remove a <code>Clone</code> implementation, so that’s a less onerous commitment.</p>
<h3 id="h2-123456c01-0003">Ergonomic Trait Implementations</h3>
<p class="BodyFirst">Rust does not automatically implement traits for references to types that implement traits. To phrase this a different way, you cannot generally call <code>fn foo&lt;T: Trait&gt;(t: T)</code> with a <code>&amp;Bar</code>, even if <code>Bar: Trait</code>. This is because <code>Trait</code> may contain methods that take <code>&amp;mut self</code> or <code>self</code>, which obviously cannot be called on <code>&amp;Bar</code>. Nonetheless, this behavior might be very surprising to a user who sees that <code>Trait</code> has only <code>&amp;self</code> methods!</p>
<p>For this reason, when you define a new trait, you’ll usually want to provide blanket implementations as appropriate for that trait for <code>&amp;T where T: Trait</code>, <code>&amp;mut T where T: Trait</code>, and <code>Box&lt;T&gt; where T: Trait</code>. You may be able to implement only some of these depending on what receivers the methods of <code>Trait</code> have. Many of the traits in the standard library have similar implementations, precisely because that leads to fewer surprises for the user.</p>
<p>Iterators are another case where you’ll often want to specifically add trait implementations on references to a type. For any type that can be iterated over, consider implementing <code>IntoIterator</code> for both <code>&amp;MyType</code> and <code>&amp;mut MyType</code> where applicable. This makes <code>for</code> loops work with borrowed instances of your type as well out of the box, just like users would expect.</p>
<h3 id="h2-123456c01-0004">Wrapper Types</h3>
<p class="BodyFirst">Rust does not have object inheritance in the classical sense. However, the <code>Deref</code> trait and its cousin <code>AsRef</code> both provide something a little like inheritance. These traits allow you to have a value of type <code>T</code> and call methods on some type <code>U</code> by calling them directly on the <code>T</code>-typed value if <code>T: Deref&lt;Target = U&gt;</code>. This feels like magic to the user, and is generally great.</p>
<p><span epub:type="pagebreak" title="41" id="Page_41"/>If you provide a relatively transparent wrapper type (like <code>Arc</code>), there’s a good chance you’ll want to implement <code>Deref</code> so that users can call methods on the inner type by just using the <code>.</code> operator. If accessing the inner type does not require any complex or potentially slow logic, you should also consider implementing <code>AsRef</code>, which allows users to easily use a <code>&amp;WrapperType</code> as an <code>&amp;InnerType</code>. For most wrapper types, you will also want to implement <code>From&lt;InnerType&gt;</code> and <code>Into&lt;InnerType&gt;</code> where possible so that your users can easily add or remove your wrapping.</p>
<p>You may also have come across the <code>Borrow</code> trait, which feels very similar to <code>Deref</code> and <code>AsRef</code> but is really a bit of a different beast. Specifically, <code>Borrow</code> is tailored for a much narrower use case: allowing the caller to supply any one of multiple essentially identical variants of the same type. It could, perhaps, have been called <code>Equivalent</code> instead. For example, for a <code>HashSet&lt;String&gt;</code>, <code>Borrow</code> allows the caller to supply either a <code>&amp;str</code> <em>or</em> a <code>&amp;String</code>. While the same could have been achieved with <code>AsRef</code>, that would not be safe without <code>Borrow</code>’s additional requirement that the target type implements <code>Hash</code>, <code>Eq</code>, and <code>Ord</code> exactly the same as the implementing type. <code>Borrow</code> also has a blanket implementation of <code>Borrow&lt;T&gt;</code> for <code>T</code>, <code>&amp;T</code>, and <code>&amp;mut T</code>, which makes it convenient to use in trait bounds to accept either owned <em>or</em> referenced values of a given type. In general, <code>Borrow</code> is intended only for when your type is essentially equivalent to another type, whereas <code>Deref</code> and <code>AsRef</code> are intended to be implemented more widely for anything your type can “act as.”</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Deref and Inherent Methods</h2>
<p class="BoxBodyFirst">The magic around the dot operator and <code>Deref</code> can get confusing and surprising when there are methods on <code>T</code> that take <code>self</code>. For example, given a value <code>t: T</code>, it is not clear whether <code>t.frobnicate()</code> frobnicates the <code>T</code> or the underlying <code>U</code>! </p>
<p>For this reason, types that allow you to transparently call methods on some inner type that isn’t known in advance should avoid inherent methods. It’s fine for <code>Vec</code> to have a <code>push</code> method even though it dereferences to a slice, since you know that slices won’t get a <code>push</code> method any time soon. But if your type dereferences to a user-controlled type, any inherent method you add may also exist on that user-controlled type, and thus cause issues. In these cases, favor static methods of the form <code>fn frobnicate(t: T)</code>. That way, <code>t.frobnicate()</code> always calls <code>U::frobnicate</code>, and <code>T::frobnicate(t)</code> can be used to frobnicate the <code>T</code> itself. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside><h2 id="h1-123456c01-0002">Flexible</h2>
<p class="BodyFirst">Every piece of code you write includes, implicitly or explicitly, a contract. The contract consists of a set of requirements and a set of promises. The requirements are restrictions on how the code can be used, while the <span epub:type="pagebreak" title="42" id="Page_42"/>promises are guarantees about how the code can be used. When designing a new interface, you want to think carefully about this contract. A good rule of thumb is to avoid imposing unnecessary restrictions and to only make promises you can keep. Adding restrictions or removing promises usually requires a major semantic version change and is likely to break code elsewhere. Relaxing restrictions or giving additional promises, on the other hand, is usually backward compatible.</p>
<p>In Rust, restrictions usually come in the form of trait bounds and argument types, and promises come in the form of trait implementations and return types. For example, compare the three function signatures in <a href="#listing3-1" id="listinganchor3-1">Listing 3-1</a>.</p>
<pre><code>fn frobnicate1(s: String) -&gt; String
fn frobnicate2(s: &amp;str) -&gt; Cow&lt;'_, str&gt;
fn frobnicate3(s: impl AsRef&lt;str&gt;) -&gt; impl AsRef&lt;str&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing3-1">Listing 3-1</a>: Similar function signatures with different contracts</p>
<p>These three function signatures all take a string and return a string, but they do so under very different contracts.</p>
<p>The first function requires the caller to own the string in the form of the <code>String</code> type, and it promises that it will return an owned <code>String</code>. Since the contract requires the caller to allocate and requires us to return an owned <code>String</code>, we cannot later make this function allocation-free in a backward compatible way.</p>
<p>The second function relaxes the contract: the caller can provide any reference to a string, so the user no longer needs to allocate or give up ownership of a <code>String</code>. It also promises to give back a <code>std::borrow::Cow</code>, meaning it can return either a string reference or an owned <code>String</code>, depending on whether it needs to own the string. The promise here is that the function will always return a <code>Cow</code>, which means that we cannot, say, change it to use some other optimized string representation later. The caller must also specifically provide a <code>&amp;str</code>, so if they have, say, a pre-existing <code>String</code> of their own, they must dereference it to a <code>&amp;str</code> to call our function.</p>
<p>The third function lifts these restrictions. It requires only that the user pass in a type that can produce a reference to a string, and it promises only that the return value can produce a reference to a string.</p>
<p>None of these function signatures is <em>better</em> than the others. If you need ownership of a string in the function, you can use the first argument type to avoid an extra string copy. If you want to allow the caller to take advantage of the case where an owned string was allocated and returned, the second function with a return type of <code>Cow</code> may be a good choice. Instead, what I want you to take away from this is that you should think carefully about what contract your interface binds you to, because changing it after the fact can be disruptive.</p>
<p>In the remainder of this section I give examples of interface design decisions that often come up, and their implications for your interface contract.</p>
<h3 id="h2-123456c01-0005"><span epub:type="pagebreak" title="43" id="Page_43"/>Generic Arguments</h3>
<p class="BodyFirst">One obvious requirement your interface must place on users is what types they must provide to your code. If your function explicitly takes a <code>Foo</code>, the user must own and give you a <code>Foo</code>. There is no way around it. In most cases it pays off to use generics rather than concrete types, to allow the caller to pass any type that conforms to what your function actually needs, rather than only a particular type. Changing <code>&amp;str</code> in <a href="#listing3-1">Listing 3-1</a> to <code>impl AsRef&lt;str&gt;</code> is an example of this kind of relaxing. One way to go about relaxing requirements this way is to start with the argument fully generic with no bounds, and then just follow the compiler errors to discover what bounds you need to add.</p>
<p>However, if taken to the extreme, this approach would make every argument to every function its own generic type, which would be both hard to read and hard to understand. There are no hard-and-fast rules for exactly when you should or should not make a given parameter generic, so use your best judgment. A good rule of thumb is to make an argument generic if you can think of other types a user might reasonably and frequently want to use instead of the concrete type you started with.</p>
<p>You may remember from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> that generic code is duplicated for every combination of types ever used with the generic code through monomorphization. With that in mind, the idea of making lots of arguments generic might make you worried about overly enlarging your binaries. In <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> we also discussed how you can use dynamic dispatch to mitigate this at a (usually) negligible performance cost, and that applies here too. For arguments that you take by reference anyway (recall that <code>dyn Trait</code> is not <code>Sized</code>, and that you need a wide pointer to use them), you can easily replace your generic argument with one that uses dynamic dispatch. For instance, instead of <code>impl AsRef&lt;str&gt;</code>, you could take <code>&amp;dyn AsRef&lt;str&gt;</code>.</p>
<p>Before you go running to do that, though, there are a few things you should consider. First, you are making this choice on behalf of your users, who cannot opt out of dynamic dispatch. If you know that the code you’re applying dynamic dispatch to will never be performance-sensitive, that may be fine. But if a user comes along who wants to use your library in their high-performance application, dynamic dispatch in a function that is called in a hot loop may be a deal breaker. Second, at the time of writing, using dynamic dispatch will work only when you have a simple trait bound like <code>T: AsRef&lt;str&gt;</code> or <code>impl AsRef&lt;str&gt;</code>. For more complex bounds, Rust does not know how to construct a dynamic dispatch vtable, so you cannot take, say, <code>&amp;dyn Hash + Eq</code>. And finally, remember that with generics, the caller can always choose dynamic dispatch themselves by passing in a trait object. The reverse is not true: if you take a trait object, that is what the caller must provide.</p>
<p>It may be tempting to start your interfaces off with concrete types and then turn them generic over time. This can work, but keep in mind that such changes are not necessarily backward compatible. To see why, imagine that you change a function from <code>fn foo(v: &amp;Vec&lt;usize&gt;)</code> to <code>fn foo(v: impl AsRef&lt;[usize]&gt;)</code>. While every <code>&amp;Vec&lt;usize&gt;</code> implements <code>AsRef&lt;[usize]&gt;</code>, type <span epub:type="pagebreak" title="44" id="Page_44"/>inference can still cause issues for users. Consider what happens if the caller invokes <code>foo</code> with <code>foo(&amp;iter.collect())</code>. In the original version, the compiler could determine that it should collect into a <code>Vec</code>, but now it just knows that it needs to collect into some type that implements <code>AsRef&lt;[usize]&gt;</code>. And there could be multiple such types, so with this change, the caller’s code will no longer compile!</p>
<h3 id="h2-123456c01-0006">Object Safety</h3>
<p class="BodyFirst">When you define a new trait, whether or not that trait is object-safe (see the end of “Compilation and Dispatch” in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>) is an unwritten part of the trait’s contract. If the trait is object-safe, users can treat different types that implement your trait as a single common type using <code>dyn Trait</code>. If it isn’t, the compiler will disallow <code>dyn Trait</code> for that trait. You should prefer your traits to be object-safe even if that comes at a slight cost to the ergonomics of using them (such as taking <code>impl AsRef&lt;str&gt;</code> over <code>&amp;str</code>), since object safety enables new ways to use your traits. If your trait must have a generic method, consider whether its generic parameters can be on the trait itself or if its generic arguments can also use dynamic dispatch to preserve the object safety of the trait. Alternatively, you can add a <code>where Self: Sized</code> trait bound to that method, which makes it possible to call the method only with a concrete instance of the trait (and not through <code>dyn Trait</code>). You can see examples of this pattern in the <code>Iterator</code> and <code>Read</code> traits, which are object-safe but provide some additional convenience methods on concrete instances.</p>
<p>There is no single answer to the question of how many sacrifices you should be willing to make to preserve object safety. My recommendation is that you consider how your trait will be used, and whether it makes sense for users to want to use it as a trait object. If you think it’s likely that users will want to use many different instances of your trait together, you should work harder to provide object safety than if you don’t think that use case makes much sense. For example, dynamic dispatch would not be useful for the <code>FromIterator</code> trait because its one method does not take <code>self</code>, so you wouldn’t be able to construct a trait object in the first place. Similarly, <code>std::io::Seek</code> is fairly useless as a trait object on its own, because the only thing you would be able to do with such a trait object is seek, without being able to read or write.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Drop Trait objects</h2>
<p class="BoxBodyFirst">You might think that the <code>Drop</code> trait is also useless as a trait object, since all you can do with <code>Drop</code> as a trait object is to drop it. But it turns out there are some libraries that specifically just want to be able to drop arbitrary types. For example, a library that offers deferred dropping of values, such as for concurrent garbage collection or just deferred cleanup, cares only that the values can <span epub:type="pagebreak" title="45" id="Page_45"/>be dropped, and nothing else. Interestingly enough, the story of <code>Drop</code> doesn’t end there; since Rust needs to be able to drop trait objects too, <em>every</em> vtable contains the <code>drop</code> method. Effectively, every <code>dyn Trait</code> is also a <code>dyn Drop</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Remember that object safety is a part of your public interface! If you modify a trait in an otherwise backward compatible way, such as by adding a method with a default implementation, but it makes the trait not object-safe, you need to bump your major semantic version number.</p>
<h3 id="h2-123456c01-0007">Borrowed vs. Owned</h3>
<p class="BodyFirst">For nearly every function, trait, and type you define in Rust, you must decide whether it should own, or just hold a reference to, its data. Whatever decision you make will have far-reaching implications for the ergonomics and performance of your interface. Luckily, these decisions very often make themselves.</p>
<p>If the code you write needs ownership of the data, such as to call methods that take <code>self</code> or to move the data to another thread, it must store the owned data. When your code must own data, it should generally also make the caller provide owned data, rather than taking values by reference and cloning them. This leaves the caller in control of allocation, and it is upfront about the cost of using the interface in question.</p>
<p>On the other hand, if your code doesn’t need to own the data, it should operate on references instead. One common exception to this rule is with small types like <code>i32</code>, <code>bool</code>, or <code>f64</code>, which are just as cheap to store and copy directly as to store through references. Be wary of assuming this holds true for all <code>Copy</code> types, though; <code>[u8; 8192]</code> is <code>Copy</code>, but it would be expensive to store and copy it all over the place.</p>
<p>Sometimes, you don’t know if your code must own data or not, as it is runtime dependent. For this, the <code>Cow</code> type is your friend. It lets you represent data that <em>may</em> be owned by holding either a reference or an owned value. If asked to produce an owned value when it only has a reference, a <code>Cow</code> uses the <code>ToOwned</code> trait to make one behind the scenes, usually by cloning. <code>Cow</code> is typically used in return types to represent functions that sometimes allocate. For example, <code>String::from_utf8_lossy</code> allocates only if the input contains invalid UTF-8. <code>Cow</code> can also be used in arguments for functions that can sometimes make use of owned inputs, but that’s rarer in practice.</p>
<p>Other times, reference lifetimes complicate the interface so much that it becomes a pain to use. If your users are struggling to get code to compile on top of your interface, that’s a sign that you may want to (even unnecessarily) take ownership of certain pieces of data. If you do this, start with data that is cheap to clone or is not <span epub:type="pagebreak" title="46" id="Page_46"/>part of anything performance-sensitive before you decide to heap-allocate what might be a huge chunk of bytes.</p>
<h3 id="h2-123456c01-0008">Fallible and Blocking Destructors</h3>
<p class="BodyFirst">Types centered on I/O often need to perform cleanup when they’re dropped. This may include flushing writes to disk, closing files, or gracefully terminating connections to remote hosts. The natural place to perform this cleanup is in the type’s <code>Drop</code> implementation. Unfortunately, once a value is dropped, we no longer have a way to communicate errors to the user except by panicking. A similar problem arises in asynchronous code, where we wish to finish up when there is work pending. By the time <code>drop</code> is called, the executor may be shutting down, and we have no way to do more work. We could try to start another executor, but that comes with its own host of problems, such as blocking in asynchronous code, as we will see in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>.</p>
<p>There is no perfect solution to these problems, and no matter what we do, some applications will inevitably fall back to our <code>Drop</code> implementation. For that reason, we need to provide best-effort cleanup through <code>Drop</code>. If cleanup errors, at least we tried—we swallow the error and move on. If an executor is still available, we might spawn a future to do cleanup, but if it never gets to run, we did what we could.</p>
<p>However, we ought to provide a better alternative for users who wish to leave no loose threads. We can do this by providing an explicit destructor. This usually takes the form of a method that takes ownership of <code>self</code> and exposes any errors (using <code>-&gt; Result&lt;_, _&gt;</code>) or asynchrony (using <code>async fn</code>) that are inherent to the destruction. A careful user can then use that method to gracefully tear down any associated resources.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Make sure you highlight the explicit destructor in your documentation!</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>As always, there’s a trade-off. The moment you add an explicit destructor, you will run into two issues. First, since your type implements <code>Drop</code>, you can no longer move out of any of that type’s fields in the destructor. This is because <code>Drop::drop</code> will still be called after your explicit destructor runs, and it takes <code>&amp;mut self</code>, which requires that no part of <code>self</code> has been moved. Second, <code>drop</code> takes <code>&amp;mut self</code>, not <code>self</code>, so your <code>Drop</code> implementation cannot simply call your explicit destructor and ignore its result (because it doesn’t own <code>self</code>). There are a couple of ways around these problems, none of which are perfect.</p>
<p>The first is to make your top-level type a newtype wrapper around an <code>Option</code>, which in turn holds some inner type that holds all of the type’s fields. You can then use <code>Option::take</code> in both destructors, and call the inner type’s explicit destructor only if the inner type has not already been taken. Since the inner type does not implement <code>Drop</code>, you can take ownership of all the fields there. The downside of this approach is that all the methods you wish to provide on the top-level type must now include code to get through the <code>Option</code> (which you know is always <code>Some</code> since <code>drop</code> has not yet been called) to the fields on the inner type.</p>
<p><span epub:type="pagebreak" title="47" id="Page_47"/>The second workaround is to make each of your fields <em>takeable</em>. You can “take” an <code>Option</code> by replacing it with <code>None</code> (which is what <code>Option::take</code> does), but you can do this with many other types as well. For example, you can take a <code>Vec</code> or <code>HashMap</code> by simply replacing them with their cheap-to-construct default values—<code>std::mem::take</code> is your friend here. This approach works great if your types have sane “empty” values but gets tedious if you must wrap nearly every field in an <code>Option</code> and then modify every access of those fields with a matching <code>unwrap</code>.</p>
<p>The third option is to hold the data inside the <code>ManuallyDrop</code> type, which dereferences to the inner type, so there’s no need for unwraps. You can also use <code>ManuallyDrop::take</code> in <code>drop</code> to take ownership at destruction time. The primary downside of this approach is that <code>ManuallyDrop::take</code> is unsafe. There are no safety mechanisms in place to ensure that you don’t try to use the value inside the <code>ManuallyDrop</code> after you’ve called <code>take</code> or that you don’t call <code>take</code> multiple times. If you do, your program will silently exhibit undefined behavior, and bad things will happen.</p>
<p>Ultimately, you should choose whichever of these approaches fits your application best. I would err on the side of going with the second option, and switching to the others only if you find yourself in a sea of <code>Option</code>s. The <code>ManuallyDrop</code> solution is excellent if the code is simple enough that you can easily check the safety of your code, and you are confident in your ability to do so.</p>
<h2 id="h1-123456c01-0003">Obvious</h2>
<p class="BodyFirst">While some users may be familiar with aspects of the implementation that underpins your interface, they are unlikely to understand all of its rules and limitations. They won’t know that it’s never okay to call <code>foo</code> after calling <code>bar</code>, or that it’s only safe to call the unsafe method <code>baz</code> when the moon is at a 47-degree angle and no one has sneezed in the past 18 seconds. Only if the interface makes it clear that something strange is going on will they reach for the documentation or carefully read type signatures. It’s therefore critical for you to make it as easy as possible for users to understand your interface and as hard as possible for them to use it incorrectly. The two primary techniques at your disposal for this are your documentation and the type system, so let’s look at each of those in turn.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	You can also take advantage of naming to suggest to the user when there’s more to an interface than meets the eye. If a user sees a method named <code>dangerous</code>, chances are they will read its documentation.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-123456c01-0009">Documentation</h3>
<p class="BodyFirst">The first step to making your interfaces transparent is to write good documentation. I could write an entire book dedicated to how to write documentation, but let’s focus on Rust-specific advice here.</p>
<p>First, clearly document any cases where your code may do something unexpected, or where it relies on the user doing something beyond what’s dictated by the type signature. Panics are a good example of both of <span epub:type="pagebreak" title="48" id="Page_48"/>these circumstances: if your code can panic, document that fact, along with the circumstances it might panic under. Similarly, if your code might return an error, document the cases in which it does. For unsafe functions, document what the caller must guarantee in order for the call to be safe.</p>
<p>Second, include end-to-end usage examples for your code on a crate and module level. These are more important than examples for specific types or methods, since they give the user a feel for how everything fits together. With a decent high-level understanding of the interface’s structure, the developer may soon realize what particular methods and types do and where they should be used. End-to-end examples also give the user a starting point for customizing their usage, and they can, and often will, copy-paste the example and then modify it to suit their needs. This kind of “learning by doing” tends to work better than having them try to piece something together from the components.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Very method-specific examples that show that, yes, the <var>len</var> method indeed returns the length are unlikely to tell the user anything new about your code.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Third, organize your documentation. Having all your types, traits, and functions in a single top-level module makes it difficult for the user to get a sense of where to start. Take advantage of modules to group together semantically related items. Then, use intra-documentation links to interlink items. If the documentation on type A talks about trait B, then it should link to that trait right there. If you make it easy for the user to explore your interface, they are less likely to miss important connections or dependencies. Also consider marking parts of your interface that are not intended to be public but are needed for legacy reasons with <code>#[doc(hidden)]</code>, so that they do not clutter up your documentation.</p>
<p>And finally, enrich your documentation wherever possible. Link to external resources that explain concepts, data structures, algorithms, or other aspects of your interface that may have good explanations elsewhere. RFCs, blog posts, and whitepapers are great for this, if any are relevant. Use <code>#[doc(cfg(..))]</code> to highlight items that are available only under certain configurations so the user quickly realizes why some method that’s listed in the documentation isn’t available. Use <code>#[doc(alias = "...")]</code> to make types and methods discoverable under other names that users may search for them by. In the top-level documentation, point the user to commonly used modules, features, types, traits, and methods.</p>
<h3 id="h2-123456c01-0010">Type System Guidance</h3>
<p class="BodyFirst">The type system is an excellent tool to ensure that your interfaces are obvious, self-documenting, and misuse-resistant. You have several techniques at your disposal that can make your interfaces very hard to misuse, and thus, make it more likely that they will be used correctly.</p>
<p>The first of these is <em>semantic typing</em>, in which you add types to represent the <em>meaning</em> of a value, not just its primitive type. The classic example here is for Booleans: if your function takes three <code>bool</code> arguments, chances <span epub:type="pagebreak" title="49" id="Page_49"/>are some user will mess up the order of the values and realize it only after something has gone terribly wrong. If, on the other hand, it takes three arguments of distinct two-variant enum types, the user cannot get the order wrong without the compiler yelling at them: if they attempt to pass <code>DryRun::Yes</code> to the <code>overwrite</code> argument, that will simply not work, nor will passing <code>Overwrite::No</code> as the <code>dry_run</code> argument.  You can apply semantic typing beyond Booleans as well. For example, a newtype around a numeric type may provide a unit for the contained value, or it could constrain raw pointer arguments to only those that have been returned by another method.</p>
<p>A closely related technique is to use zero-sized types to indicate that a particular fact is true about an instance of a type. Consider, for instance, a type called <code>Rocket</code> that represents the state of a real rocket. Some operations (methods) on <code>Rocket</code> should be available no matter what state the rocket is in, but some make sense only in particular situations. It is, for example, impossible to launch a rocket if it has already been launched. Similarly, it should probably not be possible to separate the fuel tank if the rocket has not yet launched. We could model these as enum variants, but then all the methods would be available at every stage, and we’d need to introduce possible panics.</p>
<p>Instead, as shown in <a href="#listing3-2" id="listinganchor3-2">Listing 3-2</a>, we can introduce a generic parameter on <code>Rocket</code>, <code>Stage</code>, and use it to restrict what methods are available when.</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> struct Grounded;
struct Launched;
<span class="LiteralGray">// and so on</span>
struct Rocket&lt;Stage = Grounded&gt; {
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> stage: std::marker::PhantomData&lt;Stage&gt;,
}

<span class="CodeAnnotationHang" aria-label="annotation3">3</span> impl Default for Rocket&lt;Grounded&gt; {}
impl Rocket&lt;Grounded&gt; {
  pub fn launch(self) -&gt; Rocket&lt;Launched&gt; { }
}
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> impl Rocket&lt;Launched&gt; {
  pub fn accelerate(&amp;mut self) { }
  pub fn decelerate(&amp;mut self) { }
}

<span class="CodeAnnotationHang" aria-label="annotation5">5</span> impl&lt;Stage&gt; Rocket&lt;Stage&gt; {
  pub fn color(&amp;self) -&gt; Color { }
  pub fn weight(&amp;self) -&gt; Kilograms { }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-2">Listing 3-2</a>: Using marker types to restrict implementations</p>
<p>We introduce unit types to represent each stage of the rocket <span class="CodeAnnotation" aria-label="annotation1">1</span>. We don’t actually need to store the stage—only the meta-information it provides—so we store it behind a <code>PhantomData</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to guarantee that it is eliminated at compile time. Then, we write implementation blocks for <code>Rocket</code> only when it holds a particular type parameter. You can construct a rocket only on the <span epub:type="pagebreak" title="50" id="Page_50"/>ground (for now), and you can launch it only from the ground <span class="CodeAnnotation" aria-label="annotation3">3</span>. Only when the rocket has been launched can you control its velocity <span class="CodeAnnotation" aria-label="annotation4">4</span>. There are some things you can always do with the rocket, no matter what state it is in, and those we place in a generic implementation block <span class="CodeAnnotation" aria-label="annotation5">5</span>. You’ll notice that with the interface designed this way, it’s simply not possible for the user to call a method at the wrong time—we have encoded the usage rules in the types themselves, and made illegal states <em>unrepresentable</em>.</p>
<p>This notion extends to many other domains as well; if your function ignores a pointer argument unless a given Boolean argument is true, it’s better to combine the two arguments instead. With an enum type with one variant for <code>false</code> (and no pointer) and one variant for <code>true</code> that holds a pointer, neither the caller nor the implementer can misunderstand the relationship between the two. This is a powerful idea that I highly encourage you to make use of.</p>
<p>Another small but useful tool in making interfaces obvious is the <code>#[must_use]</code> annotation. Add it to any type, trait, or function, and the compiler will issue a warning if the user’s code receives an element of that type or trait, or calls that function, and does not explicitly handle it. You may already have seen this in the context of <code>Result</code>: if a function returns a <code>Result</code> and you do not assign its return value somewhere, you get a compiler warning. Be careful not to overuse this annotation, though—add it only if the user is very likely to make a mistake if they are not using the return value.</p>
<h2 id="h1-123456c01-0004">Constrained</h2>
<p class="BodyFirst">Over time, some user will depend on every property of your interface, whether bug or feature. This is especially true for publicly available libraries where you have no control over your users. As a result, you should think carefully before you make user-visible changes. Whether you’re adding a new type, field, method, or trait implementation or changing an existing one, you want to make sure that the change will not break existing users’ code, and that you are planning to keep that change around for a while. Frequent backward incompatible changes (major version increases in semantic versioning) are sure to draw the ire of your users.</p>
<p>Many backward incompatible changes are obvious, like renaming a public type or removing a public method, but some are subtler and tie in deeply with the way Rust works. Here, we’ll cover some of the thornier subtle changes and how to plan for them. You’ll see that you need to balance some of these against how flexible you want your interface to be—sometimes, something’s got to give.</p>
<h3 id="h2-123456c01-0011">Type Modifications</h3>
<p class="BodyFirst">Removing or renaming a public type will almost certainly break some user’s code. To counter this, you’ll want to take advantage of Rust’s visibility modifiers, like <code>pub(crate)</code> and <code>pub(in path)</code>, whenever possible. The fewer public types you have, the more freedom you have to change things later without breaking existing code.</p>
<p><span epub:type="pagebreak" title="51" id="Page_51"/>User code can depend on your types in more ways than just by name, though. Consider the public type in <a href="#listing3-3" id="listinganchor3-3">Listing 3-3</a> and the given use of that code.</p>
<pre><code><span class="LiteralGray">// in your interface</span>
pub struct Unit;
<span class="LiteralGray">// in user code</span>
let u = lib::Unit;</code></pre>
<p class="CodeListingCaption"><a id="listing3-3">Listing 3-3</a>: An innocent-looking public type</p>
<p>Now consider what happens if you add a private field to <code>Unit</code>. Even though the field you add is private, the change will still break the user’s code, because the constructor they relied on has disappeared. Similarly, consider the code and use in <a href="#listing3-4" id="listinganchor3-4">Listing 3-4</a>.</p>
<pre><code><span class="LiteralGray">// in your interface</span>
pub struct Unit { pub field: bool };
<span class="LiteralGray">// in user code</span>
fn is_true(u: lib::Unit) -&gt; bool {
    matches!(u, Unit { field: true })
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-4">Listing 3-4</a>: User code accessing a single public field</p>
<p>Here, too, adding a private field to <code>Unit</code> will break user code, this time because Rust’s exhaustive pattern match checking logic is able to see parts of the interface that the user cannot see. It recognizes that there are more fields, even though the user code cannot access them, and rejects the user’s pattern as incomplete. A similar issue arises if we turn a tuple struct into a regular struct with named fields: even if the fields themselves are exactly the same, any old patterns will no longer be valid for the new type definition.</p>
<p>Rust provides the <code>#[non_exhaustive]</code> attribute to help mitigate these issues. You can add it to any type definition, and the compiler will disallow the use of implicit constructors (like <code>lib::Unit { field1: true }</code>) and nonexhaustive pattern matches (that is, patterns without a trailing <code>, ..</code>) on that type. This is a great attribute to add if you suspect that you’re likely to modify a particular type in the future. It does constrain user code though, such as by taking away users’ ability to rely on exhaustive pattern matches, so avoid adding it if you think a given type is likely to remain stable.</p>
<h3 id="h2-123456c01-0012">Trait Implementations</h3>
<p class="BodyFirst">As you’ll recall from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, Rust’s coherence rules disallow multiple implementations of a given trait for a given type. Since we do not know what implementations downstream code may have added, adding a blanket implementation of an existing trait is generally a breaking change. The same holds true for implementing a foreign trait for an existing type, or an existing trait for a foreign type—in both cases, the owner of the foreign <span epub:type="pagebreak" title="52" id="Page_52"/>trait or type may simultaneously add a conflicting implementation, so this must be a breaking change.</p>
<p>Removing a trait implementation is a breaking change, but implementing traits for a <em>new</em> type is never a problem, since no crate can have implementations that conflict with that type.</p>
<p>Perhaps counterintuitively, you also want to be careful about implementing <em>any</em> trait for an existing type. To see why, consider the code in <a href="#listing3-5" id="listinganchor3-5">Listing 3-5</a>.</p>
<pre><code><span class="LiteralGray">// crate1 1.0</span>
pub struct Unit;
put trait Foo1 { fn foo(&amp;self) }
<span class="LiteralGray">// note that Foo1 is not implemented for Unit</span>

<span class="LiteralGray">// crate2; depends on crate1 1.0</span>
use crate1::{Unit, Foo1};
trait Foo2 { fn foo(&amp;self) }
impl Foo2 for Unit { .. }
fn main() {
  Unit.foo();
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-5">Listing 3-5</a>: Implementing a trait for an existing type may cause problems.</p>
<p>If you add <code>impl Foo1 for Unit</code> to <code>crate1</code> without marking it a breaking change, the downstream code will suddenly stop compiling since the call to <code>foo</code> is now ambiguous. This can even apply to implementations of <em>new</em> public traits, if the downstream crate uses wildcard imports (<code>use crate1::*</code>). You will particularly want to keep this in mind if you provide a <code>prelude</code> module that you instruct users to use wildcard imports for.</p>
<p>Most changes to existing traits are also breaking changes, such as changing a method signature or adding a new method. Changing a method signature breaks all implementations, and probably many uses, of the trait, whereas adding a new method “just” breaks all implementations. Adding a new method with a default implementation is fine though, since existing implementations will continue to apply.</p>
<p>I say “generally” and “most” here, because as interface authors, we have a tool available to us that lets us skirt some of these rules: <em>sealed traits</em>. A<em> </em>sealed trait is one that can be used only, and not implemented, by other crates. This immediately makes a number of breaking changes non-breaking. For example, you can add a new method to a sealed trait, since you know there are no implementations outside of the current crate to consider. Similarly, you can implement a sealed trait for new foreign types, since you know the foreign crate that defined that type cannot have added a conflicting implementation.</p>
<p>Sealed traits are most commonly used for <em>derived</em> traits—traits that provide blanket implementations for types that implement particular other traits. You should seal a trait only if it does not make sense for a foreign crate to implement your trait; it severely restricts the usefulness of the trait, since downstream crates will no longer be able to implement it for <span epub:type="pagebreak" title="53" id="Page_53"/>their own types. You can also use sealed traits to restrict which types can be used as type arguments, such as restricting the <code>Stage</code> type in the <code>Rocket</code> example from <a href="#listing3-2">Listing 3-2</a> to only the <code>Grounded</code> and <code>Launched</code> types.</p>
<p><a href="#listing3-6" id="listinganchor3-6">Listing 3-6</a> shows how to seal a trait and how to then still add implementations for it in the defining crate.</p>
<pre><code>pub trait CanUseCannotImplement: sealed::Sealed <span class="CodeAnnotationCode" aria-label="annotation1">1</span> { .. }
mod sealed {
  pub trait Sealed {}
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> impl&lt;T&gt; Sealed for T where T: TraitBounds {}
}
impl&lt;T&gt; CanUseCannotImplement for T where T: TraitBounds {}</code></pre>
<p class="CodeListingCaption"><a id="listing3-6">Listing 3-6</a>: How to seal a trait and add implementations for it</p>
<p>The trick is to add a private, empty trait as a supertrait of the trait you wish to seal <span class="CodeAnnotation" aria-label="annotation1">1</span>. Since the supertrait is in a private module, other crates cannot reach it and thus cannot implement it. The sealed trait requires the underlying type to implement <code>Sealed</code>, so only the types that we explicitly allow <span class="CodeAnnotation" aria-label="annotation2">2</span> are able to ultimately implement the trait.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you do seal a trait this way, make sure you document that fact so that users do not get frustrated trying to implement the trait themselves!</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-123456c01-0013">Hidden Contracts</h3>
<p class="BodyFirst">Sometimes, changes you make to one part of your code affect the contract elsewhere in your interface in subtle ways. The two primary ways this happens are through re-exports and auto-traits.</p>
<h4 id="h3-123456c01-0001">Re-Exports</h4>
<p class="BodyFirst">If any part of your interface exposes foreign types, then any change to one of those foreign types is <em>also</em> a change to your interface. For example, consider what happens if you move to a new major version of a dependency and expose a type from that dependency as, say, an iterator type in your interface. A user that depends on your interface may also depend directly on that dependency and expect that the type your interface provides is the same as the one by the same name in that dependency. But if you change the major version of your dependency, that is no longer true even though the <em>name</em> of the type is the same. <a href="#listing3-7" id="listinganchor3-7">Listing 3-7</a> shows an example of this.</p>
<pre><code><span class="LiteralGray">// your crate: bestiter</span>
pub fn iter&lt;T&gt;() -&gt; itercrate::Empty&lt;T&gt; { .. }
<span class="LiteralGray">// their crate</span>
struct EmptyIterator { it: itercrate::Empty&lt;()&gt; }
EmptyIterator { it: bestiter::iter() }</code></pre>
<p class="CodeListingCaption"><a id="listing3-7">Listing 3-7</a>: Re-exports make foreign crates part of your interface contract.</p>
<p><span epub:type="pagebreak" title="54" id="Page_54"/>If your crate moves from <code>itercrate 1.0</code> to <code>itercrate 2.0</code> but otherwise does not change, the code in this listing will no longer compile. Even though no types have changed, the compiler believes (correctly) that <code>itercrate1.0::Empty</code> and <code>itercrate2.0::Empty</code> are <em>different</em> types. Therefore, you cannot assign the latter to the former, making this a breaking change in your interface.</p>
<p>To mitigate issues like this, it’s often best to wrap foreign types using the newtype pattern, and then expose only the parts of the foreign type that you think are useful. In many cases, you can avoid the newtype wrapper altogether by using <code>impl Trait</code> to provide only the very minimal contract to the caller. By promising less, you make fewer changes breaking.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>The Semver Trick</h2>
<p class="BoxBodyFirst">The <code>itercrate</code> example may have rubbed you the wrong way. If the <code>Empty</code> type did not change, then why does the compiler not allow anything that uses it to keep working, regardless of whether the code is using version 1.0 or 2.0 of it? The answer is . . . complicated. It boils down to the fact that the Rust compiler does not assume that just because two types have the same fields, they are the same. To take a simple example of this, imagine that <code>itercrate</code> 2.0 added a <code>#[derive(Copy)]</code> for <code>Empty</code>. Now, the type suddenly has different move semantics depending on whether you are using 1.0 or 2.0! And code written with one in mind won’t work with the other.</p>
<p>This problem tends to crop up in large, widely used libraries, where over time, breaking changes are likely to have to happen <em>somewhere</em> in the crate. Unfortunately, semantic versioning happens at the crate level, not the type level, so a breaking change anywhere is a breaking change everywhere.</p>
<p>But all is not lost. A few years ago, David Tolnay (the author of <code>serde</code>, among a vast number of other Rust contributions) came up with a neat trick to handle exactly this kind of situation. He called it “the semver trick.” The idea is simple: if some type <code>T</code> stays the same across a breaking change (from 1.0 to 2.0, say), then after releasing 2.0, you can release a new 1.0 <em>minor</em> version that depends on 2.0 and replaces <code>T</code> with a re-export of <code>T</code> from 2.0.</p>
<p>By doing this, you’re ensuring that there is in fact only a single type <code>T</code> across both major versions. This, in turn, means that any crate that depends on 1.0 will be able to use a <code>T</code> from 2.0, and vice versa. And because this happens only for types you <em>explicitly</em> opt into with this trick, changes that were in fact breaking will continue to be.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-123456c01-0002">Auto-Traits</h4>
<p class="BodyFirst">Rust has a handful of traits that are automatically implemented for every type depending on what that type contains. The most relevant of these for this discussion are <code>Send</code> and <code>Sync</code>, though the <code>Unpin</code>, <code>Sized</code>, and <code>UnwindSafe</code> <span epub:type="pagebreak" title="55" id="Page_55"/>traits have similar issues. By their very nature, these add a hidden promise made by nearly every type in your interface. These traits even propagate through otherwise type-erased types like <code>impl Trait</code>.</p>
<p>Implementations for these traits are (generally) automatically added by the compiler, but that also means that they are <em>not</em> automatically added if they no longer apply. So, if you have a public type <code>A</code> that contains a private type <code>B</code>, and you change <code>B</code> so that it is no longer <code>Send</code>, then <code>A</code> is now <em>also</em> not <code>Send</code>. That is a breaking change!</p>
<p>These changes can be hard to keep track of and are often not discovered until a user of your interface complains that their code no longer works. To catch these cases before they happen, it’s good practice to include some simple tests in your test suite that check that all your types implement these traits the way you expect. <a href="#listing3-8" id="listinganchor3-8">Listing 3-8</a> gives an example of what such a test might look like.</p>
<pre><code>fn is_normal&lt;T: Sized + Send + Sync + Unpin&gt;() {}
#[test]
fn normal_types() {
  is_normal::&lt;MyType&gt;();
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-8">Listing 3-8</a>: Testing that a type implements a set of traits</p>
<p>Notice that this test does not run any code, but simply tests that the code compiles. If <code>MyType</code> no longer implements <code>Sync</code>, the test code will not compile, and you will know that the change you just made broke the auto-trait implementation.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Hiding Items from Documentation</h2>
<p class="BoxBodyFirst">The <code>#[doc(hidden)]</code> attribute lets you hide a public item from your documentation without making it inaccessible to code that happens to know it is there. This is often used to expose methods and types that are needed by macros, but not by user code. How such hidden items interact with your interface contract is a matter of some debate. In general, items marked as <code>#[doc(hidden)]</code> are only considered part of your contract insofar as their public effects; for example, if user code may end up containing a hidden type, then whether that type is <code>Send</code> or not is part of the contract, whereas its name is not. Hidden inherent methods and hidden trait methods on sealed traits are not generally part of your interface contract, though you should make sure to state this clearly in the documentation for those methods. And yes, hidden items should still be documented!</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-123456c01-0005"><span epub:type="pagebreak" title="56" id="Page_56"/>Summary</h2>
<p class="BodyFirst">In this chapter we’ve explored the many facets of designing a Rust interface, whether it’s intended for external use or just as an abstraction boundary between the different modules within your crate. We covered a lot of specific pitfalls and tricks, but ultimately, the high-level principles are what should guide your thinking: your interfaces should be unsurprising, flexible, obvious, and constrained. In the next chapter, we will dig into how to represent and handle errors in Rust code.</p>
</section>
</div></body></html>