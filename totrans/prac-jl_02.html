<html><head></head><body>
<h2 class="h" id="ch01"><span epub:type="pagebreak" id="page_3" class="calibre1"/><strong class="calibre2"><span class="big">1</span><br class="calibre3"/>GETTING STARTED</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">You don’t have to see the whole staircase, just take the first step.</em></p>
<p class="center1"><em class="calibre11">—</em>Dr. Martin Luther King Jr.</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">As mentioned in the introduction, to learn a programming language, it’s not enough to read a book—not even one as good as this. Experimenting and writing programs yourself is essential. After absorbing a key concept in the book or running a code sample, try to construct variations of the code and run them. Writing your own variations will help you achieve fluency in the language.</p>
<p class="indent">This chapter first covers how to install Julia on all the major operating systems, and then discusses the various types of coding environments. We’ll see how to install each one, and explore their unique features, advantages, and disadvantages.</p>
<h3 class="h2" id="ch01lev1"><strong class="calibre2">Installation Guide</strong></h3>
<p class="noindent">Of course, to be able to do any of this you will need access to a Julia system. If you’re already set up to run Julia code, you can safely skip this <span epub:type="pagebreak" id="page_4"/>whole section. If not, you can skip the subsections covering installation on operating systems that you don’t use, but you should probably read everything else.</p>
<h4 class="h3" id="ch01lev1sec1"><strong class="calibre2"><em class="calibre4">Hardware Requirements</em></strong></h4>
<p class="noindent">For learning Julia, almost any computer will be sufficient. It should have at least 2GB of RAM, but twice that amount will be more comfortable. You’ll need about 0.5GB of free disk space to install Julia, but you should have at least 3GB of additional space for the packages that you’ll install for plotting and other purposes.</p>
<p class="indent">These modest requirements are fine for learning the language and even for doing many real calculations, although you may require beefier hardware for larger-scale projects. Julia is used for calculations at every scale, and it can make efficient use of all types of hardware from laptops to GPU array processors to the world’s largest supercomputers (see “Further Reading” on <a href="ch01.xhtml#fur1" class="calibre10">page 23</a> for an example). I have run every example calculation in this book on a very modestly powered laptop, so all of the code here should run with no problems on any machine that you’re likely to be using.</p>
<p class="indent">Julia runs on Linux, FreeBSD, macOS, and Windows. At the time of writing, Julia is fully supported on these systems:</p>
<ul class="calibre12">
<li class="noindent1">Linux 2.6.18+: x86-64 (64-bit), i686 (32-bit), and ARMv8 (64-bit)</li>
<li class="noindent1">FreeBSD 11.0+: x86-64 (64-bit)</li>
<li class="noindent1">macOS 10.9+: x86-64 (64-bit)</li>
<li class="noindent1">Windows 7+: x86-64 (32- and 64-bit)</li></ul>
<p class="indent">These installation requirements may change, so check <a href="https://julialang.org/downloads/" class="calibre10"><em class="calibre11">https://julialang.org/downloads/</em></a> for up-to-date information.</p>
<p class="indent">Julia also runs on some system versions and architectures not listed here, but with reduced support, weaker guarantees, or possibly hampered functionality. It can also take advantage of more specialized hardware—for example, graphical processing unit array processors, which we’ll discuss in later chapters.</p>
<h4 class="h3" id="ch01lev1sec2"><strong class="calibre2"><em class="calibre4">Prerequisites</em></strong></h4>
<p class="noindent">To use Julia effectively, you need to know a few things about how to operate your computer. You need a basic knowledge of the terminal and the command line: how to create and change directories (folders), view a list of files, find out how much storage space is available on your hard drive, and delete files.</p>
<p class="indent">Every operating system has various graphical utilities for accomplishing those tasks, both built-in and as third-party software, but it is a good idea for the computational scientist to become familiar with the command line and use it routinely. There’s a good chance you’ll find yourself in a remote <span epub:type="pagebreak" id="page_5"/>computing situation some day, where the command line may be the only way to communicate with the remote machine.</p>
<p class="indent">It’s also a good idea, even if your personal computer uses some other operating system, to learn how to perform these rudimentary tasks on Linux, as that is by far the most common frontend OS on compute servers for scientific work. If your daily driver comes from Apple, that won’t be a problem, as the basic commands in the macOS BSD-derived terminal are nearly the same as on Linux. If you’re accustomed to Windows, you may need to learn some translations; however, that is beyond the scope of this book, and you won’t need to know the Linux dialect to use Julia on your personal computer.</p>
<p class="indent">You’ll also need to be familiar with an editor on your system that can save files in a plaintext format. Most programmers use Vim, Emacs, or a more elaborate integrated development environment (IDE)—options that we will discuss further in the next section. You can use any editor you’re familiar with, but graphical editors such as Word are not the best choice. However, if you really want to use such programs, they’ll work. Just be sure to save your creations as plaintext files, and use a monospaced font, which will work better for writing code.</p>
<h4 class="h3" id="ch01lev1sec3"><strong class="calibre2"><em class="calibre4">Julia Versions</em></strong></h4>
<p class="noindent">Most people, no matter their platform, will download Julia from the official Julia website at <a href="https://julialang.org/downloads/" class="calibre10"><em class="calibre11">https://julialang.org/downloads/</em></a>. Whether you get it there or somewhere else, keep in mind that Julia, although it’s been stable for several years, is still undergoing rapid development. <em class="calibre11">Stable</em> in this context means that you can expect no breaking changes: programs that you write now, or have written using any version of Julia from v1.0 onward, will continue to work as you upgrade your Julia installation in the future, with few exceptions. However, <em class="calibre11">rapid development</em> means that the particular version you have installed can make a substantial difference.</p>
<p class="indent">Regarding the language implementation itself, the Julia team has made continuous progress in speed and responsiveness since the first public release, and that’s likely to continue, which is reason enough to recommend using the most recent stable language version. Regarding the ecosystem generally, many important packages, which are libraries of Julia code that you can use in your own programs, are also progressing rapidly, and new ones are emerging every month. Older Julia versions may not be compatible with new, or newer versions of, important packages.</p>
<p class="indent">In the download section of the Julia website, you will find downloads corresponding to various “releases,” or recent versions, of Julia. Most people will be best served by the one identified as “Current stable release.” “Upcoming release” is a beta version of the next stable release. It will have more recently added features, but it will also have slightly more compatibility problems with various packages and may be afflicted with some minor bugs. Depending on when you are reading this, the “Long-term support” release may or may not have all of the features this book uses. In general, to avoid any <span epub:type="pagebreak" id="page_6"/>confusion arising from possibly different behavior from the code samples here, ensure that you install Julia v1.6.0 or greater and avoid beta releases.</p>
<h4 class="h3" id="ch01lev1sec4"><strong class="calibre2"><em class="calibre4">Installation</em></strong></h4>
<p class="noindent">This section contains instructions for various options to install Julia on every OS for which it is available. You only need to pay attention to the sections that apply to you.</p>
<p class="indent">As an alternative to these instructions, which leave you with a Julia binary ready to run, you can download the Julia source code at the same location as the other download links. As Julia is completely free and open source software, the source is always available for experts to inspect and compile themselves. If you want to run Julia on an unusual system for which a binary is not supplied, this is your only option.</p>
<h5 class="h4" id="ch01sec1sec1"><strong class="calibre2">On Linux and FreeBSD</strong></h5>
<p class="noindent">Almost every Linux distribution has its own package management system: an official mechanism for installing programs and keeping them updated. Using the official package manager has two advantages. First, it is integrated, meaning that dependencies among all the installed programs should be automatically resolved and everything will work together. The second benefit is security: packages in the official repositories are generally vetted and unlikely to contain malicious code.</p>
<p class="indent">Unfortunately, it takes considerable time for software to be packaged and included in the official repositories of most Linux distributions. Projects such as Julia that are undergoing rapid development should generally not be installed using the package manager. The distribution’s version will lag too far behind the current versions that you can get directly from the Julia project. This is less of a problem for certain Linux distributions that employ a rolling release schedule and keep their packages up to date, but it makes the use of the package manager in, for example, Debian-based distributions a poor choice for Julia.</p>
<p class="indent">For these reasons, if you are on Linux, the best strategy is to go to the Julia download page at <a href="https://julialang.org/downloads/" class="calibre10"><em class="calibre11">https://julialang.org/downloads/</em></a>. Look for the heading “Current stable release” and, under that, find the entry for your machine’s architecture. Most people will want the 64-bit download for “Generic Linux on x86.” Clicking the download link copies a file to your computer with the extension <em class="calibre11">.tar.gz</em>. It will be a little more than 100MB.</p>
<p class="indent">The default location for browser downloads for most people is the <em class="calibre11">Downloads</em> directory inside their home directory, but your browser may be configured differently. After you have found the download location, you should see the file you just acquired, named something like <em class="calibre11">julia-1.</em>X<em class="calibre11">.0-linux-x86_64.tar.gz</em>, which indicates v1.<em class="calibre11">X</em>.0 of Julia, built for Linux systems with the x86, 64-bit architecture. The double extension indicates that this is a compressed tarfile. You can uncompress and un-archive the file with a single command (substituting the actual downloaded filename):<span epub:type="pagebreak" id="page_7"/></p>
<pre class="calibre13"><span class="codestrong">tar zxvf julia-1.<span class="codeitalic">X</span>.0-linux-x86_64.tar.gz</span></pre>
<p class="indent">The <code>tar</code> command should already be installed on any normal Linux system. After entering this command, you should see the names of a bit more than 2,000 files scroll by in your terminal, indicating the creation of subdirectories and the un-archiving of the files needed for an initial installation of Julia to work. You won’t need to do anything directly with any of these files except one. After the process is complete, which should take under a minute, you’ll have a new directory with a name taken from the beginning of the archive’s name. For the example <em class="calibre11">julia-1.</em>X<em class="calibre11">.0-linux-x86_64.tar.gz</em> download file, that directory is <em class="calibre11">julia-1.</em>X<em class="calibre11">.0</em>. The installation will take up about four times the space of the tarfile, which you can delete after the <code>tar</code> command completes successfully.</p>
<p class="indent">The next step is to set up your system so that entering <code>julia</code> in the terminal starts the Julia program that you just installed.</p>
<p class="indent">To make the final installation step, first check your path by entering <span class="codestrong1">echo</span> <span class="codestrong1">$PATH</span>. If <em class="calibre11">/usr/local/bin</em> is listed, navigate there. If it’s not, but there’s another directory in your path where you like to keep local commands, go there. Otherwise, it’s a good idea to establish such a directory, which can be <em class="calibre11">/usr/local/bin</em> or something else. The method for doing that varies a bit depending on your shell. For the most common case of bash and bash-compatible shells, add this line to your <em class="calibre11">.bash_profile</em> startup file (which you can find in your home directory):</p>
<pre class="calibre13"><span class="codestrong">PATH=/usr/local/bin:$PATH; export PATH</span></pre>
<p class="indent">After you have navigated to <em class="calibre11">/usr/local/bin</em> or to your local command directory of choice, make a symbolic link to the file <em class="calibre11">/bin/julia</em> within your new Julia installation directory, and call it <em class="calibre11">julia</em>. For our example, the command is:</p>
<pre class="calibre13"><span class="codestrong">ln -s $HOME/Downloads/julia/julia-1.<span class="codeitalic">X</span>.0/bin/julia julia</span></pre>
<p class="indent">To create the link you need to be root, or use <code>sudo</code>.</p>
<p class="indent">You can keep your downloaded Julia installation anywhere, but you’ll need to update the link set in the command if you move it.</p>
<p class="indent">To check that your new Julia installation is working, open a fresh shell and enter <code>julia</code>. An interactive prompt should appear, waiting for you to type your first line of Julia code.</p>
<h5 class="h4" id="ch01sec1sec2"><strong class="calibre2">On macOS</strong></h5>
<p class="noindent">You can install Julia on your Apple computer the same way you install any other application. Navigate to the Julia download page, find the section for your desired version, and click the 64-bit link in the table. A normal macOS<em class="calibre11">.dmg</em> file will be downloaded to your system, which should open itself. You should see the Julia icon of red, green, and purple circles arranged in a pyramid. Drag this to your <em class="calibre11">Applications</em> folder as usual.</p>
<p class="indent">When you double-click this icon, a terminal should open with the Julia interactive prompt ready for your first command.</p>
<p class="indent"><span epub:type="pagebreak" id="page_8"/>The next step is to make arrangements so you can start Julia from the terminal command line and not need to click the icon, which will be convenient later on. These preparations also will allow you to run saved Julia programs without using the REPL.</p>
<p class="indent">Enabling this behavior requires two steps. If the Julia interactive prompt is still waiting for you, press <small class="calibre5">CTRL-D</small> to quit the REPL or enter <span class="codestrong1">exit()</span>. Next, at the shell command line, enter the following command to delete any existing <code>julia</code> command that might be left over from a previous installation:</p>
<pre class="calibre13"><span class="codestrong">rm -f /usr/local/bin/julia</span></pre>
<p class="indent">Then enter the following (change <span class="codeitalic1">Julia-1.</span><code>X</code><span class="codeitalic1">.app</span> to match the version that you have installed):</p>
<pre class="calibre13"><span class="codestrong">ln -s /Applications/Julia-1.<span class="codeitalic">X</span>.app/Contents/Resources/julia/bin/julia /usr/local/bin/julia</span></pre>
<p class="indent">You may also want to check for the presence of <code>julia</code> commands elsewhere in your path, such as in <code>/usr/bin</code>, and delete them or move them out of the command path, so that you don’t inadvertently invoke an older executable from a previous installation.</p>
<p class="indent">This command creates what’s known as a <em class="calibre11">symbolic link</em> to the actual Julia binary program stored deep within your <em class="calibre11">Applications</em> folder. Now you can type <code>julia</code> in any terminal to start the interactive Julia shell or to run Julia programs.</p>
<h5 class="h4" id="ch01sec1sec3"><strong class="calibre2">On Windows</strong></h5>
<p class="noindent">Some installations of Windows do not have a modern terminal set up. You will need such a program to run Julia effectively and to follow the examples in this book. If you don’t already have a good terminal installed, a reasonable option is the Windows Terminal, a free program available from the Microsoft Store. Before doing anything else, install this terminal or something equally capable and make sure that you know how to start and use it.</p>
<p class="indent">Navigate to the Julia download page and find the section for your desired version (see “Julia Versions” on <a href="ch01.xhtml#ch01lev1sec3" class="calibre10">page 5</a>).</p>
<p class="indent">If you know you’re on a 64-bit version of Windows, click the 64-bit download link. If you’re on 32-bit or are not sure of the architecture, click the 32-bit link. This will get you a Julia install that will work on both architectures, but using the 64-bit build has some advantages if you know you can use it.</p>
<p class="indent">This will download a <em class="calibre11">.exe</em> installer, which you should run next. It will inform you of the installation directory; be sure to make a note of it.</p>
<p class="indent">The following instructions to set up Julia to run from a terminal will work for recent versions of Windows. If you’re running Windows 8 or earlier, you’ll find specific installation instructions linked from the Julia download page.</p>
<p class="indent">Recent versions of the installer offer a checkbox for setting the Julia path. If yours doesn’t, or you prefer to choose the path yourself, follow this procedure:<span epub:type="pagebreak" id="page_9"/></p>
<ol class="calibre14">
<li class="noindent1">Open <code>Run</code> by pressing <strong class="calibre7">Windows key-R</strong> and enter the following command to open the System Variables window so you can edit the path:
<pre class="calibre13"><span class="codestrong">rundll32 sysdm.cpl,EditEnvironmentVariables</span></pre></li>
<li class="noindent1">Click <strong class="calibre7">New</strong> and enter (or paste) the path the installer told you about (you copied that information, right?). If you’ve lost the path, look for a program with “julia” in the name in <em class="calibre11">C:\Users\&lt;your_username&gt;\AppData\Local\Programs</em>.</li>
<li class="noindent1">Click <strong class="calibre7">OK</strong>, open a terminal, and enter <span class="codestrong1">julia</span> to test your setup. You should see a terminal-flavored rendering of the Julia logo, a brief message, and an interactive prompt, waiting for your first line of Julia code.</li>
</ol>
<p class="noindent">Another option on Windows is provided by package managers. The open source edition of the popular Chocolately package manager, for example, installs a reasonably up-to-date Julia version.</p>
<h5 class="h4" id="ch01sec1sec4"><strong class="calibre2">Using Docker</strong></h5>
<p class="noindent">Read this section if you know what Docker is and you are sure that you want to install Julia by using a Docker image.</p>
<p class="indent">If that’s you, you are fortunate that a Docker community exists for Julia. Go to <a href="https://hub.docker.com/_/julia" class="calibre10"><em class="calibre11">https://hub.docker.com/_/julia</em></a>, which contains a description of the image for using Julia. I won’t list the details of what systems and versions are supported, because those are likely to change frequently. The page has up-to-date information for installing and using the Julia container on your machine. Aside from that, everything else in this book applies identically to Julia run from within a Docker container and Julia installed in the conventional way.</p>
<h4 class="h3" id="ch01lev1sec5"><strong class="calibre2"><em class="calibre4">Privacy Note</em></strong></h4>
<p class="noindent">The Julia team is scrupulous in pointing out a privacy issue that, although of no concern to most people, and something that most would take for granted in any case, deserves to be mentioned. Julia’s package management system (something we’ll discuss in later chapters) is designed with the expectation that you are connected to the internet, and it will download software as needed for you to complete your tasks. This means that, of necessity, your IP address, what you downloaded, and when, are stored on a server somewhere, at least for a while.</p>
<h3 class="h2" id="ch01lev2"><strong class="calibre2">The Julia Coding Environment</strong></h3>
<p class="noindent">With the basic Julia system installed, let’s turn to the various options for interacting with it. Different methods of talking to Julia are best suited for different situations. Also, if you have a favorite editor or IDE, this section will explain how you can program in Julia without changing your workflow.</p>
<p class="indent"><span epub:type="pagebreak" id="page_10"/><a href="ch01.xhtml#ch1tab1" class="calibre10">Table 1-1</a> is a brief table of the coding environments discussed next and their salient advantages and disadvantages:</p>
<p class="tabcap" id="ch1tab1"><strong class="calibre7">Table 1-1:</strong> Coding Environment Comparison</p>
<table class="all">
<colgroup class="calibre15">
<col class="calibre16"/>
<col class="calibre17"/>
<col class="calibre18"/>
</colgroup>
<thead class="calibre19">
<tr class="calibre20">
<th class="table-h"><p class="noindent"><strong class="calibre7">Environment</strong></p></th>
<th class="table-h"><p class="noindent"><strong class="calibre7">Advantages</strong></p></th>
<th class="table-h"><p class="noindent"><strong class="calibre7">Disadvantages</strong></p></th>
</tr>
</thead>
<tbody class="calibre21">
<tr class="calibre20">
<td class="gray"><p class="noindent">REPL</p></td>
<td class="gray"><p class="noindent">Nothing to install, quick, useful modes</p></td>
<td class="gray"><p class="noindent">Graphics in separate windows, repetitive entry</p></td>
</tr>
<tr class="calibre20">
<td class="calibre22"><p class="noindent">Text editors</p></td>
<td class="calibre22"><p class="noindent">File organization, editing convenience, REPL integration</p></td>
<td class="calibre22"><p class="noindent">No graphics, limited interactivity</p></td>
</tr>
<tr class="calibre20">
<td class="gray"><p class="noindent">Jupyter</p></td>
<td class="gray"><p class="noindent">Huge community, inline graphics, interactivity, multiple languages, good for sharing</p></td>
<td class="gray"><p class="noindent">Poor organization, no version control, hidden state, browser text entry</p></td>
</tr>
<tr class="calibre20">
<td class="calibre22"><p class="noindent">Pluto</p></td>
<td class="calibre22"><p class="noindent">Inline graphics, sophisticated interactive controls, reactive and consistent, full REPL integration, backed by normal Julia file</p></td>
<td class="calibre22"><p class="noindent">Julia only, browser text entry</p></td>
</tr>
<tr class="calibre20">
<td class="gray"><p class="noindent">VS Code</p></td>
<td class="gray"><p class="noindent">Integrated editor, REPL, graphics, good language support</p></td>
<td class="gray"><p class="noindent">Less powerful as an editor than Vim or Emacs</p></td>
</tr>
</tbody>
</table>
<p class="indent">Let’s take a more detailed look at each of these options.</p>
<h4 class="h3" id="ch01lev1sec6"><strong class="calibre2"><em class="calibre4">The Julia REPL</em></strong></h4>
<p class="noindent">When you enter <code>julia</code> in the terminal, you enter the <em class="calibre11">REPL</em>, or <em class="calibre11">read-eval-print loop</em>. You’ll see a welcome message and the prompt will change from your system’s shell prompt to Julia’s.</p>
<h5 class="h4" id="ch01sec1sec5"><strong class="calibre2">REPL Modes</strong></h5>
<p class="noindent">The REPL has several modes. The initial mode, with the <code>julia&gt;</code> prompt, is the normal mode in which you will spend most of your REPL time. Here you can enter any Julia expression, press <small class="calibre5">ENTER</small>, and Julia will print the result of the expression. Even if you don’t know any Julia yet, try it out to make sure everything is working correctly. Enter an arithmetic expression such as <code>1 + 1</code>, and you should see the result immediately after pressing ENTER.</p>
<p class="indent">This mode of operation will be familiar to you if you’ve used Python, Node, APL, or any other REPL-based language. Unlike Python, Julia is compiled rather than interpreted. This difference will have implications in how you use the REPL in later chapters, but for now, you can use the Julia interactive interface just like any other REPL you may have used before.</p>
<p class="indent">The Julia REPL’s normal mode is a sophisticated environment with a few tricks up its sleeve to make your work easier. It has a “paste mode” that lets you paste in code samples you may have copied, for instance, from a web page, and that may be littered with the <code>julia&gt;</code> prompt and have code interleaved with explanatory text. The REPL will know to just execute the actual code on any line starting with <code>julia&gt;</code>, provided the first line pasted starts with it. (At the time of writing, paste mode does not work on Windows.)</p>
<p class="indent"><span epub:type="pagebreak" id="page_11"/>The REPL is fully readline capable. This means you can use the up arrow and down arrow to recall earlier commands and edit them before repeating them. This feature even works well for multiline code blocks such as function definitions. To search for a previous command, you can press CTRL-R and type some text contained within that command. Your command and code history is saved between REPL sessions, so you can quit the REPL, come back the next day, and still recall your commands with the arrow keys. The history is stored in the <em class="calibre11">.julia/logs/repl_history.jl</em> file within your home directory. This file contains all the code you enter, and it even timestamps each entry, but it does not record the results Julia returns.</p>
<p class="indent">Another useful REPL mode is the help mode. Press <strong class="calibre7">?</strong>, and the prompt will change to <code>help?&gt;</code>. Enter any Julia function, data type, operator, or library, and you will see a nicely formatted description of the item you entered, often with a useful collection of examples.</p>
<pre class="calibre13">help?&gt; <span class="codestrong">Base</span>
search: Base basename AbstractSet AbstractSlices Broadcast broadcast broadcast! AbstractString
AbstractDisplay


  Base



  The base library of Julia. Base is a module that contains basic functionality
  (the contents of base/). All modules implicitly contain using Base, since this is needed
  in the vast majority of cases.</pre>
<p class="indent">Later on you’ll learn how to document your own functions in a way that hooks into the REPL help system.</p>
<p class="indent">The REPL also has a shell mode, activated by pressing <code>;</code>, that allows you to enter system shell commands from within the REPL session:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">ilj = "I love Julia"</span>
"I love Julia"

# Enter ";" here to switch to shell mode.

shell&gt; <span class="codestrong">echo $ilj</span>
I love Julia</pre>
<p class="indent">We can use shell mode for simple commands. As the listing shows, we can interpolate Julia variables, but piping and redirection won’t work.</p>
<p class="indent">Another REPL mode you will use often is the package mode, activated by pressing <code>]</code>, which we’ll cover in <a href="ch03.xhtml" class="calibre10">Chapter 3</a> when we explore how to use packages and modules. For now, just be aware that the package system in Julia is an integral part of the language and environment, so much so that it’s built into the REPL. Julia developers don’t need to wrestle with several competing third-party package systems, nor with the inevitable “dependency hell” that afflicts some other languages.</p>
<p class="indent"><span epub:type="pagebreak" id="page_12"/>To exit out of any of these modes back into the normal (sometimes called “Julian”) REPL mode, press <small class="calibre5">BACKSPACE</small> while the cursor is at the starting position.</p>
<p class="indent"><small class="calibre5">TAB</small> works in any REPL mode to generate context-aware completions. If there is a unique completion, it is entered for you at the cursor; otherwise, the REPL presents you with a list of options.</p>
<h5 class="h4" id="ch01sec1sec6"><strong class="calibre2">REPL Colors</strong></h5>
<p class="noindent">To help you to know which mode you’re in, the REPL colors each of its prompts differently. The colors help visually separate the prompts from the expressions you enter and their results. The REPL also uses colors in certain types of output, such as help output, to distinguish elements like keywords and variables from normal text. The default colors work well when using a terminal with a black or dark background, which is the most popular choice. However, they are too light to be easily legible on a white or very light background. I use such a background for the illustrations in this book, as it prints better than the black background I usually use on my computer. If you use a light terminal background, or simply prefer a different appearance from the default, you can edit a configuration file to change any of the REPL colors.</p>
<p class="indent">In your home directory, you will find a directory called <em class="calibre11">.julia</em> (note the dot: in most people’s shells, as they are typically configured, this directory will not be listed using the usual commands unless you add a flag to request listing of “invisible files,” and graphical file management tools may or may not show the directory by default). Within <em class="calibre11">.julia</em>, there may already be a <em class="calibre11">config</em> directory; if not, create one. Enter the <em class="calibre11">config</em> directory and edit the <em class="calibre11">startup.jl</em> file (or create it if it doesn’t exist). Add the following to <em class="calibre11">startup.jl</em>:</p>
<pre class="calibre13"><span class="codestrong">function customize_colors(repl)
    repl.prompt_color = Base.text_colors[28]
    repl.help_color = Base.text_colors[178]
end

atreplinit(customize_colors)</span></pre>
<p class="indent">You have just written your first Julia function. Julia runs the <em class="calibre11">startup.jl</em> file every time the REPL starts (the <em class="calibre11">.jl</em> extension is used for Julia programs). This function simply defines two variables: one for the color of the prompt in normal mode and the other for help mode. The two numbers in square brackets are ANSI color codes, which are understood by most modern terminal programs. I’ve chosen two colors that work well on my monitor when using a white terminal background. If you want to pick your own colors, you can find tables of the 256 ANSI colors and their codes by searching the web for “ANSI color codes.” I’ve redefined only these two colors because the <span epub:type="pagebreak" id="page_13"/>other defaults happened to work well. If you want to change some other colors, you can define the <code>repl.shell_color</code>, <code>repl.input_color</code>, and <code>repl.answer_color</code> variables as well.</p>
<p class="indent">Julia also understands several color <em class="calibre11">names</em>, but too few to allow an ideal selection.</p>
<h5 class="h4" id="ch01sec1sec7"><strong class="calibre2">Unicode Characters</strong></h5>
<p class="noindent">Julia allows the use of Unicode characters in variable names and for other identifiers. This means you can make formulas in your Julia programs look more like real math, using, for instance, Greek letters and subscripts. Some people have set up their systems to allow them to type such characters easily. Even if you haven’t, you can still use these characters thanks to a Unicode input mode provided by the REPL. If you enter a backslash (<code>\</code>) followed by a string of ASCII characters, then press <small class="calibre5">TAB</small>, one of three things will happen. If the REPL recognizes the string as one of its codes for a Unicode character, the entire entry, beginning with the backslash, will be replaced by that character. If the code you typed is the beginning of a character code or one of several possible codes, the tab completion mechanism will work in the normal way. If the REPL does not recognize what you typed, it will do nothing.</p>
<p class="indent">A complete list of the Unicode character codes recognized by the REPL is maintained at <a href="https://docs.julialang.org/en/v1/manual/unicode-input/" class="calibre10"><em class="calibre11">https://docs.julialang.org/en/v1/manual/unicode-input/</em></a>. Those familiar with LaTeX syntax will be happy to know that all the Greek letters and some other symbols that have LaTeX commands are on the list unchanged. For example, to input <em class="calibre11">α</em> in the REPL, type <span class="codestrong1">\alpha</span> and then press <small class="calibre5">TAB</small>. There is much more—even a wide selection of emoji.</p>
<p class="indent">If you want to know the LaTeX-style abbreviation for a particular Unicode character, perhaps one that you’ve copied from the documentation, enter the help mode in the REPL, paste in the character, and press <small class="calibre5">ENTER</small>. If an abbreviation exists, the help system will tell you what it is.</p>
<p class="indent"><a href="ch01.xhtml#ch1fig1" class="calibre10">Figure 1-1</a> shows a simple example of what you can do with an expanded character set.</p>
<div class="image1"><img alt="Image" id="ch1fig1" src="../images/ch01fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 1-1: Using Unicode in the REPL</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_14"/>This is more than just fun and games. The ability to employ a wider collection of characters, including Greek letters and subscripts, allows us to make our code more concise and expressive.</p>
<h4 class="h3" id="ch01lev1sec7"><strong class="calibre2"><em class="calibre4"><em class="calibre4">Text Editors</em></em></strong></h4>
<p class="noindent">Julia programmers use text editors routinely, either in addition to or in coordination with the REPL. I’ll go over some of the relevant features of the most-used programmer’s editors here. If you use something else, be sure to search for any enhancements, either built-in or in the form of third-party plug-ins, specific to Julia. These enhancements typically include syntax highlighting, which helps immensely in avoiding typos in your code, and can include more sophisticated features, such as code formatting and execution.</p>
<h5 class="h4" id="ch01sec1sec8"><strong class="calibre2">Vim</strong></h5>
<p class="noindent">Vim is an excellent editor for programming in any language, and it has valuable Julia support. I recommend installing the <code>julia-vim</code> plug-in, available at <a href="https://github.com/JuliaEditorSupport/julia-vim" class="calibre10"><em class="calibre11">https://github.com/JuliaEditorSupport/julia-vim</em></a>, where you will also find its documentation. The plug-in requires Vim version 7.4 or greater. To take the best advantage of <code>julia-vim</code>, ensure that the built-in <code>matchit</code> plug-in is enabled by executing the <span class="codestrong1">:runtime macros/matchit.vim</span> Vim command, which should be in your Vim startup file. This plug-in adds a Julia file type with syntax coloring and awareness of the block structure of Julia syntax. It extends the <code>matchit</code> operation by allowing you to jump to the end or beginning of function definitions and other blocks by entering <code>%</code>. You can also select or delete blocks, or the bodies of blocks, in the same way that Vim allows you to operate on other text objects.</p>
<p class="indent">The plug-in also emulates the REPL’s LaTeX-style entry of Unicode characters. For this it provides two options: you can have it wait for you to press TAB, as the REPL does, or it can expand the entry on the fly as soon as it sees a character (usually a space) that seems to indicate the end of the entry (the on-the-fly mode does not support emoji, however).</p>
<p class="indent">Another option for recent versions of NeoVim or Vim is to install language support for tree-sitter, which adds syntax-aware highlighting and other features to the editor. If you have Vim version 8.0 or greater, which I highly recommend, or the NeoVim fork, you can interact with <em class="calibre11">any</em> REPL directly, including the Julia REPL. By “interact,” I mean that you can remain in an editing buffer containing your Julia program and send selected lines, expressions, or blocks directly to the REPL for execution. The execution is asynchronous, so you can continue editing while Julia is churning through a time-consuming command. Communication with the REPL is two-way, so you can also send results printed in the REPL back into the editing buffer. The following instructions apply to Vim, but NeoVim users should be able to adapt them to that program.</p>
<p class="indent">First, install the <code>vim-sendtowindow</code> plug-in, which lives at <a href="https://github.com/karoliskoncevicius/vim-sendtowindow" class="calibre10"><em class="calibre11">https://github.com/karoliskoncevicius/vim-sendtowindow</em></a>. After opening the editing buffer of choice, execute the <span class="codestrong1">:term julia</span> Vim command. If you have the <code>julia</code> <span epub:type="pagebreak" id="page_15"/>command set up properly (see <a href="ch01.xhtml#ch01lev1" class="calibre10">“Installation”</a> on <a href="ch01.xhtml#ch01lev1" class="calibre10">page 6</a>), a new Vim buffer should open with the Julia REPL running within it, below the editing window.</p>
<p class="indent">Now you can select any text in the editing window and press the spacebar followed by <code>j</code> to send it to the REPL. If you’d prefer some other shortcut for this operation, the <code>vim-sendtowindow</code> web page explains how to set it up. You can also define shortcuts for sending text to the right, left, and up, which is handy for sending text <em class="calibre11">from</em> the REPL and in case you prefer to split your windows vertically. The <code>:term</code> command, with its asynchronous execution of commands, is built into Vim. The plug-in provides a convenient way to send text back and forth between the editing and terminal buffers. The author of <code>vim-sendtowindow</code> maintains a list of plug-ins with similar functionality on its website.</p>
<p class="indent">Similar REPL interactions are possible with earlier versions of Vim, using plug-ins such as <code>ScreenSend</code>, but the <code>term</code> command in version 8 makes REPL interaction smoother and less error prone.</p>
<h5 class="h4" id="ch01sec1sec9"><strong class="calibre2">Emacs</strong></h5>
<p class="noindent">Emacs is a powerful programmer’s editor with sophisticated Julia support available. The official Julia major mode for Emacs, called <code>julia-emacs</code>, is developed on GitHub at <a href="https://github.com/JuliaEditorSupport/julia-emacs" class="calibre10"><em class="calibre11">https://github.com/JuliaEditorSupport/julia-emacs</em></a>. The creators of the Julia language are contributors to the project, which is probably one of the reasons that a deep and detailed knowledge of the language’s structure and syntax is built into the mode. Once installed, Emacs will display Julia code using a variety of colors and font styles to clarify its syntax. It also provides movement among and manipulation of code structures such as blocks.</p>
<p class="indent">To install <code>julia-emacs</code>, first enable the MELPA repository (<a href="https://melpa.org" class="calibre10"><em class="calibre11">https://melpa.org</em></a>) and add <span class="codestrong1">(require 'julia-mode)</span> to your Emacs initialization file. For most people, this will be <em class="calibre11">.emacs</em> in their home directory. For a smooth experience, you should be running a version of Emacs that is at least 24.1. If your version is earlier, an upgrade would be advisable for using Emacs and Julia together.</p>
<p class="indent">Emacs shines at interacting with REPL-based languages, and Julia is no exception. Several minor modes are available specifically for Julia interaction. One of the most popular is <code>julia-repl</code>, also developed on GitHub and available at <a href="https://github.com/tpapp/julia-repl" class="calibre10"><em class="calibre11">https://github.com/tpapp/julia-repl</em></a>. It’s designed to work with the aforementioned <code>julia-emacs</code>, and you must have at least version 25 of Emacs installed.</p>
<p class="indent">To install <code>julia-repl</code>, edit your <em class="calibre11">.emacs</em> initialization file, adding the following lines:</p>
<pre class="calibre13"><span class="codestrong">(add-to-list 'load-path path-to-julia-repl)
(require 'julia-repl)
(add-hook 'julia-mode-hook 'julia-repl-mode)</span></pre>
<p class="indent">Now you can start a Julia REPL right from within Emacs. It will run in an ANSI terminal, with the full complement of text colors and formatting. A <span epub:type="pagebreak" id="page_16"/>table of keyboard shortcuts is available on the mode’s GitHub page. You can perform the usual sending of fragments, whole blocks, or the entire buffer to the REPL for execution. In addition, the built-in knowledge of Julia allows the mode to do such things as listing all the methods of a function, which will make more sense after you read <a href="ch08.xhtml" class="calibre10">Chapter 8</a>.</p>
<h4 class="h3" id="ch01lev1sec8"><strong class="calibre2"><em class="calibre4">Jupyter Notebooks</em></strong></h4>
<p class="noindent">You can use Julia from within a web browser, in two main ways, in what is referred to as a <em class="calibre11">notebook</em> interface. The older way is the Jupyter Notebook. Jupyter popularized the notebook concept in the free software arena, and it’s widely used in the Julia, Python, and R communities. In fact, the word <em class="calibre11">Jupyter</em> is a mashup of the names of those three programming languages.</p>
<p class="indent">If you want to use or explore a notebook interface and do not have a particular reason to use Jupyter, proceed directly to the next section and learn about Pluto. Pluto offers the same style of notebook interactivity as Jupyter while improving on the concept. For those who need to use Jupyter to collaborate with others using the system, who want to use other languages (besides Julia) with the same notebook interface, or who desire to explore existing Jupyter Notebooks, this section is designed to get you started.</p>
<p class="indent">If you already have Jupyter set up and working on your computer, you merely need to install the Julia backend. In the Julia REPL, press <strong class="calibre7">]</strong> to enter the package mode (see <a href="ch01.xhtml#page_11" class="calibre10">page 11</a>). Make sure you’re connected to the internet, and enter the <span class="codestrong1">add IJulia</span> command to download and install the Julia backend for the notebook and the packages that it depends on. This is a fairly big install and will take some time, but the REPL will keep you informed with an animated display showing the progress of the downloads and the precompilation of modules. When the process is complete, enter <span class="codestrong1">jupyter notebook</span> either at a separate system shell prompt or using the REPL shell mode to launch the notebook.</p>
<p class="indent">If you don’t already have Jupyter installed, after the installation described earlier is complete, enter the following lines in the Julia REPL:</p>
<pre class="calibre13"><span class="codestrong">using IJulia
notebook()</span></pre>
<p class="indent">Julia will ask if you want to install Jupyter using the <code>Conda</code> package. Answer in the affirmative. This next phase of installation should be quicker than the <code>IJulia</code> install, but may still take some time. When the software is ready, Julia will open a window or tab in your default browser with the starting Jupyter page. To start up Jupyter in future sessions, repeat these commands in a Julia REPL.</p>
<p class="indent">When the Jupyter Notebook page opens, you’ll have a drop-down list of installed kernels, or language backends. Choose the Julia kernel, and a new tab or window will open. On that page, you can enter Julia expressions in “cells.” When you press <small class="calibre5">CTRL-ENTER</small> while the cursor is in a cell, Julia will evaluate the expression and print the result in an output cell underneath it.</p>
<p class="indent"><span epub:type="pagebreak" id="page_17"/>Because we are in a web browser, the system can take advantage of the ability to format text and display graphics. <a href="ch01.xhtml#ch1fig2" class="calibre10">Figure 1-2</a> shows a Jupyter Notebook after I’ve executed a few cells.</p>
<div class="image1"><img alt="Image" id="ch1fig2" src="../images/ch01fig02.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 1-2: Using Jupyter with Julia</em></p>
<p class="indent">The last cell is a command to create a surface plot, which directly embeds the plot in the page.</p>
<p class="indent">You don’t need to worry about saving your work with Jupyter, as it makes frequent autosaves, as indicated with the notice near the top of the page in <a href="ch01.xhtml#ch1fig2" class="calibre10">Figure 1-2</a>.</p>
<p class="indent">Sharing your work is as simple as sending the on-disk form of the notebook to your colleagues. Everything is in one file, including the graphs and other images, which by default are encoded as SVG. Jupyter Notebook files have the <em class="calibre11">.ipynb</em> extension, and are stored in the directory where you started the REPL.</p>
<p class="indent">If you are going to use Jupyter extensively, consult the detailed documentation at <a href="https://jupyter.org" class="calibre10"><em class="calibre11">https://jupyter.org</em></a> to learn more about all of its features.</p>
<h4 class="h3" id="ch01lev1sec9"><strong class="calibre2"><em class="calibre4">Pluto: A Better Notebook</em></strong></h4>
<p class="noindent">Pluto is a notebook interface to Julia that uses a web browser, similarly to Jupyter. Although it’s a young project, it’s already used routinely by a large community and has significant advantages over Jupyter. Its only shortcoming is that it is Julia-only, but this specialization allows Pluto to take better advantage of what Julia has to offer than frontends that support multiple kernels.</p>
<p class="indent">Pluto does not depend on anything aside from a modern web browser and Julia. To install it, press <code>]</code> to enter the package mode in the Julia REPL <span epub:type="pagebreak" id="page_18"/>and execute the <span class="codestrong1">add Pluto</span> command. After everything downloads and installs, press <small class="calibre5">BACKSPACE</small> to exit the package mode, and execute this code in the REPL:</p>
<pre class="calibre13"><span class="codestrong">using Pluto
Pluto.run()</span></pre>
<p class="indent">A new window or tab will open in your default web browser with the Pluto welcome page, which looks like <a href="ch01.xhtml#ch1fig3" class="calibre10">Figure 1-3</a>.</p>
<div class="image1"><img alt="Image" id="ch1fig3" src="../images/ch01fig03.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 1-3: The Pluto welcome page</em></p>
<p class="indent">Here you’ll see links for opening a fresh notebook, continuing work on an existing one, or examining sample notebooks. The sample notebooks cover a variety of subjects and are well done and instructive.</p>
<p class="indent">A Pluto notebook is a web page where you can enter Julia expressions in “cells.” Pressing <small class="calibre5">CTRL-ENTER</small> while the cursor is in a cell will cause Julia to execute the code in that cell as well as all the cells that depend on it. If, for example, you define, or redefine, a variable in a cell and execute it, and you have a second cell that uses that variable, Pluto will execute that second cell after the first one is done. If a third cell depends on the result from the second cell, Pluto will execute that one next, and so on. After each cell is run, its result is displayed <em class="calibre11">above</em> the input cell. You can watch the progress of execution passing from cell to cell by observing the animated progress bars on their left borders.</p>
<p class="indent">Pluto determines the order of execution by calculating a <em class="calibre11">dependency graph</em> for all the cells on the page. Using the dependency graph means that the results shown on the page are independent of the visual order in which they are arranged, and of the order in which you decide to execute cells. <span epub:type="pagebreak" id="page_19"/>What you see is completely determined by the code in the cells, so you can share your notebooks with collaborators and everyone will see the same, consistent notebook. This is the major advance over other notebooks, such as Jupyter, where the results displayed on the page are the consequence of the order in which the cells were run and may even depend on cells that have been deleted.</p>
<p class="indent">Pluto’s behavior is, in some ways, similar to a spreadsheet, and offers the same live, reactive experience. Even die-hard terminal users such as myself enjoy using Pluto for certain kinds of exploratory computation. Its ability to embed graphics and, as we’ll see in later chapters, incorporate graphical controls such as sliders and color pickers creates a rich environment for experimenting with code and data.</p>
<p class="indent"><a href="ch01.xhtml#ch1fig4" class="calibre10">Figure 1-4</a> shows a Pluto page with a simple matrix calculation. I created it by clicking the link to start a new notebook in the welcome page. Pluto opened a new tab and the browser switched to it, and I entered expressions in three cells and pressed <small class="calibre5">CTRL-ENTER</small> to evaluate them.</p>
<div class="image1"><img alt="Image" id="ch1fig4" src="../images/ch01fig04.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 1-4: Matrix calculations in the Pluto notebook</em></p>
<p class="indent"><a href="ch01.xhtml#ch1fig4" class="calibre10">Figure 1-4</a> shows the main elements of the Pluto interface. At the top is the path of the notebook file. Until you type this in, a message in that space will invite you to do so. To the right of that is a save button, but you only need to use it if you change the location of the file and want to save immediately. Every time you execute a cell, Pluto saves your work automatically.</p>
<p class="indent">In the first two code cells I’ve defined two small matrices, <code>m</code> and <code>n</code>, and in the third cell, I asked for their matrix product. (This is a preview of the array operations that we’ll explore in <a href="ch02.xhtml" class="calibre10">Chapter 2</a>.) Keep in mind that in Pluto, the results are printed above the input cells.</p>
<p class="indent"><span epub:type="pagebreak" id="page_20"/>So far, we could have done this the same way in the REPL. The difference here is that if we change any of the numbers in <code>m</code> or <code>n</code> and run the cell with its new definition, the matrix product is instantly recalculated and the revised result replaces the old one without any further action by the user. In the REPL, we would have to type <code>m * n</code> again, and the new result would be printed below that, possibly scrolling other information off the screen.</p>
<p class="indent">In Pluto, because the results displayed are independent of the order in which they appear on the page, we can rearrange the cells to provide a good exposition, without worrying about affecting the calculations. We can combine Julia expressions with text formatted using Markdown or HTML, and turn our notebook into an article or a live explanatory text.</p>
<p class="indent">In the final cell, I’ve entered a question mark (<code>?</code>) followed by the name of a data type, <code>Matrix</code>. As soon as you enter the question mark and begin typing, a live help window opens, displaying documentation about what you’ve typed so far. As you add letters, the documentation changes to reflect what you’ve typed, and you can stop when you see what you want.</p>
<p class="indent">The help window stays there, displaying documentation about whatever you type into any cell, whether or not you ask for help. If it becomes distracting, click the little down arrow to tuck the window away. Because of Pluto’s close integration with Julia, it has other conveniences, such as tab completion, that work the same way as in the REPL.</p>
<p class="indent">The text file that backs the notebook page, stored at the location you entered at the top, is a normal Julia module file. You can import it into other Julia programs, edit it directly, and put it into version control. You are not locked into the Pluto notebook, but can use the code you develop there in other Julia projects.</p>
<p class="indent">Pluto is a new and innovative way to develop programs and carry out exploratory computation that is fun to use. Even if you turn to it only now and then, you should install it and become familiar with the interface. Follow Pluto developments and find more documentation at <a href="https://github.com/fonsp/Pluto.jl" class="calibre10"><em class="calibre11">https://github.com/fonsp/Pluto.jl</em></a>.</p>
<h4 class="h3" id="ch01lev1sec10"><strong class="calibre2"><em class="calibre4">Integrated Development Environments</em></strong></h4>
<p class="noindent">Both Vim and Emacs can serve as capable IDEs for Julia by installing the plug-ins described in their respective sections earlier. Traditional IDEs don’t afford as much of a critical advantage for languages like Julia as they might for more verbose and ceremony-laden languages such as Java or C++, where many developers consider them essential. A text editor is all you need for writing Julia programs.</p>
<p class="indent">However, some users prefer a “real” IDE or may already be accustomed to one. The Julia IDE situation is in flux at the moment of writing. An IDE called Juno, consisting of a plug-in for the Atom editor, was essentially the official IDE for Julia, but work on it has ceased. As the language moves forward, Juno will not keep up. IDE development for Julia has shifted to a plug-in for VS Code, a popular IDE from Microsoft.</p>
<p class="indent">You can download VS Code from its GitHub repository at <a href="https://github.com/microsoft/vscode" class="calibre10"><em class="calibre11">https://github.com/microsoft/vscode</em></a> and compile for your system. A quicker route for Linux, <span epub:type="pagebreak" id="page_21"/>macOS, or Windows is to download the appropriate package file from <a href="https://code.visualstudio.com/Download" class="calibre10"><em class="calibre11">https://code.visualstudio.com/Download</em></a> and follow your system’s normal install procedure. Microsoft also offers branded versions as binary downloads. These may contain small enhancements, and are released under a Microsoft product license.</p>
<p class="indent">After installing the base VS Code program, you will install the Julia plug-in, which you can do from within the IDE. <a href="ch01.xhtml#ch1fig5" class="calibre10">Figure 1-5</a> illustrates how to do this.</p>
<div class="image1"><img alt="Image" id="ch1fig5" src="../images/ch01fig05.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 1-5: Installing the Julia plug-in within VS Code</em></p>
<p class="indent">The screenshot shows the left-hand area of the VS Code window, with the extension icon selected. I’ve entered “Julia” into the extension search box at the top, and the program is displaying a list of publicly available extensions that match. When you perform this search, the list will likely look different, but you want the extension titled simply “Julia,” which, in this case, is at the top of the list. Click the blue <strong class="calibre7">Install</strong> button to download and install the plug-in.</p>
<p class="indent">Quit VS Code and restart it after installing the plug-in. If you have set your path properly, as described in “Installation” on 6, press <small class="calibre5">CTRL-SHIFT</small>-P (<small class="calibre5">CMD-SHIFT</small>-P on macOS) to open a command window and execute the <span class="codestrong1">Julia: Start REPL</span> command. A Julia REPL should open in a pane at the bottom of the window. It behaves just like the normal REPL described on <a href="ch01.xhtml#ch01lev1sec6" class="calibre10">page 10</a>, with all REPL modes available, and using your color and other customizations.</p>
<p class="indent">In addition to typing directly in the REPL, you can open an existing or new file for editing. Julia code is syntax colored, and there are syntax-aware commands for moving through the code and manipulating its structures. The documentation at <a href="https://www.julia-vscode.org/docs/stable/" class="calibre10"><em class="calibre11">https://www.julia-vscode.org/docs/stable/</em></a> consists largely of <span epub:type="pagebreak" id="page_22"/>blank pages at the time of writing, but I expect this situation to be improved soon. Open the command window and type <code>Julia:</code> to discover Julia-specific commands and then scroll through the list. If you see a command you’ll be using often, this list contains buttons next to each command that allow you to define keyboard shortcuts.</p>
<p class="indent">I recommend defining a shortcut for the “Send Current Line or Selection to REPL” command. This allows you to send any expression or statement directly from the editor to the REPL for execution.</p>
<p class="indent">If you execute a plot command in the REPL, the plot appears in its own dedicated pane within the VS Code window. <a href="ch01.xhtml#ch1fig6" class="calibre10">Figure 1-6</a> shows the main part of the window as it appears on my laptop, with the light background selected from among VS Code’s three appearance options.</p>
<div class="image1"><img alt="Image" id="ch1fig6" src="../images/ch01fig06.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 1-6: Using the Julia plug-in in VS Code</em></p>
<p class="indent">In the top pane, I’m editing a file with a few lines of Julia code, which I’ve sent directly to the REPL in the bottom pane. Although you may not understand all the language syntax yet, you may be able to form an idea of what the expressions are intended to return. After trying some arithmetic to see if the setup is working, I define a range of numbers, assigned to the <code>x</code> variable, and then plot a function applied to each value in the list. At the top right, the plot window has appeared.</p>
<h3 class="h2" id="ch01lev3"><strong class="calibre2"><span epub:type="pagebreak" id="page_23" class="calibre1"/>Recommendations</strong></h3>
<p class="noindent">As the choice of tools is a matter of personal preference, I’ve tried to provide enough information about all the main ways of interacting with Julia and editing Julia programs to allow you to choose the methods that most appeal to you. If you are already in the habit of using Vim, Emacs, or any other tool for programming, you don’t need to learn anything new or change your workflows to use Julia. Use what you are familiar with, as Julia can easily adapt to it.</p>
<p class="indent">If, however, you’re not yet committed to any specific tooling, I have a recommendation. I suggest that you install Vim, along with the Julia-specific plug-ins described in “Text Editors” on <a href="ch01.xhtml#ch01lev1sec7" class="calibre10">page 14</a>. Vim takes some getting used to, but the long-term rewards are worthwhile, as it is an efficient and flexible editor, and it makes working alongside the REPL easy.</p>
<p class="indent">If Vim is new to you, to ease the burden of learning both a new language and an unfamiliar editor simultaneously, consider working through Pluto, as well as in the REPL directly, while you take your time to become comfortable with a new editor.</p>
<p class="indent">Be aware that this reflects my personal preferences, and you may prefer a different environment. For example, if you find working in a browser-based notebook appealing, there is no reason you can’t do all of your Julia work within Pluto. My only negative recommendation is not to stick with a primitive editor that has no REPL or language support, as doing so will hold you back in the long run.</p>
<div class="box">
<p class="boxtitle-d" id="fur1"><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">My article “The Scientist’s Linux Toolbox” in <em class="calibre11">Linux Pro Magazine</em> (<a href="https://www.linuxpromagazine.com/Issues/2020/241/Scientist-s-Toolbox" class="calibre10"><em class="calibre11">https://www.linuxpromagazine.com/Issues/2020/241/Scientist-s-Toolbox</em></a>) provides more information about Julia and other software useful to scientists computing on Linux.</li>
<li class="noindent1">In “An Introduction to Pluto” (<a href="https://lwn.net/Articles/835930/" class="calibre10"><em class="calibre11">https://lwn.net/Articles/835930/</em></a>), I describe the development of the Pluto notebook, give some examples of its use, and contrast it with the popular Jupyter Notebook interface.</li>
<li class="noindent1">A useful ANSI color code table is available at <a href="https://misc.flogisoft.com/_media/bash/colors_format/256_colors_bg.png" class="calibre10"><em class="calibre11">https://misc.flogisoft.com/_media/bash/colors_format/256_colors_bg.png</em></a>.</li>
<li class="noindent1">Go to <a href="https://gitforwindows.org" class="calibre10"><em class="calibre11">https://gitforwindows.org</em></a> for a Windows solution that provides Git, a terminal program, and some more conveniences.<span epub:type="pagebreak" id="page_24"/></li>
</ul>
</div>
</body></html>