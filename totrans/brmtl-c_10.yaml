- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serial Output on the STM
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re now back to “Hello World,” only this time we’ll use our Nucleo board,
    which presents several challenges. The first is where to write the message. There
    is no display. Fortunately, the chip has a serial port that’s nicely connected
    to a USB/serial port on the top half of the board.
  prefs: []
  type: TYPE_NORMAL
- en: The next challenge is the writing itself. We need to initialize the device and
    create a procedure to actually write a character. The device is designed to accept
    one character at a time, and we must keep that limitation in mind when writing
    our program.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll simulate the process before working with the device. C has a great deal
    of standard functions, such as `puts`, that make outputting data easy. The Nucleo
    board doesn’t have such nice features, so we must write our own output functions.
    In order to transition into the low-level coding we need for the Nucleo, we’ll
    write out “Hello World” one character at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a String One Character at a Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a C program calls the standard `puts` function, it starts a long programming
    process that involves kernel calls, internal buffering, interrupt scheduling,
    and device drivers (more on those in the next chapter). Ultimately, it reaches
    the point where it sends one character at a time to the device. To simulate this,
    we’ll send one character at a time to the operating system. In other words, we’ll
    limit ourselves to using only the standard `putchar` function to write the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-1](#listing9-1) contains a program that writes out `"Hello World\n"`
    the hard way. Again, we’re doing this the hard way because later, with the Nucleo
    board, we’re going to have to do it the *really* hard way.'
  prefs: []
  type: TYPE_NORMAL
- en: '**putchar.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: Writing a string one character at a time*'
  prefs: []
  type: TYPE_NORMAL
- en: The only interesting piece in this program is the `for` loop 1, which does not
    stop after a certain number of characters. Instead, it stops when the program
    reaches the end-of-string (`'\0'`) character. That way, the program can output
    any length of string.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Our Own putchar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To improve this program, first we’ll make `curChar` a local variable. Then we’ll
    define a function called `myPutchar` that sends the character to standard out
    (see [Listing 9-2](#listing9-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '**my_putchar.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-2: One character at a time using our own output function*'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of `myPutchar`, we’ve added some additional elements 1 to the
    comment block. The keyword `@param` indicates a parameter, and the `@note` keyword
    defines a note. You can use lots of other keywords in Doxygen-style comments,
    but for now we’ll use the basics to be compatible with the existing STM code.
  prefs: []
  type: TYPE_NORMAL
- en: The actual function starts with the `void myPutchar(const char ch)` declaration
    2, which indicates that the `myPutchar` procedure returns nothing and takes one
    parameter of type `char`. The `const` modifier indicates that we don’t change
    it inside the procedure. (In fact, we can’t change it, because if we try, the
    compiler will generate an error.)
  prefs: []
  type: TYPE_NORMAL
- en: 'When the procedure is executed 4, the program performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It computes the value of `hello[curChar]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It places this value in a location where `myPutchar` can find it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It records the address of the next instruction (the end of the `for` loop).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It starts executing `myPutchar`. (The `ch` variable will have been initialized
    by step 2.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A similar set of steps is executed when we call `putchar` 3. The only difference
    is that we had to write `myPutchar`, and the people who wrote the standard C library
    supplied `putchar`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a function (`myPutchar`) that does nothing but call another (`putchar`)
    is not very useful. The Nucleo board doesn’t have a `putchar` function, so we’ll
    write our own later in the chapter. But before we do that, let’s look at the details
    of the serial device.
  prefs: []
  type: TYPE_NORMAL
- en: Serial Output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serial output is one of the easiest ways to get data out of an embedded system.
    The electrical interface consists of a send line (TX), a receive line (RX), and
    ground (GND). Most embedded systems have them hidden away, available only to developers
    willing to crack open the case and connect to the serial port.
  prefs: []
  type: TYPE_NORMAL
- en: Our chip has a serial device we can write to. All we need to do is connect TX,
    RX, and GND between our microcontroller (the bottom half of the development board)
    and the USB/serial device on the top half of the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the connections we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Microcontroller** | **USB/serial and other support devices** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RX | CN9-1 | TX | CN3-1 |'
  prefs: []
  type: TYPE_TB
- en: '| TX | CN9-2 | RX | CN3-2 |'
  prefs: []
  type: TYPE_TB
- en: '| GND | CN6-5 | GND | CN4-3 |'
  prefs: []
  type: TYPE_TB
- en: We would have to make these connections if we had a Raspberry Pi or other embedded
    system without a built-in serial controller. [Figure 9-1](#figure9-1) shows the
    layout of these components and the internal wiring supplied by STM.
  prefs: []
  type: TYPE_NORMAL
- en: STM has already made the connections for us. No jumpers needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![f09001](image_fi/501621c09/f09001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: Serial communications on the Nucleo board'
  prefs: []
  type: TYPE_NORMAL
- en: A Brief History of Serial Communications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Serial communications go back a long way, back to the BC years (as in, *before
    computers*). The telegraph was the internet of its day, allowing for the transmission
    of long-distance messages over wires. The sender consisted of a telegraph key
    that, when pressed, would cause the receiver to “click.” The clicks were encoded
    using a system called *Morse code* (still in use today). This invention revolutionized
    communications. You could send a message to the next city and get a response the
    same day. Take that, Pony Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'There was just one problem, however; you needed skilled operators at both ends
    of the telegraph who knew Morse code. Unskilled people could not send or receive
    messages, and training operators was expensive. One solution was to use two clocks:
    one for the transmitter and one for the receiver. On the clock dial were the letters,
    from *A* to *Z*. To send an *S*, for example, the sender would wait until the
    single hand on the clock pointed to the *S* and press the telegraph key. The receiver
    would see that the hand pointed to *S* and record the letter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping the clocks in sync was next to impossible, though, so a very smart
    inventor decided that each clock would stop its hands at the top position. When
    the sender wanted to send a letter, they would press the telegraph key as a *start
    signal*. The clocks would keep good enough time to make it around the dial once
    correctly. The sender would then press the letter signal. When the hand reached
    the top, a short pause called the *stop time* would give the slower clock a chance
    to catch up. The sequence of events went like this: start signal, letter signal,
    stop time.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s fast-forward to the invention of the teletype machine, which could
    send text over the equivalent of telegraph lines. Instead of a single letter pulse,
    the teletype encoded the characters into a series of eight pulses (seven for data
    and one for primitive error checking). It used a keyboard encoder built out of
    levers to turn a key press into an 8-bit code that was fed to a mechanical shift
    register that looked like a distributor cap. This device sent the pulses down
    the wire, where another teletype would turn them into a single printed letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The teletype sequence went like this: The sender would press a key, and the
    mechanical sender would send out a 10-bit signal (1 start bit, 8 data bits, and
    1 stop bit). When the receiver got the start bit, it turned on its shift register
    (another motor with a distributor cap) and used the incoming pulses to turn a
    print head so the right letter printed. After the 8 data bits were sent, both
    machines paused at least 1 bit time (the stop bit) to remain synchronized.'
  prefs: []
  type: TYPE_NORMAL
- en: Most teletypes could transmit characters at 110 baud (bits/second), or 10 characters
    a second. That doesn’t sound like much in the day of megabit internet connections,
    but it was a revolutionary improvement in communications.
  prefs: []
  type: TYPE_NORMAL
- en: Computers today still use the serial communication that the teletype used. The
    speeds have improved, but the basic protocol remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Line Endings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In fact, we’re still dealing with one other teletype legacy: line endings.
    After typing 80 characters, you could send the machine a character called a *carriage
    return* to make it return to position 1\. The problem was that it took two-tenths
    of a second to move the printhead. If you sent a character immediately after the
    carriage return, you’d get a blurred blob printed in the middle of the line as
    the printhead tried to print while moving.'
  prefs: []
  type: TYPE_NORMAL
- en: The teletype people solved this issue by making the end of a line two characters.
    The first, the carriage return, moved the print head to position 1\. The second,
    the line feed, moved the paper up one line. Since the line feed didn’t print anything
    on the paper, the fact that it was done while the printhead was flying to the
    left didn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: However, when computers came out, storage cost a lot of money (hundreds of dollars
    *per* *byte*), so storing two characters for an end of line was costly. The people
    who created Unix, the inspiration for Linux, decided to use the line feed (`\n`)
    character only. Apple decided to use the carriage return (`\r`) only, and Microsoft
    decided to use both the carriage return and the line feed (`\r\n`) for its line
    ending.
  prefs: []
  type: TYPE_NORMAL
- en: C automatically handles the different types of newlines in the system library,
    but only when you use the system library. If you are doing it yourself, like we
    are about to do, you must write out the full end-of-line sequence (`\r\n`).
  prefs: []
  type: TYPE_NORMAL
- en: Serial Communications Today
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Today, almost every embedded processor has a serial interface on it. Serial
    devices are simple and cheap to make. The only difference between the interface
    of today and that of the 1800s is that speed has gone up (from 110 bits/second
    up to 115,200 bits/second), and the voltages have changed. In the 1800s they used
    –15 to –3 as a zero bit and +3 to +15 as a one bit. That’s still the “standard,”
    but most computers use voltages of 0 (for zero) and 3 (for one).
  prefs: []
  type: TYPE_NORMAL
- en: 'The device that handles the serial I/O is called a *universal asynchronous
    receiver-transmitter (UART)*. There are two major types of serial communication:
    *asynchronous* and *synchronous*. With synchronous communications, the sender’s
    and receiver’s clocks must be synchronized by having the sender continually send
    out characters. The receiver then looks at the incoming characters and deduces
    the clock timing from them. The sender must always send characters, even if it’s
    just an “idle” character (indicating no data). With asynchronous communications,
    there is no shared clock. The start bit triggers the receiver to start its clock
    and look for a character. Asynchronous communications assume that the sender and
    receiver can keep their clocks close enough together for one character time. Because
    there is no need for continuous transmissions to keep the clocks synchronized,
    there is no idle character. When idle, the transmitter just doesn’t send anything.'
  prefs: []
  type: TYPE_NORMAL
- en: The STM chip has one port that allows for both synchronous and asynchronous
    communications, so in the STM documentation, you’ll see it referred to as a *universal
    synchronous/asynchronous receiver-transmitter (USART)*. This program uses the
    term *UART* to be compatible with the STM HAL library.
  prefs: []
  type: TYPE_NORMAL
- en: Serial Hello World!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create a new project for *main.c*, which is a somewhat long “Hello World,”
    but it has to do all the things that the operating system hides from us. First,
    we include the header files that define the information about the UART (and lots
    of other devices as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the code, we’ll start with the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function looks pretty much like the one in Listings 9-1 and 9-2\.
    One addition is that it must initialize all the devices we’re going to use 1,
    including the hardware library (`HAL_Init`), the red LED (`led2_Init`), and the
    UART (`uart2_Init`). Our embedded program can’t stop, so we have an infinite loop
    2 that sends out the string 3 and then sleeps for half a second 4.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things to do next is create an `ErrorHandler` function, which
    the HAL library calls if something goes wrong. We can’t print an error message,
    because our printing code just went south, so we resort to blinking the red light.
    True, it’s a very limited error indication, but so is the check engine light in
    your car. In both cases, the designers are doing the best they can. We won’t go
    through the `Error_Handler` function here; it’s “blink” from Chapter 3 with a
    new name.
  prefs: []
  type: TYPE_NORMAL
- en: UART Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A serial device should be simple to program. The engineers at STMicroelectronics,
    however, have decided to improve the simple UART by providing additional features.
    As a result, our simple serial device now takes 45 pages worth of reference manual
    to describe. We just want to use the thing to send characters. It doesn’t even
    need to receive them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the HAL library provides a function called `HAL_UART_Init` that
    hides many of the messy details from us. Unfortunately, it doesn’t hide the messy
    details of calling `HAL_UART_Init`, but you can’t have everything. In the `uart2_Init`
    function, we have to set up an initialization structure and then call `HAL_UART_Init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We first tell the system which UART to use 1. Our chip has more than one, and
    the second one is connected to the USB serial interface. Next, we set the speed
    to 9,600 baud (bits/second) 2, or 960 characters a second. Why the 10 to 1 ratio?
    We have 1 bit for the start bit, 8 data bits, and 1 stop bit. The number of bits
    per character is 8, because C stores characters in 8-bit units. It is possible
    to have systems with 5, 6, 7, or 9 bits per character, but almost everyone uses
    8, except for a TDD deaf communication device, which uses 5\. We need to tell
    the system that we’re using 8 bits 3.
  prefs: []
  type: TYPE_NORMAL
- en: The next line configures the number of stop bits 4, which is the amount of time
    (in bits) that occurs between characters. Most people use 1 stop bit. (If the
    sender uses 2 and the receiver uses 1, it still works. The extra bit will be interpreted
    as between-character idle time.)
  prefs: []
  type: TYPE_NORMAL
- en: Early serial devices used a 7-bit character and 1 parity bit. The parity bit
    provided a simple, primitive method of error checking. We do not use this feature,
    so we turn parity off 5. We then enable the transmitter and receiver 6.
  prefs: []
  type: TYPE_NORMAL
- en: The original serial interface (RS-232 standard) has a number of hardware flow
    control lines. On our board, they are not wired up, and we don’t use them 7.
  prefs: []
  type: TYPE_NORMAL
- en: One of this UART’s advanced features is *oversampling*, which allows the receiver
    to check the state of an incoming bit multiple times before deciding whether it
    is a one or a zero. This feature is sometimes useful when you have a noisy electrical
    environment and are running serial cables over long distances. Our serial “cable”
    consists of two traces that run from the bottom of the board to the top, a distance
    of about 3 inches. We don’t need oversampling, but we do have to turn it off 8.
    Finally, we are not using any advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we call `HAL_UART_Init` to initialize the UART 9, which needs help to
    do its job. The general-purpose input/output (GPIO) pins on our processor can
    do a lot of different things, including act as GPIO pins. Most of them have “alternate
    functions,” meaning that you can program them to act as different devices (GPIO
    pin, USART device, SPI bus, I2C bus, PWM pin, and so on). Note that not all pins
    support all devices. Finally, `HAL_UART_Init` calls `HAL_UART_MspInit`, which
    sets up pins for the UART:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We need to supply `HAL_UART_MspInit`. Keep in mind that pins are expensive and
    transistors to drive them are cheap. By default, the two pins that drive our serial
    device, named PA2 and PA3, are GPIO pins. We need to tell the system to use the
    pins’ alternate function and turn them into serial device pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `HAL_UART_MspInit` function looks a lot like the initialization code for
    the GPIO pin we used for “blink,” but with some slight differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function starts by checking which USART we are using. We only set up USART2
    in this code 1. Then we enable the clock for the device 2. Next, we configure
    the GPIO pins 3 (we’ve done this before in our blink program), which tells the
    chip that PA2/PA3 are not GPIO pins but instead should be connected to USART2.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting a Character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll use the `myPutchar` function to transmit characters over the serial device.
    The USART is a memory-mapped I/O device. To send a character, we have to assign
    (write) it to the magic memory location (a *register*), and then it goes out the
    wire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to time the character just right, and that requires some extra
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The register we are writing is called the *transmit data register (TDR)*. If
    we write this register while a character is being transmitted, the new character
    overwrites the old one, causing errors and confusion. To send `a`, `b`, `c`, we’d
    write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This sort of timing is tricky, especially if we want to execute code between
    characters. The STM32 chip has a bit for everything, including “TDR empty, you
    can write another character now.”
  prefs: []
  type: TYPE_NORMAL
- en: This bit is in a register called the *interrupt and status register (ISR)* that
    has a number of bits in it indicating the status of the device. [Figure 9-2](#figure9-2)
    shows a diagram of this register from the STM32F030R8 reference manual (“RM0360
    Reference manual/STM32F030x4/x6/x8/xC and STM32F070x6/xB”).
  prefs: []
  type: TYPE_NORMAL
- en: '![f09002](image_fi/501621c09/f09002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: Interrupt and status register contents'
  prefs: []
  type: TYPE_NORMAL
- en: We are interested in the bit named TXE (bit 0 in the diagram). The HAL defines
    the TXE bit using the name `UART_FLAG_TXE`. We must wait for the TXE bit to clear
    (become zero) before we can send data to the TDR without clobbering a character
    being transmitted. Nothing in the code changes `uartHandle.Instance->ISR`.
  prefs: []
  type: TYPE_NORMAL
- en: However, `uartHandle.Instance->ISR` is a magic memory location electrically
    connected to the device. The state of the device changes when something like a
    character transmission completes, and when that happens, the contents of `uartHandle.Instance->ISR`
    change as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you try to examine `uartHandle.Instance->ISR` using the debugger, the
    `UART_FLAG_TXE` flag will appear always to be set. That’s because it’s cleared
    when a character is transmitted (in 1/960th of a second), which is a long time
    in terms of computers, but a very short time in terms of humans typing commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help show what’s going on, we’ve added a useless statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This statement tests the value of `UART_FLAG_TXE` and stores it in `result`.
    Now the value of `(uartHandle.Instance->ISR & UART_FLAG_TXE)` might magically
    change, but the value `result` will remain the same for the lifetime of the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can look at `result` in the debugger and see what the value of the bit
    was at the beginning of the loop. You’ll notice a strange phrase in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is a GCC extension to the C language. It tells the compiler that we know
    this variable is not used, so it doesn’t generate a warning. (In fact, it’s not
    used by the program, but it may be used by the debugger. The compiler doesn’t
    see anything outside the program itself.)
  prefs: []
  type: TYPE_NORMAL
- en: The string we send for “Hello World” ends with `\r\n` (carriage return, line
    feed). In our original “Hello World” program from Chapter 1, the operating system
    edited the output stream and changed `\n` into `\r\n` for us. We have no operating
    system, so we must do it all ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-3](#listing9-3) contains the full serial version of our “Hello World”
    program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-3: Program* 08.serial'
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the Device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have a program that sends out the “Hello World” message on the serial
    line. The serial line is connected to the USB/serial device on the board, which
    is plugged in to your computer. To view the message, you need to run a terminal
    emulator on your computer. [Figure 9-3](#figure9-3) shows the setup.
  prefs: []
  type: TYPE_NORMAL
- en: '![f09003](image_fi/501621c09/f09003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: Serial communications'
  prefs: []
  type: TYPE_NORMAL
- en: Each operating system has a different terminal emulator program, and in some
    cases, more than one. The ones mentioned here are common, free, and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Windows, we’ll use the PuTTY program ([https://putty.org](https://putty.org)).
    Download and install it on your system, selecting the defaults for all options,
    and then follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the Nucleo board is *not* connected to your computer. Open the Control
    Panel and go to the Device Manager screen (see [Figure 9-4](#figure9-4)). There
    is no serial device and, therefore, no Ports section in the list.![f09004](image_fi/501621c09/f09004.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9-4: Serial device not installed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Plug in the Nucleo board. The device list will change as shown in [Figure 9-5](#figure9-5).![f09005](image_fi/501621c09/f09005.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9-5: New USB serial device'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should see a new USB serial device named COM3\. (Windows has a system for
    assigning COM parts to serial devices, but no one knows what that is. You may
    see a different COM port on your machine.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start PuTTY. In the main window, shown in [Figure 9-6](#figure9-6), select the
    **Serial** radio button. Under **Serial Line**, select the new COM port you just
    found in the Device Manager. The speed should default to 9600.![f09006](image_fi/501621c09/f09006.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9-6: Starting PuTTY'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click **Open**. A terminal window should appear, and the device should start
    greeting you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Linux and macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Unix-based systems like Linux and macOS, the `screen` program works well.
    (The `minicom` program also does the job.) To use `screen`, you need to know the
    serial device’s name, which is different on different operating systems. On Linux,
    the device is most likely */dev/ttyACM0*, although if you have other serial devices
    plugged in, it might be */dev/ttyACM1*, */dev/ttyACM2*, or similar. On macOS,
    the name is likely */dev/tty.usbmodem001*, but it could be */dev/tty.usbmodem002*,
    */dev/tty.usbmodem003*, or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the name, make sure the Nucleo board is *not* connected to your computer,
    then execute one of the following commands in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Plug in the device and execute the same command again. You should see one more
    device in the list. Use that one. Now execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should see “Hello World” appear. To exit the program, press CTRL-A-\.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This programming book covers “Hello World” in Chapter 9. Why? Because we had
    to do everything ourselves. Writing a simple program to send out our message,
    character by character, involved initializing the UART (a nontrivial process),
    telling the GPIO pin that it was now a serial pin, and using a hardware register
    (those mysterious memory locations that magically change depending on the state
    of the device) to see when the UART was ready to transmit a character.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve made a tremendous leap forward. First, we’ve programmed a moderately complex
    device and in the process learned a lot about direct low-level I/O. Second, the
    serial port is the main diagnostic and maintenance device hidden in many embedded
    devices. Despite all the advances in computer technology in the last 60 years,
    the most commonly used debugging technique is still `printf` to the serial port.
    The serial port is a very simple robust device that’s cheap to make and easy to
    connect to, and now we know how to use it to debug our embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the student: After you get the program working, see what happens if you
    remove the `\r`. Then try it with the `\r` back in, but the `\n` removed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Moderately difficult mystery: Try changing the configuration so that you send
    7 data bits and even parity (instead of 8 data bits, no parity). Do not change
    your terminal emulator’s configuration. Some of the characters will be changed.
    Examine the bit pattern of the characters and figure out which ones changed and
    why.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Advanced: As written, our program has no flow control. You’re going to get
    a “Hello World” whether you like it or not. Change the initialization code to
    use soft flow control. This means when you type the XOFF character (CTRL-S), the
    output should stop. When you type XON (CTRL-Q), it should resume.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Advanced: Write a function for the Nucleo board that reads a character. It
    will look much like the `myPutchar` function, only it will check a different bit
    and read the I/O port instead of writing to it. You’ll need to read the microcontroller’s
    documentation to see what the RDR bit does.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
