- en: '**24**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GOING FURTHER WITH THE GRAMMAR OF GRAPHICS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You covered the basics of the `ggplot2` package—which offers an alternative
    to traditional R graphics—in [Section 7.4](ch07.xhtml#ch07lev1sec26) and throughout
    [Chapter 14](ch14.xhtml#ch14). In this chapter, you’ll look at a couple of this
    package’s more popular and useful features, as well as its relatively young cousin,
    `ggvis`, which provides an interactive, browser-based experience.
  prefs: []
  type: TYPE_NORMAL
- en: '**24.1 ggplot or qplot?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far when creating the relatively simple `ggplot2` graphics, you’ve used
    the `qplot` function to initialize the visual object. In fact, the more general
    `ggplot` command is the core function of `ggplot2`. There are several key differences
    between these two initialization functions:'
  prefs: []
  type: TYPE_NORMAL
- en: • `qplot` is a shortcut version of `ggplot`; it’s used if you just want a quick
    look at your data or if you’re working directly in the R console.
  prefs: []
  type: TYPE_NORMAL
- en: • `qplot` is designed to be reminiscent of the base R `plot` function—you pass
    it *x*- and *y*-coordinate vectors and then tell it what to do. By contrast, `ggplot`
    prefers its data argument as a data frame object, and you tell it what to do by
    explicitly adding geom layers.
  prefs: []
  type: TYPE_NORMAL
- en: • A call to `qplot` alone can produce a graphic. When using `ggplot`, layers
    have to be added before anything becomes visible.
  prefs: []
  type: TYPE_NORMAL
- en: • To access the full power and flexibility of `ggplot2` graphics, `ggplot` is
    the recommended function; this comes at the cost of providing a little more explicit
    instruction than `qplot` requires.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, you can create most plots using either `qplot` or `ggplot`. Many
    users make the decision based on the form their data are in (in other words, a
    data frame or as separate vectors in the global environment) and whether they
    want polished visuals (for example, for publication purposes) or just a quick
    look at the data while working directly in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick example of the difference in syntax, flip back to the code on [page
    297](ch14.xhtml#page_297) used to create the histogram on the right of [Figure
    14-5](ch14.xhtml#ch14fig5). You could argue that the numerous modifications made
    to that particular plot warrant a more compartmentalized approach than `qplot`
    offers. Load `ggplot2` with a call to `library("ggplot2")` and create the following
    three objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first object, `gg.static`, represents the part of the plot that will stay
    the same throughout, say, if you wanted to experiment with adding other features
    later. Note that the call to `ggplot` differs from `qplot` in that the first argument
    is the entire data frame of interest, allowing access to all data columns within
    the frame for any subsequent geoms or annotations. You then add the `ggtitle`
    and `labs` functions to set the main title and the horizontal axis title. The
    second object, `mtcars.mm`, stores the horsepower mean and median as a “dummy”
    data frame. The mean and median lines are then superimposed on the histogram by
    the third object, `gg.lines`, which is a single call to the `geom_vline` function
    with the same content used in the earlier code, albeit in a slightly modified
    form to stay true to the initial use of `ggplot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing is displayed until you make a call that prints the `ggplot2` object
    (as noted in [Section 7.4](ch07.xhtml#ch07lev1sec26)). The following call reproduces
    the image on the right of [Figure 14-5](ch14.xhtml#ch14fig5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The pieces are put together in much the same way as for the creation of [Figure
    14-5](ch14.xhtml#ch14fig5): the addition of the `geom_histogram` layer to `gg.static`
    invokes the plot, and the addition of `gg.lines` with changes to the default line
    types made with `scale_linetype_manual` marks off the mean and median. If you
    wanted to produce the histogram without these lines, you would simply print the
    `gg.static` object plus `geom_histogram`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you get more experienced with `ggplot2`, you’ll find yourself leaning toward
    either `ggplot` or `qplot`, depending on the application. The help file in `?ggplot`
    provides a good description of the typical ways `ggplot` is used and how it stacks
    up against `qplot`. For further information, refer to *ggplot2: Elegant Graphics
    for Data Analysis* by Wickham ([2009](ref.xhtml#ref72)). I’ll use `ggplot` for
    the rest of the plots in this chapter to provide some examples of the syntax of
    the `ggplot` command to compare with the earlier uses of `qplot`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**24.2 Smoothing and Shading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data visualization using the `ggplot2` package is particularly powerful when
    you want to split features of the plot by one or more categorical variables. This
    is especially apparent when you’re enhancing your plot with features that are
    more difficult to achieve using base R commands.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2.1 Adding LOESS Trends***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you’re looking at raw data, it’s sometimes difficult to get an overall
    impression of trends without fitting a parametric model (for example, via linear
    regression), which means making assumptions about the nature of these trends.
    This is where *nonparametric smoothing* comes in—you can use certain methods to
    determine how your data appear to behave without fitting a specific model. These
    methods are a flexible aid for interpreting overall trends, whatever their form,
    but the trade-off is that you’re not provided with any specific numeric details
    of the relationships between response and predictors (since you’re not estimating
    any coefficients such as slopes or intercepts) and you lose any reliable ability
    to extrapolate.
  prefs: []
  type: TYPE_NORMAL
- en: '*Locally weighted scatterplot smoothing (LOESS or LOWESS)* is a nonparametric
    smoothing technique that produces the smoothed trend by using regression methods
    on localized subsets of the data, step-by-step over the entire range of the explanatory
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For theoretical details, [Chapter 6](ch06.xhtml#ch06) of* Applied Nonparametric
    Regression *([Härdle, 1990](ref.xhtml#ref29)), as well as [Chapters 2](ch02.xhtml#ch02)
    and [3](ch03.xhtml#ch03) of* Introduction to Nonparametric Regression *([Takezawa,
    2006](ref.xhtml#ref64)), provide clear discussions of LOESS smoothers.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For an illustration, load the `MASS` package and return your attention to the
    `survey` data frame. First, create a new data frame object with any missing values
    deleted to avoid default warning messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, after loading `ggplot2`, execute the following to produce the image on
    the left of [Figure 24-1](ch24.xhtml#ch24fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The call to `ggplot` initializes the object and sets the default mapping of
    handspan on the *x*-axis and height on the *y*-axis. The addition of `geom_point`
    adds the points, using color and point type to differentiate between males and
    females. The addition of `geom_smooth` superimposes the LOESS smoother. By default,
    a 95 percent confidence interval for the estimated trend is marked off by a transparent
    gray-shaded area.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f24-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 24-1: Showcasing* `ggplot2` *(left) and base R graphics (right) for
    display of nonparametrically estimated trends via LOESS*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I’ll demonstrate how to produce a similar result using base R graphics.
    Although there are base R functions, such as `scatter.smooth`, that can produce
    a scatterplot with the smoothed trend relatively quickly, to be able to do things
    such as shade in the confidence interval region, it’s helpful to be able to build
    the plot up piece by piece. Compare the relative ease of the `ggplot2` approach
    with the following base R code, which produces the image on the right of [Figure
    24-1](ch24.xhtml#ch24fig1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first line plots the raw data, and the second line uses the built-in `loess`
    function to provide the smoothed trend—the syntax is identical to that of `lm`.
    Just as with linear models fitted by `lm`, for drawing to begin, you need to set
    up a fine sequence of values of the *x*-axis variable at which to obtain the point
    estimates and their standard errors; this is achieved with `seq` in the third
    line, followed by `predict` in the fourth line with the `se` argument set to `TRUE`.
    This results in the object `sm`, a list with components `$fit` and `$se` as usual.
  prefs: []
  type: TYPE_NORMAL
- en: The smoothed trend is then drawn, using `sm$fit` in a call to `lines`. Finally,
    a rough 95 percent confidence interval is calculated for each of the predicted
    values as the `sm$fit` elements plus and minus twice the corresponding standard
    errors in `sm$se`. This is done directly in the call to `polygon`, which draws
    the gray band based on the vertices formed by the confidence interval (therein,
    the `rev` command is used to reverse the entries in the given `handseq` vector).
    You need to instruct the gray-filled shape to be transparent with a call to the
    ready-to-use `adjustcolor` command (the argument `alpha.f` takes a value from
    0, which is fully transparent, to 1, which is fully opaque); setting `alpha.f=0.5`
    sets 50 percent opacity of the specified `"gray"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that, and a legend hasn’t been put in yet! This example certainly exposes
    the extra effort the base R version of the image requires, not just in terms of
    the length of the script but also for the whole process of thinking about its
    construction (for example, putting together the vertices of a polygon for the
    confidence region appropriately and remembering to adjust the opacity of the filled
    shape to prevent any preplotted content being covered up). This becomes even more
    apparent the moment you become a little more ambitious with such features. Suppose
    you wanted to superimpose smoothers for each sex separately; this would require
    separate estimation of the LOESS functions and a rethink of the plotting strategy.
    However, this addition is simple in `ggplot2` terms, simply requiring a change
    in the aesthetic mapping of the relevant geom. The following code produces [Figure
    24-2](ch24.xhtml#ch24fig2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All that’s happened is that the aesthetic mapping for color and point type (`col=Sex`
    and `shape=Sex`, respectively) has shifted so that instead of being specific to
    the plotted points only, it’s part of the default mapping declared in the initialization
    call to `ggplot`. Any layer added afterward (that doesn’t reassign the mapping)
    will follow this default, as is the case for both `geom_point` and `geom_smooth`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The implementation of LOESS and other trend smoothers depends on you specifying
    the amount of smoothing you want; this is controlled by the proportion of the
    data to use as each localized weighted subset, for each step/location in the estimation
    procedure. A larger proportion leads to a smoother, less variable trend estimate
    than a smaller proportion. This value, referred to as the* span*, can be set by
    the optional argument* `span` *in either* `loess` *or* `geom_smooth`*. For quick
    data exploration, however, the default value of 0.75 is usually adequate. You
    can try experimenting with this on the example plots in this section to see the
    effects on the respective trends.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f24-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 24-2: Illustrating separate LOESS smoothers for categorical subsets
    of data, a result of a simple change in aesthetic mapping, with* `ggplot2` *functionality*'
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2.2 Constructing Smooth Density Estimates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The idea of smoothing isn’t limited to scatterplot trends. *Kernel density estimation
    (KDE)* is a method for producing a smooth estimate of a probability density function,
    based on observed data. Briefly, KDE involves assigning a scaled probability function
    (the *kernel*) to each observation in a data set and summing them all to give
    an impression of the distribution of the data set as a whole. It’s basically a
    sophisticated version of a histogram. For theoretical details, the text by Wand
    and Jones ([1995](ref.xhtml#ref70)) is a good reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this method, consider the built-in `airquality` data frame; enter
    `?airquality` at the prompt to open the documentation, which tells you it contains
    a number of measurements taken of the air in New York over several months. A basic
    plot of the kernel estimate of the density of the temperature measurements is
    provided with the following line and shown on the left of [Figure 24-3](ch24.xhtml#ch24fig3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a plot is relatively easy to create with base R graphics as well, using
    the built-in `density` command to implement KDE for a given data vector. However,
    `ggplot2` lets you dress up the plot using aesthetic mappings with relative ease—a
    big draw for fans of `ggplot2`. For example, suppose you want to visualize the
    density estimates for temperature separately according to the month of observation.
    First, execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f24-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 24-3: Visualizing temperature distributions in the* `airquality` *data
    frame via KDE, using* `ggplot2` *functionality*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This has created a copy of the `airquality` data frame in your workspace and
    recoded the originally numeric `Month` vector as a factor vector (as required
    for `ggplot2` mappings), labeling the entries appropriately. Then, using `air`,
    the following code produces the right-hand plot in [Figure 24-3](ch24.xhtml#ch24fig3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The different densities are clearly identified by different color fills, set
    using `fill=Month` in `aes` in the plot initialization mapped out by `ggplot`.
    You additionally supply `alpha=0.4` to `geom_density` to set 40 percent opacity
    so you can see all five curves clearly. The remaining calls to `ggtitle` and `labs`
    simply tidy up the main and axis titles. Features of the distributions of these
    measurements are as you might expect—temperatures for July, the hottest month,
    are centered over a far higher range of values than, say, those for May.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Just like LOESS techniques, the precise appearance of kernel-estimated probability
    density function is dependent on the amount of smoothing employed. Like the binwidth
    in the construction of a histogram, the quantity of interest in KDE is referred
    to as the* bandwidth *or* smoothing parameter*—a larger bandwidth imposes greater
    smoothing over the range of the data. By default, the bandwidth is automatically
    chosen using a data-driven technique in these examples. This default level of
    smoothing is generally acceptable for simple exploration of your data.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**24.3 Multiple Plots and Variable-Mapped Facets**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Section 23.1.4](ch23.xhtml#ch23lev2sec225), you saw different ways in which
    several traditional R plots can be viewed or laid out in a single graphics device.
    The same methods, such as setting `mfrow` in a call to `par` or compartmentalizing
    the device using `layout`, can’t be used for `ggplot2` graphics. There are other
    functions, though, that allow independent `ggplot2` plots to populate a single
    device. True to form, `ggplot2` also offers a convenient way to consider multiple-plot
    graphics using facets, where the images are all drawn in one go.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.3.1 Independent Plots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, let’s say you have several `ggplot2` plots that you’ve created independently
    of one another and that you’d like to arrange as a single image. A quick way to
    do this is to use the `grid.arrange` function provided in the contributed `gridExtra`
    package ([Auguie, 2012](ref.xhtml#ref05)). Install the package by running `install.packages("gridExtra")`
    at the prompt (you’ll need an Internet connection).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the use of `grid.arrange`, continue with the `air` object—the
    copy of `airquality` you created in [Section 24.2](ch24.xhtml#ch24lev1sec83) with
    the factor `Month` column. Now, consider the following three `ggplot2` objects,
    which I’ll explain further in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute `library("gridExtra")` to load the required package. To view `gg1`,
    `gg2`, and `gg3` in one window, simply call the following, which produces [Figure
    24-4](ch24.xhtml#ch24fig4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that you’ll likely see some warning messages telling you there are missing
    values in the `air` data frame and recommending to resize the window containing
    the plots.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f24-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 24-4: A series of three* `ggplot2` *graphics of the* `airquality` *data,
    plotted in the same device window via* `grid.arrange` *in the* `gridExtra` *package.
    Top: A time series of the temperatures by day, distinguishing between months and
    wind speed, with an overall LOESS trend with a 95 percent CI. Middle: Kernel density
    estimates of the distributions of solar radiation by month. Bottom: A scatterplot
    of temperature by wind speed, using color to delineate month and point size to
    reference ozone level. Separately fitted simple linear models of temperature on
    wind speed, split by month, along with 90 percent CIs, are superimposed.*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `grid.arrange` is easy to use—you simply create your `ggplot2`
    images first and store them as objects, then provide them directly to the arrangement
    function. `grid.arrange` decides how to produce the final layout based on the
    number of objects you give it (in this case, it’s a column of the three plots).
    You can control the order of the plots by changing the order in which the objects
    are supplied. There are more optional arguments, which you can read about in the
    documentation file `?grid.arrange`.
  prefs: []
  type: TYPE_NORMAL
- en: The plots `gg1`, `gg2`, and `gg3` also provide an opportunity to discuss even
    more `ggplot2` capabilities. Since there’s a lot going on, especially in `gg1`
    and `gg3`, I’ll discuss the code for each object separately.
  prefs: []
  type: TYPE_NORMAL
- en: '`gg1` The first plot is of the daily temperature. In setting the default aesthetics
    in `ggplot`, I create a sequence of integers matching the number of rows in `air`,
    to be paired with the relevant `Temp` element. Then `geom_line` and `geom_point`
    add the interconnecting lines and the raw observations themselves, to be added
    to the default aesthetic mapping. The interconnecting lines are set to change
    color according to `Month`. The raw observations also change color according to
    `Month`, and the point sizes change to be proportional to the wind speed readings.
    I include an overall LOESS smoother with its default color changed to `"black"`.
    I remain with the default mapping here—I don’t want separate smoothed trends for
    each month. The final addition of `labs` merely clarifies the axis titles as you’ve
    already seen it used.'
  prefs: []
  type: TYPE_NORMAL
- en: '`gg2` The second plot is a variant of the plot on the right of [Figure 24-3](ch24.xhtml#ch24fig3).
    This time, it shows the estimated densities of the solar radiation readings (in
    angstroms). The opacity is set, as you saw earlier, using `alpha` in `geom_density`.
    It’s also worth noting that I used `expression` in `labs` to approximate the angstrom
    unit symbol, Å, using `ring(A)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`gg3` The last is a scatterplot of temperature by wind speed, where you can
    see a negative relationship. The color, again to be assigned to each month, is
    also set as the default aesthetic mapping in `ggplot`. In the call to `geom_point`,
    the aesthetic enhancement is instructed to plot point size as proportional to
    the ozone reading (this is to ensure correct formatting of the corresponding legend,
    in light of the next addition). Here you can see a different kind of use for `geom_smooth`.
    In setting `method="lm"`, the line (or lines) I want superimposed correspond to
    simple linear model fits according to the `x` and `y` aesthetic mappings as predictor
    and response, respectively. Additionally including the factor `Month` in the default
    mapping ensures separate simple linear models are fitted for the temperature on
    wind speed data for each month and colored appropriately (it’s important to note
    that the plotted lines do not reflect a multiple linear model that includes all
    the variables used in the plot). Light, transparent 90 percent CIs are included
    with each regression (`level=0.9` and `alpha=0.2`), and setting `fullrange=FALSE`
    restricts each regression line only to the width of the observed data for each
    month.'
  prefs: []
  type: TYPE_NORMAL
- en: '***24.3.2 Facets Mapped to a Categorical Variable***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want independently created `ggplot2` graphics to appear in the same window,
    `grid.arrange` is arguably the best way to deal with them. However, the `ggplot2`
    package offers a flexible alternative to quickly view multiple plots. Often, when
    exploring a data set, you’ll want to create several plots of the same variables
    based on the levels of one or more important categorical variables. This behavior,
    referred to as *faceting*, is familiar territory for `ggplot2` using either the
    `facet_wrap` or the `facet_grid` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s focus on the simplest case where you have one categorical variable. Remaining
    with the `air` data frame object, the following line creates a `ggplot2` object
    of the density plots of the New York temperatures shown on the right of [Figure
    24-3](ch24.xhtml#ch24fig3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Rather than view all density estimates together, you can create a plot of each
    one separately, displaying them in the same device, with the following three uses
    of `facet_wrap`; the results are at the top left, top right, and bottom of [Figure
    24-5](ch24.xhtml#ch24fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f24-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 24-5: Three examples of using* `facet_wrap` *to display kernel density
    estimates of the temperature data, split by month*'
  prefs: []
  type: TYPE_NORMAL
- en: The `facet_wrap` function automates the layout of the multiple plots; a formula
    specifies the faceting variable. In all the previous plots, this is set to `~Month`,
    to be read as “by Month.” The code for the first visualization, given at the top
    left, offers no additional arguments, and without arguments the *x-*and *y*-axes
    of each facet are fixed, so you can compare the plots on the same scale. If you
    don’t want that, you can instruct the axes to be “free,” which means each plot
    is produced on scales specific to its own contents. You can see this in the second
    plot, at the top right in [Figure 24-5](ch24.xhtml#ch24fig5), the line of code
    for which specifies `scales="free"`. You can also opt to free only the horizontal
    or vertical axis with `scales="free_x"` or `scales="free_y"`, respectively. Finally,
    note that facet placement can be tailored by using the `nrow` and `ncol` arguments.
    In the third plot, setting `nrow=1` instructs R to place the plots in one row
    only, giving the horizontal arrangement on the bottom of [Figure 24-5](ch24.xhtml#ch24fig5).
    For further details on placement, you can find the documentation for this command
    at `?facet_wrap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative to `facet_wrap`, `facet_grid`, does much the same thing but
    isn’t able to wrap the plots if you’re faceting by only one categorical variable.
    The formula `var1` ~ var2 is interpreted as “facet by `var1` as rows and by `var2`
    as columns.” If you are indeed interested in faceting by only one grouping variable
    in either columns or rows, then simply replace either `var1` or `var2` with a
    dot (`.`). The third image in [Figure 24-5](ch24.xhtml#ch24fig5), for example,
    can just as easily be achieved via `facet_grid` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example, however, shows `facet_grid` in action with two grouping variables.
    Turn your attention again to the `diabetes` data frame in the `faraway` package.
    After loading the package, the following code creates the object with `diab` as
    the data frame of interest and with missing-value rows deleted, producing [Figure
    24-6](ch24.xhtml#ch24fig6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The initial call to `ggplot` tells R to use `diab` and plot total cholesterol
    against age. Then an addition of `geom_point` sets the shape, size, and color
    of each plotted point to change according to the county location, the weight,
    and the height of the individuals, respectively (as you’ve already seen for point
    size based on a continuous variable, point color is also automatically changed
    to vary on a continuum if the correspondingly mapped aesthetic variable isn’t
    a factor).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f24-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 24-6: Illustrating two-way faceting in* `ggplot2`*, using the* `diabetes`
    *data frame from the* `faraway` *package. Plots of cholesterol level against age,
    along with simple linear model fits, are faceted according to sex (rows) and body
    frame type (columns). Points are colored and sized according to weight and height,
    respectively, and two different point types differentiate the two county locations
    in Virginia of the study participants.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, those commands have still defined only a single scatterplot. With the
    addition of the call to `facet_grid`, the formula `gender~frame` separates the
    plots into a different scatterplot for males/females (as rows) and for each of
    the three body frame types: small/medium/large (as columns). You set simple linear
    model fits to accompany each plot based on the default aesthetic mapping (cholesterol
    on age) with a call to `geom_smooth`, and a final call to `labs` clarifies the
    vertical axis title.'
  prefs: []
  type: TYPE_NORMAL
- en: The plots themselves reveal, generally, some of the trends you’ll have picked
    up on an earlier analysis of these data ([Section 21.5.2](ch21.xhtml#ch21lev2sec203)).
    Increasing age tends to be associated with an increase in mean cholesterol, though
    that relationship seems, at least visually, less prominent for males. The overall
    smaller size of the points in the small frame column on the left makes sense—those
    with a smaller frame will typically weigh less than those with larger frames.
    There is also a tendency for the plots on the bottom row (females) to be of a
    darker shade than those along the top row—indicating that on average females are
    typically shorter than males. Any differences between the participants from the
    two counties, however, is difficult to discern—there doesn’t seem to be a systematic
    departure of the pattern of the Buckingham symbols (•) from that of the Louisa
    symbols (▴). (Remember, though, if you’re trying to understand the complex, potentially
    interactive relationships in your multivariate data, fitting an appropriate statistical
    model is preferable over plots alone.)
  prefs: []
  type: TYPE_NORMAL
- en: These elegant plots serve to further highlight the relative ease with which
    the `ggplot2` package can produce complex graphics—typically involving partitioning
    the observations by one or more factors—both in terms of an individual image or
    an arrangement of images. Although similar plots are of course still possible
    using base R methods, that approach demands a somewhat finer or lower-level handling
    of the details of your data subsets, as well as any varying aesthetic features.
    This doesn’t mean base R graphics are redundant or should be ignored (you’ll see
    some nice new plots achieved with traditional commands in [Chapter 25](ch25.xhtml#ch25))—it’s
    just that you can create certain graphical displays with less coding effort (and
    usually a prettier end result) by utilizing Wickham’s well-received implementation
    of the grammar of graphics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 24.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Load the `MASS` package and inspect the help file for the `UScereal` data. This
    data frame provides nutritional and other information concerning breakfast cereals
    for sale in the United States in the early 1990s.
  prefs: []
  type: TYPE_NORMAL
- en: Create a copy of the data frame; name it `cereal`. To ease plotting, collapse
    the `mfr` column (manufacturer) of `cereal` to be a factor with only three levels,
    with the corresponding labels `"General Mills"`, `"Kelloggs"`, and `"Other"`.
    Also, convert the `shelf` variable (shelf number from floor) to a factor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `cereal`, construct and store two `ggplot` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A scatterplot of calories on protein. Points should be colored according to
    shelf position and shaped according to manufacturer. Include simple linear regression
    lines for calories on protein, split according to shelf position. Ensure tidy
    axis and legend titles.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A set of kernel estimates of calories, with filled color differentiating shelf
    positions. Use 50 percent opaque fills, and again ensure tidy axis and legend
    titles.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Arrange the two plots in (b) on a single device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Produce a faceted graphic of calories on protein, with each panel corresponding
    to a manufacturer as defined in your `cereal` object. A LOESS smoother with a
    90 percent span should be superimposed upon each scatterplot. In addition, the
    points should be colored according to sugar content, sized according to sodium
    content, and shaped according to shelf position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the `car` package (downloading and installing it first if you haven’t already)
    and consider the `Salaries` object—a data frame detailing the salaries (in US
    dollars) of 397 academics working in the United States during the 2008–2009 school
    year ([Fox and Weisberg, 2011](ref.xhtml#ref25)). An inspection of the help file
    `?Salaries` informs you of the present variables, which, in addition to the salary
    figure, include each academic’s rank, sex, and research discipline (as factors)
    as well as the number of years of service.
  prefs: []
  type: TYPE_NORMAL
- en: Produce a `ggplot` object, named `gg1`, of a scatterplot of salary on the vertical
    axis against years of service on the horizontal axis. Color should be used to
    distinguish between males and females, along with sex-specific LOESS trends, and
    ensure axis and legend titles are understandable. View your plot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following three additional plot objects, again ensuring tidy axis
    and legend titles. Name the following `gg2`, `gg3`, and `gg4`, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Side-by-side boxplots of salary, split by rank. Each boxplot should be further
    split up according to sex (this can be done simply in the default aesthetic mapping—try
    assigning the sex variable to either `col` or `fill`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Side-by-side boxplots of salary, split by discipline, with each discipline split
    further by sex using color or fill.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Kernel density estimates of salary, using 30 percent opaque fills to distinguish
    rank.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Display your four plot objects (`gg1`, `gg2`, `gg3`, and `gg4`) from (e) and
    (f) in a single device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, plot the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A series of kernel density estimates of salary using 70 percent opaque fills
    to distinguish between males and females, faceted by academic rank.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scatterplots of salary on years of service, using color to distinguish between
    males and females, faceted by discipline as rows and by academic rank as columns.
    Each scatterplot should have a sex-specific simple linear regression line with
    confidence band superimposed and have free horizontal scales.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**24.4 Interactive Tools in ggvis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To wrap up this chapter, I’ll touch on a relatively new addition to the “gg”
    family, `ggvis`, by Chang and Wickham ([2015](ref.xhtml#ref10)). The package enables
    you to design flexible statistical plots that the end user can interact with.
    The results are provided as web graphics. You’ll see the image pop up as a new
    tab in your default web browser (if you’re using the RStudio IDE—see [Appendix
    B](app01.xhtml#app01)—the `ggvis` graphics are embedded within the Viewer pane).
  prefs: []
  type: TYPE_NORMAL
- en: As a cautionary note, be aware that `ggvis` is, at the time of writing, still
    under development by its authors. New functionality is being added and bugs addressed.
    If you’re interested in the functionality, visit the `ggvis` website at *[http://ggvis.rstudio.com/](http://ggvis.rstudio.com/)*.
    The site contains a beginner-friendly tutorial and recipe book of things that
    are currently possible. Here, I’ll just give you an overview of `ggvis`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `ggvis` package along with its dependencies and then load it with
    a call to `library("ggvis")`. Also make sure you have access to the student survey
    data, `survey`, by loading the `MASS` package. Create the following object to
    be used in the upcoming examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The common way to begin a `ggvis` graphic is to declare the data frame of interest,
    followed by a call to `ggvis` that defines the variables to be used and then to
    pile on the layers. When you use the variables from the data frame, they must
    be prefaced by a `~`, which explicitly tells R that you’re referring to a column
    of that data frame and not another object of the same name somewhere else. To
    add functions in the object definition, you don’t use `+` as in `ggplot2`, but
    `%>%` (called a *pipe*). The equivalents of the `geom_` functions in `ggplot2`
    are prefaced by `layer_` in `ggvis`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a simple static plot. The topmost image of [Figure 24-7](ch24.xhtml#ch24fig7),
    a histogram of the height measurements, can be obtained with the following execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `surv` data frame is declared, and then you pipe to `ggvis`, which instructs
    the `~Height` variable to be mapped to the *x*-axis. Last, a pipe to `layer_histograms`
    produces the graphic, which assigns a default binwidth based on the range of the
    *x*-mapped data.
  prefs: []
  type: TYPE_NORMAL
- en: So what? You’ve already created lot of histograms. But wouldn’t it be great
    if you could play with the value of the binwidth without needing to create static
    plot after static plot? The `input_` collection of commands in `ggvis` allows
    you to instruct the resulting graphic to take interactive input. Consider the
    following code; [Figure 24-7](ch24.xhtml#ch24fig7) shows my result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f24-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 24-7: Histograms of the height observations from the* `survey` *data
    frame, using* `ggvis`*. Top: Default static plot. Bottom: The result of incorporating
    a slider button tied to the binwidth—the user can interact with, and immediately
    see, the effect of altering the bins.*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `width` argument that controls the feature of interest is instructed
    to take the result of `input_slider`, which sets up an interactive slider button.
    The range of the slider values for `width` is set as `1` to `15` (inclusive),
    and the optional argument `label` provides a title for the interactive gadget.
    Last, using `fill` in `layer_histogram` sets the color of the bars. Note the particular
    assignment `fill:="gray"` uses `:=`, not just `=`. The `=` alone is used in `ggvis`
    for mapping variables, that is, when the feature of interest is to be passed a
    variable subject to change, essentially like an aesthetic mapping in `ggplot2`.
    The combination of `:=` should be interpreted as a set constant, that is, when
    you simply intend to universally fix a certain feature.
  prefs: []
  type: TYPE_NORMAL
- en: Once the code successfully executes, you can experiment with sliding the button
    for smaller and larger binwidths. It’s interesting to gauge just how much your
    interpretation of the distribution changes along with it. As the text printed
    out beneath the executed commands in the console tells you, you have to exit the
    interactive plot to use R again. Pressing ESC will terminate the interactivity
    and return control to the user at the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Other kinds of interactive abilities include `input_select` (for a drop-down
    menu), `input_radiobuttons` (radio button options), and `input_checkbox` (for
    checkboxes). You can even set up interactive text or numeric input boxes with
    `input_numeric`. See the relevant help files or the `ggvis` website for further
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example based on the `surv` data frame, let’s try a scatterplot.
    Starting again with a simple static plot, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I won’t show this result here, but you can see from the call to `ggvis` that
    you’ll be plotting height against handspan and that you’re universally enlarging
    the points as well as setting a universal level of 30 percent opacity. The last
    pipe to `layer_points` produces the image. As with the static plot of the histogram,
    since there’s no interactivity, you don’t need to “exit” the plot—you’re returned
    control at the console prompt immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more interesting graphic, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, three objects are created for the interactive bits. A set of radio buttons
    specifies the color of the plotted points according to one of three possible categorical
    variables (`Sex`, `Smoke`, or `Exer`), and two slider buttons control the point
    size and opacity. Note that when you intend to use variables from the data frame
    as ingredients for interactive behavior, you need to supply their exact names
    as a vector of character strings and set the optional `map=as.name`; this is done
    when defining the `filler` object. In the subsequent call to `ggvis`, you pass
    `filler` to `fill`, using `=`. The two slider buttons in the objects `sizer` and
    `opacityer` are passed to the relevant arguments with `:=` since they don’t depend
    on variables in the data frame. The call to `layer_points` generates the plot,
    and additional pipes to `add_axis` and `add_legend` simply tidy up the *x*-axis
    and legend titles from their defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The top of [Figure 24-8](ch24.xhtml#ch24fig8) shows a screenshot of the result,
    where I’ve selected the point color to vary according to the exercise frequency
    variable, reduced the point size, and chosen a moderate-to-high level of opacity.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f24-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 24-8: Two examples of* `ggvis` *scatterplots of height on handspan
    of the student survey data. Top: Color (fill) changed using radio buttons based
    on sex, smoking status, or exercise frequency and slider buttons for point size
    and opacity. Bottom: Splitting points by sex using color and superimposing sex-specific
    LOESS smoothers and corresponding CIs; their smoothing span is controllable via
    a slider button.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s produce the same scatterplot but settle on using sex to color
    the points. You can add separate LOESS smoothers to males and females and dynamically
    control the degree of smoothing using a slider button. This last example, a screenshot
    of which appears on the bottom of [Figure 24-8](ch24.xhtml#ch24fig8), is the result
    of executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: LOESS smoothers are added with the `layer_smooths` command, whose `span` argument,
    the target parameter of interest, is assigned an `input_slider`. Its range of
    possible values is set as usual, and the optional `value` argument (also applicable
    in other `input_` functions) sets the starting value when the plot is first initialized.
    Additionally, the `se=TRUE` argument to `layer_smooths` ensures 95 percent CIs
    accompany the smoothed trends. Note that the pipe to `layer_smooths` is preempted
    by a pipe through `group_by(Sex)`. Without it, the smoothers would simply be applied
    to the `x` and `y` data as a whole (also note, at the time of writing, you don’t
    preface the variable name with `~` in `group_by`).
  prefs: []
  type: TYPE_NORMAL
- en: As such, `ggvis` shows great potential for a more dynamic experience for visual
    data exploration. These tools are especially useful in activities such as presentations
    or website designs, where you can offer your audience an interactive appreciation
    of your data in a grammar of graphics style. If you’re interested in using these
    tools, I strongly encourage you to keep abreast of developments at the `ggvis`
    website.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 24.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the `car` and `ggvis` packages are loaded. Revisit the `Salaries` data
    frame you looked at in [Exercise 24.1](ch24.xhtml#ch24exc1); inspect the help
    file `?Salaries` to remind yourself of the present variables.
  prefs: []
  type: TYPE_NORMAL
- en: Produce an interactive scatterplot of salary on the vertical axis and the years
    of service on the horizontal axis. Employ radio buttons to color points according
    to either academic rank, research discipline, or sex. Use pipes to `add_legend`
    and `add_axis` to omit a legend title and to tidy up the axis titles, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pipe to `layer_densities` (which you’ve not yet met) is used to produce kernel
    density estimates, similar to those appearing in [Figure 24-5](ch24.xhtml#ch24fig5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `ggvis` to create a static plot of kernel density estimates of salary distributions,
    split up according to academic rank. To do this, assign the salary variable to
    `x` and the rank variable to `fill`, followed by a pipe to `group_by` to explicitly
    instruct grouping by the rank variable. Lastly, piping to `layer_densities` (just
    use all default argument values in this instance) will generate the graphic. Your
    result should resemble the `gg4` object from [Exercise 24.1](ch24.xhtml#ch24exc1).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like the `width` argument to `layer_histograms` is used to control the
    appearance of a histogram, the `adjust` argument in `layer_densities` is used
    to control the degree of smoothness of the kernel estimates. Reproduce the rank-specific
    kernel estimates from the previous plot, but this time, the graphic should be
    interactive—implement a slider button with a range of 0.2 to 2 and a label of
    `"Smoothness"` to control the smoothing adjustment. At your discretion, either
    suppress or clarify the axis and legend titles of the result.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure you have the `MASS` package loaded, once more gaining access to the
    `UScereal` data frame. If you haven’t already done so, inspect the help file `?UScereal`
    and re-create the `cereal` object exactly as specified in [Exercise 24.1](ch24.xhtml#ch24exc1)
    (a). Then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up an object for radio buttons to choose among the manufacturer, the shelf,
    and the vitamins variables. Make sure the labels for each radio button are clear,
    and set up an appropriate title label for what will form the collection of options
    to color the points. Name the object `filler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Borrowing the `sizer` and `opacityer` objects created in [Section 24.4](ch24.xhtml#ch24lev1sec85)
    and using the object you just created in (c) to control `fill`, create an interactive
    scatterplot of calories on protein. Tidy up the axis titles and suppress the legend
    title for the point color fill. The result should essentially be the same, in
    terms of functionality, as the graphic appearing as the topmost screenshot in
    [Figure 24-8](ch24.xhtml#ch24fig8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new object for the same radio buttons as specified in (c) that will
    control the shape of the points (in other words, the characters used to plot points).
    Modify the title label accordingly. Name this object `shaper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, re-create the interactive scatterplot of calories on protein exactly
    as in (d), but this time additionally assigning `shaper` from (e) to the `shape`
    modifier in your call to `ggvis`. To prevent the legends for the two sets of radio
    buttons from overlapping each other, you need to add the following pipes to your
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: add_legend("shape",title="",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: properties=legend_props(legend=list(y=100)))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_options(duration=0)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first simply moves the legend for the `shape` modifier vertically downward,
    and the second eliminates the slight “animation delay” that occurs by default
    when switching between options in the interactive graphic. Once more, use additional
    calls to `add_axis` and `add_legend` to clarify or suppress axis and legend titles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ggplot` | Initialize `ggplot2` plot | [Section 24.1](ch24.xhtml#ch24lev1sec82),
    [p. 610](ch24.xhtml#page_610) |'
  prefs: []
  type: TYPE_TB
- en: '| `geom_smooth` | Trend line geom | [Section 24.2.1](ch24.xhtml#ch24lev2sec238),
    [p. 612](ch24.xhtml#page_612) |'
  prefs: []
  type: TYPE_TB
- en: '| `loess` | Calculate LOESS (base R) | [Section 24.2.1](ch24.xhtml#ch24lev2sec238),
    [p. 612](ch24.xhtml#page_612) |'
  prefs: []
  type: TYPE_TB
- en: '| `rev` | Reverse vector elements | [Section 24.2.1](ch24.xhtml#ch24lev2sec238),
    [p. 612](ch24.xhtml#page_612) |'
  prefs: []
  type: TYPE_TB
- en: '| `adjustcolor` | Alter color opacity (base R) | [Section 24.2.1](ch24.xhtml#ch24lev2sec238),
    [p. 612](ch24.xhtml#page_612) |'
  prefs: []
  type: TYPE_TB
- en: '| `geom_density` | Kernel density geom | [Section 24.2.2](ch24.xhtml#ch24lev2sec239),
    [p. 614](ch24.xhtml#page_614) |'
  prefs: []
  type: TYPE_TB
- en: '| `ggtitle` | Add `ggplot2` title | [Section 24.2.2](ch24.xhtml#ch24lev2sec239),
    [p. 615](ch24.xhtml#page_615) |'
  prefs: []
  type: TYPE_TB
- en: '| `grid.arrange` | Multiple `ggplot2` plots | [Section 24.3.1](ch24.xhtml#ch24lev2sec240),
    [p. 616](ch24.xhtml#page_616) |'
  prefs: []
  type: TYPE_TB
- en: '| `facet_wrap` | One-factor faceting | [Section 24.3.2](ch24.xhtml#ch24lev2sec241),
    [p. 619](ch24.xhtml#page_619) |'
  prefs: []
  type: TYPE_TB
- en: '| `facet_grid` | Two-factor faceting | [Section 24.3.2](ch24.xhtml#ch24lev2sec241),
    [p. 620](ch24.xhtml#page_620) |'
  prefs: []
  type: TYPE_TB
- en: '| `ggvis` | Initialize `ggvis` plot | [Section 24.4](ch24.xhtml#ch24lev1sec85),
    [p. 624](ch24.xhtml#page_624) |'
  prefs: []
  type: TYPE_TB
- en: '| `%>%` | Pipe to `ggvis` layer | [Section 24.4](ch24.xhtml#ch24lev1sec85),
    [p. 624](ch24.xhtml#page_624) |'
  prefs: []
  type: TYPE_TB
- en: '| `layer_histograms ggvis` | histogram layer | [Section 24.4](ch24.xhtml#ch24lev1sec85),
    [p. 624](ch24.xhtml#page_624) |'
  prefs: []
  type: TYPE_TB
- en: '| `input_slider` | Interactive slider | [Section 24.4](ch24.xhtml#ch24lev1sec85),
    [p. 624](ch24.xhtml#page_624) |'
  prefs: []
  type: TYPE_TB
- en: '| `:=` | Constant `ggvis` assignment | [Section 24.4](ch24.xhtml#ch24lev1sec85),
    [p. 624](ch24.xhtml#page_624) |'
  prefs: []
  type: TYPE_TB
- en: '| `layer_points ggvis` | points layer | [Section 24.4](ch24.xhtml#ch24lev1sec85),
    [p. 626](ch24.xhtml#page_626) |'
  prefs: []
  type: TYPE_TB
- en: '| `input_radiobuttons` | Interactive buttons | [Section 24.4](ch24.xhtml#ch24lev1sec85),
    [p. 626](ch24.xhtml#page_626) |'
  prefs: []
  type: TYPE_TB
- en: '| `add_legend` | Add/alter `ggvis` legend | [Section 24.4](ch24.xhtml#ch24lev1sec85),
    [p. 626](ch24.xhtml#page_626) |'
  prefs: []
  type: TYPE_TB
- en: '| `layer_smooths ggvis` | trend line layer | [Section 24.4](ch24.xhtml#ch24lev1sec85),
    [p. 627](ch24.xhtml#page_627) |'
  prefs: []
  type: TYPE_TB
- en: '| `add_axis` | Add/alter `ggvis` axis | [Section 24.4](ch24.xhtml#ch24lev1sec85),
    [p. 627](ch24.xhtml#page_627) |'
  prefs: []
  type: TYPE_TB
