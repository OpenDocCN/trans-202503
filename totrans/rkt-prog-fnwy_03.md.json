["```\n(lambda (x) (+ 1 x))\n```", "```\n(λ (x) (+ 1 x))\n```", "```\n> ((λ (x y) (+ (* 2 x) y)) 4 5)\n13\n```", "```\n> (let ([x 4]\n        [y 5])\n    (+ (* 2 x) y))\n13\n```", "```\n> (define foo (λ (x y) (+ (* 2 x) y)))\n> (foo 4 5)\n13\n```", "```\n> (define (foo x y) (+ (* 2 x) y))\n> (foo 4 5)\n13\n```", "```\n> (map (λ (x) (+ 1 x)) '(1 2 3))\n'(2 3 4)\n```", "```\n> (define my-add1 (λ (x) (+ 1 x)))\n> (map my-add1 '(1 2 3)) ; this works too\n'(2 3 4)\n```", "```\n> (map + '(1 2 3) '(2 3 4))\n'(3 5 7)\n```", "```\n> (+ 1 2 3 4)\n10\n```", "```\n> (+ '(1 2 3 4))\n. . +: contract violation\n  expected: number?\n  given: '(1 2 3 4)\n```", "```\n> (apply + '(1 2 3 4))\n10\n```", "```\n> (foldr + 0 '(1 2 3 4))\n10\n```", "```\n> (foldl cons '() '(1 2 3 4))\n'(4 3 2 1)\n\n> (foldr cons '() '(1 2 3 4))\n'(1 2 3 4)\n```", "```\n(define (n+1_squared n) (sqr (add1 n)))\n```", "```\n> (define n+1_squared (compose sqr add1))\n> (n+1_squared 4)\n25\n```", "```\n> ((compose sqr add1) 4)\n25\n```", "```\n> (filter even? '(1 2 3 4 5 6))\n'(2 4 6)\n```", "```\n> (define ten 10)\n> ten\n10\n```", "```\n(let ([x 4]\n      [y 5])\n  (+ (* 2 x) y))\n```", "```\n(let ([x 4]\n      [y 5]\n      [z (* 2 x)])\n  (+ z y))\n```", "```\n> (let* ([x 4]\n         [y 5]\n         [z (* 2 x)])\n    (+ z y))\n13\n```", "```\n> (let ([x 4]\n        [y 5])\n    (let ([z (* 2 x)])\n      (+ z y)))\n13\n```", "```\n(define (div-3-5 n)\n  (let ([div3 (= 0 (remainder n 3))]\n        [div5 (= 0 (remainder n 5))])\n    (cond [(and div3 div5) 'div-by-both]\n          [div3 'div-by-3]\n          [div5 'div-by-5]\n          [else 'div-by-neither])))\n```", "```\n> (div-3-5 10)\n'div-by-5\n\n> (div-3-5 6)\n'div-by-3\n\n> (div-3-5 15)\n'div-by-both\n\n> (div-3-5 11)\n'div-by-neither\n```", "```\n(define (parity n)\n  (if (= 0 (remainder n 2)) 'even 'odd))\n```", "```\n> (parity 5)\n'odd\n> (parity 4)\n'even\n```", "```\n> (when (> 5 4)\n    (displayln 'a)\n    (displayln 'b))\na\nb\n\n> (when (< 5 4) ; doesn't generate output\n    (displayln 'a)\n    (displayln 'b))\n```", "```\n> (unless (> 5 4) ; doesn't generate output\n    (displayln 'a)\n    (displayln 'b))\n\n> (unless (< 5 4)\n    (displayln 'a)\n    (displayln 'b))\na\nb\n```", "```\ndef sum(n):\n    s = 0\n    while n > 0:\n     ➊ s = s + n\n     ➋ n = n - 1\n    return s\n```", "```\n (define (sum n)\n➊ (if (= 0 n) 0\n    ➋ (+ n (sum (- n 1)))))\n```", "```\n> (sum 100)\n5050\n```", "```\n(define (sum n)\n  (if (= 0 n) 0\n   ➊ (+ n (sum (- n 1)))))\n```", "```\n(define (sum n)\n  (define (s n acc)\n ➊ (if (= 0 n) acc\n     ➋ (s (- n 1) (+ acc n))))\n  (s n 0))\n```", "```\n(define (sum n)\n  (let loop ([n n] [acc 0])\n    (if (= 0 n) acc\n        (loop (- n 1) (+ acc n)))))\n```", "```\n(define (sum n)\n  (let ([s 0])   ; initialize s to zero\n    (do ()       ; an optional initializer statement can go here\n      ((< n 1))  ; do until this becomes true\n      (set! s (+ s n))\n      (set! n (- n 1)))\n    s))\n```", "```\nint sum(int n)\n{\n  int s = 0;\n  for (i=1; i<= n; i++) // initialize i=1, set i = i+1 at each iteration\n                        // do while i<= n\n  {\n      s = s + i;\n  }\n  return s;             // return s\n}\n```", "```\n (define (sum n)\n➊ (let ([s 0])\n  ➋ (do ([i 1 (add1 i)])   ; initialize i=1, set i = i+1 at each iteration\n    ➌ ((> i n) s)          ; do until i>n, then return s\n    ➍ (set! s (+ s i)))))\n```", "```\n> (define digits (in-range 10))\n> (stream-first digits)\n0\n\n> (stream-first (stream-rest digits))\n1\n\n> (stream-ref digits 5)\n5\n```", "```\n> (define naturals (in-naturals))\n> (stream-first naturals)\n0\n\n> (stream-first (stream-rest naturals))\n1\n\n> (stream-ref naturals 1000)\n1000\n```", "```\n> (let* ([h \"Hello\"]\n      ➊ [l (string-length h)])\n   ➋ (for ([i (in-range l)])\n     ➌ (display (string-ref h i))\n      (newline)))\nH\ne\nl\nl\no\n```", "```\n> (for ([i 5]) (display i))\n01234\n```", "```\n> (for ([c \"Hello\"])\n    (display c)\n    (newline))\nH\ne\nl\nl\no\n```", "```\n> (define (list-chars str)\n    (for ([c str]\n          [i (in-naturals)])\n      (printf \"~a: ~a\\n\" i c)))\n\n> (list-chars \"Hello\")\n0: H\n1: e\n2: l\n3: l\n4: o\n```", "```\n> (for* ([i (in-range 2 7 4)]\n         [j (in-range 1 4)])\n    (display (list i j (* i j)))\n    (newline))\n(2 1 2)\n(2 2 4)\n(2 3 6)\n(6 1 6)\n(6 2 12)\n(6 3 18)\n```", "```\n> (for/list ([x (in-naturals)] #:break (> x 10)) (sqr x))\n'(0 1 4 9 16 25 36 49 64 81 100)\n```", "```\n> (for/list ([x (in-range 11)]) (sqr x))\n'(0 1 4 9 16 25 36 49 64 81 100)\n```", "```\n> (for/list ([x (in-range 11)] #:when (even? x)) (sqr x))\n'(0 4 16 36 64 100)\n```", "```\n> (for ([n (in-range 1 10)] #:unless (= n 5))\n    (printf \"~a: ~a\\n\" n (sqr n)))\n1: 1\n2: 4\n3: 9\n4: 16\n6: 36\n7: 49\n8: 64\n9: 81\n```", "```\n> (for/and ([x '(2 4 6)]) (even? x))\n#t\n\n> (for/and ([x '(2 4 5 6)]) (even? x)) \n#f\n```", "```\n> (for/and ([x '(2 4 5 6)]\n            [y #(3 5 9 8)])\n    (< x y)) \n#t\n> (for/and ([x '(2 6 5 6)]\n            [y #(3 5 9 8)])\n    (< x y)) \n#f\n```", "```\n> (for/or ([x '(2 7 4 6)]) (> x 5)) \n#t\n\n> (for/or ([x '(2 1 4 5)]) (> x 5)) \n#f\n```", "```\n> (for/first ([x '(2 1 4 6 7 1)] #:when (> x 5)) x)\n6\n\n> (for/first ([x '(2 1 4 5 2)] #:when (> x 5)) x)\n#f\n```", "```\n> (for/last ([x '(2 1 4 6 7 1)] #:when (> x 5)) x)\n7\n```", "```\n> (for/sum ([i (in-range 1 11)]) (sqr i))\n385\n```", "```\n> (for/product ([i (in-range 1 11)]) (sqr i))\n13168189440000\n```", "```\n(define (make-comp bal int)\n  (let ([rate (add1 (/ int 100.0))])\n ➊ (λ () (set! bal (* bal rate))  (round bal))))\n```", "```\n> (define bal (make-comp 100 4))\n\n> (bal)\n104.0\n\n> (bal)\n108.0\n\n> (bal)\n112.0\n\n> (bal)\n117.0\n```", "```\n(define (fact n)\n  (if ( = 0 n) 1\n      (* n (fact (- n 1)))))\n```", "```\n(define fact\n  (let ([h (make-hash)]) ; hash table to contain memoized values\n ➊ (define (fact n)\n      (cond [(= n 0) 1]\n         ➋ [(hash-has-key? h n) (hash-ref h n)]\n             [else\n             ➌ (let ([f (* n (fact (- n 1)))]) \n               ➍ (hash-set! h n f)\n                f)]))\n ➎ fact))\n```", "```\n> (car q)\n'tom\n\n> (set! q (cdr q))\n> q\n'(dick harry)\n```", "```\n> (set! q (append q (list 'sue)))\n> q\n'(dick harry sue)\n```", "```\n> (define a (mcons 'apple 'orange))\n> (define b a)\n> a\n(mcons 'apple 'orange)\n> b\n(mcons 'apple 'orange)\n\n> (set-mcdr! a 'banana)\n> a\n(mcons 'apple 'banana)\n> b\n(mcons 'apple 'banana)\n```", "```\n➊ (define queue%\n\n  ➋ (class object%\n\n    ➌ (init [queue-list '()])\n\n    ➍ (define head '{})\n       (define tail '{}) \n\n    ➎ (super-new) \n\n    ➏ (define/public (enqueue val)\n         (let ([t (mcons val '())])\n           (if (null? head)\n               (begin\n                 (set! head t)\n                 (set! tail t))\n               (begin\n                 (set-mcdr! tail t)\n                 (set! tail t)))))\n\n    ➐ (define/public (dequeue)\n         (if (null? head) (error \"Queue is empty.\")\n             (let ([val (mcar head)])\n            ➑ (set! head (mcdr head))\n               (when (null? head) (set! tail '()))\n               val)))\n\n      (define/public (print-queue)\n        (define (prt rest)\n          (if (null? rest)\n              (newline)\n              (let ([h (mcar rest)]\n                    [t (mcdr rest)])\n                (printf \"~a \" h)\n                (prt t))))\n         (prt head))\n\n    ➒ (for ([v queue-list]) (enqueue v))))\n```", "```\n> (define queue (new queue% [queue-list '(tom dick harry)]))\n\n> (send queue dequeue)\n'tom\n\n> (send queue enqueue 'sue)\n> (send queue print-queue)\ndick harry sue \n\n> (send queue dequeue)\n'dick\n\n> (send queue dequeue)\n'harry\n\n> (send queue dequeue)\n'sue\n\n> (send queue dequeue)\n. . Queue is empty.\n```", "```\n> (define moves (- (expt 2 64) 1))\n> moves\n18446744073709551615\n\n> (define seconds-in-a-year (* 60 60 24 365.25))\n> seconds-in-a-year\n31557600.0\n\n> (/ moves seconds-in-a-year)\n584542046090.6263\n```", "```\n➊ (define (hanoi n f t)\n  ➋ (if (= 1 n) (list (list f t))        ; only a single disk to move\n      ➌ (let* ([u (- 3 (+ f t))]         ; determine unused peg\n             ➍ [m1 (hanoi (sub1 n) f u)] ; move n-1 disks from f to u\n             ➎ [m2 (list f t)]           ; move single disk from f to t\n             ➏ [m3 (hanoi (sub1 n) u t)]); move disks from u to t\n        ➐ (append m1 (cons m2 m3)))))\n```", "```\n> (hanoi 3 0 2)\n'((0 2) (0 1) (2 1) (0 2) (1 0) (1 2) (0 2))\n```", "```\n(define (F n)\n  (if (<= n 1) n\n    (+ (F (- n 1)) (F (- n 2)))))\n```", "```\n(define (F n)\n  (define (f a b c)\n    (if (= c 0) b\n        (f (+ a b) a (- c 1))))\n  (f 1 0 n))\n```", "```\n(define F\n  (let ([f (make-hash)]) ; hash table to contain memoized F values\n    (define (fib n)\n      (cond [(<= n 1) n]\n            [(hash-has-key? f n) (hash-ref f n)]\n            [else\n              (let ([fn (+ (fib (- n 1)) (fib (- n 2)))])\n                (hash-set! f n fn)\n                fn)]))\n    fib))\n```", "```\n(define (F n)\n  (let* ([phi (/ (add1 (sqrt 5)) 2)]\n         [phi^n (expt phi n)])\n    (round (/ phi^n (sqrt 5)))))\n```", "```\n   #lang racket\n   (require math/number-theory)\n\n➊ (define triples '())\n   (define (gen-triples d1)\n  ➋ (let* ([q (/ 36 d1)]\n            [divs (divisors q)])\n     ➌ (define (try-div divs)\n          (when (not (null? divs))\n        ➍ (let* ([d2 (car divs)] [d3 (/ q d2)])\n          ➎ (when (<= d3 d2 d1)\n            ➏ (set! triples (cons (list d3 d2 d1) triples)))\n            (try-div (cdr divs)))))\n      (try-div divs)))\n\n➐ (for ([d (divisors 36)]) (gen-triples d))\n\n   triples\n```", "```\n(for ([triple triples]) (printf \"~a: ~a\\n\" triple (apply + triple)))\n```"]