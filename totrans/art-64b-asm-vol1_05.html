<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="147" id="Page_147"/>4</span><br/>
<span class="ChapterTitle">Constants, Variables, and Data Types</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro"><span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> discussed the basic format for data in memory. <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> covered how a computer system physically organizes that data in memory. This chapter finishes the discussion by connecting the concept of <em>data representation</em> to its actual physical representation. As the title indicates, this chapter concerns itself with three main topics: constants, variables, and data structures. I do not assume that you’ve had a formal course in data structures, though such experience would be useful.</p>
<p>This chapter discusses how to declare and use constants, scalar variables, integers, data types, pointers, arrays, records/structures, and unions. You must master these subjects before going on to the next chapter. Declaring and accessing arrays, in particular, seem to present a multitude of problems to beginning assembly language programmers. However, the rest of this text depends on your understanding of these data structures and their memory <span epub:type="pagebreak" title="148" id="Page_148"/>representation. Do not try to skim over this material with the expectation that you will pick it up as you need it later. You will need it right away, and trying to learn this material along with later material will only confuse you more.</p>
<h2 id="h1-501089c04-0001">	4.1	The imul Instruction</h2>
<p class="BodyFirst">This chapter introduces arrays and other concepts that will require the expansion of your x86-64 instruction set knowledge. In particular, you will need to learn how to multiply two values; hence, this section looks at the <code>imul</code> (<em>integer multiply</em>) instruction.</p>
<p>The <code>imul</code> instruction has several forms. This section doesn’t cover all of them, just the ones that are useful for array calculations (for the remaining <code>imul</code> instructions, see <span class="xref" itemid="xref_target_“Arithmetic Expressions” in Chapter 6">“Arithmetic Expressions” in Chapter 6</span>). The <code>imul</code> variants of interest right now are as follows:</p>
<pre><code>; The following computes <var>destreg</var> = <var>destreg</var> * <var>constant</var>:

imul <var>destreg</var><sub>16</sub>, <var>constant</var>
imul <var>destreg</var><sub>32</sub>, <var>constant</var>
imul <var>destreg</var><sub>64</sub>, <var>constant</var><sub>32</sub>

; The following computes <var>dest</var> = <var>src</var> * <var>constant</var>:

imul <var>destreg</var><sub>16</sub>, <var>srcreg</var><sub>16</sub>, <var>constant</var>
imul <var>destreg</var><sub>16</sub>, <var>srcmem</var><sub>16</sub>, <var>constant</var>

imul destreg<sub>32</sub>, srcreg<sub>32</sub>, <var>constant</var>
imul destreg<sub>32</sub>, srcmem<sub>32</sub>, <var>constant</var>

imul <var>destreg</var><sub>64</sub>, <var>srcreg</var><sub>64</sub>, <var>constant</var><sub>32</sub>
imul <var>destreg</var><sub>64</sub>, <var>srcmem</var><sub>64</sub>, <var>constant</var><sub>32</sub>

; The following computes <var>dest</var> = <var>destreg</var> * <var>src</var>:

imul <var>destreg</var><sub>16</sub>, <var>srcreg</var><sub>16</sub>
imul <var>destreg</var><sub>16</sub>, <var>srcmem</var><sub>16</sub>
imul <var>destreg</var><sub>32</sub>, <var>srcreg</var><sub>32</sub>
imul <var>destreg</var><sub>32</sub>, <var>srcmem</var><sub>32</sub>
imul <var>destreg</var><sub>64</sub>, <var>srcreg</var><sub>64</sub>
imul <var>destreg</var><sub>64</sub>, <var>srcmem</var><sub>64</sub></code></pre>
<p>Note that the syntax of the <code>imul</code> instruction is different from that of the <code>add</code> and <code>sub</code> instructions. In particular, the destination operand must be a register (<code>add</code> and <code>sub</code> both allow a memory operand as a destination). Also note that <code>imul</code> allows three operands when the last operand is a constant. Another important difference is that the <code>imul</code> instruction allows only 16-, 32-, and 64-bit operands; it does not multiply 8-bit operands. Finally, as is true for most instructions that support the immediate addressing mode, the CPU limits constant sizes to 32 bits. For 64-bit operands, the x86-64 will sign-extend the 32-bit immediate constant to 64 bits.</p>
<p><span epub:type="pagebreak" title="149" id="Page_149"/><code>imul</code> computes the product of its specified operands and stores the result into the destination register. If an overflow occurs (which is always a signed overflow, because <code>imul</code> multiplies only signed integer values), then this instruction sets both the carry and overflow flags. <code>imul</code> leaves the other condition code flags undefined (so, for example, you cannot meaningfully check the sign flag or the zero flag after executing <code>imul</code>).</p>
<h2 id="h1-501089c04-0002">	4.2	The inc and dec Instructions</h2>
<p class="BodyFirst">As several examples up to this point have indicated, adding or subtracting 1 from a register or memory location is a very common operation. In fact, these operations are so common that Intel’s engineers included a pair of instructions to perform these specific operations: <code>inc</code> (<em>increment</em>) and <code>dec</code> (<em>decrement</em>).</p>
<p>The <code>inc</code> and <code>dec</code> instructions use the following syntax:</p>
<pre><code>inc <var>mem</var>/<var>reg</var>
dec <var>mem</var>/<var>reg</var></code></pre>
<p>The single operand can be any legal 8-, 16-, 32-, or 64-bit register or memory operand. The <code>inc</code> instruction will add 1 to the specified operand, and the <code>dec</code> instruction will subtract 1 from the specified operand.</p>
<p>These two instructions are slightly shorter than the corresponding <code>add</code> or <code>sub</code> instructions (their encoding uses fewer bytes). There is also one slight difference between these two instructions and the corresponding <code>add</code> or <code>sub</code> instructions: they do not affect the carry flag.</p>
<h2 id="h1-501089c04-0003">	4.3	MASM Constant Declarations</h2>
<p class="BodyFirst">MASM provides three directives that let you define constants in your assembly language programs.<sup class="FootnoteReference"><a id="c04-footnoteref-1" href="#c04-footnote-1">1</a></sup> Collectively, these three directives are known as <em>equates</em>. You’ve already seen the most common form:</p>
<pre><code><var>symbol</var> = <var>constant_expression</var></code></pre>
<p>For example:</p>
<pre><code>MaxIndex = 15</code></pre>
<p>Once you declare a symbolic constant in this manner, you may use the symbolic identifier anywhere the corresponding literal constant is legal. These constants are known as <em>manifest</em> <em>constants</em>—symbolic representations that allow you to substitute the literal value for the symbol anywhere in the program.</p>
<p>Contrast this with <code>.const</code> variables; a<code> .const</code> variable is certainly a constant value because you cannot change its value at runtime. However, a memory <span epub:type="pagebreak" title="150" id="Page_150"/>location is associated with a <code>.const</code> variable; the operating system, not the MASM compiler, enforces the read-only attribute. Although it will certainly crash your program when it runs, it is perfectly legal to write an instruction like <code>mov ReadOnlyVar, eax</code>. On the other hand, it is no more legal to write <code>mov MaxIndex, eax </code>(using the preceding declaration) than it is to write <code>mov 15, eax</code>. In fact, both statements are equivalent because the compiler substitutes <code>15</code> for <code>MaxIndex</code> whenever it encounters this manifest constant.</p>
<p>Constant declarations are great for defining “magic” numbers that might possibly change during program modification. Most of the listings throughout this book have used manifest constants like <code>nl</code> (<em>newline</em>), <code>maxLen</code>, and <code>NULL</code>.</p>
<p>In addition to the <code>=</code> directive, MASM provides the <code>equ</code> directive:</p>
<pre><code><var>symbol</var> equ <var>constant_expression</var></code></pre>
<p>With a couple exceptions, these two equate directives do the same thing: they define a manifest constant, and MASM will substitute the <var>constant_expression</var> value wherever the <code>symbol</code> appears in the source file.</p>
<p>The first difference between the two is that MASM allows you to redefine symbols that use the <code>=</code> directive. Consider the following code snippet:</p>
<pre><code>maxSize  = 100

<var>Code that uses maxSize, expecting it to be 100</var>

maxSize  = 256

<var>Code that uses maxSize, expecting it to be 256</var></code></pre>
<p>You might question the term <em>constant</em> when it’s pretty clear in this example that <code>maxSize</code>’s value changes at various points in the source file. However, note that while <code>maxSize</code>’s value does change during assembly, at runtime the particular literal constant (100 or 256 in this example) can never change.</p>
<p>You cannot redefine the value of a constant you declare with an <code>equ</code> directive (at runtime or assembly time). Any attempt to redefine an <code>equ</code> symbol results in a symbol redefinition error from MASM. So if you want to prevent the accidental redefinition of a constant symbol in your source file, you should use the <code>equ</code> directive rather than the <code>=</code> directive.</p>
<p>Another difference between the <code>=</code> and <code>equ</code> directives is that constants you define with <code>=</code> must be representable as a 64-bit (or smaller) integer. Short character strings are legal as <code>=</code> operands, but only if they have eight or fewer characters (which would fit into a 64-bit value). Equates using <code>equ</code> have no such limitation. </p>
<p>Ultimately, the difference between <code>=</code> and <code>equ</code> is that the <code>=</code> directive computes the value of a numeric expression and saves that value to substitute wherever that symbol appears in the program. The <code>equ</code> directive, if its operand can be reduced to a numeric value, will work the same way. However, if the <code>equ</code> operand cannot be converted to a numeric value, then the <code>equ</code> directive will save its operand as textual data and substitute that textual data in place of the symbol.</p>
<p><span epub:type="pagebreak" title="151" id="Page_151"/>Because of the numeric/text processing, <code>equ</code> can get confused on occasion by its operand. Consider the following example:</p>
<pre><code>SomeStr  equ   "abcdefgh"
          .
          .
          .
memStr   byte  SomeStr</code></pre>
<p>MASM will report an error (<code>initializer magnitude too large for specified size</code> or something similar) because a 64-bit value (obtained by creating an integer value from the eight characters <code>abcdefgh</code>) will not fit into a byte variable. However, if we add one more character to the string, MASM will gladly accept this:</p>
<pre><code>SomeStr  equ   "abcdefghi"
          .
          .
          .
memStr   byte  SomeStr</code></pre>
<p>The difference between these two examples is that in the first case, MASM decides that it can represent the string as a 64-bit integer, so the constant is a quad-word constant rather than a string of characters. In the second example, MASM cannot represent the string of characters as an integer, so it treats the operand as a text operand rather than a numeric operand. When MASM does a textual substitution of the string <code>abcdefghi</code> for <code>memStr</code> in the second example, MASM assembles the code properly because strings are perfectly legitimate operands for the <code>byte</code> directive.</p>
<p>Assuming you really want MASM to treat a string of eight characters or fewer as a string rather than as an integer value, there are two solutions. The first is to surround the operand with <em>text delimiters</em>. MASM uses the symbols <code>&lt;</code> and <code>&gt;</code> as text delimiters in an <code>equ</code> operand field. So, you could use the following code to solve this problem:</p>
<pre><code>SomeStr  equ   &lt;"abcdefgh"&gt;
          .
          .
          .
memStr   byte  SomeStr</code></pre>
<p>Because the <code>equ</code> directive’s operand can be somewhat ambiguous at times, Microsoft introduced a third equate directive, <code>textequ</code>, to use when you want to create a text equate. Here’s the current example using a text equate:</p>
<pre><code>SomeStr  textequ   &lt;"abcdefgh"&gt;
          .
          .
          .
memStr   byte      SomeStr</code></pre>
<p><span epub:type="pagebreak" title="152" id="Page_152"/>Note that <code>textequ</code> operands must always use the text delimiters (<code>&lt;</code> and <code>&gt;</code>) in the operand field.</p>
<p>Whenever MASM encounters a symbol defined with the text directive in a source file, it will immediately substitute the text associated with that directive for the identifier. This is somewhat similar to the C/C++ <code>#define</code> macro (except you don’t get to specify any parameters). Consider the following example:</p>
<pre><code>maxCnt  =       10
max     textequ &lt;maxCnt&gt;
max     =       max+1</code></pre>
<p>MASM substitutes <code>maxCnt</code> for <code>max</code> throughout the program (after the <code>textequ</code> declaring <code>max</code>). In the third line of this example, this substitution yields the statement:</p>
<pre><code>maxCnt  =       maxCnt+1</code></pre>
<p>Thereafter in the program, MASM will substitute the value <code>11</code> everywhere it sees the symbol <code>maxCnt</code>. Whenever MASM sees <code>max</code> after that point, it will substitute <code>maxCnt</code>, and then it will substitute <code>11</code> for <code>maxCnt</code>.</p>
<p>You could even use MASM text equates to do something like the following:</p>
<pre><code>mv    textequ  &lt;mov&gt;
        .
        .
        .
       mv      rax,0</code></pre>
<p>MASM will substitute <code>mov</code> for <code>mv</code> and compile the last statement in this sequence into a <code>mov</code> instruction. Most people would consider this a huge violation of assembly language programming style, but it’s perfectly legal.</p>
<h3 id="h2-501089c04-0001">4.3.1	Constant Expressions</h3>
<p class="BodyFirst">Thus far, this chapter has given the impression that a symbolic constant definition consists of an identifier, an optional type, and a literal constant. Actually, MASM constant declarations can be a lot more sophisticated than this because MASM allows the assignment of a constant expression, not just a literal constant, to a symbolic constant. The generic constant declaration takes one of the following two forms:</p>
<pre><code><var>identifier</var> =   <var>constant_expression</var>
<var>identifier</var> equ <var>constant_expression</var></code></pre>
<p>Constant (integer) expressions take the familiar form you’re used to in high-level languages like C/C++ and Python. They may contain literal constant values, previously declared symbolic constants, and various arithmetic operators.</p>
<p><span epub:type="pagebreak" title="153" id="Page_153"/>The constant expression operators follow standard precedence rules (similar to those in C/C++); you may use the parentheses to override the precedence if necessary. In general, if the precedence isn’t obvious, use parentheses to exactly state the order of evaluation. <a href="#table4-1" id="tableanchor4-1">Table 4-1</a> lists the arithmetic operators MASM allows in constant (and address) expressions.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-1">Table 4-1</a>: Operations Allowed in Constant Expressions</p></figcaption>
<table id="table-501089c04-0001" border="1">
<thead>
<tr>
<td colspan="2"><b>Arithmetic operators</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>-</code> (unary negation)</td>
<td>Negates the expression immediately following <code>-</code>.</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Multiplies the integer or real values around the asterisk.</td>
</tr>
<tr>
<td><code>/</code></td>
<td>Divides the left integer operand by the right integer operand, producing an integer (truncated) result.</td>
</tr>
<tr>
<td><code>mod</code></td>
<td>Divides the left integer operand by the right integer operand, producing an integer remainder.</td>
</tr>
<tr>
<td><code>/</code></td>
<td>Divides the left numeric operand by the second numeric operand, producing a floating-point result.</td>
</tr>
<tr>
<td><code>+</code></td>
<td>Adds the left and right numeric operands.</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Subtracts the right numeric operand from the left numeric operand.</td>
</tr>
<tr>
<td><code>[]</code></td>
<td><var>expr</var><span class="SubscriptLiteral">1</span><code>[</code><var>expr</var><span class="SubscriptLiteral">2</span><code>]</code> computes the sum of <var>expr</var><span class="SubscriptLiteral">1</span> + <var>expr</var><span class="SubscriptLiteral">2</span>.</td>
</tr>
<tr>
<td colspan="2"><b>Comparison operators</b></td>
</tr>
<tr>
<td><code>EQ</code></td>
<td>Compares left operand with right operand. Returns true if equal.*</td>
</tr>
<tr>
<td><code>NE</code></td>
<td>Compares left operand with right operand. Returns true if not equal.</td>
</tr>
<tr>
<td><code>LT</code></td>
<td>Returns true if left operand is less than right operand.</td>
</tr>
<tr>
<td><code>LE</code></td>
<td>Returns true if left operand is <code>≤</code> right operand.</td>
</tr>
<tr>
<td><code>GT</code></td>
<td>Returns true if left operand is greater than right operand.</td>
</tr>
<tr>
<td><code>GE</code></td>
<td>Returns true if left operand is <code>≥</code> right operand.</td>
</tr>
<tr>
<td colspan="2"><b>Logical operators**</b></td>
</tr>
<tr>
<td><code>AND</code></td>
<td>For Boolean operands, returns the logical AND of the two operands.</td>
</tr>
<tr>
<td><code>OR</code></td>
<td>For Boolean operands, returns the logical OR of the two operands.</td>
</tr>
<tr>
<td><code>NOT</code></td>
<td>For Boolean operands, returns the logical negation (inverse).</td>
</tr>
<tr>
<td colspan="2"><b>Unary operators</b></td>
</tr>
<tr>
<td><code>HIGH</code></td>
<td>Returns the HO byte of the LO 16 bits of the following expression.</td>
</tr>
<tr>
<td><code>HIGHWORD</code></td>
<td>Returns the HO word of the LO 32 bits of the following expression.</td>
</tr>
<tr>
<td><code>HIGH32</code></td>
<td>Returns the HO 32 bits of the 64-bit expression following the operator.</td>
</tr>
<tr>
<td><code>LENGTHOF</code></td>
<td>Returns the number of data elements of the variable name following the operator.</td>
</tr>
<tr>
<td><code>LOW</code></td>
<td>Returns the LO byte of the expression following the operator.</td>
</tr>
<tr>
<td><code>LOWWORD</code></td>
<td>Returns the LO word of the expression following the operator.</td>
</tr>
<tr>
<td><code><span epub:type="pagebreak" title="154" id="Page_154"/>LOW32</code></td>
<td>Returns the LO dword of the expression following the operator.</td>
</tr>
<tr>
<td><code>OFFSET</code></td>
<td>Returns the offset into its respective section for the symbol following the operator.</td>
</tr>
<tr>
<td><code>OPATTR</code></td>
<td>Returns the attributes of the expression following the operator. The attributes are returned as a bit map with the following meanings:<br/>
bit 0: There is a code label in the expression.<br/>
bit 1: The expression is relocatable.<br/>
bit 2: The expression is a constant expression.<br/>
bit 3: The expression uses direct addressing. <br/>
bit 4: The expression is a register.<br/>
bit 5: The expression contains no undefined symbols.<br/>
bit 6: The expression is a stack-segment memory expression.<br/>
bit 7: The expression references an external label.<br/>
bits 8–11: Language type (probably 0 for 64-bit code).</td>
</tr>
<tr>
<td><code>SIZE</code></td>
<td>Returns the size, in bytes, of the first initializer in a symbol’s declaration.</td>
</tr>
<tr>
<td><code>SIZEOF</code></td>
<td>Returns the size, in bytes, allocated for a given symbol.</td>
</tr>
<tr>
<td><code>THIS</code></td>
<td>Returns an address expression equal to the value of the current program counter within a section. Must include type after <code>this</code>; for example, <code>this byte</code>.</td>
</tr>
<tr>
<td><code>$</code></td>
<td>Synonym for <code>this</code>.</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="h2-501089c04-0002">4.3.2	this and $ Operators</h3>
<p class="BodyFirst">The last two operators in <a href="#table4-1">Table 4-1</a> deserve special mention. The <code>this</code> and <code>$</code> operands (they are roughly synonyms for one another) return the current offset into the section containing them. The current offset into the section is known as the <em>location counter</em> (see <span class="xref" itemid="xref_target_“How MASM Allocates Memory for Variables” in Chapter 3">“How MASM Allocates Memory for Variables” in Chapter 3</span>). Consider the following:</p>
<pre><code>someLabel equ $</code></pre>
<p>This sets the label’s offset to the current location in the program. The type of the symbol will be <em>statement label</em> (for example, <code>proc</code>). Typically, people use the <code>$</code> operator for branch labels (and advanced features). For example, the following creates an infinite loop (effectively locking up the CPU):</p>
<pre><code>jmp $     ; "$" is equivalent to the address of the jmp instr</code></pre>
<p>You can also use instructions like this to skip a fixed number of bytes ahead (or behind) in the source file:</p>
<pre><code>jmp $+5   ; Skip to a position 5 bytes beyond the jmp</code></pre>
<p><span epub:type="pagebreak" title="155" id="Page_155"/>For the most part, creating operands like this is crazy because it depends on knowing the number of bytes of machine code each machine instruction compiles into. Obviously, this is an advanced operation and not recommended for beginning assembly language programmers (it’s even hard to recommend for most advanced assembly language programmers).</p>
<p>One practical use of the <code>$</code> operator (and probably its most common use) is to compute the size of a block of data declarations in the source file:</p>
<pre><code>someData     byte 1, 2, 3, 4, 5
sizeSomeData =    $-someData</code></pre>
<p>The address expression <code>$-someData</code> computes the current offset minus the offset of <code>someData</code> in the current section. In this case, this produces <code>5</code>, the number of bytes in the <code>someData</code> operand field. In this simple example, you’re probably better off using the <code>sizeof someData</code> expression. This also returns the number of bytes required for the <code>someData</code> declaration. However, consider the following statements:</p>
<pre><code>someData     byte 1, 2, 3, 4, 5
             byte 6, 7, 8, 9, 0
sizeSomeData =    $-someData</code></pre>
<p>In this case, <code>sizeof someData</code> still returns <code>5</code> (because it returns only the length of the operands attached to <code>someData</code>), whereas <code>sizeSomeData</code> is set to <code>10</code>.</p>
<p>If an identifier appears in a constant expression, that identifier must be a constant identifier that you have previously defined in your program in the equate directive. You may not use variable identifiers in a constant expression; their values are not defined at assembly time when MASM evaluates the constant expression. Also, don’t confuse compile-time and runtime operations:</p>
<pre><code>; Constant expression, computed while MASM
; is assembling your program:

x     = 5
y     = 6
Sum   = x + y

; Runtime calculation, computed while your program
; is running, long after MASM has assembled it:

     mov al, x
     add al, y</code></pre>
<p>The <code>this</code> operator differs from the <code>$</code> operator in one important way: the <code>$</code> has a default type of statement label. The <code>this</code> operator, on the other hand, allows you to specify a type. The syntax for the <code>this</code> operator is the following:</p>
<pre><code>this <var>type</var></code></pre>
<p class="BodyContinued"><span epub:type="pagebreak" title="156" id="Page_156"/>where <var>type</var> is one of the usual data types (<code>byte</code>, <code>sbyte</code>, <code>word</code>, <code>sword</code>, and so forth). Therefore, <code>this proc</code> is what is directly equivalent to <code>$</code>. Note that the following two MASM statements are equivalent:</p>
<pre><code>someLabel label byte
someLabel equ   this byte</code></pre>
<h3 id="h2-501089c04-0003">4.3.3	Constant Expression Evaluation</h3>
<p class="BodyFirst">MASM immediately interprets the value of a constant expression during assembly. It does not emit any machine instructions to compute <code>x + y</code> in the constant expression of the example in the previous section. Instead, it directly computes the sum of these two constant values. From that point forward in the program, MASM associates the value <code>11</code> with the constant <code>Sum</code> just as if the program had contained the statement <code>Sum = 11</code> rather than <code>Sum = x + y</code>. On the other hand, MASM does not precompute the value <code>11</code> in AL for the <code>mov</code> and <code>add</code> instructions in the previous section; it faithfully emits the object code for these two instructions, and the x86-64 computes their sum when the program is run (sometime after the assembly is complete).</p>
<p>In general, constant expressions don’t get very sophisticated in assembly language programs. Usually, you’re adding, subtracting, or multiplying two integer values. For example, the following set of equates defines a set of constants that have consecutive values:</p>
<pre><code>TapeDAT        =  0
Tape8mm        =  TapeDAT + 1
TapeQIC80      =  Tape8mm + 1
TapeTravan     =  TapeQIC80 + 1
TapeDLT        =  TapeTravan + 1</code></pre>
<p>These constants have the following values: <code>TapeDAT = 0</code>, <code>Tape8mm = 1</code>, <code>TapeQIC80 = 2</code>, <code>TapeTravan = 3</code>, and <code>TapeDLT = 4</code>. This example, by the way, demonstrates how you would create a list of enumerated data constants in MASM.</p>
<h2 id="h1-501089c04-0004">	4.4	The MASM typedef Statement</h2>
<p class="BodyFirst">Let’s say that you do not like the names that MASM uses for declaring <code>byte</code>, <code>word</code>, <code>dword</code>, <code>real4</code>, and other variables. Let’s say that you prefer Pascal’s naming convention or perhaps C’s naming convention. You want to use terms like <em>integer</em>, <em>float</em>, <em>double</em>, or whatever. If MASM were Pascal, you could redefine the names in the <code>type</code> section of the program. With C, you could use a <code>typedef</code> statement to accomplish the task. Well, MASM, like C/C++, has its own type statement that also lets you create aliases of these names. The MASM <code>typedef</code> statement takes the following form:</p>
<pre><code><var>new_type_name</var>  typedef  <var>existing_type_name</var></code></pre>
<p><span epub:type="pagebreak" title="157" id="Page_157"/>The following example demonstrates how to set up some names in your MASM programs that are compatible with C/C++ or Pascal:</p>
<pre><code>integer   typedef  sdword
float     typedef  real4
double    typedef  real8
colors    typedef  byte</code></pre>
<p>Now you can declare your variables with more meaningful statements like these:</p>
<pre><code>           .data
i          integer ?
x          float   1.0
HouseColor colors  ?</code></pre>
<p>If you program in Ada, C/C++, or FORTRAN (or any other language, for that matter), you can pick type names you’re more comfortable with. Of course, this doesn’t change how the x86-64 or MASM reacts to these variables one iota, but it does let you create programs that are easier to read and understand because the type names are more indicative of the actual underlying types. One warning for C/C++ programmers: don’t get too excited and go off and define an <code>int</code> data type. Unfortunately, <code>int</code> is an x86-64 machine instruction (<em>interrupt</em>), and therefore this is a reserved word in MASM.</p>
<h2 id="h1-501089c04-0005">	4.5	Type Coercion</h2>
<p class="BodyFirst">Although MASM is fairly loose when it comes to type checking, MASM does ensure that you specify appropriate operand sizes to an instruction. For example, consider the following (incorrect) program in <a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a>.</p>
<pre><code>; Listing 4-1
 
; Type checking errors.

        option  casemap:none

nl      =       10  ; ASCII code for newline

        .data
i8      sbyte   ?
i16     sword   ?
i32     sdword  ?
i64     sqword  ?

        .code

; Here is the "asmMain" function.

        public  asmMain
asmMain proc

<span epub:type="pagebreak" title="158" id="Page_158"/>        mov     eax, i8
        mov     al, i16
        mov     rax, i32
        mov     ax, i64

        ret     ; Returns to caller
asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: MASM type checking</p>
<p>MASM will generate errors for these four <code>mov</code> instructions because the operand sizes are incompatible. The <code>mov</code> instruction requires both operands to be the same size. The first instruction attempts to move a byte into EAX, the second instruction attempts to move a word into AL, and the third instruction attempts to move a double word into RAX. The fourth instruction attempts to move a qword into AX. Here’s the output from the compiler when you attempt to assemble this file:</p>
<pre><code>C:\&gt;<b>ml64 /c listing4-1.asm</b>
Microsoft (R) Macro Assembler (x64) Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

 Assembling: listing4-1.asm
listing4-1.asm(24) : error A2022:instruction operands must be the same size
listing4-1.asm(25) : error A2022:instruction operands must be the same size
listing4-1.asm(26) : error A2022:instruction operands must be the same size
listing4-1.asm(27) : error A2022:instruction operands must be the same size</code></pre>
<p>While this is a good feature in MASM,<sup class="FootnoteReference"><a id="c04-footnoteref-4" href="#c04-footnote-4">2</a></sup> sometimes it gets in the way. Consider the following code fragments:</p>
<pre><code>             .data
byte_values  label byte
             byte  0, 1

             .
             .
             .

             mov ax, byte_values</code></pre>
<p>In this example, let’s assume that the programmer really wants to load the word starting at the address of <code>byte_values</code> into the AX register because they want to load AL with 0, and AH with 1, by using a single instruction (0 is held in the LO memory byte, and 1 is held in the HO memory byte). MASM will refuse, claiming a type mismatch error (because <code>byte_values</code> is a byte object and AX is a word object).</p>
<p><span epub:type="pagebreak" title="159" id="Page_159"/>The programmer could break this into two instructions, one to load AL with the byte at address <code>byte_values</code> and the other to load AH with the byte at address <code>byte_values[1]</code>. Unfortunately, this decomposition makes the program slightly less efficient (which was probably the reason for using the single <code>mov</code> instruction in the first place). To tell MASM that we know what we’re doing and we want to treat the <code>byte_values</code> variable as a <code>word</code> object, we can use type coercion.</p>
<p><em>Type coercion</em> is the process of telling MASM that you want to treat an object as an explicit type, regardless of its actual type.<sup class="FootnoteReference"><a id="c04-footnoteref-5" href="#c04-footnote-5">3</a></sup> To coerce the type of a variable, you use the following syntax:</p>
<pre><code><var>new_type_name</var> ptr <var>address_expression</var></code></pre>
<p>The <var>new_type_name</var> item is the new type you wish to associate with the memory location specified by <var>address_expression</var>. You may use this coercion operator anywhere a memory address is legal. To correct the previous example, so MASM doesn’t complain about type mismatches, you would use the following statement:</p>
<pre><code>mov ax, word ptr byte_values</code></pre>
<p>This instruction tells MASM to load the AX register with the word starting at address <code>byte_values</code> in memory. Assuming <code>byte_values</code> still contains its initial value, this instruction will load 0 into AL and 1 into AH.</p>
<p><a href="#table4-2" id="tableanchor4-2">Table 4-2</a> lists all the MASM type-coercion operators.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-2">Table 4-2</a>: MASM Type-Coercion Operators</p></figcaption>
<table id="table-501089c04-0002" border="1">
<thead>
<tr>
<td><b>Directive</b></td>
<td><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>byte ptr</code></td>
<td>Byte (unsigned 8-bit) value</td>
</tr>
<tr>
<td><code>sbyte ptr</code></td>
<td>Signed 8-bit integer value</td>
</tr>
<tr>
<td><code>word ptr</code></td>
<td>Unsigned 16-bit (word) value</td>
</tr>
<tr>
<td><code>sword ptr</code></td>
<td>Signed 16-bit integer value</td>
</tr>
<tr>
<td><code>dword ptr</code></td>
<td>Unsigned 32-bit (double-word) value</td>
</tr>
<tr>
<td><code>sdword ptr</code></td>
<td>Signed 32-bit integer value</td>
</tr>
<tr>
<td><code>qword ptr</code></td>
<td>Unsigned 64-bit (quad-word) value</td>
</tr>
<tr>
<td><code>sqword ptr</code></td>
<td>Signed 64-bit integer value</td>
</tr>
<tr>
<td><code>tbyte ptr</code></td>
<td>Unsigned 80-bit (10-byte) value</td>
</tr>
<tr>
<td><code>oword ptr</code></td>
<td>128-bit (octal-word) value</td>
</tr>
<tr>
<td><code>xmmword ptr</code></td>
<td>128-bit (octal-word) value—same as <code>oword ptr</code></td>
</tr>
<tr>
<td><code>ymmword ptr</code></td>
<td>256-bit value (for use with AVX YMM registers)</td>
</tr>
<tr>
<td><code>zmmword ptr</code></td>
<td>512-bit value (for use with AVX-512 ZMM registers)</td>
</tr>
<tr>
<td><code><span epub:type="pagebreak" title="160" id="Page_160"/>real4 ptr</code></td>
<td>Single-precision (32-bit) floating-point value</td>
</tr>
<tr>
<td><code>real8 ptr</code></td>
<td>Double-precision (64-bit) floating-point value</td>
</tr>
<tr>
<td><code>real10 ptr</code></td>
<td>Extended-precision (80-bit) floating-point value</td>
</tr>
</tbody>
</table>
</figure>
<p>Type coercion is necessary when you specify an anonymous variable as the operand to an instruction that directly modifies memory (for example, <code>neg</code>, <code>shl</code>, <code>not</code>, and so on). Consider the following statement:</p>
<pre><code>not [rbx]</code></pre>
<p>MASM will generate an error on this instruction because it cannot determine the size of the memory operand. The instruction does not supply sufficient information to determine whether the program should invert the bits in the byte pointed at by RBX, the word pointed at by RBX, the double word pointed at by RBX, or the quad word pointed at by RBX. You must use type coercion to explicitly specify the size of anonymous references with these types of instructions:</p>
<pre><code>not byte ptr [rbx]
not dword ptr [rbx]</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Warning</span></h2>
<p>	Do not use the type-coercion operator unless you know exactly what you are doing and fully understand the effect it has on your program. Beginning assembly language programmers often use type coercion as a tool to quiet the assembler when it complains about type mismatches, without solving the underlying problem.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Consider the following statement (where <code>byteVar</code> is an 8-bit variable):</p>
<pre><code>mov dword ptr byteVar, eax</code></pre>
<p>Without the type-coercion operator, MASM complains about this instruction because it attempts to store a 32-bit register in an 8-bit memory location. Beginning programmers, wanting their programs to assemble, may take a shortcut and use the type-coercion operator, as shown in this instruction; this certainly quiets the assembler—it will no longer complain about a type mismatch—so the beginning programmers are happy.</p>
<p>However, the program is still incorrect; the only difference is that MASM no longer warns you about your error. The type-coercion operator does not fix the problem of attempting to store a 32-bit value into an 8-bit memory location—it simply allows the instruction to store a 32-bit value <em>starting at the address specified by the 8-bit variable</em>. The program still stores 4 bytes, overwriting the 3 bytes following <code>byteVar</code> in memory.</p>
<p>This often produces unexpected results, including the phantom modification of variables in your program.<sup class="FootnoteReference"><a id="c04-footnoteref-6" href="#c04-footnote-6">4</a></sup> Another, rarer possibility is for the <span epub:type="pagebreak" title="161" id="Page_161"/>program to abort with a general protection fault, if the 3 bytes following <code>byteVar</code> are not allocated in real memory or if those bytes just happen to fall in a read-only section of memory. The important thing to remember about the type-coercion operator is this: if you cannot exactly state the effect this operator has, don’t use it.</p>
<p>Also keep in mind that the type-coercion operator does not perform any translation of the data in memory. It simply tells the assembler to treat the bits in memory as a different type. It will not automatically extend an 8-bit value to 32 bits, nor will it convert an integer to a floating-point value. It simply tells the compiler to treat the bit pattern of the memory operand as a different type.</p>
<h2 id="h1-501089c04-0006">	4.6	Pointer Data Types</h2>
<p class="BodyFirst">You’ve probably experienced pointers firsthand in the Pascal, C, or Ada programming languages, and you’re probably getting worried right now. Almost everyone has a bad experience when they first encounter pointers in a high-level language. Well, fear not! Pointers are actually easier to deal with in assembly language than in high-level languages.</p>
<p>Besides, most of the problems you had with pointers probably had nothing to do with pointers but rather with the linked list and tree data structures you were trying to implement with them. Pointers, on the other hand, have many uses in assembly language that have nothing to do with linked lists, trees, and other scary data structures. Indeed, simple data structures like arrays and records often involve the use of pointers. So, if you have some deep-rooted fear about pointers, forget everything you know about them. You’re going to learn how great pointers really are.</p>
<p>Probably the best place to start is with the definition of a pointer. A <em>pointer</em> is a memory location whose value is the address of another memory location. Unfortunately, high-level languages like C/C++ tend to hide the simplicity of pointers behind a wall of abstraction. This added complexity (which exists for good reason, by the way) tends to frighten programmers because <em>they don’t understand what’s going on</em>.</p>
<p>To illuminate what’s really happening, consider the following array declaration in Pascal:</p>
<pre><code>M: array [0..1023] of integer;</code></pre>
<p>Even if you don’t know Pascal, the concept here is pretty easy to understand. <code>M</code> is an array with 1024 integers in it, indexed from <code>M[0]</code> to <code>M[1023]</code>. Each one of these array elements can hold an integer value that is independent of all the others. In other words, this array gives you 1024 different integer variables, each of which you refer to by number (the array index) rather than by name.</p>
<p><span epub:type="pagebreak" title="162" id="Page_162"/>If you encounter a program that has the statement <code>M[0] := 100;</code>, you probably won’t have to think at all about what is happening with this statement. It is storing the value <code>100</code> into the first element of the array <code>M</code>. Now consider the following two statements:</p>
<pre><code>i := 0;      (Assume "i" is an integer variable)
M [i] := 100;</code></pre>
<p>You should agree, without too much hesitation, that these two statements perform the same operation as <code>M[0] := 100;</code>. Indeed, you’re probably willing to agree that you can use any integer expression in the range 0 to 1023 as an index into this array. The following statements still perform the same operation as our single assignment to index 0:</p>
<pre><code>i := 5;      (Assume all variables are integers)
j := 10;
k := 50;
m [i*j-k] := 100;</code></pre>
<p>“Okay, so what’s the point?” you’re probably thinking. “Anything that produces an integer in the range 0 to 1023 is legal. So what?” Okay, how about the following:</p>
<pre><code>M [1] := 0;
M [M [1]] := 100;</code></pre>
<p>Whoa! Now that takes a few moments to digest. However, if you take it slowly, it makes sense, and you’ll discover that these two instructions perform the same operation you’ve been doing all along. The first statement stores <code>0</code> into array element <code>M[1]</code>. The second statement fetches the value of <code>M[1]</code>, which is an integer so you can use it as an array index into <code>M</code>, and uses that value (<code>0</code>) to control where it stores the value <code>100</code>.</p>
<p>If you’re willing to accept this as reasonable—perhaps bizarre, but usable nonetheless—then you’ll have no problems with pointers. Because <code>M[1]</code> is a pointer! Well, not really, but if you were to change <code>M</code> to <em>memory</em> and treat this array as all of memory, this is the exact definition of a pointer: a memory location whose value is the address (or index, if you prefer) of another memory location. Pointers are easy to declare and use in an assembly language program. You don’t even have to worry about array indices or anything like that.</p>
<h3 id="h2-501089c04-0004">4.6.1	Using Pointers in Assembly Language</h3>
<p class="BodyFirst">A MASM pointer is a 64-bit value that may contain the address of another variable. If you have a dword variable <code>p</code> that contains 1000_0000h, then <code>p</code> “points” at memory location 1000_0000h. To access the dword that <code>p</code> points at, you could use code like the following:</p>
<pre><code>mov  rbx, p       ; Load RBX with the value of pointer p
mov  rax, [rbx]   ; Fetch the data that p points at</code></pre>
<p><span epub:type="pagebreak" title="163" id="Page_163"/>By loading the value of <code>p</code> into RBX, this code loads the value 1000_0000h into RBX (assuming <code>p</code> contains 1000_0000h). The second instruction loads the RAX register with the qword starting at the location whose offset appears in RBX. Because RBX now contains 1000_0000h, this will load RAX from locations 1000_0000h through 1000_0007h.</p>
<p>Why not just load RAX directly from location 1000_0000h by using an instruction like <code>mov rax, mem </code>(assuming <code>mem</code> is at address 1000_0000h)? Well, there are several reasons. But the primary reason is that this <code>mov</code> instruction always loads RAX from location <code>mem</code>. You cannot change the address from where it loads RAX. The former instructions, however, always load RAX from the location where <code>p</code> is pointing. This is easy to change under program control. In fact, the two instructions <code>mov rax, offset mem2</code> and <code>mov p, rax</code> will cause those previous two instructions to load RAX from <code>mem2</code> the next time they execute. Consider the following code fragment:</p>
<pre><code>    mov rax, offset i
    mov p, rax
      .
      .
      .      ; Code that sets or clears the carry flag.

    jc skipSetp

       mov rax, offset j
       mov p, rax
        .
        .
        .

skipSetp:
    mov rbx, p           ; Assume both code paths wind up
    mov rax, [rbx]       ; down here</code></pre>
<p>This short example demonstrates two execution paths through the program. The first path loads the variable <code>p</code> with the address of the variable <code>i</code>. The second path through the code loads <code>p</code> with the address of the variable <code>j</code>. Both execution paths converge on the last two <code>mov</code> instructions that load RAX with <code>i</code> or <code>j</code> depending on which execution path was taken. In many respects, this is like a parameter to a procedure in a high-level language like Swift. Executing the same instructions accesses different variables depending on whose address (<code>i</code> or<code> j</code>) winds up in <code>p</code>.</p>
<h3 id="h2-501089c04-0005">4.6.2	Declaring Pointers in MASM</h3>
<p class="BodyFirst">Because pointers are 64 bits long, you could use the <code>qword</code> type to allocate storage for your pointers. However, rather than use qword declarations, an arguably better approach is to use <code>typedef</code> to create a pointer type:</p>
<pre><code>          .data
pointer   typedef qword
<span epub:type="pagebreak" title="164" id="Page_164"/>b         byte    ?
d         dword   ?
pByteVar  pointer b
pDWordVar pointer d</code></pre>
<p>This example demonstrates that it is possible to initialize as well as declare pointer variables in MASM. Note that you may specify addresses of static variables (<code>.data</code>, <code>.const</code>, and <code>.data?</code> objects) in the operand field of a <code>qword/pointer</code> directive, so you can initialize only pointer variables with the addresses of static objects.</p>
<h3 id="h2-501089c04-0006">4.6.3	Pointer Constants and Pointer Constant Expressions</h3>
<p class="BodyFirst">MASM allows very simple constant expressions wherever a pointer constant is legal. Pointer constant expressions take one of the three following forms:<sup class="FootnoteReference"><a id="c04-footnoteref-7" href="#c04-footnote-7">5</a></sup></p>
<pre><code>offset StaticVarName [PureConstantExpression]
offset StaticVarName + PureConstantExpression
offset StaticVarName - PureConstantExpression</code></pre>
<p>The <code>PureConstantExpression</code> term is a numeric constant expression that does not involve any pointer constants. This type of expression produces a memory address that is the specified number of bytes before or after (<code>-</code> or <code>+</code>, respectively) the <code>StaticVarName</code> variable in memory. Note that the first two forms shown here are semantically equivalent; both return a pointer constant whose address is the sum of the static variable and the constant expression.</p>
<p>Because you can create pointer constant expressions, it should come as no surprise to discover that MASM lets you define manifest pointer constants by using equates. The program in <a href="#listing4-2" id="listinganchor4-2">Listing 4-2</a> demonstrates how you can do this.</p>
<pre><code>; Listing 4-2
 
; Pointer constant demonstration.

        option  casemap:none

nl      =       10

        .const
ttlStr  byte    "Listing 4-2", 0
fmtStr  byte    "pb's value is %ph", nl
        byte    "*pb's value is %d", nl, 0

        .data
b       byte    0
        byte    1, 2, 3, 4, 5, 6, 7

<span epub:type="pagebreak" title="165" id="Page_165"/>pb      textequ &lt;offset b[2]&gt;

        .code
        externdef printf:proc

; Return program title to C++ program:

         public getTitle
getTitle proc
         lea rax, ttlStr
         ret
getTitle endp

; Here is the "asmMain" function.

        public  asmMain
asmMain proc

; "Magic" instruction offered without
; explanation at this point:

        sub     rsp, 48

        lea     rcx, fmtStr
        mov     rdx, pb
        movzx   r8, byte ptr [rdx]
        call    printf

        add     rsp, 48
        ret     ; Returns to caller

asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing4-2">Listing 4-2</a>: Pointer constant expressions in a MASM program</p>
<p>Here’s the assembly and execution of this code:</p>
<pre><code>C:\&gt;<b>build listing4-2</b>

C:\&gt;<b>echo off</b>
 Assembling: listing4-2.asm
c.cpp

C:\&gt;<b>listing4-2</b>
Calling Listing 4-2:
pb's value is 00007FF6AC381002h
*pb's value is 2
Listing 4-2 terminated</code></pre>
<p>Note that the address printed may vary on different machines and different versions of Windows.</p>
<h3 id="h2-501089c04-0007"><span epub:type="pagebreak" title="166" id="Page_166"/>4.6.4	Pointer Variables and Dynamic Memory Allocation</h3>
<p class="BodyFirst">Pointer variables are the perfect place to store the return result from the C Standard Library <code>malloc()</code> function. This function returns the address of the storage it allocates in the RAX register; therefore, you can store the address directly into a pointer variable with a single <code>mov</code> instruction immediately after a call to <code>malloc()</code>. <a href="#listing4-3" id="listinganchor4-3">Listing 4-3</a> demonstrates calls to the C Standard Library <code>malloc()</code> and <code>free()</code> functions.</p>
<pre><code>; Listing 4-3
 
; Demonstration of calls
; to C standard library malloc
; and free functions.

        option  casemap:none

nl      =       10

        .const
ttlStr  byte    "Listing 4-3", 0
fmtStr  byte    "Addresses returned by malloc: %ph, %ph", nl, 0

        .data
ptrVar  qword   ?
ptrVar2 qword   ?

        .code
        externdef printf:proc
        externdef malloc:proc
        externdef free:proc

; Return program title to C++ program:

         public getTitle
getTitle proc
         lea rax, ttlStr
         ret
getTitle endp

; Here is the "asmMain" function.

        public  asmMain
asmMain proc

; "Magic" instruction offered without
; explanation at this point:

        sub     rsp, 48

; C standard library malloc function.
 
; ptr = malloc(byteCnt);

<span epub:type="pagebreak" title="167" id="Page_167"/>        mov     rcx, 256        ; Allocate 256 bytes
        call    malloc
        mov     ptrVar, rax     ; Save pointer to buffer

        mov     rcx, 1024       ; Allocate 1024 bytes
        call    malloc
        mov     ptrVar2, rax    ; Save pointer to buffer

        lea     rcx, fmtStr
        mov     rdx, ptrVar
        mov     r8, rax         ; Print addresses
        call    printf

; Free the storage by calling
; C standard library free function.
 
; free(ptrToFree);

        mov     rcx, ptrVar
        call    free

        mov     rcx, ptrVar2
        call    free

        add     rsp, 48
        ret     ; Returns to caller
        
asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing4-3">Listing 4-3</a>: Demonstration of <code>malloc()</code> and <code>free()</code> calls</p>
<p>Here’s the output I obtained when building and running this program. Note that the addresses that <code>malloc()</code> returns may vary by system, by operating system version, and for other reasons. Therefore, you will likely get different numbers than I obtained on my system.</p>
<pre><code>C:\&gt;<b>build listing4-3</b>

C:\&gt;<b>echo off</b>
 Assembling: listing4-3.asm
c.cpp

C:\&gt;<b>listing4-3</b>
Calling Listing 4-3:
Addresses returned by malloc: 0000013B2BC43AD0h, 0000013B2BC43BE0h
Listing 4-3 terminated</code></pre>
<h3 id="h2-501089c04-0008">4.6.5	Common Pointer Problems</h3>
<p class="BodyFirst">Programmers encounter five common problems when using pointers. Some of these errors will cause your programs to immediately stop with a diagnostic message; other problems are subtler, yielding incorrect results without <span epub:type="pagebreak" title="168" id="Page_168"/>otherwise reporting an error or simply affecting the performance of your program without displaying an error. These five problems are as follows:</p>
<ol class="decimal">
<li value="1">Using an uninitialized pointer</li>
<li value="2">Using a pointer that contains an illegal value (for example, NULL)</li>
<li value="3">Continuing to use <code>malloc()</code>’d storage after that storage has been freed</li>
<li value="4">Failing to <code>free()</code> storage once the program is finished using it</li>
<li value="5">Accessing indirect data by using the wrong data type</li>
</ol>
<p>The first problem is using a pointer variable before you have assigned a valid memory address to the pointer. Beginning programmers often don’t realize that declaring a pointer variable reserves storage only for the pointer itself; it does not reserve storage for the data that the pointer references. The short program in <a href="#listing4-4" id="listinganchor4-4">Listing 4-4</a> demonstrates this problem (don’t try to compile and run this program; it will crash).</p>
<pre><code>; Listing 4-4
 
; Uninitialized pointer demonstration.
; Note that this program will not
; run properly.

        option  casemap:none

nl      =       10

        .const
ttlStr  byte    "Listing 4-4", 0
fmtStr  byte    "Pointer value= %p", nl, 0
        
        .data
ptrVar  qword   ?
        
        .code
        externdef printf:proc

; Return program title to C++ program:

         public getTitle
getTitle proc
         lea rax, ttlStr
         ret
getTitle endp

; Here is the "asmMain" function.

        public  asmMain
asmMain proc

; "Magic" instruction offered without
; explanation at this point:

        sub     rsp, 48

<span epub:type="pagebreak" title="169" id="Page_169"/>        lea     rcx, fmtStr
        mov     rdx, ptrVar
        mov     rdx, [rdx]      ; Will crash system
        call    printf

        add     rsp, 48
        ret     ; Returns to caller
        
asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing4-4">Listing 4-4</a>: Uninitialized pointer demonstration</p>
<p>Although variables you declare in the <code>.data</code> section are, technically, initialized, static initialization still doesn’t initialize the pointer in this program with a valid address (it initializes the pointer with <code>0</code>, which is NULL).</p>
<p>Of course, there is no such thing as a truly uninitialized variable on the x86-64. What you really have are variables that you’ve explicitly given an initial value to and variables that just happen to inherit whatever bit pattern was in memory when storage for the variable was allocated. Much of the time, these garbage bit patterns lying around in memory don’t correspond to a valid memory address. Attempting to <em>dereference</em> such a pointer (that is, access the data in memory at which it points) typically raises a <em>memory access violation</em> exception.</p>
<p>Sometimes, however, those random bits in memory just happen to correspond to a valid memory location you can access. In this situation, the CPU will access the specified memory location without aborting the program. Although to a naive programmer this situation may seem preferable to stopping the program, in reality this is far worse because your defective program continues to run without alerting you to the problem. If you store data through an uninitialized pointer, you may very well overwrite the values of other important variables in memory. This defect can produce some very difficult-to-locate problems in your program.</p>
<p>The second problem programmers have with pointers is storing invalid address values into a pointer. The first problem is actually a special case of this second problem (with garbage bits in memory supplying the invalid address rather than you producing it via a miscalculation). The effects are the same; if you attempt to dereference a pointer containing an invalid address, you either will get a memory access violation exception or will access an unexpected memory location.</p>
<p>The third problem listed is also known as the <em>dangling pointer problem</em>. To understand this problem, consider the following code fragment:</p>
<pre><code>mov  rcx, 256
call malloc       ; Allocate some storage
mov  ptrVar, rax  ; Save address away in ptrVar
 .
 .    ; Code that uses the pointer variable ptrVar.
 .
<span epub:type="pagebreak" title="170" id="Page_170"/>mov   rcx, ptrVar
call  free        ; Free storage associated with ptrVar
  .
  .   ; Code that does not change the value in ptrVar.
  .
mov rbx, ptrVar
mov [rbx], al</code></pre>
<p>In this example, the program allocates 256 bytes of storage and saves the address of that storage in the <code>ptrVar</code> variable. Then the code uses this block of 256 bytes for a while and frees the storage, returning it to the system for other uses. Note that calling <code>free()</code> does not change the value of <code>ptrVar</code> in any way; <code>ptrVar</code> still points at the block of memory allocated by <code>malloc()</code> earlier. Indeed, <code>free()</code> does not change any data in this block, so upon return from <code>free()</code>, <code>ptrVar</code> still points at the data stored into the block by this code.</p>
<p>However, note that the call to <code>free()</code> tells the system that the program no longer needs this 256-byte block of memory and the system can use this region of memory for other purposes. The <code>free()</code> function cannot enforce the fact that you will never access this data again; you are simply promising that you won’t. Of course, the preceding code fragment breaks this promise; as you can see in the last two instructions, the program fetches the value in <code>ptrVar</code> and accesses the data it points at in memory.</p>
<p>The biggest problem with dangling pointers is that you can get away with using them a good part of the time. As long as the system doesn’t reuse the storage you’ve freed, using a dangling pointer produces no ill effects in your program. However, with each new call to <code>malloc()</code>, the system may decide to reuse the memory released by that previous call to <code>free()</code>. When this happens, any attempt to dereference the dangling pointer may produce unintended consequences. The problems range from reading data that has been overwritten (by the new, legal use of the data storage), to overwriting the new data, to (the worst case) overwriting system heap management pointers (doing so will probably cause your program to crash). The solution is clear: <em>never use a pointer value once you free the storage associated with that pointer</em>.</p>
<p>Of all the problems, the fourth (failing to free allocated storage) will probably have the least impact on the proper operation of your program. The following code fragment demonstrates this problem:</p>
<pre><code>mov  rcx, 256
call malloc
mov  ptrVar, rax
 .              ; Code that uses ptrVar.
 .              ; This code does not free up the storage
 .              ; associated with ptrVar.
mov  rcx, 512
call malloc
mov  ptrVar, rax

; At this point, there is no way to reference the original
; block of 256 bytes pointed at by ptrVar.</code></pre>
<p><span epub:type="pagebreak" title="171" id="Page_171"/>In this example, the program allocates 256 bytes of storage and references this storage by using the <code>ptrVar</code> variable. At some later time, the program allocates another block of bytes and overwrites the value in <code>ptrVar</code> with the address of this new block. Note that the former value in <code>ptrVar</code> is lost. Because the program no longer has this address value, there is no way to call <code>free()</code> to return the storage for later use. </p>
<p>As a result, this memory is no longer available to your program. While making 256 bytes of memory inaccessible to your program may not seem like a big deal, imagine that this code is in a loop that repeats over and over again. With each execution of the loop, the program loses another 256 bytes of memory. After a sufficient number of loop iterations, the program will exhaust the memory available on the heap. This problem is often called a <em>memory leak</em> because the effect is the same as though the memory bits were leaking out of your computer (yielding less and less available storage) during program execution.</p>
<p>Memory leaks are far less damaging than dangling pointers. Indeed, memory leaks create only two problems: the danger of running out of heap space (which, ultimately, may cause the program to abort, though this is rare) and performance problems due to virtual memory page swapping. Nevertheless, you should get in the habit of always freeing all storage once you have finished using it. When your program quits, the operating system reclaims all storage, including the data lost via memory leaks. Therefore, memory lost via a leak is lost only to your program, not the whole system.</p>
<p>The last problem with pointers is the lack of type-safe access. This can occur because MASM cannot and does not enforce pointer type checking. For example, consider the program in <a href="#listing4-5" id="listinganchor4-5">Listing 4-5</a>.</p>
<pre><code>; Listing 4-5
 
; Demonstration of lack of type
; checking in assembly language
; pointer access.

          option  casemap:none

nl        =     10
maxLen    =     256

          .const
ttlStr    byte    "Listing 4-5", 0
prompt    byte    "Input a string: ", 0
fmtStr    byte    "%d: Hex value of char read: %x", nl, 0

          .data
bufPtr    qword   ?
bytesRead qword   ?

        .code
        externdef readLine:proc
        externdef printf:proc
<span epub:type="pagebreak" title="172" id="Page_172"/>        externdef malloc:proc
        externdef free:proc

; Return program title to C++ program:

         public getTitle
getTitle proc
         lea rax, ttlStr
         ret
getTitle endp

; Here is the "asmMain" function.

        public  asmMain
asmMain proc
        push    rbx             ; Preserve RBX

; "Magic" instruction offered without
; explanation at this point:

        sub     rsp, 40

; C standard library malloc function.
; Allocate sufficient characters
; to hold a line of text input
; by the user:

        mov     rcx, maxLen     ; Allocate 256 bytes
        call    malloc
        mov     bufPtr, rax     ; Save pointer to buffer

; Read a line of text from the user and place in
; the newly allocated buffer:

        lea     rcx, prompt     ; Prompt user to input
        call    printf          ; a line of text

        mov     rcx, bufPtr     ; Pointer to input buffer
        mov     rdx, maxLen     ; Maximum input buffer length
        call    readLine        ; Read text from user
        cmp     rax, -1         ; Skip output if error
        je      allDone
        mov     bytesRead, rax  ; Save number of chars read

; Display the data input by the user:

        xor     rbx, rbx        ; Set index to zero
dispLp: mov     r9, bufPtr      ; Pointer to buffer
        mov     rdx, rbx        ; Display index into buffer
        mov     r8d, [r9+rbx*1] ; Read dword rather than byte!
        lea     rcx, fmtStr
        call    printf

<span epub:type="pagebreak" title="173" id="Page_173"/>        inc     rbx             ; Repeat for each char in buffer
        cmp     rbx, bytesRead
        jb      dispLp

; Free the storage by calling
; C standard library free function.

; free(bufPtr);

allDone:
        mov     rcx, bufPtr
        call    free

        add     rsp, 40
        pop     rbx     ; Restore RBX
        ret             ; Returns to caller
asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing4-5">Listing 4-5</a>: Type-unsafe pointer access example</p>
<p>Here are the commands to build and run this sample program:</p>
<pre><code>C:\&gt;<b>build listing4-5</b>

C:\&gt;<b>echo off</b>
 Assembling: listing4-5.asm
c.cpp

C:\&gt;<b>listing4-5</b>
Calling Listing 4-5:
Input a string: Hello, World!
0: Hex value of char read: 6c6c6548
1: Hex value of char read: 6f6c6c65
2: Hex value of char read: 2c6f6c6c
3: Hex value of char read: 202c6f6c
4: Hex value of char read: 57202c6f
5: Hex value of char read: 6f57202c
6: Hex value of char read: 726f5720
7: Hex value of char read: 6c726f57
8: Hex value of char read: 646c726f
9: Hex value of char read: 21646c72
10: Hex value of char read: 21646c
11: Hex value of char read: 2164
12: Hex value of char read: 21
13: Hex value of char read: 5c000000
Listing 4-5 terminated</code></pre>
<p>The program in <a href="#listing4-5">Listing 4-5</a> reads data from the user as character values and then displays the data as double-word hexadecimal values. While a powerful feature of assembly language is that it lets you ignore data types at will and automatically coerce the data without any effort, this power is a <span epub:type="pagebreak" title="174" id="Page_174"/>two-edged sword. If you make a mistake and access indirect data by using the wrong data type, MASM and the x86-64 may not catch the mistake, and your program may produce inaccurate results. Therefore, when using pointers and indirection in your programs, you need to take care that you use the data consistently with respect to data type.</p>
<p>This demonstration program has one fundamental flaw that could create a problem for you: when reading the last two characters of the input buffer, the program accesses data beyond the characters input by the user. If the user inputs 255 characters (plus the zero-terminating byte that <code>readLine()</code> appends), this program will access data beyond the end of the buffer allocated by <code>malloc()</code>. In theory, this could cause the program to crash. This is yet another problem that can occur when accessing data by using the wrong type via pointers.</p>
<h2 id="h1-501089c04-0007">	4.7	Composite Data Types</h2>
<p class="BodyFirst"><em>Composite data types</em>, also known as <em>aggregate data types</em>, are those that are built up from other (generally scalar) data types. The next sections cover several of the more important composite data types—character strings, arrays, multidimensional arrays, records/structs, and unions. A string is a good example of a composite data type; it is a data structure built up from a sequence of individual characters and other data.</p>
<h2 id="h1-501089c04-0008">	4.8	Character Strings</h2>
<p class="BodyFirst">After integer values, <em>character strings</em> are probably the most common data type that modern programs use. The x86-64 does support a handful of string instructions, but these instructions are really intended for block memory operations, not a specific implementation of a character string. Therefore, this section will provide a couple of definitions of character strings and discuss how to process them.</p>
<p>In general, a character string is a sequence of ASCII characters that possesses two main attributes: a <em>length</em> and <em>character data</em>. Different languages use different data structures to represent strings. Assembly language (at least, sans any library routines) doesn’t really care how you implement strings. All you need to do is create a sequence of machine instructions to process the string data in whatever format the strings take.</p>
<h3 id="h2-501089c04-0009">4.8.1	Zero-Terminated Strings</h3>
<p class="BodyFirst">Without question, <em>zero-terminated strings</em> are the most common string representation in use today because this is the native string format for C, C++, and other languages. A zero-terminated string consists of a sequence of zero or more ASCII characters ending with a 0 byte. For example, in C/C++, the string <code>"abc"</code> requires 4 bytes: the three characters <code>a</code>, <code>b</code>, and <code>c</code> followed by a <code>0</code>. As you’ll soon see, MASM character strings are upward <span epub:type="pagebreak" title="175" id="Page_175"/>compatible with zero-terminated strings, but in the meantime, you should note that creating zero-terminated strings in MASM is easy. The easiest place to do this is in the <code>.data</code> section by using code like the following:</p>
<pre><code>           .data
zeroString byte   "This is the zero-terminated string", 0</code></pre>
<p>Whenever a character string appears in the <code>byte</code> directive as it does here, MASM emits each character in the string to successive memory locations. The zero value at the end of the string terminates this string.</p>
<p>Zero-terminated strings have two principal attributes: they are simple to implement, and the strings can be any length. On the other hand, zero-terminated strings have a few drawbacks. First, though not usually important, zero-terminated strings cannot contain the NUL character (whose ASCII code is 0). Generally, this isn’t a problem, but it does create havoc once in a while. The second problem with zero-terminated strings is that many operations on them are somewhat inefficient. For example, to compute the length of a zero-terminated string, you must scan the entire string looking for that 0 byte (counting characters up to the 0). The following program fragment demonstrates how to compute the length of the preceding string:</p>
<pre><code>          lea rbx, zeroString
          xor rax, rax    ; Set RAX to zero
whileLp:  cmp byte ptr [rbx+rax*1], 0
          je  endwhile

          inc rax
          jmp whileLp

endwhile:

; String length is now in RAX.</code></pre>
<p>As you can see from this code, the time it takes to compute the length of the string is proportional to the length of the string; as the string gets longer, it takes longer to compute its length.</p>
<h3 id="h2-501089c04-0010">4.8.2	Length-Prefixed Strings</h3>
<p class="BodyFirst">The <em>length-prefixed string</em> format overcomes some of the problems with zero-terminated strings. Length-prefixed strings are common in languages like Pascal; they generally consist of a length byte followed by zero or more character values. The first byte specifies the string length, and the following bytes (up to the specified length) are the character data. In a length-prefixed scheme, the string <code>"abc"</code> would consist of the 4 bytes: <code>03</code> (the string length) followed by <code>a</code>, <code>b</code>, and <code>c</code>. You can create length-prefixed strings in MASM by using code like the following:</p>
<pre><code>        .data
lengthPrefixedString label byte;
        byte 3, "abc"</code></pre>
<p><span epub:type="pagebreak" title="176" id="Page_176"/>Counting the characters ahead of time and inserting them into the byte statement, as was done here, may seem like a major pain. Fortunately, there are ways to have MASM automatically compute the string length for you.</p>
<p>Length-prefixed strings solve the two major problems associated with zero-terminated strings. It is possible to include the NUL character in length-prefixed strings, and those operations on zero-terminated strings that are relatively inefficient (for example, string length) are more efficient when using length-prefixed strings. However, length-prefixed strings have their own drawbacks. The principal drawback is that they are limited to a maximum of 255 characters in length (assuming a 1-byte length prefix).</p>
<p>Of course, if you have a problem with a string length limitation of 255 characters, it’s perfectly possible to create a length-prefixed string by using any number of bytes for the length as needed. For example, the <em>High-Level Assembler</em> <em>(HLA)</em> uses a 4-byte length variant of length-prefixed strings, allowing strings up to 4GB long.<sup class="FootnoteReference"><a id="c04-footnoteref-8" href="#c04-footnote-8">6</a></sup> The point is that in assembly language, you can define string formats however you like.</p>
<p>If you want to create length-prefixed strings in your assembly language programs, you don’t want to have to manually count the characters in the string and emit that length in your code. It’s far better to have the assembler do this kind of grunge work for you. This is easily accomplished using the location counter operator (<code>$</code>) as follows:</p>
<pre><code>     .data
lengthPrefixedString label byte;
     byte lpsLen, "abc"
lpsLen = $-lengthPrefixedString-1</code></pre>
<p>The <code>lpsLen</code> operand subtracts 1 in the address expression because <code>$-lengthPrefixedString</code> also includes the length prefix byte, which isn’t considered part of the string length.</p>
<h3 id="h2-501089c04-0011">4.8.3	String Descriptors</h3>
<p class="BodyFirst">Another common string format is a <em>string descriptor</em>. A string descriptor is typically a small data structure (record or structure, see <span class="xref" itemid="xref_target_“Records/Structs” on page 197">“Records/Structs” on page 197</span>) that contains several pieces of data describing a string. At a bare minimum, a string descriptor will probably have a pointer to the actual string data and a field specifying the number of characters in the string (that is, the string length). Other possible fields might include the number of bytes currently occupied by the string,<sup class="FootnoteReference"><a id="c04-footnoteref-9" href="#c04-footnote-9">7</a></sup> the maximum number of bytes the string could occupy, the string encoding (for example, ASCII, Latin-1, UTF-8, or UTF-16), and any other information the string data structure’s designer could dream up.</p>
<p><span epub:type="pagebreak" title="177" id="Page_177"/>By far, the most common descriptor format incorporates a pointer to the string’s data and a size field specifying the number of bytes currently occupied by that string data. Note that this particular string descriptor is not the same thing as a length-prefixed string. In a length-prefixed string, the length immediately precedes the character data itself. In a descriptor, the length and a pointer are kept together, and this pair is (usually) separate from the character data itself.</p>
<h3 id="h2-501089c04-0012">4.8.4	Pointers to Strings</h3>
<p class="BodyFirst">Most of the time, an assembly language program won’t directly work with strings appearing in the <code>.data</code> (or <code>.const</code> or <code>.data?</code>) section. Instead, the program will work with pointers to strings (including strings whose storage the program has dynamically allocated with a call to a function like <code>malloc()</code>). <a href="#listing4-5">Listing 4-5</a> provided a simple (if not broken) example. In such applications, your assembly code will typically load a pointer to a string into a base register and then use a second (index) register to access individual characters in the string.</p>
<h3 id="h2-501089c04-0013">4.8.5	String Functions</h3>
<p class="BodyFirst">Unfortunately, very few assemblers provide a set of string functions you can call from your assembly language programs.<sup class="FootnoteReference"><a id="c04-footnoteref-10" href="#c04-footnote-10">8</a></sup> As an assembly language programmer, you’re expected to write these functions on your own. Fortunately, a couple of solutions are available if you don’t quite feel up to the task.</p>
<p>The first set of string functions you can call (without having to write them yourself) is the C Standard Library string functions (from the <em>string.h</em> header file in C). Of course, you’ll have to use C strings (zero-terminated strings) in your code when calling C Standard Library functions, but this generally isn’t a big problem. <a href="#listing4-6" id="listinganchor4-6">Listing 4-6</a> provides examples of calls to various C string functions.</p>
<pre><code>; Listing 4-6
 
; Calling C Standard Library string functions.

          option  casemap:none

nl        =       10
maxLen    =     256

          .const
ttlStr    byte  "Listing 4-6", 0
prompt    byte  "Input a string: ", 0
fmtStr1   byte  "After strncpy, resultStr='%s'", nl, 0
<span epub:type="pagebreak" title="178" id="Page_178"/>fmtStr2   byte  "After strncat, resultStr='%s'", nl, 0
fmtStr3   byte  "After strcmp (3), eax=%d", nl, 0
fmtStr4   byte  "After strcmp (4), eax=%d", nl, 0
fmtStr5   byte  "After strcmp (5), eax=%d", nl, 0
fmtStr6   byte  "After strchr, rax='%s'", nl, 0
fmtStr7   byte  "After strstr, rax='%s'", nl, 0
fmtStr8   byte  "resultStr length is %d", nl, 0

str1      byte  "Hello, ", 0
str2      byte  "World!", 0
str3      byte  "Hello, World!", 0
str4      byte  "hello, world!", 0
str5      byte  "HELLO, WORLD!", 0

          .data
strLength dword ?
resultStr byte  maxLen dup (?)

        .code
        externdef readLine:proc
        externdef printf:proc
        externdef malloc:proc
        externdef free:proc

; Some C standard library string functions:
 
; size_t strlen(char *str)
 
        externdef strlen:proc

; char *strncat(char *dest, const char *src, size_t n)

        externdef strncat:proc

; char *strchr(const char *str, int c)

        externdef strchr:proc
        
; int strcmp(const char *str1, const char *str2)

        externdef strcmp:proc

; char *strncpy(char *dest, const char *src, size_t n)

        externdef strncpy:proc

; char *strstr(const char *inStr, const char *search4)

        externdef strstr:proc

; Return program title to C++ program:

         public getTitle
getTitle proc
         lea rax, ttlStr
<span epub:type="pagebreak" title="179" id="Page_179"/>         ret
getTitle endp

; Here is the "asmMain" function.

        public  asmMain
asmMain proc

; "Magic" instruction offered without
; explanation at this point:

        sub     rsp, 48

; Demonstrate the strncpy function to copy a
; string from one location to another:

        lea     rcx, resultStr  ; Destination string
        lea     rdx, str1       ; Source string
        mov     r8, maxLen      ; Max number of chars to copy
        call    strncpy

        lea     rcx, fmtStr1
        lea     rdx, resultStr
        call    printf

; Demonstrate the strncat function to concatenate str2 to
; the end of resultStr:

        lea     rcx, resultStr
        lea     rdx, str2
        mov     r8, maxLen
        call    strncat

        lea     rcx, fmtStr2
        lea     rdx, resultStr
        call    printf

; Demonstrate the strcmp function to compare resultStr
; with str3, str4, and str5:

        lea     rcx, resultStr
        lea     rdx, str3
        call    strcmp

        lea     rcx, fmtStr3
        mov     rdx, rax
        call    printf

        lea     rcx, resultStr
        lea     rdx, str4
        call    strcmp

        lea     rcx, fmtStr4
        mov     rdx, rax
        call    printf

<span epub:type="pagebreak" title="180" id="Page_180"/>        lea     rcx, resultStr
        lea     rdx, str5
        call    strcmp

        lea     rcx, fmtStr5
        mov     rdx, rax
        call    printf
        
; Demonstrate the strchr function to search for
; "," in resultStr:

        lea     rcx, resultStr
        mov     rdx, ','
        call    strchr

        lea     rcx, fmtStr6
        mov     rdx, rax
        call    printf

; Demonstrate the strstr function to search for
; str2 in resultStr:

        lea     rcx, resultStr
        lea     rdx, str2
        call    strstr

        lea     rcx, fmtStr7
        mov     rdx, rax
        call    printf

; Demonstrate a call to the strlen function:

        lea     rcx, resultStr
        call    strlen

        lea     rcx, fmtStr8
        mov     rdx, rax
        call    printf

        add     rsp, 48
        ret     ; Returns to caller
asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing4-6">Listing 4-6</a>: Calling C Standard Library string function from MASM source code</p>
<p>Here are the commands to build and run <a href="#listing4-6">Listing 4-6</a>:</p>
<pre><code>C:\&gt;<b>build listing4-6</b>

C:\&gt;<b>echo off</b>
 Assembling: listing4-6.asm
c.cpp

<span epub:type="pagebreak" title="181" id="Page_181"/>C:\&gt;<b>listing4-6</b>
Calling Listing 4-6:
After strncpy, resultStr='Hello, '
After strncat, resultStr='Hello, World!'
After strcmp (3), eax=0
After strcmp (4), eax=-1
After strcmp (5), eax=1
After strchr, rax=', World!'
After strstr, rax='World!'
resultStr length is 13
Listing 4-6 terminated</code></pre>
<p>Of course, you could make a good argument that if all your assembly code does is call a bunch of C Standard Library functions, you should have written your application in C in the first place. Most of the benefits of writing code in assembly language happen only when you “think” in assembly language, not C. In particular, you can dramatically improve the performance of your string function calls if you stop using zero-terminated strings and switch to another string format (such as length-prefixed or descriptor-based strings that include a length component).</p>
<p>In addition to the C Standard Library, you can find lots of x86-64 string functions written in assembly language out on the internet. A good place to start is the MASM Forum at <a href="https://masm32.com/board/" class="LinkURL">https://masm32.com/board/</a> (despite the name, this message forum supports 64-bit as well as 32-bit MASM programming). <span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span> discusses string functions written in assembly language in greater detail.</p>
<h2 id="h1-501089c04-0009">	4.9	Arrays</h2>
<p class="BodyFirst">Along with strings, arrays are probably the most commonly used composite data. Yet most beginning programmers don’t understand how arrays operate internally and their associated efficiency trade-offs. It’s surprising how many novice (and even advanced!) programmers view arrays from a completely different perspective once they learn how to deal with arrays at the machine level.</p>
<p>Abstractly, an <em>array</em> is an aggregate data type whose members (elements) are all the same type. Selection of a member from the array is by an integer index.<sup class="FootnoteReference"><a id="c04-footnoteref-11" href="#c04-footnote-11">9</a></sup> Different indices select unique elements of the array. This book assumes that the integer indices are contiguous (though this is by no means required). That is, if the number <em>x</em> is a valid index into the array and <em>y</em> is also a valid index, with <em>x</em> &lt; <em>y</em>, then all <em>i</em> such that <em>x</em> &lt; <em>i</em> &lt; <em>y</em> are valid indices.</p>
<p>Whenever you apply the indexing operator to an array, the result is the specific array element chosen by that index. For example, <code>A[i]</code> chooses the <em>i</em>th element from array <code>A</code>. There is no formal requirement that element <code>i</code> be anywhere near element <code>i+1</code> in memory. As long as <code>A[i]</code> always refers to the <span epub:type="pagebreak" title="182" id="Page_182"/>same memory location and <code>A[i+1]</code> always refers to its corresponding location (and the two are different), the definition of an array is satisfied.</p>
<p>In this book, we assume that array elements occupy contiguous locations in memory. An array with five elements will appear in memory as <a href="#figure4-1" id="figureanchor4-1">Figure 4-1</a> shows.</p>
<figure>
<img src="image_fi/501089c04/f04001.png" alt="f04001" class=""/>
<figcaption><p><a id="figure4-1">Figure 4-1</a>: Array layout in memory</p></figcaption>
</figure>
<p>The <em>base address</em> of an array is the address of the first element in the array and always appears in the lowest memory location. The second array element directly follows the first in memory, the third element follows the second, and so on. Indices are not required to start at zero. They may start with any number as long as they are contiguous. However, for the purposes of discussion, this book will start all indexes at zero.</p>
<p>To access an element of an array, you need a function that translates an array index to the address of the indexed element. For a single-dimensional array, this function is very simple:</p>
<pre><code><var>element_address</var> = <var>base_address</var> + <var>((index</var> - <var>initial_index)</var> * <var>element_size)</var></code></pre>
<p class="BodyContinued">where <var>initial_index</var> is the value of the first index in the array (which you can ignore if it’s zero), and the value <var>element_size</var> is the size, in bytes, of an individual array element.</p>
<h3 id="h2-501089c04-0014">4.9.1	Declaring Arrays in Your MASM Programs</h3>
<p class="BodyFirst">Before you can access elements of an array, you need to set aside storage for that array. Fortunately, array declarations build on the declarations you’ve already seen. To allocate <em>n</em> elements in an array, you would use a declaration like the following in one of the variable declaration sections:</p>
<pre><code><var>array_name</var>  <var>base_type</var> n dup (?)</code></pre>
<p><var>array_name</var> is the name of the array variable, and <var>base_type</var> is the type of an element of that array. This declaration sets aside storage for the array. To obtain the base address of the array, just use <var>array_name</var>.</p>
<p>The <code>n </code><code>dup (?)</code> operand tells MASM to duplicate the object <code>n</code> times. Now let’s look at some specific examples:</p>
<pre><code>           .data

; Character array with elements 0 to 127.

CharArray  byte 128 dup (?)

<span epub:type="pagebreak" title="183" id="Page_183"/>; Array of bytes with elements 0 to 9.

ByteArray  byte  10 dup (?)

; Array of double words with elements 0 to 3.

DWArray    dword  4 dup (?)</code></pre>
<p>These examples all allocate storage for uninitialized arrays. You may also specify that the elements of the arrays be initialized using declarations like the following in the <code>.data</code> and <code>.const</code> sections:</p>
<pre><code>RealArray   real4  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
IntegerAry  sdword 1, 1, 1, 1, 1, 1, 1, 1</code></pre>
<p>Both definitions create arrays with eight elements. The first definition initializes each 4-byte real value to <code>1.0</code>, and the second declaration initializes each 32-bit integer (<code>sdword</code>) element to <code>1</code>.</p>
<p>If all the array elements have the same initial value, you can save a little work by using the following declarations:</p>
<pre><code>RealArray   real4  8 dup (1.0)
IntegerAry  sdword 8 dup (1)</code></pre>
<p>These operand fields tell MASM to make eight copies of the value inside the parentheses. In past examples, this has always been <code>?</code> (an uninitialized value). However, you can put an initial value inside the parentheses, and MASM will duplicate that value. In fact, you can put a comma-separated list of values, and MASM will duplicate everything inside the parentheses:</p>
<pre><code>RealArray   real4  4 dup (1.0, 2.0)
IntegerAry  sdword 4 dup (1, 2)</code></pre>
<p>These two examples also create eight-element arrays. Their initial values will be 1.0, 2.0, 1.0, 2.0, 1.0, 2.0, 1.0, 2.0, and 1, 2, 1, 2, 1, 2, 1, 2, respectively.</p>
<h3 id="h2-501089c04-0015">4.9.2	Accessing Elements of a Single-Dimensional Array</h3>
<p class="BodyFirst">To access an element of a zero-based array, you can use this formula:</p>
<pre><code><var>element_address</var> = <var>base_address</var> + <var>index</var> * <var>element_size</var></code></pre>
<p>If you are operating in <code>LARGEADDRESSAWARE:NO</code> mode, for the <var>base_address</var> entry you can use the name of the array (because MASM associates the address of the first element of an array with the name of that array). If you are operating in a large address mode, you’ll need to load the base address of the array into a 64-bit (base) register; for example:</p>
<pre><code>lea rbx, <var>base_address</var></code></pre>
<p><span epub:type="pagebreak" title="184" id="Page_184"/>The <var>element_size</var> entry is the number of bytes for each array element. If the object is an array of bytes, the <var>element_size</var> field is 1 (resulting in a very simple computation). If each element of the array is a word (or other 2-byte type), then <var>element_size</var> is 2, and so on. To access an element of the <code>IntegerAry</code> array in the previous section, you’d use the following formula (the size is 4 because each element is an sdword object):</p>
<pre><code><var>element_address</var> = IntegerAry + (index * 4)</code></pre>
<p>Assuming <code>LARGEADDRESSAWARE:NO</code>, the x86-64 code equivalent to the statement <code>eax = IntegerAry[index]</code> is as follows:</p>
<pre><code>mov rbx, index
mov eax, IntegerAry[rbx*4]</code></pre>
<p>In large address mode (<code>LARGEADDRESSAWARE:YES</code>), you’d have to load the address of the array into a base register; for example:</p>
<pre><code>lea rdx, IntegerAry
mov rbx, index
mov eax, [rdx + rbx*4]</code></pre>
<p>These two instructions don’t explicitly multiply the index register (RBX) by 4 (the size of a 32-bit integer element in <code>IntegerAry</code>). Instead, they use the scaled-indexed address mode to perform the multiplication.</p>
<p>Another thing to note about this instruction sequence is that it does not explicitly compute the sum of the base address plus the index times 4. Instead, it relies on the scaled-indexed addressing mode to implicitly compute this sum. The instruction <code>mov eax, IntegerAry[rbx*4]</code> loads EAX from location <code>IntegerAry + rbx*4</code>, which is the base address plus <code>index*4</code> (because RBX contains <code>index*4</code>). Similarly, <code>mov eax, [rdx+rbx*4]</code> computes this same sum as part of the addressing mode. Sure, you could have used</p>
<pre><code>lea rax, IntegerAry
mov rbx, index
shl rbx, 2     ; Sneaky way to compute 4 * RBX
add rbx, rax   ; Compute base address plus index * 4
mov eax, [rbx]</code></pre>
<p class="BodyContinued">in place of the previous sequence, but why use five instructions when two or three will do the same job? This is a good example of why you should know your addressing modes inside and out. Choosing the proper addressing mode can reduce the size of your program, thereby speeding it up.</p>
<p>However, if you need to multiply by a constant other than 1, 2, 4, or 8, then you cannot use the scaled-indexed addressing modes. Similarly, if you need to multiply by an element size that is not a power of 2, you will not be able to use the <code>shl</code> instruction to multiply the index by the element size; instead, you will have to use <code>imul</code> or another instruction sequence to do the multiplication.</p>
<p><span epub:type="pagebreak" title="185" id="Page_185"/>The indexed addressing mode on the x86-64 is a natural for accessing elements of a single-dimensional array. Indeed, its syntax even suggests an array access. The important thing to keep in mind is that you must remember to multiply the index by the size of an element. Failure to do so will produce incorrect results.</p>
<p>The examples appearing in this section assume that the <code>index</code> variable is a 64-bit value. In reality, integer indexes into arrays are generally 32-bit integers or 32-bit unsigned integers. Therefore, you’d typically use the following instruction to load the index value into RBX:</p>
<pre><code>mov ebx, index  ; Zero-extends into RBX</code></pre>
<p>Because loading a 32-bit value into a general-purpose register automatically zero-extends that register to 64 bits, the former instruction sequences (which expect a 64-bit index value) will still work properly when you’re using 32-bit integers as indexes into an array.</p>
<h3 id="h2-501089c04-0016">4.9.3	Sorting an Array of Values</h3>
<p class="BodyFirst">Almost every textbook on this planet gives an example of a sort when introducing arrays. Because you’ve probably seen how to do a sort in high-level languages already, it’s instructive to take a quick look at a sort in MASM. <a href="#listing4-7" id="listinganchor4-7">Listing 4-7</a> uses a variant of the bubble sort, which is great for short lists of data and lists that are nearly sorted, but horrible for just about everything else.<sup class="FootnoteReference"><a id="c04-footnoteref-12" href="#c04-footnote-12">10</a></sup></p>
<pre><code>; Listing 4-7
 
; A simple bubble sort example.
 
; Note: This example must be assembled
; and linked with LARGEADDRESSAWARE:NO.

        option  casemap:none

nl      =       10
maxLen  =       256
true    =       1
false   =       0

bool    typedef ptr byte

        .const
ttlStr  byte    "Listing 4-7", 0
fmtStr  byte    "Sortme[%d] = %d", nl, 0

        .data

<span epub:type="pagebreak" title="186" id="Page_186"/>; sortMe - A 16-element array to sort:

sortMe  label   dword
        dword   1, 2, 16, 14
        dword   3, 9, 4,  10
        dword   5, 7, 15, 12
        dword   8, 6, 11, 13
sortSize = ($ - sortMe) / sizeof dword    ; Number of elements

; didSwap - A Boolean value that indicates
;          whether a swap occurred on the
;          last loop iteration.

didSwap bool    ?

        .code
        externdef printf:proc

; Return program title to C++ program:

         public getTitle
getTitle proc
         lea rax, ttlStr
         ret
getTitle endp

; Here's the bubblesort function.
 
;       sort(dword *array, qword count);
 
; Note: this is not an external (C)
; function, nor does it call any
; external functions. So it will
; dispense with some of the Windows
; calling sequence stuff.
 
; array - Address passed in RCX.
; count - Element count passed in RDX.

sort    proc
        push    rax             ; In pure assembly language
        push    rbx             ; it's always a good idea
        push    rcx             ; to preserve all registers
        push    rdx             ; you modify
        push    r8

        dec     rdx             ; numElements - 1

; Outer loop:

outer:  mov     didSwap, false

        xor     rbx, rbx        ; RBX = 0
inner:  cmp     rbx, rdx        ; while RBX &lt; count - 1
        jnb     xInner

<span epub:type="pagebreak" title="187" id="Page_187"/>        mov     eax, [rcx + rbx*4]      ; EAX = sortMe[RBX]
        cmp     eax, [rcx + rbx*4 + 4]  ; If EAX &gt; sortMe[RBX + 1]
        jna     dontSwap                ; then swap
        
        ; sortMe[RBX] &gt; sortMe[RBX + 1], so swap elements:

        mov     r8d, [rcx + rbx*4 + 4]
        mov     [rcx + rbx*4 + 4], eax
        mov     [rcx + rbx*4], r8d
        mov     didSwap, true

dontSwap:
        inc     rbx                     ; Next loop iteration
        jmp     inner

; Exited from inner loop, test for repeat
; of outer loop:
        
xInner: cmp     didSwap, true
        je      outer

        pop     r8
        pop     rdx
        pop     rcx
        pop     rbx
        pop     rax
        ret
sort    endp

; Here is the "asmMain" function.

        public  asmMain
asmMain proc
        push    rbx

; "Magic" instruction offered without
; explanation at this point:

        sub     rsp, 40

; Sort the "sortMe" array:

        lea     rcx, sortMe
        mov     rdx, sortSize           ; 16 elements in array
        call    sort

; Display the sorted array:

        xor     rbx, rbx
dispLp: mov     r8d, sortMe[rbx*4]
        mov     rdx, rbx
        lea     rcx, fmtStr
        call    printf

<span epub:type="pagebreak" title="188" id="Page_188"/>        inc     rbx
        cmp     rbx, sortSize
        jb      dispLp

        add     rsp, 40
        pop     rbx
        ret     ; Returns to caller
asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing4-7">Listing 4-7</a>: A simple bubble sort example</p>
<p>Here are the commands to assemble and run this sample code:</p>
<pre><code>C:\&gt;<b>sbuild listing4-7</b>

C:\&gt;<b>echo off</b>
 Assembling: listing4-7.asm
c.cpp

C:\&gt;<b>listing4-7</b>
Calling Listing 4-7:
Sortme[0] = 1
Sortme[1] = 2
Sortme[2] = 3
Sortme[3] = 4
Sortme[4] = 5
Sortme[5] = 6
Sortme[6] = 7
Sortme[7] = 8
Sortme[8] = 9
Sortme[9] = 10
Sortme[10] = 11
Sortme[11] = 12
Sortme[12] = 13
Sortme[13] = 14
Sortme[14] = 15
Sortme[15] = 16
Listing 4-7 terminated</code></pre>
<p>The bubble sort works by comparing adjacent elements in an array. The <code>cmp</code> instruction (before <code>; if EAX &gt; sortMe[RBX + 1]</code>) compares EAX (which contains <code>sortMe[rbx*4]</code>) against <code>sortMe[rbx*4 + 4]</code>. Because each element of this array is 4 bytes (<code>dword</code>), the index <code>[rbx*4 + 4]</code> references the next element beyond <code>[rbx*4]</code>.</p>
<p>As is typical for a bubble sort, this algorithm terminates if the innermost loop completes without swapping any data. If the data is already presorted, the bubble sort is very efficient, making only one pass over the data. Unfortunately, if the data is not sorted (worst case, if the data is sorted in reverse order), then this algorithm is extremely inefficient. However, the bubble sort is easy to implement and understand (which is why introductory texts continue to use it in examples).</p>
<h2 id="h1-501089c04-0010"><span epub:type="pagebreak" title="189" id="Page_189"/>	4.10	Multidimensional Arrays</h2>
<p class="BodyFirst">The x86-64 hardware can easily handle single-dimensional arrays. Unfortunately, there is no magic addressing mode that lets you easily access elements of multidimensional arrays. That’s going to take some work and several instructions.</p>
<p>Before discussing how to declare or access multidimensional arrays, it would be a good idea to figure out how to implement them in memory. The first problem is to figure out how to store a multidimensional object into a one-dimensional memory space.</p>
<p>Consider for a moment a Pascal array of the form <code>A:array[0..3,0..3]</code> <code>of char;</code>. This array contains 16 bytes organized as four rows of four characters. Somehow, you’ve got to draw a correspondence with each of the 16 bytes in this array and 16 contiguous bytes in main memory. <a href="#figure4-2" id="figureanchor4-2">Figure 4-2</a> shows one way to do this.</p>
<figure>
<img src="image_fi/501089c04/f04002.png" alt="f04002" class=""/>
<figcaption><p><a id="figure4-2">Figure 4-2</a>: Mapping a 4×4 array to sequential memory locations</p></figcaption>
</figure>
<p>The actual mapping is not important as long as two things occur: (1) each element maps to a unique memory location (that is, no two entries in the array occupy the same memory locations) and (2) the mapping is consistent (that is, a given element in the array always maps to the same memory location). So, what you really need is a function with two input parameters (row and column) that produces an offset into a linear array of 16 memory locations.</p>
<p>Now any function that satisfies these constraints will work fine. Indeed, you could randomly choose a mapping as long as it was consistent. However, what you really want is a mapping that is efficient to compute at runtime and works for any size array (not just 4×4 or even limited to two dimensions). While a large number of possible functions fit this bill, two functions in particular are used by most programmers and high-level languages: row-major ordering and column-major ordering.</p>
<h3 id="h2-501089c04-0017"><span epub:type="pagebreak" title="190" id="Page_190"/>4.10.1	Row-Major Ordering</h3>
<p class="BodyFirst"><em>Row-major ordering</em> assigns successive elements, moving across the rows and then down the columns, to successive memory locations. This mapping is demonstrated in <a href="#figure4-3" id="figureanchor4-3">Figure 4-3</a>.</p>
<figure>
<img src="image_fi/501089c04/f04003.png" alt="f04003" class=""/>
<figcaption><p><a id="figure4-3">Figure 4-3</a>: Row-major array element ordering</p></figcaption>
</figure>
<p>Row-major ordering is the method most high-level programming languages employ. It is easy to implement and use in machine language. You start with the first row (row 0) and then concatenate the second row to its end. You then concatenate the third row to the end of the list, then the fourth row, and so on (see <a href="#figure4-4" id="figureanchor4-4">Figure 4-4</a>).</p>
<figure>
<img src="image_fi/501089c04/f04004.png" alt="f04004" class=""/>
<figcaption><p><a id="figure4-4">Figure 4-4</a>: Another view of row-major ordering for a 4×4 array</p></figcaption>
</figure>
<p>The actual function that converts a list of index values into an offset is a slight modification of the formula for computing the address of an element <span epub:type="pagebreak" title="191" id="Page_191"/>of a single-dimensional array. The formula to compute the offset for a two-dimensional row-major ordered array is as follows:</p>
<pre><code><var>element_address =</var>
     <var>base_address</var> + <code>(</code><var>col_index</var> * <var>row_size</var> + <var>row_index</var><code>)</code> * <var>element_size</var></code></pre>
<p>As usual, <var>base_address</var> is the address of the first element of the array (<code>A[0][0]</code> in this case), and <var>element_size</var> is the size of an individual element of the array, in bytes. <var>col_index</var> is the leftmost index, and <var>row_index</var> is the rightmost index into the array. <var>row_size</var> is the number of elements in one row of the array (4, in this case, because each row has four elements). Assuming <var>element_size</var> is 1, this formula computes the following offsets from the base address:</p>
<pre><code>Column          Row             Offset
Index           Index           into Array
0               0               0
0               1               1
0               2               2
0               3               3
1               0               4
1               1               5
1               2               6
1               3               7
2               0               8
2               1               9
2               2               10
2               3               11
3               0               12
3               1               13
3               2               14
3               3               15</code></pre>
<p>For a three-dimensional array, the formula to compute the offset into memory is the following:</p>
<pre><code><var>Address</var> = <var>Base +</var><var/>
     <var>((depth_index</var> * <var>col_size</var> + <var>col_index)</var> * <var>row_size</var> + <var>row_index)</var> * <var>element_size</var></code></pre>
<p>The <var>col_size</var> is the number of items in a column, and <var>row_size</var> is the number of items in a row. In C/C++, if you’ve declared the array as <var>type</var> <code>A[i][j][k];</code>, then <var>row_size</var> is equal to <code>k</code> and <var>col_size</var> is equal to <code>j</code>.</p>
<p>For a four-dimensional array, declared in C/C++ as <var>type</var> <code>A[i][j][k][m];</code>, the formula for computing the address of an array element is shown here:</p>
<pre><code><var>Address</var> = <var>Base</var> + 
     <var>(((left_index</var> * <var>depth_size</var> + <var>depth_index</var><em>)</em> * <var>col_size</var> + <var>col_index)</var> *
     <var>row_size</var> + <var>row_index</var><em>)</em> * <var>element_size</var></code></pre>
<p>The <var>depth_size</var> is equal to <code>j</code>, <var>col_size</var> is equal to <code>k</code>, and <var>row_size</var> is equal to <code>m</code>. <var>left_index</var> represents the value of the leftmost index.</p>
<p>By now you’re probably beginning to see a pattern. There is a generic formula that will compute the offset into memory for an array with <em>any</em> number of dimensions; however, you’ll rarely use more than four.</p>
<p><span epub:type="pagebreak" title="192" id="Page_192"/>Another convenient way to think of row-major arrays is as arrays of arrays. Consider the following single-dimensional Pascal array definition:</p>
<pre><code>A: array [0..3] of sometype;</code></pre>
<p class="BodyContinued">where <code>sometype</code> is the type <code>sometype = array [0..3] of char;</code>.</p>
<p><code>A</code> is a single-dimensional array. Its individual elements happen to be arrays, but you can safely ignore that for the time being. The formula to compute the address of an element of a single-dimensional array is as follows:</p>
<pre><code><var>element_address</var> = <var>Base</var> +<em> </em><var>index</var> * <var>element_size</var></code></pre>
<p>In this case, <var>element_size</var> happens to be 4 because each element of <code>A</code> is an array of four characters. So, this formula computes the base address of each row in this 4×4 array of characters (see <a href="#figure4-5" id="figureanchor4-5">Figure 4-5</a>).</p>
<figure>
<img src="image_fi/501089c04/f04005.png" alt="f04005" class=""/>
<figcaption><p><a id="figure4-5">Figure 4-5</a>: Viewing a 4×4 array as an array of arrays</p></figcaption>
</figure>
<p>Of course, once you compute the base address of a row, you can reapply the single-dimensional formula to get the address of a particular element. While this doesn’t affect the computation, it’s probably a little easier to deal with several single-dimensional computations rather than a complex multidimensional array computation.</p>
<p>Consider a Pascal array defined as <code>A:array [0..3, 0..3, 0..3, 0..3, 0..3] of char;</code>. You can view this five-dimensional array as a single-dimensional array of arrays. The following Pascal code provides such a definition:</p>
<pre><code>type
 OneD   = array[0..3] of char;
 TwoD   = array[0..3] of OneD;
 ThreeD = array[0..3] of TwoD;
 FourD  = array[0..3] of ThreeD;
var
 A: array[0..3] of FourD;</code></pre>
<p><span epub:type="pagebreak" title="193" id="Page_193"/>The size of <code>OneD</code> is 4 bytes. Because <code>TwoD</code> contains four <code>OneD</code> arrays, its size is 16 bytes. Likewise, <code>ThreeD</code> is four <code>TwoDs</code>, so it is 64 bytes long. Finally, <code>FourD</code> is four <code>ThreeDs</code>, so it is 256 bytes long. To compute the address of <code>A [b, c, d, e, f]</code>, you could use the following steps:</p>
<ol class="decimal">
<li value="1">Compute the address of <code>A[b]</code> as <var>Base</var><code> + b * </code><var>size</var>. Here <var>size</var> is 256 bytes. Use this result as the new base address in the next computation.</li>
<li value="2">Compute the address of <code>A[b, c]</code> by the formula <var>Base</var><code> + c * </code><var>size</var>, where <var>Base</var> is the value obtained in the previous step and <var>size</var> is 64. Use the result as the new base in the next computation.</li>
<li value="3">Compute the base address of<em> </em><code>A [b, c, d]</code> by <var>Base</var><code> + d * </code><var>size</var>, where <var>Base</var> comes from the previous computation, and <var>size</var> is 16. Use the result as the new base in the next computation.</li>
<li value="4">Compute the address of <code>A[b, c, d, e]</code><em> </em>with the formula <var>Base</var><code> + e * </code><var>size</var>, where <var>Base</var> comes from the previous computation, and <var>size</var> is 4. Use this value as the base for the next computation.</li>
<li value="5">Finally, compute the address of <code>A[b, c, d, e, f]</code> by using the formula <var>Base</var><code> + f * </code><var>size</var>, where <var>Base</var> comes from the previous computation and <var>size</var> is 1 (obviously, you can ignore this final multiplication). The result you obtain at this point is the address of the desired element.</li>
</ol>
<p>One of the main reasons you won’t find higher-dimensional arrays in assembly language is that assembly language emphasizes the inefficiencies associated with such access. It’s easy to enter something like <code>A[b, c, d, e, f]</code> into a Pascal program, not realizing what the compiler is doing with the code. Assembly language programmers are not so cavalier—they see the mess you wind up with when you use higher-dimensional arrays. Indeed, good assembly language programmers try to avoid two-dimensional arrays and often resort to tricks in order to access data in such an array when its use becomes absolutely mandatory. </p>
<h3 id="h2-501089c04-0018">4.10.2	Column-Major Ordering</h3>
<p class="BodyFirst"><em>Column-major ordering</em> is the other function high-level languages frequently use to compute the address of an array element. FORTRAN and various dialects of BASIC (for example, older versions of Microsoft BASIC) use this method.</p>
<p>In row-major ordering, the rightmost index increases the fastest as you move through consecutive memory locations. In column-major ordering, the leftmost index increases the fastest. Pictorially, a column-major ordered array is organized as shown in <a href="#figure4-6" id="figureanchor4-6">Figure 4-6</a>.</p>
<p>The formula for computing the address of an array element when using column-major ordering is similar to that for row-major ordering. You reverse the indexes and sizes in the computation.</p>
<span epub:type="pagebreak" title="194" id="Page_194"/><figure>
<img src="image_fi/501089c04/f04006.png" alt="f04006" class=""/>
<figcaption><p><a id="figure4-6">Figure 4-6</a>: Column-major array element ordering</p></figcaption>
</figure>
<p>For a two-dimension column-major array:</p>
<pre><code><var>element_address</var> = <var>base_address</var> + <var>(row_index</var> * <var>col_size</var> + <var>col_index) *</var>
     <var>element_size</var></code></pre>
<p>For a three-dimension column-major array:</p>
<pre><code><var>Address</var> = <var>Base</var> +
     <var>((row_index</var> * <var>col_size</var> + <var>col_index)</var> *
     <var>depth_size</var> + <var>depth_index)</var> * <var>element_size</var></code></pre>
<p>For a four-dimension column-major array:</p>
<pre><code><var>Address </var>=
     <var>Base</var> + <var>(((row_index</var> * <var>col_size</var> + <var>col_index)</var> * <var>depth_size</var> + <var>depth_index)</var>
<var/>     <var>left_size</var> + <var>left_index)</var> * <var>element_size</var></code></pre>
<h3 id="h2-501089c04-0019">4.10.3	Allocating Storage for Multidimensional Arrays</h3>
<p class="BodyFirst">If you have an <em>m</em>×<em>n </em>array, it will have <em>m</em> × <em>n</em> elements and require <em>m</em> × <em>n</em> × <var>element_size</var> bytes of storage. To allocate storage for an array, you must reserve this memory. As usual, there are several ways of accomplishing this task. To declare a multidimensional array in MASM, you could use a declaration like the following:</p>
<pre><code><var>array_name</var> <var>element_type</var> <var>size</var><sub>1</sub>*<var>size</var><sub>2</sub>*<var>size</var><sub>3</sub>*...*<var>size</var><sub><em>n</em></sub> dup (?)</code></pre>
<p class="BodyContinued">where <var>size</var><span class="SubscriptLiteral">1</span> to <var>size</var><span class="SubscriptLiteral">n</span> are the sizes of each of the dimensions of the array.</p>
<p><span epub:type="pagebreak" title="195" id="Page_195"/>For example, here is a declaration for a 4×4 array of characters:</p>
<pre><code>GameGrid byte 4*4 dup (?)</code></pre>
<p>Here is another example that shows how to declare a three-dimensional array of strings (assuming the array holds 64-bit pointers to the strings):</p>
<pre><code>NameItems qword 2 * 3 * 3 dup (?)</code></pre>
<p>As was the case with single-dimensional arrays, you may initialize every element of the array to a specific value by following the declaration with the values of the array constant. Array constants ignore dimension information; all that matters is that the number of elements in the array constant corresponds to the number of elements in the actual array. The following example shows the <code>GameGrid</code> declaration with an initializer:</p>
<pre><code>GameGrid byte 'a', 'b', 'c', 'd'
         byte 'e', 'f', 'g', 'h'
         byte 'i', 'j', 'k', 'l'
         byte 'm', 'n', 'o', 'p'</code></pre>
<p>This example was laid out to enhance readability (which is always a good idea). MASM does not interpret the four separate lines as representing rows of data in the array. Humans do, which is why it’s good to write the data in this manner. All that matters is that there are 16 (4 × 4) characters in the array constant. You’ll probably agree that this is much easier to read than</p>
<pre><code>GameGrid byte  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
'k', 'l', 'm', 'n', 'o', 'p'</code></pre>
<p>Of course, if you have a large array, an array with really large rows, or an array with many dimensions, there is little hope for winding up with something readable. That’s when comments that carefully explain everything come in handy.</p>
<p>As for single-dimensional arrays, you can use the <code>dup</code> operator to initialize each element of a large array with the same value. The following example initializes a 256×64 array of bytes so that each byte contains the value 0FFh:</p>
<pre><code>StateValue byte 256*64 dup (0FFh)</code></pre>
<p>The use of a constant expression to compute the number of array elements rather than simply using the constant 16,384 (256 × 64) more clearly suggests that this code is initializing each element of a 256×64 element array than does the simple literal constant 16,384.</p>
<p>Another MASM trick you can use to improve the readability of your programs is to use <em>nested </em><var>dup</var><em> declarations</em>. The following is an example of a MASM nested <code>dup</code> declaration:</p>
<pre><code>StateValue byte 256 dup (64 dup (0FFh))</code></pre>
<p><span epub:type="pagebreak" title="196" id="Page_196"/>MASM replicates anything inside the parentheses the number of times specified by the constant preceding the <code>dup</code> operator; this includes nested <code>dup</code> declarations. This example says, “Duplicate the stuff inside the parentheses 256 times.” Inside the parentheses, there is a <code>dup</code> operator that says, “Duplicate <code>0FFh</code> 64 times,” so the outside <code>dup</code> operator duplicates the duplication of 64 <code>0FFh</code> values 256 times.</p>
<p>It is probably a good programming convention to declare multidimensional arrays by using the “<code>dup</code> of <code>dup</code> (. . . of <code>dup</code>)” syntax. This can make it clearer that you’re creating a multidimensional array rather than a single-dimensional array with a large number of elements.</p>
<h3 id="h2-501089c04-0020">4.10.4	Accessing Multidimensional Array Elements in Assembly Language</h3>
<p class="BodyFirst">Well, you’ve seen the formulas for computing the address of a multidimensional array element. Now it’s time to see how to access elements of those arrays by using assembly language.</p>
<p>The <code>mov</code>, <code>shl</code>, and <code>imul</code> instructions make short work of the various equations that compute offsets into multidimensional arrays. Let’s consider a two-dimensional array first:</p>
<pre><code>         .data
i        sdword  ?
j        sdword  ?
TwoD     sdword  4 dup (8 dup (?))

           .
           .
           .

; To perform the operation TwoD[i,j] := 5;
; you'd use code like the following.
; Note that the array index computation is (i*8 + j)*4.

          mov ebx, i   ; Remember, zero-extends into RBX
          shl rbx, 3   ; Multiply by 8
          add ebx, j   ; Also zero-extends result into RBX<sup class="FootnoteReference"><a id="c04-footnoteref-13" href="#c04-footnote-13">11</a></sup>
          mov TwoD[rbx*4], 5</code></pre>
<p>Note that this code does <em>not</em> require the use of a two-register addressing mode on the x86-64 (at least, not when using the <code>LARGEADDRESSAWARE:NO</code> option). Although an addressing mode like <code>TwoD[rbx][rsi]</code> looks like it should be a natural for accessing two-dimensional arrays, that isn’t the purpose of this addressing mode.</p>
<p>Now consider a second example that uses a three-dimensional array (again, assuming <code>LARGEADDRESSAWARE:NO</code>):</p>
<pre><code>        .data
i       dword  ?
<span epub:type="pagebreak" title="197" id="Page_197"/>j       dword  ?
k       dword  ?
ThreeD  sdword 3 dup (4 dup (5 dup (?)))
          .
          .
          .

; To perform the operation ThreeD[i,j,k] := ESI;
; you'd use the following code that computes
; ((i*4 + j)*5 + k)*4 as the address of ThreeD[i,j,k].

          mov  ebx, i   ; Zero-extends into RBX
          shl  ebx, 2   ; Four elements per column
          add  ebx, j
          imul ebx, 5   ; Five elements per row
          add  ebx, k
          mov  ThreeD[rbx*4], esi</code></pre>
<p>This code uses the <code>imul</code> instruction to multiply the value in RBX by 5, because the <code>shl</code> instruction can multiply a register by only a power of 2. While there are ways to multiply the value in a register by a constant other than a power of 2, the <code>imul</code> instruction is more convenient.<sup class="FootnoteReference"><a id="c04-footnoteref-14" href="#c04-footnote-14">12</a></sup> Also remember that operations on the 32-bit general-purpose registers automatically zero-extend their result into the 64-bit register.</p>
<h2 id="h1-501089c04-0011">	4.11	Records/Structs</h2>
<p class="BodyFirst">Another major composite data structure is the Pascal <em>record</em> or C/C++/C# <em>structure</em>.<sup class="FootnoteReference"><a id="c04-footnoteref-15" href="#c04-footnote-15">13</a></sup> The Pascal terminology is probably better, because it tends to avoid confusion with the more general term <em>data structure</em>. However, MASM uses the term <em>struct</em>, so this book favors that term.</p>
<p>Whereas an array is homogeneous, with elements that are all the same type, the elements in a struct can have different types. Arrays let you select a particular element via an integer index. With structs, you must select an element (known as a <em>field</em>) by name.</p>
<p>The whole purpose of a structure is to let you encapsulate different, though logically related, data into a single package. The Pascal record declaration for a student is a typical example:</p>
<pre><code>student = 
     record
          Name:     string[64];
          Major:    integer;
          SSN:      string[11];
          Midterm1: integer;
<span epub:type="pagebreak" title="198" id="Page_198"/>          Midterm2: integer;
          Final:    integer;
          Homework: integer;
          Projects: integer;
     end;</code></pre>
<p>Most Pascal compilers allocate each field in a record to contiguous memory locations. This means that Pascal will reserve the first 65 bytes for the name,<sup class="FootnoteReference"><a id="c04-footnoteref-16" href="#c04-footnote-16">14</a></sup> the next 2 bytes hold the major code (assuming a 16-bit integer), the next 12 bytes hold the Social Security number, and so on.</p>
<h3 id="h2-501089c04-0021">4.11.1	MASM Struct Declarations</h3>
<p class="BodyFirst">In MASM, you can create record types by using the <code>struct</code>/<code>ends</code> declaration. You would encode the preceding record in MASM as follows:</p>
<pre><code>student  struct
sName    byte    65 dup (?)  ; "Name" is a MASM reserved word
Major    word    ?
SSN      byte    12 dup (?)
Midterm1 word    ?
Midterm2 word    ?
Final    word    ?
Homework word    ?
Projects word    ?
student  ends</code></pre>
<p>As you can see, the MASM declaration is similar to the Pascal declaration. To be true to the Pascal declaration, this example uses character arrays rather than strings for the <code>sName</code> and <code>SSN</code> (US Social Security number) fields. Also, the MASM declaration assumes that integers are unsigned 16-bit values (which is probably appropriate for this type of data structure).</p>
<p>The field names within the struct must be unique; the same name may not appear two or more times in the same record. However, all field names are local to that record. Therefore, you may reuse those field names elsewhere in the program or in different records.</p>
<p>The <code>struct</code>/<code>ends</code> declaration may appear anywhere in the source file as long as you define it before you use it. A <code>struct</code> declaration does not actually allocate any storage for a <code>student</code> variable. Instead, you have to explicitly declare a variable of type <code>student</code>. The following example demonstrates how to do this:</p>
<pre><code>        .data
John    student  {}</code></pre>
<p>The funny operand (<code>{}</code>) is a MASM-ism, just something you’ll have to remember.</p>
<p><span epub:type="pagebreak" title="199" id="Page_199"/>The <code>John</code> variable declaration allocates 89 bytes of storage laid out in memory, as shown in <a href="#figure4-7" id="figureanchor4-7">Figure 4-7</a>.</p>
<figure>
<img src="image_fi/501089c04/f04007.png" alt="f04007" class=""/>
<figcaption><p><a id="figure4-7">Figure 4-7</a>: Student data structure storage in memory</p></figcaption>
</figure>
<p>If the label <code>John</code> corresponds to the base address of this record, the <code>sName</code> field is at offset <code>John + 0</code>, the <code>Major</code> field is at offset <code>John + 65</code>, the <code>SSN</code> field is at offset <code>John + 67</code>, and so on.</p>
<h3 id="h2-501089c04-0022">4.11.2	Accessing Record/Struct Fields</h3>
<p class="BodyFirst">To access an element of a structure, you need to know the offset from the beginning of the structure to the desired field. For example, the <code>Major</code> field in the variable <code>John</code> is at offset 65 from the base address of <code>John</code>. Therefore, you could store the value in AX into this field by using this instruction:</p>
<pre><code>mov word ptr John[65], ax</code></pre>
<p>Unfortunately, memorizing all the offsets to fields in a <code>struct</code> defeats the whole purpose of using them in the first place. After all, if you have to deal with these numeric offsets, why not just use an array of bytes instead of a <code>struct</code>?</p>
<p>Fortunately, MASM lets you refer to field names in a record by using the same mechanism most HLLs use: the dot operator. To store AX into the <code>Major</code> field, you could use <code>mov John.Major, ax</code><em> </em>instead of the previous instruction. This is much more readable and certainly easier to use.</p>
<p>The use of the dot operator does not introduce a new addressing mode. The instruction <code>mov John.Major, ax</code> still uses the PC-relative addressing mode. MASM simply adds the base address of <code>John</code> with the offset to the <code>Major</code> field (65) to get the actual displacement to encode into the instruction.</p>
<p>The dot operator works quite well when dealing with <code>struct</code> variables you declare in one of the static sections (<code>.data</code>, <code>.const</code>, or <code>.data?</code>) and access via the PC-relative addressing mode. However, what happens when you have a pointer to a record object? Consider the following code fragment:</p>
<pre><code>mov  rcx, sizeof student  ; Size of student struct
call malloc               ; Returns pointer in RAX
mov [rax].Final, 100</code></pre>
<p><span epub:type="pagebreak" title="200" id="Page_200"/>Unfortunately, the <code>Final</code> field name is local to the <code>student</code> structure. As a result, MASM will complain that the name <code>Final</code> is undefined in this code sequence. To get around this problem, you add the structure name to the dotted name list when using pointer references. Here’s the correct form of the preceding code:</p>
<pre><code>mov  rcx, sizeof student  ; Size of student struct
call malloc
mov [rax].student.Final, 100</code></pre>
<h3 id="h2-501089c04-0023">4.11.3	Nesting MASM Structs</h3>
<p class="BodyFirst">MASM allows you to define fields of a structure that are themselves structure types. Consider the following two <code>struct</code> declarations:</p>
<pre><code>grades    struct
Midterm1  word  ?
Midterm2  word  ?
Final     word  ?
Homework  word  ?
Projects  word  ?
grades    ends

student   struct
sName     byte  65 dup (?)  ; "Name" is a MASM reserved word
Major     word  ?
SSN       byte  12 dup (?)
sGrades   grades {}
student   ends</code></pre>
<p>The <code>sGrades</code> field now holds all the individual grade fields that were formerly individual fields in the <code>grades</code> structure. Note that this particular example has the same memory layout as the previous examples (see <a href="#figure4-7">Figure 4-7</a>). The <code>grades</code> structure itself doesn’t add any new data; it simply organizes the grade fields under its own substructure.</p>
<p>To access the subfields, you use the same syntax you’d use with C/C++ (and most other HLLs supporting records/structures). If the <code>John</code> variable declaration appearing in previous sections was of this new <code>struct</code> type, you’d access the <code>Homework</code> field by using a statement such as the following:</p>
<pre><code>mov ax, John.sGrades.Homework</code></pre>
<h3 id="h2-501089c04-0024">4.11.4	Initializing Struct Fields</h3>
<p class="BodyFirst">A typical structure declaration such as the following</p>
<pre><code>           .data
structVar  structType  {}</code></pre>
<p class="BodyContinued">leaves all fields in <code>structType</code> uninitialized (similar to having the <code>?</code> operand in other variable declarations). MASM will allow you to provide initial values <span epub:type="pagebreak" title="201" id="Page_201"/>for all the fields of a structure by supplying a list of comma-separated items between the braces in the operand field of a structure variable declaration, as shown in <a href="#listing4-8" id="listinganchor4-8">Listing 4-8</a>.</p>
<pre><code>; Listing 4-8
 
; Sample struct initialization example.

         option  casemap:none

nl       =       10

         .const
ttlStr   byte    "Listing 4-8", 0
fmtStr   byte    "aString: maxLen:%d, len:%d, string data:'%s'"
         byte    nl, 0

; Define a struct for a string descriptor:

strDesc  struct
maxLen   dword   ?
len      dword   ?
strPtr   qword   ?
strDesc  ends

         .data

; Here's the string data we will initialize the
; string descriptor with:

charData byte   "Initial String Data", 0
len      =      lengthof charData ; Includes zero byte

; Create a string descriptor initialized with
; the charData string value:

aString  strDesc {len, len, offset charData}

        .code
        externdef printf:proc

; Return program title to C++ program:

         public getTitle
getTitle proc
         lea rax, ttlStr
         ret
getTitle endp

; Here is the "asmMain" function.

        public  asmMain
asmMain proc

<span epub:type="pagebreak" title="202" id="Page_202"/>; "Magic" instruction offered without
; explanation at this point:

        sub     rsp, 48

; Display the fields of the string descriptor.

        lea     rcx, fmtStr
        mov     edx, aString.maxLen ; Zero-extends!
        mov     r8d, aString.len    ; Zero-extends!
        mov     r9,  aString.strPtr
        call    printf

        add     rsp, 48 ; Restore RSP
        ret             ; Returns to caller
asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing4-8">Listing 4-8</a>: Initializing the fields of a structure</p>
<p>Here are the build commands and output for <a href="#listing4-8">Listing 4-8</a>:</p>
<pre><code>C:\&gt;<b>build listing4-8</b>

C:\&gt;<b>echo off</b>
 Assembling: listing4-8.asm
c.cpp

C:\&gt;<b>listing4-8</b>
Calling Listing 4-8:
aString: maxLen:20, len:20, string data:'Initial String Data'
Listing 4-8 terminated</code></pre>
<p>If a structure field is an array object, you’ll need special syntax to initialize that array data. Consider the following structure definition:</p>
<pre><code>aryStruct struct
aryField1 byte    8 dup (?)
aryField2 word    4 dup (?)
aryStruct ends</code></pre>
<p>The initialization operands must either be a string or a single item. Therefore, the following is not legal:</p>
<pre><code>a aryStruct {1,2,3,4,5,6,7,8,  1,2,3,4}</code></pre>
<p>This (presumably) is an attempt to initialize <code>aryField1</code> with <code>{1,2,3,4,5,6,7,8}</code> and <code>aryField2</code> with <code>{1,2,3,4}</code>. MASM, however, won’t accept this. MASM wants only two values in the operand field (one for <code>aryField1</code> and one for <code>aryField2</code>). The solution is to place the array constants for the two arrays in their own set of braces:</p>
<pre><code>a aryStruct {{1,2,3,4,5,6,7,8}, {1,2,3,4}}</code></pre>
<p><span epub:type="pagebreak" title="203" id="Page_203"/>If you supply too many initializers for a given array element, MASM will report an error. If you supply too few initializers, MASM will quietly fill in the remaining array entries with 0 values:</p>
<pre><code>a aryStruct {{1,2,3,4}, {1,2,3,4}}</code></pre>
<p>This example initializes <code>a.aryField1</code> with <code>{1,2,3,4,0,0,0,0}</code> and initializes <code>a.aryField2</code> with <code>{1,2,3,4}</code>.</p>
<p>If the field is an array of bytes, you can substitute a character string (with no more characters than the array size) for the list of byte values:</p>
<pre><code>b aryStruct {"abcdefgh", {1,2,3,4}}</code></pre>
<p>If you supply too few characters, MASM will fill out the rest of the byte array with 0 bytes; too many characters produce an error.</p>
<h3 id="h2-501089c04-0025">4.11.5	Arrays of Structs</h3>
<p class="BodyFirst">It is a perfectly reasonable operation to create an array of structures. To do so, you create a <code>struct</code> type and then use the standard array declaration syntax. The following example demonstrates how you could do this:</p>
<pre><code>recElement struct
   <var>Fields for this record</var> 
recElement ends
            .
            .
            .
           .data
recArray   recElement 4 dup ({})</code></pre>
<p>To access an element of this array, you use the standard array-indexing techniques. Because <code>recArray</code> is a single-dimensional array, you’d compute the address of an element of this array by using the formula <var>base_address</var><code> + </code><var>index</var><code> * lengthof(recElement)</code>. For example, to access an element of <code>recArray</code>, you’d use code like the following:</p>
<pre><code>; Access element i of recArray:
; RBX := i*lengthof(recElement)

   imul ebx, i, sizeOf recElement     ; Zero-extends EBX to RBX!
   mov  eax, recArray.someField[rbx]  ; LARGEADDRESSAWARE:NO!</code></pre>
<p>The index specification follows the entire variable name; remember, this is assembly, not a high-level language (in a high-level language, you’d probably use <code>recArray[i].someField</code>).</p>
<p>Naturally, you can create multidimensional arrays of records as well. You would use the row-major or column-major order functions to compute the address of an element within such records. The only thing that really <span epub:type="pagebreak" title="204" id="Page_204"/>changes (from the discussion of arrays) is that the size of each element is the size of the record object:</p>
<pre><code>        .data
rec2D   recElement 4 dup (6 dup ({}))
          .
          .
          .
; Access element [i,j] of rec2D and load someField into EAX:

     imul ebx, i, 6
     add  ebx, j
     imul ebx, sizeof recElement
     lea  rcx, rec2D  ; To avoid requiring LARGEADDRESS...
     mov  eax, [rcx].recElement.someField[rbx*1]</code></pre>
<h3 id="h2-501089c04-0026">4.11.6	Aligning Fields Within a Record</h3>
<p class="BodyFirst">To achieve maximum performance in your programs, or to ensure that MASM’s structures properly map to records or structures in a high-level language, you will often need to be able to control the alignment of fields within a record. For example, you might want to ensure that a double-word field’s offset is a multiple of four. You can use the <code>align</code> directive to do this. The following creates a structure with unaligned fields:</p>
<pre><code>Padded  struct
b       byte    ?
d       dword   ?
b2      byte    ?
b3      byte    ?
w       word    ?
Padded  ends</code></pre>
<p>Here’s how MASM organizes this structure’s fields in memory:<sup class="FootnoteReference"><a id="c04-footnoteref-17" href="#c04-footnote-17">15</a></sup></p>
<pre><code>                Name                     Size Offset     Type
                                                         
Padded <span class="LiteralGray">. . . . . . . . . . . . .         </span>00000009
  b  <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000000        byte
  d  <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000001        dword
  b2 <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000005        byte
  b3 <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000006        byte
  w  <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000007        word</code></pre>
<p>As you can see from this example, the <code>d</code><em> </em>and <code>w</code> fields are both aligned on odd offsets, which may result in slower performance. Ideally, you would like <code>d</code> to be aligned on a double-word offset (multiple of four) and <code>w</code> aligned on an even offset.</p>
<p><span epub:type="pagebreak" title="205" id="Page_205"/>You can fix this problem by adding <code>align</code> directives to the structure, as follows:</p>
<pre><code>Padded  struct
b       byte    ?
        align   4
d       dword   ?
b2      byte    ?
b3      byte    ?
        align   2
w       word    ?
Padded  ends</code></pre>
<p>Now, MASM uses the following offsets for each of these fields:</p>
<pre><code>Padded <span class="LiteralGray">. . . . . . . . . . . . .</span>         0000000C
  b  <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000000        byte
  d  <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000004        dword
  b2 <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000008        byte
  b3 <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000009        byte
  w  <span class="LiteralGray">. . . . . . . . . . . . . .</span>         0000000A        word</code></pre>
<p>As you can see, <code>d</code> is now aligned on a 4-byte offset, and <code>w</code> is aligned at an even offset.</p>
<p>MASM provides one additional option that lets you automatically align objects in a <code>struct</code> declaration. If you supply a value (which must be 1, 2, 4, 8, or 16) as the operand to the <code>struct</code> statement, MASM will automatically align all fields in the structure to an offset that is a multiple of that field’s size or to the value you specify as the operand, <em>whichever is smaller</em>. Consider the following example:</p>
<pre><code>Padded  struct  4
b       byte    ?
d       dword   ?
b2      byte    ?
b3      byte    ?
w       word    ?
Padded  ends</code></pre>
<p>Here’s the alignment MASM produces for this structure:</p>
<pre><code>Padded <span class="LiteralGray">. . . . . . . . . . . . .</span>         0000000C
  b  <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000000        byte
  d  <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000004        dword
  b2 <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000008        byte
  b3 <span class="LiteralGray">. . . . . . . . . . . . . .</span>         00000009        byte
  w  <span class="LiteralGray">. . . . . . . . . . . . . .</span>         0000000A        word</code></pre>
<p>Note that MASM properly aligns <code>d</code> on a dword boundary and <code>w</code> on a word boundary (within the structure). Also note that <code>w</code> is not aligned on a dword boundary (even though the struct operand was 4). This is because MASM uses the smaller of the operand or the field’s size as the alignment value (and <code>w</code>’s size is 2).</p>
<h2 id="h1-501089c04-0012"><span epub:type="pagebreak" title="206" id="Page_206"/>	4.12	Unions</h2>
<p class="BodyFirst">A record/struct definition assigns different offsets to each field in the record according to the size of those fields. This behavior is quite similar to the allocation of memory offsets in a <code>.data?</code>, <code>.data</code>, or <code>.const</code> section. MASM provides a second type of structure declaration, the <code>union</code>, that does not assign different addresses to each object; instead, each field in a <code>union</code> declaration has the same offset: zero. The following example demonstrates the syntax for a <code>union</code> declaration:</p>
<pre><code>unionType union
 <var>Fields (syntactically identical to struct declarations)</var>
unionType ends</code></pre>
<p>Yes, it seems rather weird that MASM still uses <code>ends</code> for the end of the union (rather than <code>endu</code>). If this really bothers you, just create a <code>textequ</code> for <code>endu</code> as follows:</p>
<pre><code>endu  textequ &lt;ends&gt;</code></pre>
<p>Now, you can use <code>endu</code> to your heart’s content to mark the end of a union.</p>
<p>You access the fields of a <code>union</code> exactly the same way you access the fields of a struct: using dot notation and field names. The following is a concrete example of a <code>union</code> type declaration and a variable of the <code>union</code> type:</p>
<pre><code>numeric  union
i        sdword  ?
u        dword   ?
q        qword   ?
numeric  ends
           .
           .
           .
         .data
number  numeric  {}
           .
           .
           .
     mov number.u, 55
           .
           .
           .
     mov number.i, -62
           .
           .
           .
     mov rbx, number.q</code></pre>
<p>The important thing to note about union objects is that all the fields of a union have the same offset in the structure. In the preceding example, the <code>number.u</code>, <code>number.i</code>, and <code>number.q</code> fields all have the same offset: zero. Therefore, <span epub:type="pagebreak" title="207" id="Page_207"/>the fields of a union overlap in memory; this is similar to the way the x86-64 8-, 16-, 32-, and 64-bit general-purpose registers overlap one another. Usually, you may access only one field of a union at a time; you do not manipulate separate fields of a particular union variable concurrently because writing to one field overwrites the other fields. In the preceding example, any modification of <code>number.u</code> would also change <code>number.i</code> and <code>number.q</code>.</p>
<p>Programmers typically use unions for two reasons: to conserve memory or to create aliases. Memory conservation is the intended use of this data structure facility. To see how this works, let’s compare the <code>numeric</code> <code>union</code> in the preceding example with a corresponding structure type:</p>
<pre><code>numericRec  struct
i           sdword  ?
u           dword   ?
q           qword   ?
numericRec  ends</code></pre>
<p>If you declare a variable, say <code>n</code>, of type <code>numericRec</code>, you access the fields as <code>n.i</code>, <code>n.u</code>, and <code>n.q</code> exactly as though you had declared the variable to be type <code>numeric</code>. The difference between the two is that <code>numericRec</code> variables allocate separate storage for each field of the structure, whereas <code>numeric</code> (union) objects allocate the same storage for all fields. Therefore, <code>sizeof numericRec</code> is 16 because the record contains two double-word fields and a quad-word (<code>real64</code>) field. The <code>sizeof numeric</code>, however, is 8. This is because all the fields of a union occupy the same memory locations, and the size of a union object is the size of the largest field of that object (see <a href="#figure4-8" id="figureanchor4-8">Figure 4-8</a>).</p>
<figure>
<img src="image_fi/501089c04/f04008.png" alt="f04008" class=""/>
<figcaption><p><a id="figure4-8">Figure 4-8</a>: Layout of a <span class="LiteralInCaption"><code>union</code></span> versus a <span class="LiteralInCaption"><code>struct</code></span> variable</p></figcaption>
</figure>
<p>In addition to conserving memory, programmers often use unions to create aliases in their code. As you may recall, an <em>alias</em> is a different name for the same memory object. Aliases are often a source of confusion in a program, so you should use them sparingly; sometimes, however, using an alias can be quite convenient. For example, in one section of your program, you might need to constantly use type coercion to refer to an object using a different type. Although you can use a MASM <code>textequ</code> to simplify this <span epub:type="pagebreak" title="208" id="Page_208"/>process, another way to do this is to use a <code>union</code> variable with the fields representing the different types you want to use for the object. As an example, consider the following code:</p>
<pre><code>CharOrUns union
chr       byte      ?
u         dword     ?
CharOrUns ends

          .data
v         CharOrUns {}</code></pre>
<p>With a declaration like this, you can manipulate an <code>uns32</code> object by accessing <code>v.u</code>. If, at some point, you need to treat the LO byte of this <code>dword</code> variable as a character, you can do so by accessing the <code>v.chr</code> variable; for example:</p>
<pre><code>mov v.u, eax
mov ch, v.chr</code></pre>
<p>You can use unions exactly the same way you use structures in a MASM program. In particular, <code>union</code> declarations may appear as fields in structures, <code>struct</code> declarations may appear as fields in unions, <code>array</code> declarations may appear within unions, you can create arrays of unions, and so on.</p>
<h3 id="h2-501089c04-0027">4.12.1	Anonymous Unions</h3>
<p class="BodyFirst">Within a <code>struct</code> declaration, you can place a <code>union</code> declaration without specifying a field name for the <code>union</code> object. The following example demonstrates the syntax:</p>
<pre><code>HasAnonUnion struct
r            real8    ?

             union
u            dword    ?
i            sdword   ?
             ends

s            qword    ?
HasAnonUnion ends

             .data
v            HasAnonUnion {}</code></pre>
<p>Whenever an anonymous union appears within a record, you can access the fields of the union as though they were unenclosed fields of the record. In the preceding example, for instance, you would access <code>v</code>’s <code>u</code><em> </em>and <code>i</code> fields by using the syntax <code>v.u</code> and <code>v.i</code>, respectively. The <code>u</code> and <code>i</code> fields have the <span epub:type="pagebreak" title="209" id="Page_209"/>same offset in the record (8, because they follow a <code>real8</code> object). The fields of <code>v</code> have the following offsets from <code>v</code>’s base address:</p>
<pre><code>v.r           0
v.u           8
v.i           8
v.s          12</code></pre>
<p><code>sizeof(v)</code> is 20 because the <code>u</code> and <code>i</code> fields consume only 4 bytes.</p>
<p>MASM also allows anonymous structures within unions. Please see the MASM documentation for more details, though the syntax and usage are identical to anonymous unions within structures.</p>
<h3 id="h2-501089c04-0028">4.12.2	Variant Types</h3>
<p class="BodyFirst">One big use of unions in programs is to create <em>variant</em> types. A variant variable can change its type dynamically while the program is running. A variant object can be an integer at one point in the program, switch to a string at a different part of the program, and then change to a real value at a later time. Many very high-level language (VHLL) systems use a dynamic type system (that is, variant objects) to reduce the overall complexity of the program; indeed, proponents of many VHLLs insist that the use of a dynamic typing system is one of the reasons you can write complex programs with so few lines of code using those languages.</p>
<p>Of course, if you can create variant objects in a VHLL, you can certainly do it in assembly language. In this section, we’ll look at how we can use the union structure to create variant types.</p>
<p>At any one given instant during program execution, a variant object has a specific type, but under program control, the variable can switch to a different type. Therefore, when the program processes a variant object, it must use an <code>if</code> statement or <code>switch</code> statement (or something similar) to execute different instructions based on the object’s current type. VHLLs do this transparently.</p>
<p>In assembly language, you have to provide the code to test the type yourself. To achieve this, the variant type needs additional information beyond the object’s value. Specifically, the variant object needs a field that specifies the current type of the object. This field (often known as the <em>tag</em> field) is an enumerated type or integer that specifies the object’s type at any given instant. The following code demonstrates how to create a variant type:</p>
<pre><code>VariantType struct
tag         dword    ?  ; 0-uns32, 1-int32, 2-real64

            union
u           dword    ?
i           sdword   ?
r           real8    ?
<span epub:type="pagebreak" title="210" id="Page_210"/>            ends
VariantType ends

            .data
v           VariantType {}</code></pre>
<p>The program would test the <code>v.tag</code> field to determine the current type of the <code>v</code> object. Based on this test, the program would manipulate the <code>v.i</code>, <code>v.u</code>, or <code>v.r</code> field.</p>
<p>Of course, when operating on variant objects, the program’s code must constantly be testing the tag field and executing a separate sequence of instructions for <code>dword</code>, <code>sdword</code>, or <code>real8</code> values. If you use the variant fields often, it makes a lot of sense to write procedures to handle these operations for you (for example, <code>vadd</code>, <code>vsub</code>, <code>vmul</code>, and <code>vdiv</code>). </p>
<h2 id="h1-501089c04-0013">	4.13	Microsoft ABI Notes</h2>
<p class="BodyFirst">The Microsoft ABI expects fields of an array to be aligned on their <em>natural</em> size: the offset from the beginning of the structure to a given field must be a multiple of the field’s size. On top of this, the whole structure must be aligned at a memory address that is a multiple of the size of the largest object in the structure (up to 16 bytes). Finally, the entire structure’s size must be a multiple of the largest element in the structure (you must add padding bytes to the end of the structure to appropriately fill out the structure’s size).</p>
<p>The Microsoft ABI expects arrays to begin at an address in memory that is a multiple of the element size. For example, if you have an array of 32-bit objects, the array must begin on a 4-byte boundary.</p>
<p>Of course, if you’re not passing an array or structure data to another language (you’re only processing the struct or array in your assembly code), you can align (or misalign) the data however you want.</p>
<h2 id="h1-501089c04-0014">	4.14	For More Information</h2>
<p class="BodyFirst">For additional information about data structure representation in memory, consider reading my book <em>Write Great Code</em>, Volume 1<em> </em>(No Starch Press, 2004). For an in-depth discussion of data types, consult a textbook on data structures and algorithms. Of course, the MASM online documentation (at <a href="https://www.microsoft.com/" class="LinkURL">https://www.microsoft.com/</a>) is a good source of information.</p>
<h2 id="h1-501089c04-0015">	4.15	Test Yourself</h2>
<ol class="decimal">
<li value="1">What is the two-operand form of the <code>imul</code> instruction that multiplies a register by a constant?</li>
<li value="2">What is the three-operand form of the <code>imul</code> instruction that multiplies a register by a constant and leaves the result in a destination register?</li>
<li value="3"><span epub:type="pagebreak" title="211" id="Page_211"/>What is the syntax for the <code>imul</code> instruction that multiplies one register by another?</li>
<li value="4">What is a manifest constant?</li>
<li value="5">Which directive(s) would you use to create a manifest constant?</li>
<li value="6">What is the difference between a text equate and a numeric equate?</li>
<li value="7">Explain how you would use an equate to define literal strings whose length is greater than eight characters.</li>
<li value="8">What is a constant expression?</li>
<li value="9">What operator would you use to determine the number of data elements in the operand field of a byte directive?</li>
<li value="10">What is the location counter?</li>
<li value="11">What operator(s) return(s) the current location counter?</li>
<li value="12">How would you compute the number of bytes between two declarations in the <code>.data</code> section?</li>
<li value="13">How would you create a set of enumerated data constants using MASM?</li>
<li value="14">How do you define your own data types using MASM?</li>
<li value="15">What is a pointer (how is it implemented)?</li>
<li value="16">How do you dereference a pointer in assembly language?</li>
<li value="17">How do you declare pointer variables in assembly language?</li>
<li value="18">What operator would you use to obtain the address of a static data object (for example, in the <code>.data</code> section)?</li>
<li value="19">What are the five common problems encountered when using pointers in a program?</li>
<li value="20">What is a dangling pointer?</li>
<li value="21">What is a memory leak?</li>
<li value="22">What is a composite data type?</li>
<li value="23">What is a zero-terminated string?</li>
<li value="24">What is a length-prefixed string?</li>
<li value="25">What is a descriptor-based string?</li>
<li value="26">What is an array?</li>
<li value="27">What is the base address of an array?</li>
<li value="28">Provide an example of an array declaration using the <code>dup</code> operator.</li>
<li value="29">Describe how to create an array whose elements you initialize at assembly time.</li>
<li value="30">What is the formula for accessing elements of a
<ol class="lower-alpha">
<li value="1">Single-dimension array <code>dword A[10]</code>?</li>
<li value="2">Two-dimensional array <code>word W[4, 8]</code>?</li>
<li value="3">Three-dimensional array <code>real8 R[2, 4, 6]</code>?</li>
</ol></li>
<li value="31">What is row-major order?</li>
<li value="32"><span epub:type="pagebreak" title="212" id="Page_212"/>What is column-major order?</li>
<li value="33">Provide an example of a two-dimensional array declaration (word array <code>W[4, 8]</code>) using nested <code>dup</code> operators.</li>
<li value="34">What is a record/struct?</li>
<li value="35">What MASM directives do you use to declare a record data structure?</li>
<li value="36">What operator do you use to access fields of a record/struct?</li>
<li value="37">What is a union?</li>
<li value="38">What directives do you use to declare unions in MASM?</li>
<li value="39">What is the difference between the memory organization of fields in a union versus those in a record/struct?</li>
<li value="40">What is an anonymous union in a struct?</li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-1" href="#c04-footnoteref-1">1.</a></sup> Technically, you could also use macro functions to define constants in MASM. See <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span> for more details.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-4" href="#c04-footnoteref-4">2.</a></sup> After all, if the two operand sizes are different, this usually indicates an error in the program.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-5" href="#c04-footnoteref-5">3.</a></sup> Type coercion is also called <em>type casting</em> in some languages.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-6" href="#c04-footnoteref-6">4.</a></sup> If you have a variable immediately following <span class="LiteralFootnote"><code>byteVar</code></span> in this example, the <span class="LiteralFootnote"><code>mov</code></span> instruction will surely overwrite the value of that variable, whether or not you intend for this to happen.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-7" href="#c04-footnoteref-7">5.</a></sup> In MASM syntax, the form <span class="LiteralFootnote"><code>x[y]</code></span> is equivalent to <span class="LiteralFootnote"><code>x</code></span><span class="LiteralFootnote"><code> </code></span><span class="LiteralFootnote"><code>+</code></span><span class="LiteralFootnote"><code> </code></span><span class="LiteralFootnote"><code>y</code></span>. Likewise, <span class="LiteralFootnote"><code>[x][y]</code></span> is also equivalent to <span class="LiteralFootnote"><code>x</code></span><span class="LiteralFootnote"><code> </code></span><span class="LiteralFootnote"><code>+</code></span><span class="LiteralFootnote"><code> </code></span><span class="LiteralFootnote"><code>y</code></span>.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-8" href="#c04-footnoteref-8">6.</a></sup> Visit <a href="https://artofasm.randallhyde.com/" class="LinkURL">https://artofasm.randallhyde.com/</a><em> </em>for more details on the High-Level Assembler.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-9" href="#c04-footnoteref-9">7.</a></sup> The number of bytes could be different from the number of characters in the string if the string encoding includes multi-byte character sequences, such as what you would find in UTF-8 or UTF-16 encodings.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-10" href="#c04-footnoteref-10">8.</a></sup> The High-Level Assembler (HLA) is a notable exception. The HLA Standard Library includes a wide set of string functions written in HLA. Were it not for the HLA Standard Library being all 32-bit code, you would have been able to call those functions from your MASM code. That being said, it isn’t that difficult to rewrite the HLA library functions in MASM. You can obtain the HLA Standard Library source code from <a href="https://artofasm.randallhyde.com/" class="LinkURL">https://artofasm.randallhyde.com/</a> if you care to try this.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-11" href="#c04-footnoteref-11">9.</a></sup> Or it could be a value whose underlying representation is integer, such as character, enumerated, and Boolean types.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-12" href="#c04-footnoteref-12">10.</a></sup> Fear not, you’ll see some better sorting algorithms in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-13" href="#c04-footnoteref-13">11.</a></sup> The <span class="LiteralFootnote"><code>add</code></span> instruction zero-extends into RBX, assuming the HO 32 bits of RBX were zero after the <span class="LiteralFootnote"><code>shl</code></span> operation. This is generally a safe assumption, but something to keep in mind if <span class="LiteralFootnote"><code>i</code></span>’s value is large.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-14" href="#c04-footnoteref-14">12.</a></sup> A full discussion of multiplication by constants other than a power of 2 appears in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-15" href="#c04-footnoteref-15">13.</a></sup> Records and structures also go by other names in other languages, but most people recognize at least one of these names.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-16" href="#c04-footnoteref-16">14.</a></sup> Strings require an extra byte, in addition to all the characters in the string, to encode the length.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c04-footnote-17" href="#c04-footnoteref-17">15.</a></sup> By the way, if you would like MASM to provide you with this information, supply a <span class="LiteralFootnote"><code>/Fl</code></span> command line option to <em>ml64.exe</em>. This tells MASM to produce a listing file, which contains this information.</p></aside>
</section>
</section>
</body></html>