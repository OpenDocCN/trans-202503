<html><head></head><body>
<div id="sbo-rt-content">
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">

<hgroup>
<h2 class="CHAPTER" id="ch8">

<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label=" Page 199. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>

<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">WORKING WITH DATA IN PYTHON</samp></span>

</h2>
</hgroup>

<p class="COS">The basics of Python are behind you, but there’s still a lot to learn. In this chapter, you’ll expand your programming skills and start to directly investigate datasets, including BlueLeaks and chat logs leaked from a pro-Putin ransomware gang after Russia invaded Ukraine in 2022.</p>

<p class="TX">We’ll go over some more advanced Python topics, like how to use modules, how to traverse the filesystem, and how to create your own command line programs in Python. You’ll write programs that look through all of the files in a folder, including the hundreds of thousands of files in the BlueLeaks dataset, and learn to add arguments to your programs. You’ll also start working with a new type of variable in Python, the dictionary, which will prove handy for working with data that’s too complex to store in simple lists. As with the previous chapter, future chapters rely on your understanding of the topics covered here.</p>

<section epub:type="division" aria-labelledby="sec1">

<h3 class="H1" id="sec1"><span id="h-186"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_200" aria-label=" Page 200. "/><samp class="SANS_Futura_Std_Bold_B_11">Modules</samp></h3>

<p class="TNI">As you learned in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, functions are reusable blocks of code that you can run as many times as you want without having to rewrite any code. Python <i>modules</i> are similar, but instead of making a single block of code reusable, they make an entire Python file (or multiple files) reusable. You can think of a module as a separate Python file that you can load into the file you’re currently working on.</p>

<p class="TX">Python includes a wealth of features, but most of them aren’t available to every Python script by default. Instead, they’re stored in <i>built-in</i> modules, those that come with Python. Once you import a module into your script using an <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statement, you can access all of the functions, variables, and other Python objects defined in that module using the syntax <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module_name</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">item_name</samp>.</p>

<p class="TX">For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> module includes the function <samp class="SANS_TheSansMonoCd_W5Regular_11">time.sleep()</samp> (pronounced “time dot sleep”), which makes your program wait a given number of seconds before continuing to the next line of code. Run the following commands to import the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> module and then have it tell Python to wait five seconds:</p>

<pre id="pre-307"><code>&gt;&gt;&gt; <b>import time</b>

&gt;&gt;&gt; <b>time.sleep(5)</b></code></pre>

<p class="TX">Your Python interpreter should wait five seconds before the prompt appears again.</p>

<p class="TX">Here are a few of the built-in modules I use the most:</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">os</samp> Includes useful functions for browsing the filesystem, like <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>. It also includes the submodule <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path</samp>, which is full of functions to inspect files. For example, it includes <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp>, which help determine whether a specific path is a file or a folder.</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">csv</samp> Lets you work with CSV spreadsheet data.</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">json</samp> Lets you work with JSON data.</p>

<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">datetime</samp> Includes useful Python features for working with dates and times. For example, it allows you to convert strings like <samp class="SANS_TheSansMonoCd_W5Regular_11">February 24, 2022 5:07:20 UTC+3</samp> (the exact time that Russia invaded Ukraine) into a timestamp that Python can understand and compare with other timestamps, then convert it back into strings of any format you choose.</p>

<p class="TX">You’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp> module extensively later in this chapter, the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp> module in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> module in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>. You’ll briefly see how <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> works later in this chapter when you take a look at chat logs from a ransomware gang, as well as in the <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> case study, where you’ll analyze leaked neo-Nazi chat logs.</p>

<p class="TX">As your programs get more complex, you might find it useful to split them up into multiple files, with each file containing a different part of your code. When you do this, you’re creating your own modules. The name <span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label=" Page 201. "/>of the module is the same as its filename. For example, if you define some functions in a file called <i>helpers.py</i>, another Python file can access those functions by importing the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp> module. The <i>helpers.py</i> file could contain the following code:</p>

<pre id="pre-308"><code>def get_tax(price, tax_rate):

    return price * tax_rate



def get_net_price(price, tax_rate):

    return price + get_tax(price, tax_rate)</code></pre>

<p class="TX">This module contains two functions for calculating sales tax, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_tax()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_net_price()</samp>. The following Python script, <i>price.py</i>, imports it like so:</p>

<pre id="pre-309"><code>import helpers

total_price = helpers.get_net_price(50, 0.06)

print(f"A book that costs $50, and has 6% sales tax, costs ${total_price}")</code></pre>

<p class="TX">The first line, <samp class="SANS_TheSansMonoCd_W5Regular_11">import helpers</samp>, makes the functions defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp> module accessible to this script. The second line calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers.get_net _price()</samp> function from that module and stores the return value in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">total_price</samp>. The third line displays the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">total_price</samp>.</p>

<p class="TX">Here’s what it looks like when I run this script:</p>

<pre id="pre-310"><code>micah@trapdoor module % <b>python3 price.py</b>

A book that costs $50, and has 6% sales tax, costs $53.0</code></pre>

<p class="TX">Running the <i>price.py</i> script executes the code defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp> module. Inside that module, the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_net_price()</samp> function calls <samp class="SANS_TheSansMonoCd_W5Regular_11">get_tax()</samp> and uses its return value to calculate the net price, then returns <i>that</i> value back into the <i>price.py</i> script.</p>

<p class="TX">Before you write your first advanced Python script in Exercise 8-1, let’s look at the best way to start new Python scripts.</p>

</section>

<section epub:type="division" aria-labelledby="sec2">

<h3 class="H1" id="sec2"><span id="h-187"/><samp class="SANS_Futura_Std_Bold_B_11">Python Script Template</samp></h3>

<p class="TNI">I use the same basic template for all my Python scripts, putting my code into a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>, then calling that function at the bottom of the file. This isn’t required (you didn’t do this for any of the scripts you wrote in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, after all), but it’s a good way to organize your code. Here’s what it looks like:</p>

<pre id="pre-311"><code>def main():

    pass



if __name__ == "__main__":

    main()</code></pre>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_202" aria-label=" Page 202. "/>The template defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">pass</samp> statement that tells Python, “Skip this line.” I later replace <samp class="SANS_TheSansMonoCd_W5Regular_11">pass</samp> with the real body of the script.</p>

<p class="TX">Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement tells Python under which conditions it should run <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>. Python automatically defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp> variable, and the definition differs depending on what Python file is being run. If you’re running the currently executing Python file directly, then Python sets the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp> string. But if you imported the currently executing Python file from another script, Python sets the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp> to the name of the imported module. Using the example from the previous section, if you run the <i>helpers.py</i> script directly, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp> inside that script will be <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp>, but if you run the <i>price.py</i> script, then the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp> will be <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp> inside <i>price.py</i> and the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp> will be <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp> inside <i>helpers.py</i>.</p>

<p class="TX">In short, if you run your script directly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function will run. But if you import your script as a module into another script or into the Python interpreter, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function won’t run unless you call it yourself. This way, if you have multiple Python scripts in the same folder, you can have one script import another script to call the functions defined within it without worrying about calling the latter script’s <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function.</p>

<p class="TX">After I create this template script, I start filling in the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function with whatever I want the script to do. Putting the main logic of your script inside a function allows you to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement to end <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> early, which will quit the script early. You can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> when you’re not in a function.</p>

<p class="TX">In the following exercise, you’ll put this into practice by writing a script to start investigating BlueLeaks.</p>

</section>

<section epub:type="division" aria-labelledby="sec3">

<h3 class="H1F" id="sec3"><span id="h-188"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-1: Traverse the Files in BlueLeaks</samp></h3>

<p class="TNI">To efficiently investigate datasets, you need to be able to write code that looks through large collections—sometimes thousands or millions—of files for you. In this exercise, you’ll learn various ways to traverse the filesystem in Python using functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp> module, working with the BlueLeaks dataset. You’ll also rely on the foundational skills you learned in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, like using variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops, and <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements.</p>

<p class="TX">As you read along and run the scripts, feel free to modify the code however you’d like and try running those versions too. You might discover revelations I didn’t think to look for.</p>

<section epub:type="division" aria-labelledby="sec4">

<h4 class="H2" id="sec4"><span id="h-189"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">List the Filenames in a Folder</samp></h4>

<p class="TNI">Start by using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp> to list the files in the <i>BlueLeaks-extracted</i> folder. In your text editor, create a file called <i>list-files1.py</i> and enter this short script (or copy and paste it from <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/list-files1.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-8<wbr/>/list<wbr/>-files1<wbr/>.py</i></a>):</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label=" Page 203. "/>

<pre id="pre-312"><code>import os



def main():

    blueleaks_path =<b> </b>"<var>/Volumes/datasets/BlueLeaks-extracted</var>"

    for filename in os.listdir(blueleaks_path):

        print(filename)



if __name__ == "__main__":

    main()</code></pre>

<p class="TX">First, the script imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp> module. It then defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> with the path of the <i>BlueLeaks-extracted</i> folder (update the script to include the path of this folder on your own computer). The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp> function takes the path to the folder as an argument and returns a list of filenames in that folder. The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to loop through the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir(blueleaks_path)</samp>, displaying each filename.</p>
<blockquote>

<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>

<p class="NOTE-TXT"><i>Windows paths include the backslash character (<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\</samp>), which Python strings consider an escape character. For example, if your</i> <span class="note_Italic">BlueLeaks-extracted</span> <i>folder is located at</i> <span class="note_Italic">D:\BlueLeaks-extracted</span><i>, Python will misinterpret the string <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">"D:\BlueLeaks-extracted"</samp>, assuming that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\B</samp> is a special character. To escape your backslashes for any Windows path you store as a string, use <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\\</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\</samp>. In this case, set the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">blueleaks_path</samp> string to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">"D:\\BlueLeaks-extracted"</samp>.</i></p>

<p class="TX">Run this script. Here’s what the output looks like on my computer:</p>

<pre id="pre-313"><code>micah@trapdoor chapter-8 % <b>python3 list-files1.py</b>

211sfbay

Securitypartnership

acprlea

acticaz

akorca

<var>--snip--</var></code></pre>

<p class="TX">Next, you’ll try something slightly more advanced. Instead of just listing the filenames in BlueLeaks, you’ll check each filename to see whether it’s a folder, and if so, you’ll open each of those folders and count how many files and subfolders they contain.</p>

</section>

<section epub:type="division" aria-labelledby="sec5">

<h4 class="H2" id="sec5"><span id="h-190"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Count the Files and Folders in a Folder</samp></h4>

<p class="TNI">Create a file called <i>list-files2.py</i> and enter the following code (or copy and paste it from <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/list-files2.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-8<wbr/>/list<wbr/>-files2<wbr/>.py</i></a>):</p>

<pre id="pre-314"><code>import os



def main():

    blueleaks_path = "<var>/Volumes/datasets/BlueLeaks-extracted</var>"

  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> for bl_folder in os.listdir(blueleaks_path):

<b>        </b>bl_folder_path = os.path.join(blueleaks_path, bl_folder)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_204" aria-label=" Page 204. "/>



      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if not os.path.isdir(bl_folder_path):

            continue



      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> files_count = 0

        folders_count = 0

      <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> for filename in os.listdir(bl_folder_path):

            filename_path = os.path.join(bl_folder_path, filename)



          <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> if os.path.isfile(filename_path):

                files_count += 1



            if os.path.isdir(filename_path):

                folders_count += 1



      <span class="CodeAnnotationCode-1" aria-label="annotation6">❻</span> print(f"{bl_folder} has {files_count} files, {folders_count} folders")



if __name__ == "__main__":

    main()</code></pre>

<p class="TX">This script counts the number of files and folders it finds within each BlueLeaks folder. It starts like <i>list-files1.py</i> does, importing <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp> and defining the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> variable (remember to update the variable’s value to match the correct path on your computer).</p>

<p class="TX">The first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop cycles through the filenames in your <i>BlueLeaks-extracted</i> folder, this time saving each filename in the <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder</samp> variable, so its value will be something like <samp class="SANS_TheSansMonoCd_W5Regular_11">miacx</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ncric</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The script then sets the value of the new <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp> variable accordingly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp> function connects filenames together to make complete paths. Its first argument is the starting path, and it adds all other arguments to the end of that path. For example, if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">miacx</samp>, then this function will return the string <samp class="SANS_TheSansMonoCd_W5Regular_11">/Volumes/datasets/BlueLeaks-extracted/miacx</samp> on my computer (the output will be different if your <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> is different or if you’re using Windows and your filenames use backslashes instead of slashes).</p>

<p class="TX">Since you want to look inside <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp> and count the number of files and folders it contains, the script needs to check that it’s actually a folder and not a file, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp> function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp> isn’t a folder, the script runs the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement. This statement, which can run only inside of loops, tells Python to immediately continue on to the next iteration of the loop. In short, if the script comes across a file instead of a folder, it ignores it and moves on.</p>

<p class="TX">The script then prepares to count the number of files and folders within each individual BlueLeaks folder as the code loops by defining the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">files_count</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">folders_count</samp> with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>

<p class="TX">A second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop loops through the files in the BlueLeaks folder from the first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, saving each filename in the <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> variable <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Inside this loop, the script defines <samp class="SANS_TheSansMonoCd_W5Regular_11">filename_path</samp> as the absolute path for the filename under consideration. For instance, if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> is a string like <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory.csv</samp>, then the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">filename_path</samp> would be a string like <samp class="SANS_TheSansMonoCd_W5Regular_11">/Volumes/datasets/BlueLeaks-extracted/211sfbay/Directory.csv</samp>.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_205" aria-label=" Page 205. "/>The script then checks to see if this absolute path is a file or a folder, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp> functions <span class="CodeAnnotation" aria-label="annotation5">❺</span>. If the path is a file, the script increments the <samp class="SANS_TheSansMonoCd_W5Regular_11">files_count</samp> variable by 1; if it’s a folder, the script increments <samp class="SANS_TheSansMonoCd_W5Regular_11">folders_count</samp> by 1. When the second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop finishes running, these two variables should contain the total count of files and folders for the BlueLeaks folder you’re currently looping through in the first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. Finally, the script displays an f-string that shows these numbers <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>

<p class="TX">Try running the script. The output should show how many files and folders are contained in each BlueLeaks folder, potentially with the list of folders in a different order:</p>

<pre id="pre-315"><code>micah@trapdoor chapter-8 % <b>python3 list-files2.py</b>

bostonbric has 506 files, 10 folders

terrorismtip has 207 files, 0 folders

ociac has 216 files, 1 folders

usao has 0 files, 84 folders

alertmidsouth has 512 files, 10 folders

chicagoheat has 499 files, 10 folders

<var>--snip--</var></code></pre>

<p class="TX">So far, you’ve combined various functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp> module to make a list of filenames in your BlueLeaks folder and check whether each name actually refers to a file or to another folder. Now it’s time to learn to write code that can also traverse the BlueLeaks folder’s nested folders.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec6">

<h3 class="H1" id="sec6"><span id="h-191"/><samp class="SANS_Futura_Std_Bold_B_11">Traverse Folders with os.walk()</samp></h3>

<p class="TNI">Let’s say you want to write a program that displays all of the files in a folder and its subfolders, and its subsubfolders, and so on. When you have nested folders but don’t actually know how deep the folder structure goes, listing all of the filenames just by using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path .isdir()</samp> isn’t so simple. Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function solves this problem.</p>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function takes a path to a folder as an argument and returns a list of <i>tuples</i>, or multiple values contained in a single value. To define a tuple, you place all of the values, separated by commas, within parentheses. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">(3, 4)</samp> is a tuple, as is <samp class="SANS_TheSansMonoCd_W5Regular_11">("cinco", "seis", "siete")</samp>. Tuples can also contain mixed types like <samp class="SANS_TheSansMonoCd_W5Regular_11">(1, "dos")</samp> and can contain any number of values.</p>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function returns a list of tuples where each tuple contains three values:</p>

<pre id="pre-316"><code>(dirname, subdirnames, filenames)</code></pre>

<p class="BodyContinued">where <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp> is a string, <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp> is a list of strings, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp> is a list of strings. For example, the following code loops through the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk(path)</samp>:</p>

<pre id="pre-317"><code>for dirname, subdirnames, filenames in os.walk(path):

    print(f"The folder {dirname} has subfolders: {subdirnames} and files: {filenames}")</code></pre>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_206" aria-label=" Page 206. "/>When you use <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to loop through lists, you normally assign just a single variable to each item in the list. However, since each item is a tuple, you can assign three variables to it: <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>. In each loop, the values for this set of variables will be different: the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp> is the path to a folder, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp> is a list of subfolders inside that folder, and the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp> is a list of files inside that folder.</p>

<p class="TX">For example, suppose you have a folder called <i>example</i> that contains these subfolders and files:</p>

<pre id="pre-318"><code>example

├── downloads

│   ├── screenshot.png

│   └── paper.pdf

└── documents

    ├── work

    │   └── finances.xlsx

    └── personal</code></pre>

<p class="TX">This folder has two subfolders: <i>downloads</i> (containing <i>screenshot.png</i> and <i>paper.pdf</i>) and <i>documents</i>. The <i>documents</i> folder has its own subfolders: <i>work</i> (containing <i>finances.xlsx</i>) and <i>personal</i>.</p>

<p class="TX">The following commands loop through the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk ("./example")</samp>, where <i>./example</i> is the path to this <i>example</i> folder, to find the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp> for each loop:</p>

<pre id="pre-319"><code>&gt;&gt;&gt; <b>for dirname, subdirnames, filenames in os.walk("./example"):</b>

...     <b>print(f"The folder {dirname} has subfolders: {subdirnames} and files: {filenames}")</b>

...</code></pre>

<p class="TX">Running this command returns the following output:</p>

<pre id="pre-320"><code>The folder ./example has subfolders: ['documents', 'downloads'] and files: []

The folder ./example/documents has subfolders: ['personal', 'work'] and files: []

The folder ./example/documents/personal has subfolders: [] and files: []

The folder ./example/documents/work has subfolders: [] and files: ['finances.xlsx']

The folder ./example/downloads has subfolders: [] and files: ['paper.pdf', 'screenshot.png']</code></pre>

<p class="TX">This code loops once for each folder, including all subfolders, with the path to that folder stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>. The list of subfolders in that folder is stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>, and the list of files is stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>. Once you’ve looped through the folder and all of its subfolders, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop ends.</p>

<p class="TX">Any time you need to traverse all of the files in a dataset that contains lots of nested folders, you’ll want to use <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>. With a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, you’ll be able to write code that inspects each file in the entire dataset. The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function has many uses, including figuring out which files are the largest or smallest, as you’ll see next.</p>

</section>

<section epub:type="division" aria-labelledby="sec7">

<h3 class="H1F" id="sec7"><span id="h-192"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_207" aria-label=" Page 207. "/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-2: Find the Largest Files in BlueLeaks</samp></h3>

<p class="TNI">In this exercise, you’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> to write a script that looks through all the files, folders, and subfolders in BlueLeaks; measures the size of each file; and displays the filenames for files over 100MB. This code allows you to loop through all of the files in a folder, no matter how deep the folder structure.</p>

<p class="TX">Create a file called <i>find-big-files.py</i> and enter the following code (or copy and paste it from <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/find-big-files.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-8<wbr/>/find<wbr/>-big<wbr/>-files<wbr/>.py</i></a>):</p>

<pre id="pre-321"><code>import os



def main():

    blueleaks_path =<b> </b>"<var>/Volumes/datasets/BlueLeaks-extracted</var>"

    for dirname, subdirnames, filenames in os.walk(blueleaks_path):

        for filename in filenames:

            absolute_filename = os.path.join(dirname, filename)

            size_in_bytes = os.path.getsize(absolute_filename)

            size_in_mb = int(size_in_bytes / 1024 / 1024)

            if size_in_mb &gt;= 100:

                print(f"{absolute_filename} is {size_in_mb}MB")



if __name__ == "__main__":

    main()</code></pre>

<p class="TX">Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function, the script first defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> variable as the path of the <i>BlueLeaks-extracted</i> folder and loops through all of the files in the entire BlueLeaks dataset using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function. Inside each loop in the first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop are the <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp> variables. Each item in the list that <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> returns represents a different folder or subfolder in the BlueLeaks dataset, so by the time this loop finishes, the code will have traversed the entire dataset.</p>

<p class="TX">To find the biggest files, the next step is to look at each file with another <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, this time looping through <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>. Inside this second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the script defines <samp class="SANS_TheSansMonoCd_W5Regular_11">absolute_filename</samp> to be the absolute path to the filename. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp> tells the script which folder it’s looking in, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> tells the script which file it’s looking at, the script passes these values into <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp> to combine them, creating the absolute path to the filename.</p>

<p class="TX">A new function, <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.getsize()</samp>, returns the size, in bytes, of the file under consideration and stores it in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_bytes</samp>. The script then converts this value from bytes to megabytes (storing that in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_mb</samp>) and checks if it’s greater than or equal to 100MB. If it is, the output displays its filename and file size in megabytes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function.</p>

<p class="TX">Try running the script. It will take longer than the previous scripts in this chapter, because this time, you’re measuring the size of every single file in BlueLeaks. Here’s what the output looks like when I run it (your output may be displayed in a different order):</p>

<pre id="pre-322"><code>micah@trapdoor chapter-8 % <b>python3 find-big-files.py</b>

/Volumes/datasets/BlueLeaks-extracted/usao/usaoflntraining/files/VVSF00000/001.mp4 is 644MB<span role="doc-pagebreak" epub:type="pagebreak" id="pg_208" aria-label=" Page 208. "/>

/Volumes/datasets/BlueLeaks-extracted/chicagoheat/html/ZA-CHICAGO HEaT_LR-20160830-034_Final

Files.pdf is 102MB

/Volumes/datasets/BlueLeaks-extracted/nmhidta/files/RFIF300000/722.pdf is 148MB

/Volumes/datasets/BlueLeaks-extracted/nmhidta/files/RFIF200000/543.pdf is 161MB

/Volumes/datasets/BlueLeaks-extracted/nmhidta/files/RFIF100000/723.pdf is 206MB

/Volumes/datasets/BlueLeaks-extracted/fbicahouston/files/VVSF00000/002.mp4 is 145MB

/Volumes/datasets/BlueLeaks-extracted/fbicahouston/files/PSAVF100000/009.mp4 is 146MB

/Volumes/datasets/BlueLeaks-extracted/fbicahouston/files/PSAVF100000/026.mp4 is 105MB

<var>--snip--</var></code></pre>

<p class="TX">The script should display the absolute paths of the 101 files in BlueLeaks that are at least 100MB, along with each file’s size.</p>

</section>

<section epub:type="division" aria-labelledby="sec8">

<h3 class="H1" id="sec8"><span id="h-193"/><samp class="SANS_Futura_Std_Bold_B_11">Third-Party Modules</samp></h3>

<p class="TNI">In addition to built-in modules, Python also supports third-party modules that you can easily incorporate into your own code. Most Python scripts that I write, even simple ones, rely on at least one third-party module (when a Python program depends on third-party modules, they’re called <i>dependencies</i>). In this section, you’ll learn how to install third-party modules and use them in your own scripts.</p>

<p class="TX">The Python Package Index (PyPI) contains hundreds of thousands of third-party Python <i>packages</i>, or bundles of Python modules, and subpackages. Pip, which stands for Package Installer for Python, is a package manager similar to Ubuntu’s apt or macOS’s Homebrew used to install packages hosted on PyPI. You can search for packages on PyPI’s website (<a href="https://pypi.org"><i>https://<wbr/>pypi<wbr/>.org</i></a>), then install a package by running the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python3 -m pip install</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">package_name</samp> command.</p>

<p class="TX">For example, I frequently use a package called Click, which stands for Command Line Interface Creation Kit. The <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> Python module makes it simple to add command line arguments to your scripts. To see what happens when you try importing this module before you’ve installed it, open a Python interpreter and run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">import click</samp>. Assuming you don’t already have the package installed, you should see a <samp class="SANS_TheSansMonoCd_W5Regular_11">ModuleNotFoundError</samp> error message:</p>

<pre id="pre-323"><code>Traceback (most recent call last):

  File "&lt;stdin&gt;", line 1, in &lt;module&gt;

ModuleNotFoundError: No module named 'click'

&gt;&gt;&gt;</code></pre>

<p class="TX">Now exit the Python interpreter and install <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> with pip by running the following command:</p>

<pre id="pre-324"><code>micah@trapdoor ~ % <b>python3 -m pip install click</b>

Collecting click

  Using cached click-8.1.3-py3-none-any.whl (96 kB)

Installing collected packages: click

Successfully installed click-8.1.3</code></pre>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_209" aria-label=" Page 209. "/>Open the Python interpreter again and try importing <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> once more:</p>

<pre id="pre-325"><code>&gt;&gt;&gt; <b>import click</b>

&gt;&gt;&gt;</code></pre>

<p class="TX">If no error messages pop up, you’ve successfully imported the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> module, and its additional features are now available for you to use.</p>

<p class="TX">The command to uninstall a package is <samp class="SANS_TheSansMonoCd_W5Regular_11">python3 -m pip uninstall</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">package_name</samp>. Try uninstalling <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>:</p>

<pre id="pre-326"><code>micah@trapdoor ~ % <b>python3 -m pip uninstall click</b>

Found existing installation: click 8.1.3

Uninstalling click-8.1.3:

  Would remove:

    /usr/local/lib/python3.10/site-packages/click-8.1.3.dist-info/*

    /usr/local/lib/python3.10/site-packages/click/*

Proceed (Y/n)? <b>y</b>

  Successfully uninstalled click-8.1.3</code></pre>

<p class="TX">As you can see, when I ran this command, the output listed the files that pip would need to delete to uninstall the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> module, then asked if I wanted to proceed. I entered <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and pressed <small>ENTER</small>, and the files were deleted and the module uninstalled.</p>

<p class="TX">You can install multiple Python packages at once like so:</p>

<pre id="pre-327"><code><b>python3 -m pip install</b> <b><var>package_name1 package_name2 package_name3</var></b></code></pre>

<p class="TX">The same is true of uninstalling.</p>

<p class="TX">It’s common to define the Python packages that your script requires inside a file called <i>requirements.txt</i>, then install all of them at once with the <samp class="SANS_TheSansMonoCd_W5Regular_11">python3 -m pip install -r requirements.txt</samp> command. For example, suppose in addition to using <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>, you want to use the HTTP client <samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp> to load web pages inside Python and the <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlalchemy</samp> module to work with SQL databases. To include all three in your Python script, first create a <i>requirements .txt</i> file with each package name on its own line:</p>

<pre id="pre-328"><code>click

httpx

sqlalchemy</code></pre>

<p class="TX">Then run the following command to install them simultaneously:</p>

<pre id="pre-329"><code>micah@trapdoor chapter-8 % <b>python3 -m pip install -r requirements.txt</b>

Collecting click

  Using cached click-8.1.3-py3-none-any.whl (96 kB)

Collecting httpx

  Using cached httpx-0.23.0-py3-none-any.whl (84 kB)

<var>--snip--</var>

Successfully installed anyio-3.6.1 certifi-2022.9.24 click-8.1.3 h11-0.12.0 httpcore-0.15.0

httpx-0.23.0 idna-3.4 rfc3986-1.5.0 sniffio-1.3.0 sqlalchemy-1.4.41</code></pre>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_210" aria-label=" Page 210. "/>As you can see, this command installs more than just those three Python packages: <samp class="SANS_TheSansMonoCd_W5Regular_11">rfc3986</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">certifi</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sniffio</samp>, and so on are also included. That’s because <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlachemy</samp> have dependencies of their own. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">httpcore</samp> is a dependency of the <samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp> package, so it installs that as well. To summarize, the <i>requirements.txt</i> file defines your project’s dependencies, each of which might depend on its own list of packages.</p>
<blockquote>

<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>

<p class="NOTE-TXT"><i>To learn more about how to use</i> <i>httpx</i> <i>and other Python modules to automate interacting with websites, check out <a href="appendixB.xhtml">Appendix B</a>. I recommend waiting until you complete <a href="chapter7.xhtml">Chapters 7</a>, <a href="chapter8.xhtml">8</a>, <a href="chapter9.xhtml">9</a>, and <a href="chapter11.xhtml">11</a>, however, since the instructions covered in <a href="appendixB.xhtml">Appendix B</a> rely on the skills you’ll pick up in those chapters.</i></p>
<aside class="box" aria-labelledby="box-19">

<h4 class="BH" id="box-19"><samp class="SANS_Dogma_OT_Bold_B_11">VIRTUAL ENVIRONMENTS</samp></h4>

<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">It’s not unusual to have multiple versions of Python and multiple versions of the same dependencies for different projects installed on the same computer. If you routinely install Python packages with pip for various projects, this can get very messy over time. For example, different projects might depend on different versions of the same module to work, but you can’t have two versions of a module installed at the same time—at least not without</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">virtual environments</samp><samp class="SANS_Futura_Std_Book_11">, which are like stand-alone folders containing your Python dependencies for a specific project. This way, different projects’ dependencies won’t trip each other up.</samp></p>

<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">To keep things simple, this book doesn’t use virtual environments, and it uses only pip to install Python packages. As long as you don’t have multiple Python projects requiring specific versions of the few third-party modules this book uses, you should be fine without using a virtual environment.</samp></p>

<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">You can learn more about virtual environments at</samp> <a href="https://docs.python.org/3/tutorial/venv.html"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://docs.python.org/3/tutorial/venv.html</samp></a><samp class="SANS_Futura_Std_Book_11">.</samp> <samp class="SANS_Futura_Std_Book_11">For larger Python projects, you might also consider using Python package management programs such as</samp> <samp class="SANS_Futura_Std_Book_11">Poetry (</samp><a href="https://python-poetry.org"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://python-poetry.org</samp></a><samp class="SANS_Futura_Std_Book_11">)</samp> <samp class="SANS_Futura_Std_Book_11">or Pipenv (</samp><a href="https://github.com/pypa/pipenv"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://github.com/pypa/pipenv</samp></a><samp class="SANS_Futura_Std_Book_11">),</samp> <samp class="SANS_Futura_Std_Book_11">which handle the complicated parts of keeping track of Python packages and virtual environments for you.</samp></p>
</aside>

<p class="TX">Now that you know how to install third-party modules, you’ll practice using Click.</p>

</section>

<section epub:type="division" aria-labelledby="sec9">

<h3 class="H1F" id="sec9"><span id="h-194"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-3: Practice Command Line Arguments with Click</samp></h3>

<p class="TNI">As you learned in the previous section, the Click package makes it simple to add command line arguments to your scripts. You can use it to define variables to pass into your <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function from the terminal, without having to define those variables in your code. In this exercise, you’ll learn how to use Click by writing a sample script in preparation for using this module in later exercises.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_211" aria-label=" Page 211. "/>First, install the Click package with pip again by running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python3 -m pip install click</samp>. Next, open your text editor and enter the following Python script, <i>exercise-8-3.py</i> (or copy and paste it from <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-3.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-8<wbr/>/exercise<wbr/>-8<wbr/>-3<wbr/>.py</i></a>):</p>

<pre id="pre-330"><code>import click



@click.command()

@click.argument("name")

def main(name):

    """Simple program that greets NAME"""

    print(f"Hello {name}!")



if __name__ == "__main__":

    main()</code></pre>

<p class="TX">First, the script imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> module. It then runs a few <i>decorators</i>, function calls that begin with <samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp> and add functionality to another function you’re about to define—the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function, in this case. The <samp class="SANS_TheSansMonoCd_W5Regular_11">@click.command()</samp> decorator tells Click that <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> is a command, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">@click .argument("name")</samp> decorator tells Click that this command has an argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>.</p>

<p class="TX">Next, the script defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function, which takes <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> as an argument. This function has a docstring, <samp class="SANS_TheSansMonoCd_W5Regular_11">Simple program that greets NAME</samp>. Click uses this docstring for its commands when it builds the output for <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>, as you’ll see shortly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function simply displays a string with the name you passed in as an argument.</p>

<p class="TX">Finally, the script calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function. Notice that even though <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> requires an argument (<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>), the script doesn’t explicitly pass that argument in when calling the function. This is where the magic of the Click decorators comes in. When the script calls <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>, Click will figure out what arguments it needs to pass in, find their values from the CLI arguments, and pass them in for you.</p>

<p class="TX">Run the script as follows:</p>

<pre id="pre-331"><code>micah@trapdoor chapter-8 % <b>python3 exercise-8-3.py</b>

Usage: click-example.py [OPTIONS] NAME

Try 'click-example.py --help' for help.



Error: Missing argument 'NAME'.</code></pre>

<p class="TX">When you run the program, if you don’t pass in the correct CLI arguments, Click tells you what you did wrong. As you can see, you’re missing the required <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp> argument. Click also tells you that you can get help by running the script again with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp> argument.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_212" aria-label=" Page 212. "/>Try running the <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp> command:</p>

<pre id="pre-332"><code>micah@trapdoor chapter-8 % <b>python3 exercise-8-3.py --help</b>

Usage: click-example.py [OPTIONS] NAME



  Simple program that greets NAME



Options:

  --help  Show this message and exit.</code></pre>

<p class="TX">This time, the output shows a description of the program based on the docstring. Any CLI program that uses Click will display the docstring for the command when you run it with <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>.</p>

<p class="TX">Try running the command again, this time passing in a name. For example, here’s what happens when I pass in <samp class="SANS_TheSansMonoCd_W5Regular_11">Eve</samp> as the name:</p>

<pre id="pre-333"><code>micah@trapdoor chapter-8 % <b>python3 exercise-8-3.py Eve</b>

Hello Eve!</code></pre>

<blockquote>

<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>

<p class="NOTE-TXT"><i>You can read more about using Click at</i> <a href="https://click.palletsprojects.com"><span class="note_LinkURL_Italic">https://click.palletsprojects.com</span></a><i>.</i></p>

</section>

<section epub:type="division" aria-labelledby="sec10">

<h3 class="H1" id="sec10"><span id="h-195"/><samp class="SANS_Futura_Std_Bold_B_11">Avoiding Hardcoding with Command Line Arguments</samp></h3>

<p class="TNI">As you’ve seen in previous chapters, CLI arguments let you run the same program in many different ways, targeting different data. For example, in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, you used the <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp> command to estimate the disk space of a folder by adding the folder’s path as an argument. In <samp class="SANS_TheSansMonoCd_W5Regular_11">du -sh --apparent-size</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">path</samp>, the arguments are <samp class="SANS_TheSansMonoCd_W5Regular_11">-sh</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">--apparent-size</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">path</samp>.</p>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp> command would be much less useful if it could measure disk space for only a single hardcoded folder. <i>Hardcoding</i> means embedding information, like a path, directly into source code. You can avoid hardcoding anything in your CLI programs by having the user provide this information as arguments when running them.</p>

<p class="TX">Passing paths into scripts, rather than hardcoding them, makes for a better user experience. In previous exercises in this chapter, you hardcoded the path to your copy of the BlueLeaks dataset into your Python scripts. If you were to pass the appropriate path in as an argument, however, other people could use your script without editing it—they could just pass in <i>their</i> path when they ran it.</p>

<p class="TX">Using arguments rather than hardcoding can also make your scripts more universally useful. For example, in <span class="Xref">Exercise 8-2</span>, you wrote a script to find all of the files that are at least 100MB in the BlueLeaks dataset. Using CLI arguments, you could make this script work for any dataset you get your hands on, not just BlueLeaks, and for any minimum file size, allowing you to run it in a variety of situations. You’d just need to pass in the dataset path and the minimum file size as CLI arguments. You’ll try this out in the next exercise.</p>

</section>

<section epub:type="division" aria-labelledby="sec11">

<h3 class="H1F" id="sec11"><span id="h-196"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_213" aria-label=" Page 213. "/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-4: Find the Largest Files in Any Dataset</samp></h3>

<p class="TNI">In this exercise, you’ll modify the script you wrote in <span class="Xref">Exercise 8-2</span> to make it work for any dataset, and for any minimum file size, using CLI arguments. In the following chapters, you’ll write simple Python scripts that use Click for CLI arguments, so you can provide the paths to the datasets you’ll be working with.</p>

<p class="TX">Create a new file called <i>exercise-8-4.py</i>, and copy and paste the <i>exercise-8-2 .py</i> code into it. Next, make the following modifications to the code, highlighted in bold (or find the full modified script at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-4.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-8<wbr/>/exercise<wbr/>-8<wbr/>-4<wbr/>.py</i></a>):</p>

<pre id="pre-334"><code>import os

<b>import click</b>



<b>@click.command()</b>

<b>@click.argument("path")</b>

<b>@click.argument("min_file_size", type=click.INT)</b>

def main(<b>path, min_file_size</b>):

    <b>"""Find files in PATH that are at least MIN_FILE_SIZE MB big"""</b>

    for dirname, subdirnames, filenames in os.walk(<b>path</b>):

        for filename in filenames:

            absolute_filename = os.path.join(dirname, filename)

            size_in_bytes = os.path.getsize(absolute_filename)

            size_in_mb = int(size_in_bytes / 1024 / 1024)

            if size_in_mb &gt;= <b>min_file_size</b>:

                  print(f"{absolute_filename} is {size_in_mb}MB")



if __name__ == "__main__":

    main()</code></pre>

<p class="TX">This code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> module at the top of the file. Next, it adds Click decorators before the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function: <samp class="SANS_TheSansMonoCd_W5Regular_11">@click.command()</samp> makes the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function a Click command, and <samp class="SANS_TheSansMonoCd_W5Regular_11">@click.argument()</samp> adds <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp> as arguments. The script specifies with <samp class="SANS_TheSansMonoCd_W5Regular_11">type=click.INT</samp> that the <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp> argument should be an <i>integer</i>, or a whole number, as opposed to a string. Then it adds <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp> as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function and adds a docstring that describes what this command does.</p>

<p class="TX">The new script uses arguments instead of hardcoded values. It deletes the line that defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> variable, and in the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function call, it changes <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> to just <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>, which is the argument. Finally, it changes <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_mb</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>.</p>

<p class="TX">You can now use this program to find big files in any folder in the BlueLeaks dataset or elsewhere. For example, here’s what it looks like when I search for all files that are at least 500MB in <i>/Applications</i> on my Mac:</p>

<pre id="pre-335"><code>micah@trapdoor chapter-8 % <b>python3 exercise-8-4.py /Applications 500</b>

/Applications/Dangerzone.app/Contents/Resources/share/container.tar.gz is 668MB

/Applications/Docker.app/Contents/Resources/linuxkit/services.iso is 602MB</code></pre>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_214" aria-label=" Page 214. "/>As you can see, I have only two apps installed that include files this big: Dangerzone and Docker Desktop.</p>

<p class="TX">Now that you’ve seen how to add CLI arguments to your Python scripts using Click, you should be able to avoid hardcoding information like dataset paths in your future programs.</p>

<p class="TX">Next, we’ll switch gears and explore a new powerful type of Python variable called dictionaries.</p>

</section>

<section epub:type="division" aria-labelledby="sec12">

<h3 class="H1" id="sec12"><span id="h-197"/><samp class="SANS_Futura_Std_Bold_B_11">Dictionaries</samp></h3>

<p class="TNI">In the course of your investigations, sometimes you’ll need to keep track of data with more structure than a simple list. To do so, you can use Python dictionaries. Instead of a collection of items, a <i>dictionary</i> (<i>dict</i> for short) is a collection of keys that map to values. <i>Keys</i> are labels that you use to save or retrieve information in a dictionary, and <i>values</i> are the actual information being saved or retrieved. Nearly every Python script I write that deals with data uses dictionaries. In this section, you’ll learn how to define dictionaries, get values from them, add values to them, and update existing values in them.</p>

<section epub:type="division" aria-labelledby="sec13">

<h4 class="H2" id="sec13"><span id="h-198"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Dictionaries</samp></h4>

<p class="TNI">Dictionaries are defined using braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}), sometimes referred to as curly brackets. Inside the braces is a list of key-value pairs in the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">key</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">value</samp>, where each pair is separated from the next by commas—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">{"country": "Italy", "drinking_age": 18}</samp>. For longer dictionaries, you can make your code more readable by putting each key-value pair on its own line.</p>

<p class="TX"><a href="#list8-1">Listing 8-1</a> shows an example dictionary stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp>.</p>

<pre id="pre-336"><code>capitals = {

    "United States": "Washington, DC",

    "India": "New Delhi",

    "South Africa": "Cape Town",

    "Brazil": "Brasília",

    "Germany": "Berlin",

    "Russia": "Moscow",

    "China": "Beijing"	

}</code></pre>

<p class="CodeListingCaption" id="list8-1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: A dictionary stored in the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">capitals</samp> variable</samp></p>

<p class="TX">In this case, the keys are country names and the values are the capitals of those countries.</p>

<p class="TX">Each key in a dictionary can have only one value. If you try to set the same key more than once, Python will save the version you last set. For example, if you define a dictionary and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> key more than once, the dictionary will overwrite the previous value with the most recent one:</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_215" aria-label=" Page 215. "/>

<pre id="pre-337"><code>&gt;&gt;&gt; <b>test_dict = {"name": "Alice", "name": "Bob", "hobby": "cryptography"}</b>

&gt;&gt;&gt; <b>print(test_dict)</b>

{'name': 'Bob', 'hobby': 'cryptography'}</code></pre>

<p class="TX">However, you can also use lists, or other dictionaries, as values:</p>

<pre id="pre-338"><code>&gt;&gt;&gt; <b>test_dict = {"names": ["Alice", "Bob"], "hobby": "cryptography"}</b>

&gt;&gt;&gt; <b>print(test_dict)</b>

{'names': ['Alice', 'Bob'], 'hobby': 'cryptography'}</code></pre>

<p class="TX">In this case, the value for the key <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">['Alice', 'Bob']</samp>, which itself is a list. You can use a combination of lists and dictionaries to organize pretty much any type of data, no matter how complicated, allowing you to more easily work with it in Python.</p>

</section>

<section epub:type="division" aria-labelledby="sec14">

<h4 class="H2" id="sec14"><span id="h-199"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting and Setting Values</samp></h4>

<p class="TNI">To retrieve an item you’ve stored inside a dictionary, add square brackets containing the item’s key to the end of the dictionary name. If you try to use a key you haven’t defined, your script will crash with a <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyError</samp>. For example, here’s how to look up the capitals of certain countries in the <samp class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp> dictionary:</p>

<pre id="pre-339"><code>&gt;&gt;&gt; <b>capitals["United States"]</b>

'Washington, DC'

&gt;&gt;&gt; <b>capitals["China"]</b>

'Beijing'

&gt;&gt;&gt; <b>capitals["Kenya"]</b>

Traceback (most recent call last):

  File "&lt;stdin&gt;", line 1, in &lt;module&gt;

KeyError: 'Kenya'</code></pre>

<p class="TX">When you run <samp class="SANS_TheSansMonoCd_W5Regular_11">capitals["Kenya"]</samp>, Python throws the error message <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyError: 'Kenya'</samp>. This means that <samp class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp> isn’t a valid key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp> dictionary. You can see that the only keys defined in <span class="Xref"><a href="#list8-1">Listing 8-1</a></span> are <samp class="SANS_TheSansMonoCd_W5Regular_11">United States</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">India</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">South Africa</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Brazil</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Germany</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Russia</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">China</samp>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp> isn’t a key in this dictionary, you can’t retrieve its value.</p>

<p class="TX">You can add new key-value pairs to a dictionary, or update an existing one, like this:</p>

<pre id="pre-340"><code>&gt;&gt;&gt; <b>capitals["Kenya"] = "Nairobi"</b>

&gt;&gt;&gt; <b>capitals["United States"] = "Mar-a-Lago"</b>

&gt;&gt;&gt; <b>print(capitals)</b>

{'United States': 'Mar-a-Lago', 'India': 'New Delhi', 'South Africa': 'Cape Town', 'Brazil': 'Brasília', 'Germany': 'Berlin', 'Russia': 'Moscow', 'China': 'Beijing', 'Kenya': 'Nairobi'}</code></pre>

<p class="TX">This code defines a new key, <samp class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp>, with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">Nairobi</samp>. It also updates an existing key, <samp class="SANS_TheSansMonoCd_W5Regular_11">United States</samp>, to have the value <samp class="SANS_TheSansMonoCd_W5Regular_11">Mar-a-Lago</samp>, overwriting its old value, which used to be <samp class="SANS_TheSansMonoCd_W5Regular_11">Washington, DC</samp>.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec15">

<h3 class="H1" id="sec15"><span id="h-200"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_216" aria-label=" Page 216. "/><samp class="SANS_Futura_Std_Bold_B_11">Navigating Dictionaries and Lists in the Conti Chat Logs</samp></h3>

<p class="TNI">You can combine dictionaries and lists in a single flexible data structure that allows you to represent a wide variety of information. If you’re writing Python code to work with datasets, chances are you’re going to need both. You might directly load the data in this format, or you might create your own dictionaries and lists to store aspects of the data.</p>

<p class="TX">To describe how to use data structures that include a combination of dictionaries and lists, I’ll use an example from a real dataset. The day after Russia invaded Ukraine on February 24, 2022, the notorious Russian ransomware gang Conti, known for hacking companies around the world and extorting millions of dollars from them, published a statement on its website throwing its full support behind the Russian government. It threatened any “enemy” who launched cyberattacks against Russia with retaliation against their “critical infrastructure.” Three days later, a Ukrainian security researcher anonymously leaked 30GB of internal data from Conti: hacking tools, training documentation, source code, and chat logs. The Conti chat logs originally came in the form of JSON files, which is structured data. When you load JSON files into Python, they’ll automatically be loaded as a combination of dictionaries and lists.</p>

<p class="TX">In this section, you’ll look through some of these chat logs in order to practice working with real leaked data stored in dictionaries and lists. Using Python code, you’ll learn how to navigate these structures to access specific pieces of data as well as how to quickly loop through the chat logs and select just the parts you’re interested in.</p>

<section epub:type="division" aria-labelledby="sec16">

<h4 class="H2" id="sec16"><span id="h-201"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Dictionaries and Lists Full of Data in Python</samp></h4>

<p class="TNI">You can download the complete Conti dataset from <a href="https://ddosecrets.com/wiki/Conti_ransomware_chats"><i>https://<wbr/>ddosecrets<wbr/>.com<wbr/>/wiki<wbr/>/Conti<wbr/>_ransomware<wbr/>_chats</i></a>. However, for this section, you’ll use just one file from the dataset, <i>2022-02-24-general.json</i>, which the Ukranian security researcher extracted from a chat system called RocketChat.</p>

<p class="TX">Download <i>2022-02-24-general.json</i> from <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/2022-02-24-general.json"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-8<wbr/>/2022<wbr/>-02<wbr/>-24<wbr/>-general<wbr/>.json</i></a>. Open a terminal, change to the folder where you stored this file, and open a Python interpreter. Load this file into a dictionary with the following commands:</p>

<pre id="pre-341"><code>&gt;&gt;&gt; <b>import json</b>

&gt;&gt;&gt; <b>with open("2022-02-24-general.json") as f:</b>

...     <b>data </b><b>= json.load(f)</b>

...</code></pre>

<p class="TX">This code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> module and loads the data from <i>2022-02-24-general.json</i> into the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> variable. The chat logs from this file are too long to display in their entirety, but <a href="#list8-2">Listing 8-2</a> shows a snippet of the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> dictionary that demonstrates its structure.</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_217" aria-label=" Page 217. "/>

<pre id="pre-342"><code>{

    "messages": [<span class="CodeAnnotationCode" aria-label="annotation1">❶</span>

        {

<var>--snip--</var>

        },

        {

            "_id": "FmFZbde9ACs3gtw27",

            "rid": "GENERAL",

            "msg": "Некоторые американские сенаторы предлагают помимо соцсетей блокировать в

Россииещё и PornHub!",

            "ts": "2022-02-24T22:02:38.276Z",

            "u": {"_id": "NKrXj9edAPWNrYv5r", "username": "thomas", "name": "thomas"},

            "urls": [],

            "mentions": [],

            "channels": [],

            "md": [

                {

                    "type": "PARAGRAPH",

                    "value": [

                        {

                            "type": "PLAIN_TEXT",

                            "value": "Некоторые американские сенаторы предлагают помимо

соцсетейблокировать в России ещё и PornHub!",

                        }

                  ],

                }

            ],

            "_updatedAt": "2022-02-24T22:02:38.293Z",

        },

        {

<var>--snip--</var>

        },

    ],

    "success": True <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>

}</code></pre>

<p class="CodeListingCaption" id="list8-2"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Conti chat logs from RocketChat</samp></p>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> variable is a dictionary with two keys, <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp>. You access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp> key, which is a list of dictionaries, using the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. You can tell that the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> is a list because it’s enclosed in square brackets ([and]), and you can tell that the items inside it are dictionaries because they’re enclosed in braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}). Almost all of the data in this file is stored in this list.</p>

<p class="TX">Each dictionary in the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> list describes a chat message. This snippet of code includes only one of the dictionaries, the ninth chat message in the list (I snipped out the first eight messages, so you can’t tell that it’s the ninth without looking at the original file). You can access the dictionary that contains that specific chat message using the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp>. (Remember, in programming we start counting at 0, not 1, so the first item is at index 0, the second item is at index 1, and so on.) If you run the command <samp class="SANS_TheSansMonoCd_W5Regular_11">print(data["messages"][8])</samp> to display the dictionary <span role="doc-pagebreak" epub:type="pagebreak" id="pg_218" aria-label=" Page 218. "/>for the ninth message, the output should match the message in the listing. Notice that just as you place index numbers within brackets to select from lists, you place keys within brackets to select from dictionaries, like <samp class="SANS_TheSansMonoCd_W5Regular_11">["messages"]</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">["success"]</samp>.</p>

<p class="TX">You can also access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp> key with <samp class="SANS_TheSansMonoCd_W5Regular_11">data["success"]</samp>. Its value is the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. I’m not entirely sure what this means, but I suspect that the <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp> key was left over from whatever system the Ukrainian researcher used to export these chat messages from RocketChat, confirming that exporting the data was successful and that there were no errors.</p>

<p class="TX">The file from which I loaded this code contained 604 different chat messages, each in its own dictionary, that were sent in Conti’s #general RocketChat channel on February 24, 2022. I discovered that this list has 604 items by measuring its length with the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp> function, like this:</p>

<pre id="pre-343"><code>&gt;&gt;&gt; <b>len(data["messages"])</b>

604</code></pre>

<p class="TX">The dictionary for each chat message has many keys: <samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">rid</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">urls</samp>, and so on.</p>

<p class="TX">You can find out what types of data these keys contain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">key_variable</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dictionary</samp> syntax, and you can determine a variable’s data type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp> function. Try this out using the following commands:</p>

<pre id="pre-344"><code>&gt;&gt;&gt; <b>for key in data["messages"][8]:</b>

...     <b>print(f"{key}: {type(data['messages'][8][key])}")</b>

...</code></pre>

<p class="TX">This command loops through the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp> dictionary and stores each key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> variable. Then, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function and an f-string, it displays the key (<samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>) and the type of data stored in that key, as shown in the following output:</p>

<pre id="pre-345"><code>_id: &lt;class 'str'&gt;

rid: &lt;class 'str'&gt;

msg: &lt;class 'str'&gt;

ts: &lt;class 'str'&gt;

u: &lt;class 'dict'&gt;

urls: &lt;class 'list'&gt;

mentions: &lt;class 'list'&gt;

channels: &lt;class 'list'&gt;

md: &lt;class 'list'&gt;

_updatedAt: &lt;class 'str'&gt;</code></pre>

<p class="TX">In the output, the values at the <samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">rid</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ts</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">_updatedAt</samp> keys are all strings. The value at the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> key is a dictionary. The value at the <samp class="SANS_TheSansMonoCd_W5Regular_11">urls</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">mentions</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">md</samp> keys are lists.</p>

<p class="TX">You can get the value of the data at the key using <samp class="SANS_TheSansMonoCd_W5Regular_11">data['messages'][8][key]</samp>. Remember that to retrieve the value of a key in a dictionary, you put the key in square brackets. In this case, the key itself is stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>, so you can get its value by putting <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> inside the square brackets. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_219" aria-label=" Page 219. "/>To find out what type of data that is, then, just pass the value into the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp> function.</p>

</section>

<section epub:type="division" aria-labelledby="sec17">

<h4 class="H2" id="sec17"><span id="h-202"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Selecting Values in Dictionaries and Lists</samp></h4>

<p class="TNI">When working with datasets, you often end up with structures like this: a mess of dictionaries and lists that you need to make sense of. Being able to select the exact values you’re looking for is an important skill. To practice navigating through dictionaries and lists, take a closer look at the value of just one of these keys, the <samp class="SANS_TheSansMonoCd_W5Regular_11">md</samp> key, by running the following command:</p>

<pre id="pre-346"><code>&gt;&gt;&gt; <b>print(data["messages"][8]["md"])</b></code></pre>

<p class="TX">In the output, you can tell that this value is a list because it’s surrounded by square brackets:</p>

<pre id="pre-347"><code>[{'type': 'PARAGRAPH', 'value': [{'type': 'PLAIN_TEXT', 'value': 'Некоторые американские

сенаторы предлагают помимо соцсетей блокировать в России ещё и PornHub!'}]}]</code></pre>

<p class="TX">The list’s single item is a dictionary, which is surrounded by braces. The dictionary has a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> key whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">PARAGRAPH</samp>, as well as a <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> key. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> is another list with one item containing another dictionary; that dictionary itself contains <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> keys, where the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">PLAIN_TEXT</samp>.</p>

<p class="TX">These data structures can have as many sublists and subdictionaries as you’d like. To select specific values, after the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> variable keep adding square brackets containing an index (if it’s a list) or a key (if it’s a dictionary) until you get to the value you’re looking for. For example, use the following command to access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> key in the inner dictionary within the inner list, which is in another <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> key in the outer dictionary in the outer list:</p>

<pre id="pre-348"><code>&gt;&gt;&gt; <b>print(data["messages"][8]["md"][0]["value"][0]["value"])</b></code></pre>

<p class="TX">You already know that <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp> is a dictionary that represents a chat message. To find the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">md</samp> key in that dictionary, you include<samp class="SANS_TheSansMonoCd_W5Regular_11">["md"]</samp> in the command. As you can tell from inspecting the structure in <a href="#list8-2">Listing 8-2</a>, this is a list with one item, so adding <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp> selects that item. This item is a dictionary, and you select the value of its <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> key by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">["value"]</samp>. This item is another list with one item, so you again add <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp> to select that one item. This is yet another dictionary, so you can select the value of the final inner <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> key by adding another <samp class="SANS_TheSansMonoCd_W5Regular_11">["value"]</samp>.</p>

<p class="TX">You should get the following output:</p>

<pre id="pre-349"><code>Некоторые американские сенаторы предлагают помимо соцсетей блокировать в России ещё и PornHub!</code></pre>

<p class="TX">In English, the message that you just displayed says, “Some American Senators suggest blocking PornHub in Russia in addition to social networks!” It was posted right after Russia started its invasion of Ukraine, and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_220" aria-label=" Page 220. "/>US and European leaders immediately began imposing economic sanctions on Russia. After invading Ukraine, the Russian government censored access to Twitter and Facebook from the Russian internet. Rumors spread that PornHub, a popular American porn website, would block access to Russian users (though this didn’t happen). This same user followed up their first post with “That’s it, we’re done,” and then “They will take away our last joys!”</p>

</section>

<section epub:type="division" aria-labelledby="sec18">

<h4 class="H2" id="sec18"><span id="h-203"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analyzing Data Stored in Dictionaries and Lists</samp></h4>

<p class="TNI">Whenever I work with any sort of structured data, I find myself looping through a list of dictionaries and selecting specific pieces of data. As long as you understand its structure, you can write your own similar code to quickly pull out the relevant information, no matter what dataset you’re working with. For example, you might want to view the chat logs in the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">timestamp username</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">message</samp> in order to hide the unimportant sections of data so that you can directly copy and paste the relevant parts into machine translation systems like DeepL or Google Translate. Run the following commands to display all of the messages in <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> in that format:</p>

<pre id="pre-350"><code>&gt;&gt;&gt; <b>for message in data["messages"]:</b>

...     <b>print(f"{message['ts']} {message['u']['username']}: {message['msg']}")</b>

...</code></pre>

<p class="TX">You should get the following output:</p>

<pre id="pre-351"><code><var>--snip--</var>

2022-02-24T22:02:49.448Z thomas: последние радости у нас заберут

2022-02-24T22:02:44.463Z thomas: ну все, приплыли)

2022-02-24T22:02:38.276Z thomas: Некоторые американские сенаторы предлагают помимо соцсетей

блокировать в России ещё и PornHub!

2022-02-24T22:00:00.347Z thomas:

2022-02-24T21:58:56.152Z rags: угу :(

<var>--snip--</var></code></pre>

<p class="TX">Since <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> is a list, each time the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop in this command runs, it updates the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp> variable to a different item in that list. In this case, each item is a different dictionary. Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function displays three values: the timestamp (<samp class="SANS_TheSansMonoCd_W5Regular_11">message['ts']</samp>), the username (<samp class="SANS_TheSansMonoCd_W5Regular_11">message['u']['username']</samp>), and the message itself (<samp class="SANS_TheSansMonoCd_W5Regular_11">message['msg']</samp>).</p>

<p class="TX">You can change this command to display whatever information you’d like from each message. Maybe you’re interested is the user’s ID rather than their username. In that case, you could display <samp class="SANS_TheSansMonoCd_W5Regular_11">message['u']['_id']</samp>.</p>

<p class="TX">The previous output shows the same messages about PornHub just discussed, as well as a message posted just before that from another user, <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>. If you’re interested in seeing only the messages posted by <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>, view those by running the following commands:</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_221" aria-label=" Page 221. "/>

<pre id="pre-352"><code>&gt;&gt;&gt; <b>for message in data["messages"]:</b>

...     <b>if message["u"]["username"] ==</b><b> "rags":</b>

...         <b>print(f"{message['ts']} {message['u']['username']}: {message['msg']}")</b>

...</code></pre>

<p class="TX">This code is similar to the previous example. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop loops through each message in <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>, and then a <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> statement displays specific pieces of information from that message. This time, though, each loop also contains an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement. Each time the code finds another message, it checks to see if the username is <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp> and, if so, displays the message. Otherwise, it moves on to the next message. You should get the following output:</p>

<pre id="pre-353"><code>2022-02-24T22:08:49.684Z rags: давай бро спокойной ночи

2022-02-24T22:03:50.131Z rags: сча посмотрю спасиб =)

2022-02-24T21:58:56.152Z rags: угу :(

<var>--snip--</var></code></pre>

<p class="TX">Finally, suppose you want to figure out how many messages each person posted, perhaps to find the most active poster in the #general chatroom on this day. The simplest way to do this is to create a new empty dictionary yourself and then write code to fill it up. Run the following command to create an empty dictionary called <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>:</p>

<pre id="pre-354"><code>&gt;&gt;&gt; <b>user_posts = {}</b></code></pre>

<p class="TX">The keys in this dictionary will be usernames, and the values will be the number of posts from that user. Fill up the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp> dictionary with the following code:</p>

<pre id="pre-355"><code>&gt;&gt;&gt; <b>for message in data["messages"]:</b>

...     <b>username = message["u"]["username"]</b>

...     <b>if username not in user_posts:</b>

...         <b>user_posts[username] = 1</b>

...     <b>else:</b>

...         <b>user_posts[username] += 1</b>

...

&gt;&gt;&gt;</code></pre>

<p class="TX">Again, this code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to loop through the messages. Next, it defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp> variable as <samp class="SANS_TheSansMonoCd_W5Regular_11">message["u"]["username"]</samp>, the username of the person who posted the message the code is currently looping through. Next, using an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, the code checks to see if this username is already a key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp> dictionary. (It’s not checking to see if the string <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp> is a key, but rather if the <i>value</i> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp> variable, like <samp class="SANS_TheSansMonoCd_W5Regular_11">thomas</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>, is a key.)</p>

<p class="TX">If this user doesn’t exist in the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp> dictionary, the program adds a key to this dictionary and sets the value at that key to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, with the line <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts[username]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Otherwise, it increases the value by 1, with <span role="doc-pagebreak" epub:type="pagebreak" id="pg_222" aria-label=" Page 222. "/><samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts[username]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. By the time the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop finishes running, the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp> dictionary should be complete. The keys should be all of the usernames found in the messages, and the values should be the total number of messages for that user.</p>

<p class="TX">Use the following code to display the information inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp> dictionary, viewing the data you just collected:</p>

<pre id="pre-356"><code>&gt;&gt;&gt; <b>for username in user_posts:</b>

...     <b>print(f"{username} posted {user_posts[username]} times")</b>

...</code></pre>

<p class="TX">You should get the following output:</p>

<pre id="pre-357"><code>weldon posted 64 times

patrick posted 62 times

rags posted 38 times

thomas posted 58 times

ryan posted 2 times

kermit posted 151 times

biggie posted 39 times

stanton posted 12 times

angelo posted 102 times

Garfield posted 61 times

jaime posted 2 times

grem posted 5 times

jefferson posted 1 times

elijah posted 6 times

chad posted 1 times</code></pre>

<p class="TX">These are the users who posted in Conti’s #general chatroom, in their RocketChat server, on the day Russia invaded Ukraine in 2022. The user <i>kermit</i> posted 151 times, more than any other user.</p>

<p class="TX">In these examples, you looped through hundreds of chat messages, but the same concepts would work with millions or billions of messages or with data representing any sort of information.</p>
<aside class="box" aria-labelledby="box-20">

<h5 class="BH" id="box-20"><samp class="SANS_Dogma_OT_Bold_B_11">REVELATIONS IN THE CONTI DATASET</samp></h5>

<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">This dataset includes far more chat logs than just a few messages worrying about a porn site getting blocked. The example I used in this section included the chat logs for the #general channel for a single day, but the logs for this RocketChat server span from July 24, 2021, to February 26, 2022. The leak also includes many logs from the chat service known as Jabber, including some where Conti hackers discuss hacking a contributor to the OSINT-based investigative journalism group Bellingcat. The hackers were hoping to find information</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_223" aria-label=" Page 223. "/><samp class="SANS_Futura_Std_Book_11">about Alexei Navalny, the imprisoned Russian opposition leader who survived an FSB assassination attempt.</samp></p>

<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The anonymous Ukrainian researcher who leaked the Conti dataset told CNN, “I cannot shoot anything, but I can fight with a keyboard and mouse.” According to CNN, a few weeks after leaking the data, the researcher successfully slipped out of Ukraine during Russia’s invasion, laptop in hand.</samp></p>

<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">From reading the chat logs, I learned that many of the Conti hackers are Russian ultranationalists. Many of them believe Putin’s conspiratorial lies about Ukraine, like that it’s run by a “neo-Nazi junta,” while at the same time making antisemitic comments about Volodymyr Zelenskyy, Ukraine’s Jewish president. You can see my full reporting on this dataset at</samp> <a href="https://theintercept.com/2022/03/14/russia-ukraine-conti-russian-hackers/"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://theintercept.com/2022/03/14/russia-ukraine-conti-russian-hackers/</samp></a><samp class="SANS_Futura_Std_Book_11">.</samp></p>
</aside>

<p class="TX">In this section, you learned how to work with flexible data structures that combine dictionaries and lists, including how to pick out specific elements that you’re interested in and how to quickly traverse them by looping through them. These skills will often prove useful when you’re writing Python scripts to help you analyze data.</p>

<p class="TX">Now that you’re familiar with data structures that combine dictionaries and lists, it’s time to create your own to map out the CSV files in BlueLeaks.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec19">

<h3 class="H1F" id="sec19"><span id="h-204"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-5: Map Out the CSVs in BlueLeaks</samp></h3>

<p class="TNI">Each folder in BlueLeaks includes data from a single hacked law enforcement website in the form of hundreds of CSV files. These files contain some of the most interesting information in all of BlueLeaks, such as the contents of bulk email that fusion centers sent to local cops, or “suspicious activity reports.” In this exercise, you’ll construct a map of the contents of the dataset.</p>

<p class="TX">By manually looking in different BlueLeaks folders, I noticed that each folder seems to have a file called <i>Company.csv</i> (each containing different content), but only one folder, <i>ncric</i>, has a file called <i>911Centers.csv</i>. Clearly, not all of the BlueLeaks sites have the same data. Which CSV files are in every folder in BlueLeaks, which are in some folders, and which are unique to a single folder? Let’s write a Python script to find out.</p>

<p class="TX">As with most programming problems, there are multiple ways you could write a script that answers this question. If you feel comfortable enough with Python by now that you’d like a challenge, try writing one on your own. Otherwise, follow along with this exercise. Either way, the program must meet the following requirements:</p>
<ul class="BL">

<li class="BL">Make the script accept an argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> using Click.</li>
<li class="BL">Create an empty dictionary called <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>. Your script should fill this dictionary with data. The keys should be CSV filenames, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_224" aria-label=" Page 224. "/>and the values should be lists of BlueLeaks folders that contain this CSV.</li>
<li class="BL">Loop through all of the files and folders in <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>. For each folder, loop through all of the files it contains. For each CSV file, add data to the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> dictionary.</li>
<li class="BL">Display the contents of the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> dictionary.</li>
</ul>

<p class="TX">In each step that follows, I’ll quote a snippet of code, explain how it works, and give you a chance to run it as is. You’ll then add more features to that code and run it again. It’s good practice to write code in small batches, pausing frequently to test that it works as you expect. This will help you catch bugs early, making the process of debugging much simpler.</p>

<section epub:type="division" aria-labelledby="sec20">

<h4 class="H2" id="sec20"><span id="h-205"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accept a Command Line Argument</samp></h4>

<p class="TNI">Create an <i>exercise-8-5.py</i> file and enter the Python template:</p>

<pre id="pre-358"><code>def main():

    pass



if __name__ == "__main__":

    main()</code></pre>

<p class="TX">Next, instead of hardcoding the path to the BlueLeaks data like you did in Exercise 8-2, let’s use Click to pass in the path as a command line argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>. To do so, make the following modifications to your code (the added syntax is highlighted in bold):</p>

<pre id="pre-359"><code><b>import click</b>



<b>@click.command()</b>

<b>@click.argument("blueleaks_path")</b>

def main(<b>blueleaks_path</b>):

    <b>"""Map out the CSVs in BlueLeaks"""</b>

    <b>print(f"blueleaks_path is: {blueleaks_path}")</b>



if __name__ == "__main__":

    main()</code></pre>

<p class="TX">This code modifies the template to import the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> module, adds the correct decorators before the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function, adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function, and adds a simple docstring to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function so that running this script with <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp> will be more useful. Finally, it includes a line to display the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>, so that you can confirm the code is working when you run it.</p>

<p class="TX">Try running your script with <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp> to see if the help text works, and with a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> to see if the argument is successfully sent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function:</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_225" aria-label=" Page 225. "/>

<pre id="pre-360"><code>micah@trapdoor chapter-8 % <b>python3 exercise-8-5.py --help</b>

Usage: exercise-8-4.py [OPTIONS] BLUELEAKS_PATH



  Map out the CSVs in BlueLeaks



Options:

  --help  Show this message and exit.

micah@trapdoor chapter-8 % <b>python3 exercise-8-5.py test-path</b>

blueleaks_path is: test-path</code></pre>

<p class="TX">If your output looks like this, everything is working correctly so far.</p>

</section>

<section epub:type="division" aria-labelledby="sec21">

<h4 class="H2" id="sec21"><span id="h-206"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loop Through the BlueLeaks Folders</samp></h4>

<p class="TNI">Now that you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> CLI argument, make the following modifications to your code to have it loop through all of the folders it finds in that path:</p>

<pre id="pre-361"><code>import click

<b>import os</b>



@click.command()

@click.argument("blueleaks_path")

def main(blueleaks_path):

    """Map out the CSVs in BlueLeaks"""

    <b>for folder in os.listdir(blueleaks_path):</b>

        <b>blueleaks_folder_path = os.path.join(blueleaks_path, folder)</b>



        <b>if os.path.isdir(blueleaks_folder_path):</b>

            <b>print(f"folder: {folder}, path: {blueleaks_folder_path}")</b>



if __name__ == "__main__":

    main()</code></pre>

<p class="TX">First, you import the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp> module in order to be able to list all of the files in the <i>BlueLeaks-extracted</i> folder using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp> function. Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function, a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop loops through the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir (blueleaks_path)</samp>, the list of filenames inside the folder at <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>.</p>

<p class="TX">Inside the loop, the code defines <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp> as the path of the specific BlueLeaks folder for the current loop. For example, if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> is <i>/Volumes/datasets/BlueLeaks-extracted</i>, and at this point in the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp> is <i>icefishx</i>, then the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp> will be <i>/Volumes/datasets/BlueLeaks-extracted/icefishx</i>.</p>

<p class="TX">You want to look inside subfolders in the <i>BlueLeaks-extracted</i> folder, not inside files. If there are any files in that folder, you want to skip them. To meet these requirements, the code includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement that checks whether <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp> is actually a folder. Finally, the code displays the current value of <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_226" aria-label=" Page 226. "/>Run your script again. This time, pass in the real path to your <i>BlueLeaks -extracted</i> folder:</p>

<pre id="pre-362"><code>micah@trapdoor chapter-8 % <b>python3 exercise-8-5.py </b><b><var>/Volumes/datasets/BlueLeaks-extracted</var></b>

folder: bostonbric, path: /Volumes/datasets/BlueLeaks-extracted/bostonbric

folder: terrorismtip, path: /Volumes/datasets/BlueLeaks-extracted/terrorismtip

folder: ociac, path: /Volumes/datasets/BlueLeaks-extracted/ociac

<var>--snip--</var></code></pre>

<p class="TX">The output should show that the <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp> variable holds just the name of the folder, like <i>bostonbric</i>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp> variable includes the full path to that folder, like <i>/Volumes/datasets/BlueLeaks-extracted/bostonbric</i>. When you run this on your own computer, you may see these values in a different order than what’s shown here.</p>

</section>

<section epub:type="division" aria-labelledby="sec22">

<h4 class="H2" id="sec22"><span id="h-207"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fill Up the Dictionary</samp></h4>

<p class="TNI">You now have a script that accepts <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp> as an argument and then loops through every folder in that path. Adding the code in bold creates the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> dictionary and starts to fill it up with data:</p>

<pre id="pre-363"><code>import click

import os



@click.command()

@click.argument("blueleaks_path")

def main(blueleaks_path):

    """Map out the CSVs in BlueLeaks"""

    <b>csv_to_folders = {}</b>



    for folder in os.listdir(blueleaks_path):

        blueleaks_folder_path = os.path.join(blueleaks_path, folder)



        if os.path.isdir(blueleaks_folder_path):

            <b>for filename in os.listdir(blueleaks_folder_path):</b>

                <b>if filename.lower().endswith(".csv"):</b>

                    <b>if filename not in csv_to_folders:</b>

                        <b>csv_to_folders[filename] = []</b>



                    <b>csv_to_folders[filename].append(folder)</b>



if __name__ == "__main__":

    main()</code></pre>

<p class="TX">Your goal with this script is to map out which CSV files are in which BlueLeaks folders. To store this data, the code creates the empty dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> at the top of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function. The next step is to fill up that dictionary.</p>

<p class="TX">The code loops through all of the filenames in <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>, checking each to see if it’s a folder. Removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> statement in the previous iteration of the code, this code instead adds a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop that loops through all of the files in that specific BlueLeaks folder.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_227" aria-label=" Page 227. "/>In this second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement checks whether the filename ends in <i>.csv</i>. This <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> method on the <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> string, which returns a lowercase-only version of the string. The code then calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp> method on that lowercase string, which returns a Boolean describing whether the string ends with the string that was passed in. If the string <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> ends with <i>.csv</i>, <i>.CSV</i>, or <i>.cSv</i>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> method will convert the file extension to <i>.csv</i>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp> will return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> ends with anything else, like <i>.docx</i>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp> will return <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.</p>

<p class="TX">Each time the code following this <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement runs, it means the program has found a CSV (called <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>) in the current BlueLeaks folder (called <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>). You want <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> to be a dictionary where the keys are CSV filenames and the values are lists of folders. This code checks to see if the key <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> has been created in <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>, and if it hasn’t, creates it and set its value to an empty list (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>). Finally, after the code has confirmed that the <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> key has been created and is a list, it appends the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp> to that list.</p>

<p class="TX">These last lines are tricky, so let’s dig in a little more. The first time the script comes across a CSV filename (like <i>CatalogRelated.csv</i>), the script sets the value of that key in <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> to an empty list. If the same filename exists in another BlueLeaks folder later on, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">filename not in csv_to_folders</samp> will evaluate to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> (meaning <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders["CatalogRelated .csv"]</samp> already exists), so the code following the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement won’t run. Finally, the code appends <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>, the name of the BlueLeaks folder it’s currently looking in, to the list of folders that include that filename.</p>

<p class="TX">Pause and try running the script so far:</p>

<pre id="pre-364"><code>micah@trapdoor chapter-8 % <b>python3 exercise-8-5.py </b><b><var>/Volumes/datasets/BlueLeaks-extracted</var></b></code></pre>

<p class="TX">This should take a moment to run but displays nothing, since you’re not yet using the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function anywhere. The code is simply creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> dictionary and filling it up with data.</p>

</section>

<section epub:type="division" aria-labelledby="sec23">

<h4 class="H2" id="sec23"><span id="h-208"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Display the Output</samp></h4>

<p class="TNI">By the time the previous version of the script runs, the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> dictionary should contain a complete set of CSV filenames, mapped to the BlueLeaks sites where they were found. The following code should show you what the program found:</p>

<pre id="pre-365"><code>import click

import os



@click.command()

@click.argument("blueleaks_path")

def main(blueleaks_path):

    """Map out the CSVs in BlueLeaks"""

    csv_to_folders = {}



    for folder in os.listdir(blueleaks_path):

        blueleaks_folder_path = os.path.join(blueleaks_path, folder)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_228" aria-label=" Page 228. "/>



          if os.path.isdir(blueleaks_folder_path):

            for filename in os.listdir(blueleaks_folder_path):

                if filename.lower().endswith(".csv"):

                    if filename not in csv_to_folders:

                        csv_to_folders[filename] = []



                    csv_to_folders[filename].append(folder)



    <b>for filename in csv_to_folders:</b>

        <b>print(f"{len(csv_to_folders[filename])} folders | {filename}")</b>



if __name__ == "__main__":

    main()</code></pre>

<p class="TX">The added code in bold loops through all of the keys (each a CSV filename) in <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>, then displays the number of BlueLeaks folders that contain that file (<samp class="SANS_TheSansMonoCd_W5Regular_11">len(csv_to_folders[filename])</samp>) along with the filename itself.</p>

<p class="TX">You can find this final script at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-5.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-8<wbr/>/exercise<wbr/>-8<wbr/>-5<wbr/>.py</i></a>. When you run it, the output should look like this:</p>

<pre id="pre-366"><code>micah@trapdoor chapter-8 % <b>python3 exercise-8-5.py </b><b><var>/Volumes/datasets/BlueLeaks-extracted</var></b>

161 folders | CatalogRelated.csv

161 folders | Blog.csv

161 folders | EmailBuilderOptions.csv

<var>--snip--</var>

1 folders | HIDTAAgentCategory.csv

1 folders | Lost.csv

1 folders | AgencyContacts.csv</code></pre>

<p class="TX">Since this script displays the number of folders at the beginning of each line of output, you can pipe the output into <samp class="SANS_TheSansMonoCd_W5Regular_11">sort -n</samp> to sort it numerically in ascending order, like so:</p>

<pre id="pre-367"><code>micah@trapdoor chapter-8 % <b>python3 exercise-8-5.py </b><b><var>/Volumes/datasets/BlueLeaks-extracted</var></b><b> | sort</b>

<b>-n</b>

1 folders | 1Cadets.csv

1 folders | 1Mentors.csv

1 folders | 1Unit.csv

<var>--snip--</var>

161 folders | VideoDownload.csv

161 folders | VideoHistory.csv

161 folders | VideoOptions.csv</code></pre>

<p class="TX">Most of the CSV files are in either a single folder or all 161 folders. However, there are a few exceptions: <i>Donations.csv</i> should be in 10 folders, <i>SARs.csv</i> should be in 25, and so on. This information would have taken you many hours of busywork to find manually.</p>

<p class="TX">At this point, you’ve learned the basics of navigating the filesystem in Python. You’ve seen how to loop through folders using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>, loop through entire folder structures using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>, and look up information <span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label=" Page 229. "/>about the files and folders you find. In the next section, you’ll learn how to actually read the contents of a file you find and create new files yourself.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec24">

<h3 class="H1" id="sec24"><span id="h-209"/><samp class="SANS_Futura_Std_Bold_B_11">Reading and Writing Files</samp></h3>

<p class="TNI">To follow the rest of this book, you’ll need to know one more major Python concept: how to read and write files. During a data investigation, you’ll almost certainly need to read the contents of files, especially CSV and JSON files. You’ll also probably want to be able to create new files, by calculating some data of your own and saving it to a spreadsheet, for example. In this section you’ll learn how to open files and write or read content to them.</p>

<p class="TX">In programming, to work with a file, you first need to open it and specify the <i>mode</i>—that is, whether you’re planning on <i>reading</i> from or <i>writing</i> to this file. To open an existing file and access its contents, open it for reading using mode <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>. To create a new file and put data in it, open it for writing using mode <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp>.</p>

<section epub:type="division" aria-labelledby="sec25">

<h4 class="H2" id="sec25"><span id="h-210"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opening Files</samp></h4>

<p class="TNI">To prepare to work with a file, whether for writing or reading, you use the built-in Python function <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>. To open it for reading, you use the following code:</p>

<pre id="pre-368"><code>with open("<var>some_file.txt</var>", "r") as f:

    text = f.read()</code></pre>

<p class="TX">This code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> statement, which tells Python that after the <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp> function is done running, it should set the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> to that function’s return value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> variable is a <i>file object</i>, a type of variable that allows you to read or write data to a file. The first argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp> function is a path, and the second argument is the mode, which in this example is <samp class="SANS_TheSansMonoCd_W5Regular_11">"r"</samp> for reading.</p>

<p class="TX">In the code block after the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> statement, you can call methods on <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> to interact with the file. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">f.read()</samp> will read all of the data in the file and return it—in this case, storing it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> variable.</p>

<p class="TX">To open a file for writing, you set the mode to <samp class="SANS_TheSansMonoCd_W5Regular_11">"w"</samp> like so:</p>

<pre id="pre-369"><code>with open("output.txt", <b>"w"</b>) as f:

    f.write("hello world")</code></pre>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp> function returns the file object <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>. To write data into the file, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp> method. Here, this code is opening a file called <i>output.txt</i> and writing the string <samp class="SANS_TheSansMonoCd_W5Regular_11">hello world</samp> to it.</p>

<p class="TX">In the next two sections, you’ll learn more about using <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp> to write to files and <samp class="SANS_TheSansMonoCd_W5Regular_11">f.read()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">f.readlines()</samp> to read from files.</p>

</section>

<section epub:type="division" aria-labelledby="sec26">

<h4 class="H2" id="sec26"><span id="h-211"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_230" aria-label=" Page 230. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing Lines to a File</samp></h4>

<p class="TNI">Text files are made up of a series of individual characters. Consider a text file with these contents:</p>

<pre id="pre-370"><code>Hello World

Hola Mundo</code></pre>

<p class="TX">You could also represent the entire contents of this file as a Python string:</p>

<pre id="pre-371"><code>"Hello World\nHola Mundo\n"</code></pre>

<p class="TX">The first character of the string is <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>, and so on. The 12th character (counting the space), <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>, is a special character known as a <i>newline</i> that represents a break between lines. As with shell scripting, the backslash is the escape character in Python, so a backslash followed by another character represents a single special character.</p>

<p class="TX">Newlines are used to write lines to a file. Try running these commands in your Python interpreter:</p>

<pre id="pre-372"><code>&gt;&gt;&gt; <b>with open("output.txt", "w") as f:</b>

...     <b>f.write("Hello World\n")</b>

...     <b>f.write("Hola Mundo\n")</b>

...

12

11</code></pre>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp> in the output represent the number of bytes written. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp> call wrote 12 bytes, because the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World</samp> takes 11 bytes of memory: it has 11 characters, plus 1 for the newline character. The second call wrote 11 bytes, since <samp class="SANS_TheSansMonoCd_W5Regular_11">Hola Mundo</samp> takes 10 bytes of memory, plus 1 for the newline character.</p>

<p class="TX">In your terminal, use the following command to view the file you just wrote:</p>

<pre id="pre-373"><code>micah@trapdoor ~ % <b>cat output.txt</b>

Hello World

Hola Mundo</code></pre>

<p class="TX">If you had written the same code but without the newlines, the output would have been <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello WorldHola Mundo</samp>, with no line breaks.</p>

</section>

<section epub:type="division" aria-labelledby="sec27">

<h4 class="H2" id="sec27"><span id="h-212"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading Lines from a File</samp></h4>

<p class="TNI">Run the following command to read the file you just created:</p>

<pre id="pre-374"><code>&gt;&gt;&gt; <b>with open("output.txt", "r") as f:</b>

...     <b>text = f.read()</b>

...</code></pre>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_231" aria-label=" Page 231. "/>This code reads all of the data from the file and saves it in the string <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>. In fact, this might look familiar: earlier in this chapter, in the <span class="Xref">“Exploring Dictionaries and Lists Full of Data in Python”</span> section, we used similar code to load the leaked Conti chat logs into a Python dictionary.</p>

<p class="TX">Since splitting text files into multiple lines is so common, file objects also have a convenient method called <samp class="SANS_TheSansMonoCd_W5Regular_11">readlines()</samp>. Instead of reading all of the data into a file, it reads only one line at a time, and you can loop over the lines in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. Try this out by running the following commands:</p>

<pre id="pre-375"><code>&gt;&gt;&gt; <b>with open("/tmp/output.txt", "r") as f:</b>

...     <b>for line in f.readlines():</b>

...         <b>print(line)</b>

...

Hello World



Hola Mundo</code></pre>

<p class="TX">This code opens the file for reading, then loops through each line in the file. Each line is stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">line</samp>, then displayed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">line</samp> variable in each loop ends in <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> (for example, the first line is <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World\n</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World</samp>), and the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function automatically adds an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>, the output shows an extra hard return after each line.</p>

<p class="TX">If you don’t want to display these extra newlines, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">strip()</samp> method to get rid of any whitespace (spaces, tabs, or newlines) from the beginning and end of the string. Run the same code, but this time strip out the newline characters on each line:</p>

<pre id="pre-376"><code>&gt;&gt;&gt; <b>with open("/tmp/output.txt", "r") as f:</b>

...     <b>for line in f.readlines():</b>

...         <b>line = line.strip()</b>

...         <b>print(line)</b>

...

Hello World

Hola Mundo</code></pre>

<p class="TX">You’ll practice the basics of how to read and write files in Python in the following exercise.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec28">

<h3 class="H1F" id="sec28"><span id="h-213"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-6: Practice Reading and Writing Files</samp></h3>

<p class="TNI">In Exercise 7-5, you wrote a function that converts a string to an alternating caps version, like <samp class="SANS_TheSansMonoCd_W5Regular_11">This book is amazing</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">ThIs bOoK Is aMaZiNg</samp>. To practice your newfound reading and writing files, in this exercise, you’ll write a script to create an alternating caps version of all of the text in an entire text file.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_232" aria-label=" Page 232. "/>If you’d like a challenge, you can try programming your own script to meet the following requirements:</p>
<ul class="BL">

<li class="BL">Accepts two arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>, using Click</li>
<li class="BL">Opens the file <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp> for reading and loads its contents into the string <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp></li>
<li class="BL">Opens the file <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp> for writing and saves the alternating caps version of <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> to that new file</li>
</ul>

<p class="TX">Otherwise, follow along with my explanation of the following code, which implements this iNcReDiBlY uSeFuL command line program.</p>

<p class="TX">Start by copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp> function that you wrote in Exercise 7-5 into a new Python script called <i>exercise-8-6.py</i>. Next, make the modifications highlighted in bold here (or copy the final script at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-6.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-8<wbr/>/exercise<wbr/>-8<wbr/>-6<wbr/>.py</i></a>):</p>

<pre id="pre-377"><code><b>import click</b>



def alternating_caps(text):

    """Returns an aLtErNaTiNg cApS version of text"""

    alternating_caps_text = ""

    should_be_capital = True



    for character in text:

        if should_be_capital:

            alternating_caps_text += character.upper()

            should_be_capital = False

        else:

            alternating_caps_text += character.lower()

            should_be_capital = True



    return alternating_caps_text



<b>@click.command()</b>

<b>@click.argument("input_filename")</b>

<b>@click.argument("output_filename")</b>

<b>def main(input_filename, output_filename):</b>

    <b>"""Converts a text file to an aLtErNaTiNg cApS version"""</b>

    <b>with open(input_filename, "r") as f:</b>

        <b>text = f.read()</b>



    <b>with open(output_filename, "w") as f:</b>

        <b>f.write(alternating_caps(text))</b>



if __name__ == "__main__":

      main()</code></pre>

<p class="TX">This code first imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> module, used for the arguments, and then defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp> function. Again, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function is a Click command, but this time it takes two arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label=" Page 233. "/>Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function runs, the section for reading and writing files runs. The code opens <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp> for reading and loads all of the contents of that file into the string <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>. It then opens <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp> for writing and saves the alternating caps version of that string into the new file. It does so by running <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps(text)</samp>, which takes <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> as an argument and returns its alternating caps version, and then passes that return value directly into <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>, writing it to the file.</p>

<p class="TX">To demonstrate how this script works, try running it on the famous “To be, or not to be” soliloquy from <i>Hamlet</i>. First, save a copy of the soliloquy found at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/shakespeare.txt"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-8<wbr/>/shakespeare<wbr/>.txt</i></a> to a file called <i>shakespeare.txt</i>. Here are the original contents of <i>shakespeare.txt</i>, displayed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> command:</p>

<pre id="pre-378"><code>micah@trapdoor chapter-8 % <b>cat shakespeare.txt</b>

To be, or not to be, that is the question:

Whether 'tis nobler in the mind to suffer

The slings and arrows of outrageous fortune,

Or to take Arms against a Sea of troubles,

And by opposing end them: to die, to sleep

No more; and by a sleep, to say we end

<var>--snip--</var></code></pre>

<p class="TX">Next, pass that filename into your script to create an alternating caps version of that file. Here’s what happens when I do it:</p>

<pre id="pre-379"><code>micah@trapdoor chapter-8 % <b>python3 exercise-8-5.py shakespeare.txt shakespeare-mocking.txt</b>

micah@trapdoor chapter-8 % <b>cat shakespeare-mocking.txt</b>

To bE, oR NoT To bE, tHaT Is tHe qUeStIoN:

wHeThEr 'TiS NoBlEr iN ThE MiNd tO SuFfEr

tHe sLiNgS AnD ArRoWs oF OuTrAgEoUs fOrTuNe,

Or tO TaKe aRmS AgAiNsT A SeA Of tRoUbLeS,

aNd bY OpPoSiNg eNd tHeM: tO DiE, tO SlEeP

No mOrE; aNd bY A SlEeP, tO SaY We eNd

<var>--snip--</var></code></pre>

<p class="TX">First, I ran the script, passing in <i>shakespeare.txt</i> as <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp> and <i>shakespeare-mocking.txt</i> as <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>. The script itself displayed no output (it doesn’t include any <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> statements), but it did create a new file. I then used <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> to display the contents of that new file, which is indeed an alternating caps version of Hamlet’s soliloquy.</p>

</section>

<section epub:type="division" aria-labelledby="sec29">

<h3 class="H1" id="sec29"><span id="h-214"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>

<p class="TNI">Congratulations on making it through a crash course in the fundamentals of Python programming! You’ve learned how to bring extra functionality to your scripts with built-in and third-party Python modules. You’ve also learned how to make your own CLI programs using Click, how to write code that traverses the filesystem, how to work with structured data using dictionaries and lists, and how to read and write files.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_234" aria-label=" Page 234. "/>You’ll use these skills throughout the following chapters as you dig through various datasets, uncovering revelations you’d never discover otherwise. In the next chapter, you’ll write Python programs that loop through rows in the BlueLeaks CSV spreadsheets, transforming the data into a more workable format. You’ll get practice writing the content of law enforcement bulk email messages to files, and you’ll use Python to create your own CSV spreadsheets.</p>

</section>
</section>

</div></body></html>