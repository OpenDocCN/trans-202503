- en: '**20'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**20'
- en: NETWORK PROGRAMMING WITH BOOST ASIO**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: NETWORK PROGRAMMING WITH BOOST ASIO**
- en: '*Anyone who has lost track of time when using a computer knows the propensity
    to dream, the urge to make dreams come true, and the tendency to miss lunch.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何在使用电脑时迷失时间的人，都知道那种做梦的倾向、实现梦想的冲动，以及错过午餐的习惯。*'
- en: —Tim Berners-Lee*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —蒂姆·伯纳斯-李*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Boost Asio is a library for low-level I/O programming. In this chapter, you’ll
    learn about Boost Asio’s basic networking facilities, which enable programs to
    interact easily and efficiently with network resources. Unfortunately, the stdlib
    doesn’t contain a network-programming library as of C++17\. For this reason, Boost
    Asio plays a central role in many C++ programs with a networking component.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Asio 是一个用于低级 I/O 编程的库。在本章中，你将了解 Boost Asio 的基本网络功能，它使程序能够轻松高效地与网络资源进行交互。不幸的是，从
    C++17 开始，标准库中并没有包含网络编程库。因此，Boost Asio 在许多具有网络组件的 C++ 程序中发挥着核心作用。
- en: Although Boost Asio is the primary choice for C++ developers who want to incorporate
    cross-platform, high-performance I/O into their programs, it’s a notoriously complicated
    library. This complication combined with an unfamiliarity with low-level network
    programming might be too overwhelming for newcomers. If you find this chapter
    obtuse or if you don’t need information on network programming, you can skip this
    chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Boost Asio 是 C++ 开发者在想要将跨平台、高性能 I/O 融入程序时的主要选择，但它是一个出了名的复杂库。这种复杂性与对低级网络编程的不熟悉相结合，可能会让新手感到过于压倒。如果你觉得本章晦涩难懂，或者如果你不需要关于网络编程的信息，你可以跳过这一章。
- en: '**NOTE**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost Asio also contains facilities for I/O with serial ports, streams, and
    some operating system–specific objects. In fact, the name is derived from the
    phrase “asynchronous I/O.” See the Boost Asio documentation for more information.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost Asio 还包含用于与串口、流和一些操作系统特定对象进行 I/O 的功能。事实上，这个名称来源于“异步 I/O”这个短语。欲了解更多信息，请参阅
    Boost Asio 文档。*'
- en: '**The Boost Asio Programming Model**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Boost Asio 编程模型**'
- en: In the Boost programming model, an *I/O context object* abstracts the operating
    system interfaces that handle asynchronous data processing. This object is a registry
    for *I/O objects*, which initiate asynchronous operations. Each object knows its
    corresponding service, and the context object mediates the connection.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Boost 编程模型中，一个 *I/O 上下文对象* 抽象了处理异步数据处理的操作系统接口。这个对象是 *I/O 对象* 的注册表，I/O 对象会发起异步操作。每个对象都知道其对应的服务，而上下文对象则在其中进行调解。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All Boost Asio classes appear in the <boost/asio.hpp> convenience header.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有 Boost Asio 类都出现在 <boost/asio.hpp> 方便的头文件中。*'
- en: 'Boost Asio defines a single service object, `boost::asio::io_context`. Its
    constructor takes an optional integer argument called the *concurrency hint*,
    which is the number of threads the `io_context` should allow to run concurrently.
    For example, on an eight-core machine, you might construct an `io_context` as
    follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Asio 定义了一个单一的服务对象，`boost::asio::io_context`。它的构造函数接受一个可选的整数参数，称为*并发提示*，它表示
    `io_context` 应该允许并发运行的线程数量。例如，在一台八核机器上，你可以按如下方式构造一个 `io_context`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You’ll pass the same `io_context` object into the constructors of your I/O objects.
    Once you’ve set up all your I/O objects, you’ll call the `run` method on the `io_context`,
    which will block until all pending I/O operations complete.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把相同的 `io_context` 对象传递给你的 I/O 对象的构造函数。一旦你设置好所有 I/O 对象，你将调用 `io_context` 上的
    `run` 方法，它会阻塞直到所有待处理的 I/O 操作完成。
- en: 'One of the simplest I/O objects is the `boost::asio::steady_timer`, which you
    can use to schedule tasks. Its constructor accepts an `io_context` object and
    an optional `std::chrono::time_point` or `std::chrono_duration`. For example,
    the following constructs a `steady_timer` that expires in three seconds:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的 I/O 对象之一是 `boost::asio::steady_timer`，你可以用它来安排任务。它的构造函数接受一个 `io_context`
    对象和一个可选的 `std::chrono::time_point` 或 `std::chrono_duration`。例如，下面的代码构造了一个三秒钟后过期的
    `steady_timer`：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can wait on the timer with a blocking or a non-blocking call. To block the
    current thread, you use the timer’s `wait` method. The result is essentially similar
    to using `std::this_thread::sleep_for`, which you learned about in “Chrono” on
    [page 387](ch12.xhtml#page_387). To wait asynchronously, you use the timer’s `async_wait`
    method. This accepts a function object referred to as a *callback*. The operating
    system will invoke the function object once it’s time for the thread to wake up.
    Due to complications arising from modern operating systems, this might or might
    not be due to the timer’s expiring.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用阻塞或非阻塞调用等待定时器。要阻塞当前线程，您使用定时器的`wait`方法。其结果与使用“Chrono”中学到的`std::this_thread::sleep_for`基本相似，您可以在[第387页](ch12.xhtml#page_387)找到相关内容。要进行异步等待，您使用定时器的`async_wait`方法。这接受一个称为*回调*的函数对象。操作系统将在线程唤醒时调用该函数对象。由于现代操作系统带来的复杂性，这可能是由于定时器到期或其他原因。
- en: Once a timer expires, you can create another timer if you want to perform an
    additional wait. If you wait on an expired timer, it will return immediately.
    This is probably not what you intend to do, so make sure you wait only on unexpired
    timers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定时器到期，您可以创建另一个定时器，如果您想进行额外的等待。如果您等待一个已经到期的定时器，它将立即返回。这可能不是您打算做的事情，所以确保只在未到期的定时器上等待。
- en: To check whether the timer has expired, the function object must accept a `boost::system::error_code`.
    The `error_code` class is a simple class that represents operating system–specific
    errors. It converts implicitly to `bool` (`true` if it represents an error condition;
    `false` otherwise). If the callback’s `error_code` evaluates to `false`, the timer
    expired.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查定时器是否已经到期，函数对象必须接受一个`boost::system::error_code`。`error_code`类是一个表示操作系统特定错误的简单类。它隐式转换为`bool`（如果表示错误条件则为`true`；否则为`false`）。如果回调的`error_code`评估为`false`，则定时器已经到期。
- en: Once you enqueue an asynchronous operation using `async_wait`, you’ll call the
    `run` method on your `io_context` object because this method blocks until all
    asynchronous operations are complete.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用`async_wait`排队了一个异步操作，您将在您的`io_context`对象上调用`run`方法，因为此方法会阻塞，直到所有异步操作完成。
- en: '[Listing 20-1](ch20.xhtml#ch20ex01) illustrates how to construct and use timers
    for blocking and non-blocking waits.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 20-1](ch20.xhtml#ch20ex01)演示了如何构建和使用用于阻塞和非阻塞等待的定时器。'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 20-1: A program using `boost::asio::steady_timer` for synchronous
    and asynchronous waiting*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 20-1：使用`boost::asio::steady_timer`进行同步和异步等待的程序*'
- en: You define the `make_timer` function for building a `steady_timer` that expires
    in three seconds ➊. Within `main`, you initialize your program’s `io_context`
    ➋ and construct your first timer from `make_timer` ➌. When you call `wait` on
    this timer ➍, the thread blocks for three seconds before proceeding. Next, you
    construct another timer with `make_timer` ➎, and then you invoke `async_wait`
    with a lambda that prints `<<callback_function>>` when the timer expires ➏. Finally,
    you invoke `run` on your `io_context` to begin processing operations ➐.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您定义`make_timer`函数来构建在三秒后到期的`steady_timer`。在`main`中，您初始化程序的`io_context`，并从`make_timer`构造第一个定时器。当您在此定时器上调用`wait`时，线程将在三秒后继续。接下来，您使用`make_timer`构造另一个定时器，然后使用在定时器到期时打印`<<callback_function>>`的lambda调用`async_wait`。最后，您在您的`io_context`上调用`run`以开始处理操作。
- en: '**Network Programming with Asio**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Asio进行网络编程**'
- en: Boost Asio contains facilities for performing network-based I/O over several
    important network protocols. Now that you know the basic usage of `io_context`
    and how to enqueue asynchronous I/O operations, you can explore how to perform
    more involved kinds of I/O. In this section, you’ll extend what you learned about
    waiting for timers and employ Boost Asio’s network I/O facilities. By the end
    of this chapter, you’ll know how to build programs that communicate over a network.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Asio包含用于在几个重要网络协议上执行基于网络的I/O的设施。现在您已经了解了`io_context`的基本用法以及如何排队异步I/O操作，您可以探索如何执行更复杂的I/O操作。在本节中，您将扩展对等待定时器的了解，并使用Boost
    Asio的网络I/O设施。通过本章结束时，您将知道如何构建可以在网络上通信的程序。
- en: '***The Internet Protocol Suite***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***互联网协议套件***'
- en: 'The Internet Protocol (IP) is the primary protocol for ferrying data across
    networks. Each participant in an IP network is called a *host*, and each host
    gets an IP address to identify it. IP addresses come in two versions: IPv4 and
    IPv6\. An IPv4 address is 32 bits, and an IPv6 address is 128 bits.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网协议（IP）**是跨网络传输数据的主要协议。每个参与者在IP网络中被称为*主机*，每个主机都会获得一个IP地址用于标识自己。IP地址有两种版本：IPv4和IPv6。IPv4地址是32位，IPv6地址是128位。'
- en: The Internet Control Message Protocol (ICMP) is used by network devices to send
    information that supports operation of an IP network. The ping and traceroute
    programs use ICMP messages to query a network. Typically, end user applications
    don’t need to interface with ICMP directly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网控制消息协议（ICMP）**被网络设备用于发送支持IP网络运行的信息。ping和traceroute程序使用ICMP消息来查询网络。通常，最终用户应用程序不需要直接与ICMP交互。'
- en: To send data across an IP network, you typically use either the Transmission
    Control Protocol (TCP) or User Datagram Protocol (UDP). In general, you use TCP
    when you need to be sure that data arrives at its destination, and you use UDP
    when you need to be sure that data transits quickly. TCP is a connection-oriented
    protocol where receivers acknowledge that they’ve received messages intended for
    them. UDP is a simple, connectionless protocol that has no built-in reliability.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要在IP网络中发送数据，通常使用传输控制协议（TCP）或用户数据报协议（UDP）。一般来说，当你需要确保数据到达目的地时，使用TCP；当你需要确保数据快速传输时，使用UDP。TCP是一个面向连接的协议，接收方会确认它已收到目标消息。UDP是一个简单的无连接协议，没有内建的可靠性。
- en: '**NOTE**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might be wondering what connection means in the TCP/UDP context or thinking
    that a “connectionless” protocol seems absurd. Here a connection means establishing
    a channel between two participants in a network that guarantees delivery and order
    of messages. Those participants perform a handshake to establish a connection,
    and they have a mechanism for informing each other that they want to close the
    connection. In a connectionless protocol, a participant sends a packet to another
    participant without establishing a channel first.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会想知道在TCP/UDP的上下文中，“连接”是什么意思，或者觉得“无连接”协议似乎很荒谬。这里的连接指的是在网络中的两个参与者之间建立一个通道，以保证消息的传输和顺序。这些参与者通过握手建立连接，并且有一种机制相互通知，表示它们想要关闭连接。而在无连接协议中，参与者直接向另一个参与者发送数据包，而不先建立通道。*'
- en: With TCP and UDP, network devices connect to each other using *ports*. A port
    is an integer ranging from 0 to 65,535 (2 bytes) that specifies a particular service
    running on a given network device. This way, a single device can run multiple
    services and each can be addressed separately. When one device, called a *client**,*
    initiates communication with another device, called a *server*, the client specifies
    which port it wants to connect to. When you pair a device’s IP address with a
    port number, the result is called a *socket*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TCP和UDP时，网络设备通过*端口*彼此连接。端口是一个范围从0到65,535（2字节）的整数，指定在特定网络设备上运行的某个服务。通过这种方式，一台设备可以运行多个服务，每个服务可以单独寻址。当一台设备（称为*客户端*）与另一台设备（称为*服务器*）建立通信时，客户端指定它想连接的端口。当你将设备的IP地址与端口号配对时，结果就叫做*套接字*。
- en: For example, a device with IP address 10.10.10.100 could serve a web page by
    binding a web server application to port 80\. This creates a server socket at
    10.10.10.100:80\. Next, a device with IP address 10.10.10.200 launches a web browser,
    which opens a “random high port,” such as 55123\. This creates a client socket
    at 10.10.10.200:55123\. The client then connects to the server by creating a TCP
    connection between the client socket and the server socket. Many other processes
    could be running on either or both devices with many other network connections
    simultaneously.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个IP地址为10.10.10.100的设备可以通过将一个Web服务器应用程序绑定到端口80来提供网页。这会在10.10.10.100:80上创建一个服务器套接字。接着，一个IP地址为10.10.10.200的设备启动一个Web浏览器，打开一个“随机高端口”，例如55123。这会在10.10.10.200:55123上创建一个客户端套接字。然后，客户端通过在客户端套接字和服务器套接字之间创建TCP连接来连接到服务器。同时，其他许多进程可能在任何一台或两台设备上运行，并且有许多其他网络连接同时存在。
- en: The Internet Assigned Numbers Authority (IANA) maintains a list of assigned
    numbers to standardize the ports that certain kinds of services use (the list
    is available at *[https://www.iana.org/](https://www.iana.org/)*). [Table 20-1](ch20.xhtml#ch20tab01)
    provides a few commonly used protocols on this list.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网分配号码管理局（IANA）维护着一个分配号码的列表，用于标准化某些类型的服务所使用的端口（该列表可以在 *[https://www.iana.org/](https://www.iana.org/)*
    上找到）。[表 20-1](ch20.xhtml#ch20tab01) 提供了这个列表中的一些常用协议。
- en: '**Table 20-1:** Well-Known Protocols Assigned by IANA'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 20-1：** IANA 分配的知名协议'
- en: '| **Port** | **TCP** | **UDP** | **Keyword** | **Description** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **端口** | **TCP** | **UDP** | **关键词** | **描述** |'
- en: '| 7 | ✓ | ✓ | echo | Echo Protocol |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 7 | ✓ | ✓ | echo | 回显协议 |'
- en: '| 13 | ✓ | ✓ | daytime | Daytime Protocol |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 13 | ✓ | ✓ | daytime | 日间协议 |'
- en: '| 21 | ✓ |  | ftp | File Transfer Protocol |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 21 | ✓ |  | ftp | 文件传输协议 |'
- en: '| 22 | ✓ |  | ssh | Secure Shell Protocol |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 22 | ✓ |  | ssh | 安全外壳协议 |'
- en: '| 23 | ✓ |  | telnet | Telnet Protocol |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 23 | ✓ |  | telnet | Telnet 协议 |'
- en: '| 25 | ✓ |  | smtp | Simple Mail Transfer Protocol |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 25 | ✓ |  | smtp | 简单邮件传输协议 |'
- en: '| 53 | ✓ | ✓ | domain | Domain Name System |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 53 | ✓ | ✓ | domain | 域名系统 |'
- en: '| 80 | ✓ |  | http | Hypertext Transfer Protocol |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 80 | ✓ |  | http | 超文本传输协议 |'
- en: '| 110 | ✓ |  | pop3 | Post Office Protocol |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 110 | ✓ |  | pop3 | 邮局协议 |'
- en: '| 123 |  | ✓ | ntp | Network Time Protocol |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 123 |  | ✓ | ntp | 网络时间协议 |'
- en: '| 143 | ✓ |  | imap | Internet Message Access Protocol |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 143 | ✓ |  | imap | 互联网邮件访问协议 |'
- en: '| 179 | ✓ |  | bgp | Border Gateway Protocol |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 179 | ✓ |  | bgp | 边界网关协议 |'
- en: '| 194 | ✓ |  | irc | Internet Relay Chat |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 194 | ✓ |  | irc | 互联网中继聊天 |'
- en: '| 443 | ✓ |  | https | Hypertext Transfer Protocol (Secure) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 443 | ✓ |  | https | 超文本传输协议（安全） |'
- en: Boost Asio supports network I/O over ICMP, TCP, and UDP. For brevity, this chapter
    only discusses TCP because the Asio classes involved in all three protocols are
    so similar.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Asio 支持通过 ICMP、TCP 和 UDP 进行网络 I/O。为了简洁起见，本章仅讨论 TCP，因为这三种协议中所涉及的 Asio 类非常相似。
- en: '**NOTE**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re unfamiliar with network protocols, *The TCP/IP Guide* by Charles
    M. Kozierok is a definitive reference.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你不熟悉网络协议，*Charles M. Kozierok 的《TCP/IP指南》是一本权威的参考书。*'
- en: '***Hostname Resolution***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***主机名解析***'
- en: 'When a client wants to connect to a server, it needs the server’s IP address.
    In some scenarios, the client might already have this information. In others,
    the client might have only a service name. The process of converting a service
    name to an IP address is called *hostname resolution*. Boost Asio contains the
    `boost::asio::ip::tcp::resolver` class to perform hostname resolution. To construct
    a resolver, you pass an `io_context` instance as the only constructor parameter,
    as in the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要连接到服务器时，它需要服务器的 IP 地址。在某些情况下，客户端可能已经有了这个信息。而在其他情况下，客户端可能只有一个服务名称。将服务名称转换为
    IP 地址的过程称为 *主机名解析*。Boost Asio 包含 `boost::asio::ip::tcp::resolver` 类来执行主机名解析。要构造解析器，你只需要传递一个
    `io_context` 实例作为唯一的构造参数，示例如下：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To perform hostname resolution, you use the `resolve` method, which accepts
    at least two `string_view` arguments: the hostname and the service. You can provide
    either a keyword or a port number for service (refer to [Table 20-1](ch20.xhtml#ch20tab01)
    for some example keywords). The `resolve` method returns a range of `boost::asio::ip::tcp::resolver::basic_resolver_entry`
    objects, which expose several useful methods:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行主机名解析，你可以使用 `resolve` 方法，该方法接受至少两个 `string_view` 类型的参数：主机名和服务。你可以为服务提供一个关键字或端口号（有关一些示例关键字，请参阅
    [表 20-1](ch20.xhtml#ch20tab01)）。`resolve` 方法返回一组 `boost::asio::ip::tcp::resolver::basic_resolver_entry`
    对象，这些对象提供了几个有用的方法：
- en: '`endpoint` gets the IP address and port.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoint` 获取 IP 地址和端口。'
- en: '`host_name` gets the hostname.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host_name` 获取主机名。'
- en: '`service_name` gets the name of the service associated with this port.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service_name` 获取与该端口关联的服务名称。'
- en: If the resolution fails, `resolve` throws a `boost::system::system_error`. Alternatively,
    you can pass a `boost::system::error_code` reference, which receives the error
    in lieu of throwing an exception. For example, [Listing 20-2](ch20.xhtml#ch20ex02)
    determines the IP address and port for the No Starch Press web server using Boost
    Asio.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析失败，`resolve` 会抛出一个 `boost::system::system_error`。或者，你可以传递一个 `boost::system::error_code`
    引用，代替抛出异常，将错误信息传递给它。例如，[示例 20-2](ch20.xhtml#ch20ex02) 使用 Boost Asio 确定 No Starch
    Press 网站服务器的 IP 地址和端口。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 20-2: Blocking hostname resolution with Boost Asio*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 20-2：使用 Boost Asio 阻塞主机名解析*'
- en: '**NOTE**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Your results might vary depending on where the No Starch Press web servers
    reside in IP space.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*你的结果可能会根据 No Starch Press 网站服务器在 IP 地址空间中的位置而有所不同。*'
- en: You initialize an `io_context` ➊ and a `boost::asio::ip::tcp::resolver` ➋. Within
    a range-based `for` loop, you iterate over each `result` ➌ and extract the `service_name`
    ➍, the `host_name` ➎, and the `endpoint` ➏. If `resolve` encounters an error,
    you print it to stdout ➐.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你初始化一个`io_context` ➊和一个`boost::asio::ip::tcp::resolver` ➋。在基于范围的`for`循环内，你迭代每个`result`
    ➌并提取`service_name` ➍、`host_name` ➎和`endpoint` ➏。如果`resolve`遇到错误，你将其打印到标准输出 ➐。
- en: 'You can perform asynchronous hostname resolution using the `async_resolve`
    method. As with `resolve`, you pass a hostname and a service as the first two
    arguments. Additionally, you provide a callback function object that accepts two
    arguments: a `system_error_code` and a range of `basic_resolver_entry` objects.
    [Listing 20-3](ch20.xhtml#ch20ex03) illustrates how to refactor [Listing 20-2](ch20.xhtml#ch20ex02)
    to use asynchronous hostname resolution instead.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`async_resolve`方法执行异步主机名解析。与`resolve`一样，你将主机名和服务作为前两个参数传递。此外，你提供一个回调函数对象，接受两个参数：`system_error_code`和一个`basic_resolver_entry`对象的范围。[清单20-3](ch20.xhtml#ch20ex03)展示了如何将[清单20-2](ch20.xhtml#ch20ex02)重构为使用异步主机名解析。
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 20-3: Refactoring [Listing 20-2](ch20.xhtml#ch20ex02) to use `async_resolve`*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单20-3：重构[清单20-2](ch20.xhtml#ch20ex02)以使用`async_resolve`*'
- en: The setup is identical to [Listing 20-2](ch20.xhtml#ch20ex02) until you invoke
    `async_resolve` on your resolver ➊. You pass the same hostname and service as
    before, but you add a callback argument that accepts the obligatory parameters
    ➋. Within the body of the callback lambda, you check for an error condition ➌.
    If one exists, you print a friendly error message and `return` ➍. In the error-free
    case, you iterate over the results as before ➎, printing the `service_name`, `host_name`,
    and `endpoint` ➏. As with the timer, you need to invoke `run` on the `io_context`
    to give the asynchronous operations the opportunity to complete ➐.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 设置与[清单20-2](ch20.xhtml#ch20ex02)相同，直到你在解析器上调用`async_resolve` ➊。你传递与之前相同的主机名和服务，但你添加了一个回调参数，该参数接受必需的参数
    ➋。在回调 lambda 的主体中，你检查是否存在错误条件 ➌。若存在错误，你打印一个友好的错误信息并`return` ➍。在没有错误的情况下，你像之前一样迭代结果
    ➎，打印`service_name`、`host_name`和`endpoint` ➏。与定时器一样，你需要在`io_context`上调用`run`，以便让异步操作有机会完成
    ➐。
- en: '***Connecting***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连接中***'
- en: Once you’ve obtained a range of endpoints either through hostname resolution
    or through constructing one on your own, you’re ready to make a connection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过主机名解析或自行构建的方式获取到端点范围，你就准备好进行连接了。
- en: First, you’ll need a `boost::asio::ip::tcp::socket`, a class that abstracts
    the underlying operating system’s socket and presents it for use in Asio. The
    socket takes an `io_context` as an argument.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个`boost::asio::ip::tcp::socket`，它是一个抽象操作系统底层套接字的类，用于在Asio中使用。套接字接受一个`io_context`作为参数。
- en: Second, you’ll need to make a call to the `boost::asio::connect` function, which
    accepts a `socket` representing the endpoint you want to connect with as its first
    argument and an `endpoint` range as its second argument. You can provide an `error_code`
    reference as an optional third argument; otherwise, `connect` will throw a `system_error`
    exception if an error occurs. If successful, `connect` returns a single `endpoint`,
    the `endpoint` in the input range to which it successfully connected. After this
    point, the `socket` object represents a real socket in your system’s environment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，你需要调用`boost::asio::connect`函数，该函数接受一个表示你想连接的端点的`socket`作为第一个参数，接受一个`endpoint`范围作为第二个参数。你可以提供一个`error_code`引用作为可选的第三个参数；否则，`connect`会在出现错误时抛出`system_error`异常。如果成功，`connect`会返回一个单一的`endpoint`，即成功连接的输入范围中的`endpoint`。此时，`socket`对象表示系统环境中的一个真实套接字。
- en: '[Listing 20-4](ch20.xhtml#ch20ex04) illustrates how to connect to No Starch
    Press’s web server.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单20-4](ch20.xhtml#ch20ex04)展示了如何连接到No Starch Press的网络服务器。'
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 20-4: Connecting to the No Starch web server*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单20-4：连接到No Starch网站服务器*'
- en: You construct a `resolver` ➊ as in [Listing 20-3](ch20.xhtml#ch20ex03). In addition,
    you initialize a `socket` with the same `io_context` ➋. Next, you invoke the `resolve`
    method to obtain every `endpoint` associated with *[www.nostarch.com](http://www.nostarch.com)*
    at port 80 ➌. Recall that each `endpoint` is an IP address and a port corresponding
    to the host you resolved. In this case, `resolve` used the domain name system
    to determine that *[www.nostarch.com](http://www.nostarch.com)* at port 80 resides
    at the IP address 104.20.209.3\. You then invoke `connect` using your socket and
    endpoints ➍, which returns the endpoint to which `connect` successfully connected
    ➎. In the event of an error, `resolve` or `connect` would throw an exception,
    which you would catch and print to stderr ➏.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建一个`resolver` ➊，如同在[Listing 20-3](ch20.xhtml#ch20ex03)中所示。此外，你使用相同的`io_context`初始化一个`socket`
    ➋。接下来，你调用`resolve`方法以获取与*【www.nostarch.com】(http://www.nostarch.com)*在端口80上关联的每个`endpoint`
    ➌。回想一下，每个`endpoint`都是一个IP地址和与所解析的主机对应的端口。在这种情况下，`resolve`使用域名系统确定*【www.nostarch.com】(http://www.nostarch.com)*在端口80上的IP地址是104.20.209.3。然后，你使用`socket`和`endpoint`调用`connect`
    ➍，它返回`connect`成功连接的`endpoint` ➎。如果发生错误，`resolve`或`connect`将抛出异常，你将捕获该异常并将其打印到stderr
    ➏。
- en: 'You can also connect asynchronously with `boost::asio::async_connect`, which
    accepts the same two arguments as `connect`: a `socket` and an `endpoint` range.
    The third argument is a function object acting as the callback, which must accept
    an `error_code` as its first argument and an `endpoint` as its second argument.
    [Listing 20-5](ch20.xhtml#ch20ex05) illustrates how to connect asynchronously.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`boost::asio::async_connect`进行异步连接，它接受与`connect`相同的两个参数：一个`socket`和一个`endpoint`范围。第三个参数是一个函数对象，充当回调，它必须接受一个`error_code`作为第一个参数，`endpoint`作为第二个参数。[Listing
    20-5](ch20.xhtml#ch20ex05)展示了如何进行异步连接。
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 20-5: Connecting to the No Starch web server asynchronously*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 20-5: 异步连接到No Starch web服务器*'
- en: The setup is exactly as in [Listing 20-4](ch20.xhtml#ch20ex04) except you replace
    `connect` with `async_connect` and pass the same first ➊ and second ➋ arguments.
    The third argument is your callback function object ➌ inside of which you print
    the endpoint to stdout ➍. As with all asynchronous Asio programs, you make a call
    to `run` on your `io_context` ➎.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 配置与[Listing 20-4](ch20.xhtml#ch20ex04)中的完全相同，只不过你将`connect`替换为`async_connect`，并传入相同的第一个➊和第二个➋参数。第三个参数是你的回调函数对象➌，在其中你将`endpoint`打印到stdout
    ➍。像所有异步Asio程序一样，你需要对`io_context`调用`run` ➎。
- en: '***Buffers***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓冲区***'
- en: 'Boost Asio provides several buffer classes. A *buffer* (or *data buffer*) is
    memory that stores transient data. The Boost Asio buffer classes form the interface
    for all I/O operations. Before you can do anything with the network connections
    you make, you’ll need an interface for reading and writing data. For this, you’ll
    need just three buffer types:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Asio提供了几个缓冲区类。*缓冲区*（或*数据缓冲区*）是存储临时数据的内存。Boost Asio缓冲区类形成了所有I/O操作的接口。在你进行任何网络连接操作之前，你需要一个用于读取和写入数据的接口。为此，你只需要三种缓冲区类型：
- en: '`boost::asio::const_buffer` holds a buffer that cannot be modified once you’ve
    constructed it.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::const_buffer`持有一个缓冲区，一旦构造完成，就无法修改。'
- en: '`boost::asio::mutable_buffer` holds a buffer that can be modified after construction.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::mutable_buffer`持有一个可以在构造后修改的缓冲区。'
- en: '`boost::asio::streambuf` holds an automatically resizable buffer based on `std::streambuf.`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::streambuf`持有一个基于`std::streambuf`的自动可调整大小的缓冲区。'
- en: 'All three buffer classes provide two important methods for accessing their
    underlying data: `data` and `size`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个缓冲区类提供了两个重要方法来访问其底层数据：`data`和`size`。
- en: The `mutable_buffer` and `const_buffer` classes’ `data` methods return a pointer
    to the first element in the underlying data sequence, and their `size` methods
    return the number of elements in that sequence. The elements are contiguous. Both
    buffers provide default constructors, which initialize an empty buffer, as [Listing
    20-6](ch20.xhtml#ch20ex06) illustrates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutable_buffer`和`const_buffer`类的`data`方法返回指向底层数据序列中第一个元素的指针，而它们的`size`方法返回该序列中元素的数量。这些元素是连续的。两个缓冲区都提供默认构造函数，初始化为空缓冲区，正如[Listing
    20-6](ch20.xhtml#ch20ex06)所示。'
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 20-6: Default constructing `const_buffer` and `mutable_buffer` yields
    empty buffers.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 20-6: 默认构造`const_buffer`和`mutable_buffer`生成空缓冲区。*'
- en: Using the default constructors ➊➌, you build empty buffers that have zero `size`
    ➋➍.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认构造函数➊➌，你构建了空的缓冲区，其`size`为零➋➍。
- en: Both `mutable_buffer` and `const_buffer` provide constructors that accept a
    `void*` and a `size_t` corresponding to the data you want to wrap. Note that these
    constructors don’t take ownership of the pointed-to memory, so *you must ensure
    that the storage duration of that memory is at least as long as the lifetime of
    the buffer you’re constructing*. This is a design decision that gives you, as
    the Boost Asio user, maximum flexibility. Unfortunately, it also leads to potentially
    nasty errors. Failure to properly manage the lifetimes of buffers and the objects
    they point to will result in undefined behavior.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutable_buffer` 和 `const_buffer` 都提供接受 `void*` 和 `size_t` 的构造函数，这些构造函数对应于你要封装的数据。请注意，这些构造函数并不拥有指向的内存，因此*你必须确保该内存的存储周期至少与所构造的缓冲区的生命周期一样长*。这是一个设计决策，给你作为
    Boost Asio 用户提供最大灵活性。不幸的是，它也可能导致一些棘手的错误。未能正确管理缓冲区及其指向的对象的生命周期将导致未定义行为。'
- en: '[Listing 20-7](ch20.xhtml#ch20ex07) illustrates how to construct buffers using
    the pointer-based constructor.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 20-7](ch20.xhtml#ch20ex07) 演示了如何使用基于指针的构造函数构造缓冲区。'
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 20-7: Constructing a `const_buffer` and a `mutable_buffer` using the
    pointer-based constructor*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 20-7：使用基于指针的构造函数构造 `const_buffer` 和 `mutable_buffer`*'
- en: In the first test, you construct a `const_buffer` using a C-style string and
    a fixed length of `7` ➊. This fixed length is smaller than the length of the string
    literal `Blessed are the cheesemakers.`, so this buffer refers to `Blessed` rather
    than the entire string. This illustrates that you can select a subset of an array
    (just as with `std::string_view`, which you learned about in “String View” on
    [page 500](ch15.xhtml#page_500)). The resulting buffer has `size 7` ➋, and if
    you cast the pointer from `data` to a `const char*`, you’ll see that it points
    to the character `B` from your C-style string ➌.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次测试中，你使用 C 风格字符串和固定长度 `7` ➊ 来构造一个 `const_buffer`。这个固定长度小于字符串字面量 `Blessed
    are the cheesemakers.` 的长度，因此这个缓冲区仅引用 `Blessed` 而不是整个字符串。这说明你可以选择数组的一个子集（就像你在“字符串视图”一节中学习的
    `std::string_view`，[在第500页](ch15.xhtml#page_500)）。得到的缓冲区大小为 `7` ➋，如果你将 `data`
    指针转换为 `const char*`，你会发现它指向你的 C 风格字符串中的字符 `B` ➌。
- en: In the second test, you construct a `mutable_buffer` using a `string` by invoking
    its `data` and `size` members within the buffer’s constructor ➍. The resulting
    buffer’s `data` ➎ and `size` ➏ methods return identical data to your original
    `string`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次测试中，你通过在缓冲区的构造函数中调用 `string` 的 `data` 和 `size` 成员来构造一个 `mutable_buffer`
    ➍。得到的缓冲区的 `data` ➎ 和 `size` ➏ 方法返回与原始 `string` 相同的数据。
- en: 'The `boost::asio::streambuf` class accepts two optional constructor arguments:
    a `size_t` maximum size and an allocator. By default, the maximum size is `std::numeric_limits<std::size_t>`
    and the allocator is similar to the default allocator for stdlib containers. The
    `streambuf` input sequence’s initial size is always zero, which [Listing 20-8](ch20.xhtml#ch20ex08)
    illustrates.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::asio::streambuf` 类接受两个可选的构造函数参数：一个 `size_t` 类型的最大大小和一个分配器。默认情况下，最大大小为
    `std::numeric_limits<std::size_t>`，而分配器类似于标准库容器的默认分配器。`streambuf` 输入序列的初始大小始终为零，[如列表
    20-8](ch20.xhtml#ch20ex08) 所示。'
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 20-8: Default constructing a `streambuf`*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 20-8：默认构造 `streambuf`*'
- en: You default construct a `streambuf` ➊, and when you invoke its `size` method,
    it returns `0` ➋.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你默认构造了一个 `streambuf` ➊，当你调用它的 `size` 方法时，它返回 `0` ➋。
- en: You can pass a pointer to a `streambuf` into a `std::istream` or `std::ostream`
    constructor. Recall from “Stream Classes” on [page 524](ch16.xhtml#page_524) that
    these are specializations of `basic_istream` and `basic_ostream` that expose stream
    operations to an underlying sync or source. [Listing 20-9](ch20.xhtml#ch20ex09)
    illustrates how to write into and subsequently read from a `streambuf` using these
    classes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `streambuf` 的指针传递给 `std::istream` 或 `std::ostream` 的构造函数。回想一下在“流类”一节中，[第524页](ch16.xhtml#page_524)
    提到过，这些是 `basic_istream` 和 `basic_ostream` 的特化版本，用于向底层同步或源暴露流操作。[列表 20-9](ch20.xhtml#ch20ex09)
    演示了如何使用这些类向 `streambuf` 写入数据并随后读取数据。
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 20-9: Writing to and reading from a `streambuf`*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 20-9：向 `streambuf` 写入数据并读取数据*'
- en: You again construct an empty `streambuf` ➊, and you pass its address into the
    constructor of an `ostream` ➋. You then write the string `Welease Wodger!` into
    the `ostream`, which in turn writes the string into the underlying `streambuf`
    ➌.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你再次构造一个空的 `streambuf` ➊，并将其地址传递给 `ostream` 的构造函数 ➋。然后，你将字符串 `Welease Wodger!`
    写入 `ostream`，这会将字符串写入底层的 `streambuf` ➌。
- en: Next, you create an `istream` again using the address of the `streambuf` ➍.
    You then create a `string` ➎ and write the `istream` into the `string` ➏. Recall
    from “Special Formatting for Fundamental Types” on [page 529](ch16.xhtml#page_529)
    that this operation will skip any leading whitespace and then read the following
    string until the next whitespace. This yields the first word of the string, `Welease`
    ➐.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你再次使用 `streambuf` 的地址来创建一个 `istream` ➍。然后，你创建一个 `string` ➎ 并将 `istream`
    写入该 `string` ➏。回想一下在 [第 529 页](ch16.xhtml#page_529) 中的“基本类型的特殊格式化”部分，该操作将跳过任何前导空格，然后读取接下来的字符串直到下一个空格。这会得到字符串的第一个单词
    `Welease` ➐。
- en: 'Boost Asio also offers the convenience function template `boost::asio::buffer`,
    which accepts a `std::array` or `std::vector` of POD elements or a `std::string`.
    For example, you can create the `std::string` backed `mutable_buffer` in [Listing
    20-7](ch20.xhtml#ch20ex07) using the following construction instead:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Asio 还提供了方便的函数模板 `boost::asio::buffer`，该模板接受一个 `std::array` 或 `std::vector`
    的 POD 元素，或者一个 `std::string`。例如，你可以使用以下构造方法来创建一个由 `std::string` 支持的 `mutable_buffer`，如
    [Listing 20-7](ch20.xhtml#ch20ex07) 中所示：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `buffer` template is specialized so if you provide a `const` argument,
    it will return a `const_buffer` instead. In other words, to make a `const_buffer`
    out of `proposition`, simply make it `const`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer` 模板是特化过的，因此如果你提供一个 `const` 参数，它将返回一个 `const_buffer`。换句话说，要将 `proposition`
    转换为 `const_buffer`，只需将其设置为 `const` 即可：'
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You’ve now created a `const_buffer cb`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经创建了一个 `const_buffer cb`。
- en: 'Additionally, you can create a dynamic buffer, which is a dynamically resizable
    buffer backed by a `std::string` or a `std::vector`. You can create one by using
    the `boost::asio::dynamic_buffer` function template, which accepts either a `string`
    or a `vector` and returns a `boost::asio::dynamic_string_buffer` or `boost::asio::dynamic_vector_buffer`
    as appropriate. For example, you can make a dynamic buffer using the following
    construction:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以创建一个动态缓冲区，这是一个由 `std::string` 或 `std::vector` 支持的动态可调整大小的缓冲区。你可以使用 `boost::asio::dynamic_buffer`
    函数模板来创建该缓冲区，传入 `string` 或 `vector`，并根据情况返回 `boost::asio::dynamic_string_buffer`
    或 `boost::asio::dynamic_vector_buffer`。例如，你可以使用以下构造方法创建一个动态缓冲区：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Although a dynamic buffer is dynamically resizable, recall that the `vector`
    and `string` classes use an allocator and that allocation can be a relatively
    slow operation. So, if you know how much data you’ll write into a buffer, you
    might have better performance using a non-dynamic buffer. As always, measuring
    and experimenting will help you decide which approach to take.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管动态缓冲区是动态可调整大小的，但请记住，`vector` 和 `string` 类使用分配器，而分配操作可能相对较慢。因此，如果你知道要写入缓冲区的数据量，使用非动态缓冲区可能会带来更好的性能。像往常一样，测量和实验将帮助你决定采取哪种方法。
- en: '***Reading and Writing Data with Buffers***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用缓冲区读取和写入数据***'
- en: 'With your new knowledge of how to store and retrieve data using buffers, you
    can learn how to pull data off a socket. You can read data from active `socket`
    objects into buffer objects using built-in Boost Asio functions. For blocking
    reads, Boost Asio offers three functions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握如何使用缓冲区存储和检索数据的知识，你可以学习如何从套接字中提取数据。你可以使用内置的 Boost Asio 函数将数据从活动的 `socket`
    对象读取到缓冲区对象中。对于阻塞读取，Boost Asio 提供了三种函数：
- en: '`boost::asio::read` attempts to read a fixed-size data chunk.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::read` 尝试读取固定大小的数据块。'
- en: '`boost::asio::read_at` attempts to read a fixed-size data chunk beginning at
    an offset.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::read_at` 尝试从一个偏移位置开始读取固定大小的数据块。'
- en: '`boost::asio::read_until` attempts to read until a delimiter, regular expression,
    or arbitrary predicate matches.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::read_until` 尝试读取直到分隔符、正则表达式或任意谓词匹配为止。'
- en: 'All three methods take a `socket` as their first argument and a buffer object
    as their second argument. The remaining arguments are optional and depend on which
    function you’re using:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法都将 `socket` 作为第一个参数，将缓冲区对象作为第二个参数。其余参数是可选的，具体取决于你使用的是哪种函数：
- en: A *completion condition* is a function object that accepts an `error_code` and
    a `size_t` argument. The `error_code` will be set if the Asio function encountered
    an error, and the `size_t` argument corresponds with the number of bytes transferred
    so far. The function object returns a `size_t` corresponding to the number of
    bytes remaining to be transferred, and it returns 0 if the operation is complete.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完成条件* 是一个函数对象，它接受一个 `error_code` 和一个 `size_t` 参数。如果 Asio 函数遇到错误，`error_code`
    将被设置，而 `size_t` 参数表示迄今为止已传输的字节数。该函数对象返回一个 `size_t`，对应剩余要传输的字节数，如果操作已完成，则返回 0。'
- en: A *match condition* is a function object that accepts a range specified by a
    begin and end iterator. It must return a `std::pair`, where the first element
    is an iterator indicating the starting point for the next attempt at matching
    and the second element is a `bool` representing whether the range contains a match.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*匹配条件* 是一个函数对象，接受由开始和结束迭代器指定的范围。它必须返回一个`std::pair`，其中第一个元素是指示下一个匹配尝试起始点的迭代器，第二个元素是`bool`，表示该范围是否包含匹配项。'
- en: '`boost::system::error_code` reference, which the function will set if it encounters
    an error condition.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::system::error_code` 引用，函数将在遇到错误条件时设置此值。'
- en: '[Table 20-2](ch20.xhtml#ch20tab02) lists many of the ways you can invoke one
    of the read functions.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 20-2](ch20.xhtml#ch20tab02)列出了调用读取函数的多种方式。'
- en: '**Table 20-2:** Arguments for `read`, `read_at`, and `read_until`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 20-2：** `read`、`read_at` 和 `read_until` 的参数'
- en: '| **Invocation** | **Description** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **调用** | **描述** |'
- en: '| `read(`s, b, `[`cmp`], [`ec`])` | Reads a certain amount of data from `socket`
    s into a mutable buffer b according to completion condition cmp. Sets the `error_code`
    ec if an error condition is encountered; otherwise, throws a `system_error`. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `read(`s, b, `[`cmp`], [`ec`])` | 从`socket` s读取一定数量的数据到可变缓冲区b，依据完成条件cmp。如果遇到错误条件，则设置`error_code`
    ec；否则，抛出`system_error`。 |'
- en: '| `read_at(`s, off, b, `[`cmp`], [`ec`])` | Reads a certain amount of data
    starting from `socket` s, starting from `size_t` offset off, into a mutable buffer
    b according to completion condition cmp. Sets the `error_code` ec if an error
    condition is encountered; otherwise, throws a `system_error`. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `read_at(`s, off, b, `[`cmp`], [`ec`])` | 从`socket` s开始，按`size_t`偏移量off，从某个位置读取一定数量的数据到可变缓冲区b，依据完成条件cmp。如果遇到错误条件，则设置`error_code`
    ec；否则，抛出`system_error`。 |'
- en: '| `read_until(`s, b, x, `[`ec`])` | Reads data from `socket` s into a mutable
    buffer b until it meets a condition represented by x, which can be one of the
    following: a `char`, a `string_view`, a `boost::regex`, or a match condition.
    Sets the `error_code` ec if an error condition is encountered; otherwise, throws
    a `system_error`. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `read_until(`s, b, x, `[`ec`])` | 从`socket` s读取数据到可变缓冲区b，直到满足由x表示的条件，x可以是以下之一：`char`、`string_view`、`boost::regex`，或匹配条件。如果遇到错误条件，则设置`error_code`
    ec；否则，抛出`system_error`。 |'
- en: 'You can also write data to an active `socket` object from a buffer. For blocking
    writes, Boost Asio offers two functions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从缓冲区向活动的`socket`对象写入数据。对于阻塞式写入，Boost Asio提供了两个函数：
- en: '`boost::asio::write` attempts to write a fixed-size data chunk.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::write` 尝试写入固定大小的数据块。'
- en: '`boost::asio::write_at` attempts to write a fixed-size data chunk beginning
    at an offset.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::write_at` 尝试从偏移量开始写入固定大小的数据块。'
- en: '[Table 20-3](ch20.xhtml#ch20tab03) shows how to invoke these two methods. Their
    arguments are analogous to those for the reading methods.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 20-3](ch20.xhtml#ch20tab03)展示了如何调用这两个方法。它们的参数与读取方法的参数类似。'
- en: '**Table 20-3:** Arguments for `write` and `write_at`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 20-3：** `write` 和 `write_at` 的参数'
- en: '| **Invocation** | **Description** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **调用** | **描述** |'
- en: '| `write(`s, b, `[`cmp`], [`ec`])` | Writes a certain amount of data into `socket`
    s from a `const` buffer b according to completion condition cmp. Sets the `error_code`
    ec if an error condition is encountered; otherwise, throws a `system_error`. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `write(`s, b, `[`cmp`], [`ec`])` | 从`const`缓冲区b，将一定数量的数据写入`socket` s，依据完成条件cmp。如果遇到错误条件，则设置`error_code`
    ec；否则，抛出`system_error`。 |'
- en: '| `write_at(`s, off, b, `[`cmp`], [`ec`])` | Writes a certain amount of data
    from `const` buffer b, starting from `size_t` offset off, into `socket` `s` according
    to completion condition cmp. Sets the `error_code` ec if an error condition is
    encountered; otherwise, throws a `system_error`. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `write_at(`s, off, b, `[`cmp`], [`ec`])` | 从`const`缓冲区b，按`size_t`偏移量off开始，将一定数量的数据写入`socket`
    s，依据完成条件cmp。如果遇到错误条件，则设置`error_code` ec；否则，抛出`system_error`。 |'
- en: '**NOTE**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are *many* permutations for invoking the read and write functions. Be
    sure to read the documentation carefully when you incorporate Boost Asio into
    your code.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用读取和写入函数有*很多*种排列方式。在将Boost Asio集成到代码中时，务必仔细阅读文档。*'
- en: '***The Hypertext Transfer Protocol (HTTP)***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***超文本传输协议 (HTTP)***'
- en: HTTP is the 30-year-old protocol undergirding the web. Although it’s a very
    complicated protocol to use to introduce networking, its ubiquity makes it one
    of the most relevant choices. In the next section, you’ll use Boost Asio to make
    very simple HTTP requests. It’s not strictly necessary that you have a solid foundation
    in HTTP, so you can skip this section on first reading. However, the information
    here adds some color to the examples in the next section and provides references
    for further study.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是支撑 web 的 30 年历史的协议。尽管它是一个非常复杂的协议，涉及到网络的使用，但它的普遍性使它成为最相关的选择之一。在接下来的部分中，你将使用
    Boost Asio 发出非常简单的 HTTP 请求。并不严格要求你对 HTTP 有扎实的基础，因此你可以在首次阅读时跳过这一部分。不过，这里提供的信息为下一部分中的示例增添了一些背景，并提供了进一步学习的参考资料。
- en: 'HTTP sessions have two parties: a client and a server. An HTTP client sends
    a plaintext request over TCP containing one or more lines separated by a carriage
    return and a line feed (a “CR-LF newline”).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 会话有两个参与方：客户端和服务器。HTTP 客户端通过 TCP 发送一个纯文本请求，其中包含一行或多行，由回车符和换行符（“CR-LF 换行符”）分隔。
- en: 'The first line is the request line, which contains three tokens: an HTTP method,
    a uniform resource locator (URL), and the HTTP version of the request. For example,
    if a client wants a file called *index.htm*, the status line might be *GET /index.htm
    HTTP/1.1*.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是请求行，其中包含三个标记：HTTP 方法、统一资源定位符（URL）和请求的 HTTP 版本。例如，如果客户端想要获取名为 *index.htm*
    的文件，状态行可能是 *GET /index.htm HTTP/1.1*。
- en: 'Directly following the request line are one or more *headers*, which define
    the parameters of an HTTP transaction. Each header contains a key and a value.
    The key must be composed of alphanumeric characters and dashes. A colon plus a
    space delimits the key from the value. A CR-LF newline terminates the header.
    The following headers are especially common in requests:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请求行之后紧接着的是一个或多个 *头部*，它们定义了 HTTP 事务的参数。每个头部包含一个键和值。键必须由字母数字字符和短横线组成。键和值之间用冒号和空格分隔。CR-LF
    换行符标识头部的结束。以下头部在请求中尤为常见：
- en: '`Host` specifies the domain of the service requested. Optionally, you can include
    a port. For example, `Host: [www.google.com](http://www.google.com)` specifies
    *[www.google.com](http://www.google.com)* as the host for the requested service.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Host` 指定请求的服务的域名。你可以选择性地包括端口。例如，`Host: [www.google.com](http://www.google.com)`
    指定 *[www.google.com](http://www.google.com)* 作为请求服务的主机。'
- en: '`Accept` specifies the acceptable media types in MIME format for the response.
    For example, `Accept: text/plain` specifies that the requester can process plaintext.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accept` 指定响应中可接受的媒体类型，以 MIME 格式表示。例如，`Accept: text/plain` 指定请求者可以处理纯文本。'
- en: '`Accept-Language` specifies the acceptable human languages for the response.
    For example, `Accept-Language: en-US` specifies that the requester can process
    American English.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accept-Language` 指定响应可接受的人类语言。例如，`Accept-Language: en-US` 指定请求者可以处理美式英语。'
- en: '`Accept-Encoding` specifies the acceptable encodings for the response. For
    example, `Accept-Encoding: identity` specifies that the requester can process
    contents without any encoding.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accept-Encoding` 指定响应可接受的编码方式。例如，`Accept-Encoding: identity` 指定请求者可以处理没有任何编码的内容。'
- en: '`Connection` specifies control options for the current connection. For example,
    `Connection: close` specifies that the connection will be closed after completion
    of the response.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connection` 指定当前连接的控制选项。例如，`Connection: close` 指定响应完成后将关闭连接。'
- en: You terminate the headers with an additional CR-LF newline. For certain kinds
    of HTTP requests, you’ll also include a body following the headers. If you do,
    you’ll also include `Content-Length` and `Content-Type` headers. The `Content-Length`
    value specifies the length of the request body in bytes, and the `Content-Type`
    value specifies the MIME format of the body.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过额外的 CR-LF 换行符来终止头部。对于某些类型的 HTTP 请求，你还会在头部之后包括一个主体。如果这样做，你还需要包含 `Content-Length`
    和 `Content-Type` 头部。`Content-Length` 值指定请求主体的字节长度，而 `Content-Type` 值指定主体的 MIME
    格式。
- en: 'An HTTP response’s first line is the *status line*, which includes the HTTP
    version of the response, a status code, and a reason message. For example, the
    status line `HTTP/1.1 200 OK` indicates a successful (“OK”) request. Status codes
    are always three digits. The leading digit indicates the status group of the code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 响应的第一行是 *状态行*，其中包括响应的 HTTP 版本、状态码和原因短语。例如，状态行 `HTTP/1.1 200 OK` 表示请求成功（“OK”）。状态码始终是三位数字。首位数字表示状态码的类别：
- en: '**`1**` (Informational)** The request was received.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**`1**`（信息性）** 请求已接收。'
- en: '**`2**` (Successful)** The request was received and accepted.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**`2**`（成功）** 请求已接收并被接受。'
- en: '**`3**` (Redirection)** Further action is required.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**`3**`（重定向）** 需要进一步操作。'
- en: '**`4**` (Client Error)** The request was bad.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**`4**`（客户端错误）** 请求有误。'
- en: '**`5**` (Server Error)** The request seems okay, but the server encountered
    an internal error.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**`5**`（服务器错误）** 请求似乎没问题，但服务器遇到内部错误。'
- en: After the status line, the response contains any number of headers in the same
    format as the response. Many of the same request headers are also common response
    headers. For example, if the HTTP response contains a body, the response headers
    will include `Content-Length` and `Content-Type`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态行之后，响应包含任意数量的头部，格式与请求相同。许多相同的请求头也常见于响应头中。例如，如果 HTTP 响应包含主体，响应头将包括 `Content-Length`
    和 `Content-Type`。
- en: If you need to program HTTP applications, you should absolutely refer to the
    Boost Beast library, which provides high-performance, low-level HTTP and WebSockets
    facilities. It’s built atop Asio and works seamlessly with it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要编写 HTTP 应用程序，绝对应该参考 Boost Beast 库，它提供高性能、低级的 HTTP 和 WebSocket 功能。它建立在 Asio
    之上，并与其无缝协作。
- en: '**NOTE**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For an excellent treatment of HTTP and its tenant security issues, refer to*
    The Tangled Web: A Guide to Securing Modern Web Applications *by Michal Zalewski.
    For all the gory details, refer to the Internet Engineering Task Force’s RFCs
    7230, 7231, 7232, 7233, 7234, and 7235.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关 HTTP 及其安全性问题的优秀处理，请参考* 《The Tangled Web: A Guide to Securing Modern Web
    Applications》 *by Michal Zalewski。有关详细内容，请参考互联网工程任务组（IETF）的 RFCs 7230、7231、7232、7233、7234
    和 7235。*'
- en: '***Implementing a Simple Boost Asio HTTP Client***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现一个简单的 Boost Asio HTTP 客户端***'
- en: In this section, you’ll implement a (very) simple HTTP client. You’ll build
    an HTTP request, resolve an endpoint, connect to a web server, write the request,
    and read the response. [Listing 20-10](ch20.xhtml#ch20ex10) illustrates one possible
    implementation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将实现一个（非常）简单的 HTTP 客户端。你将构建一个 HTTP 请求，解析端点，连接到 Web 服务器，写入请求并读取响应。[Listing
    20-10](ch20.xhtml#ch20ex10) 展示了一种可能的实现方式。
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 20-10: Completing a simple request to the United States Army Cyber
    Command web server*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 20-10：完成对美国陆军网络指挥部 Web 服务器的简单请求*'
- en: You first define a `request` function, which accepts a `host` and an `io_context`
    and returns an HTTP response ➊. First, you use a `std::stringstream` to build
    a `std::string` containing an HTTP request ➋. Next, you resolve the `host` using
    a `boost::asio::ip::tcp::resolver` ➌ and connect a `boost::asio::ip::tcp::socket`
    to the resulting endpoint range ➍. (This matches the approach in [Listing 20-4](ch20.xhtml#ch20ex04).)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先定义一个 `request` 函数，它接受一个 `host` 和一个 `io_context`，并返回一个 HTTP 响应 ➊。首先，你使用 `std::stringstream`
    来构建一个包含 HTTP 请求的 `std::string` ➋。接着，你使用 `boost::asio::ip::tcp::resolver` 解析 `host`
    ➌，并将 `boost::asio::ip::tcp::socket` 连接到结果端点范围 ➍。（这与 [Listing 20-4](ch20.xhtml#ch20ex04)
    中的方法相匹配。）
- en: Then you write your HTTP request to the server you’ve connected to. You use
    `boost::asio::write`, passing in your connected `socket` and your `request`. Because
    write accepts Asio buffers, you use `boost::asio::buffer` to create a `mutable_buffer`
    from your request (which is a `std::string`) ➎.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你向你已连接的服务器发送 HTTP 请求。你使用 `boost::asio::write`，传入已连接的 `socket` 和你的 `request`。因为
    write 接受 Asio 缓冲区，你使用 `boost::asio::buffer` 从你的请求（它是一个 `std::string`）创建一个 `mutable_buffer`
    ➎。
- en: 'Next, you read the HTTP response from the server. Because you don’t know the
    length of the response in advance, you create a `std::string` called `response`
    to receive the response. Eventually, you’ll use this to back a dynamic buffer.
    For simplicity, the HTTP request contains a `Connection: close` header that causes
    the server to terminate the connection immediately after it sends its response.
    This will result in Asio returning an “end of file” error code (value 2). Because
    you expect this behavior, you declare a `boost::system::error_code` to receive
    this error.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，你从服务器读取 HTTP 响应。因为你事先不知道响应的长度，所以你创建一个名为 `response` 的 `std::string` 来接收响应。最终，你将使用它来支持一个动态缓冲区。为了简化，HTTP
    请求包含一个 `Connection: close` 头部，它会导致服务器在发送响应后立即关闭连接。这将导致 Asio 返回一个“文件结束”错误代码（值为
    2）。因为你预期这种行为，你声明一个 `boost::system::error_code` 来接收该错误。'
- en: Next, you invoke `boost::asio::read` with the connected `socket`, a dynamic
    buffer that will receive the response, and the `error_condition` ➏. You use `boost::asio_dynamic_buffer`
    to construct your dynamic buffer from `response`. Immediately after `read` returns,
    you check for an `error_condition` other than end of file (which you throw) ➐.
    Otherwise, you return the `response`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你调用`boost::asio::read`，传入已连接的`socket`、一个将接收响应的动态缓冲区以及`error_condition` ➏。你使用`boost::asio_dynamic_buffer`从`response`构造动态缓冲区。`read`返回后，立即检查是否有其他类型的`error_condition`，例如文件结束错误（此时会抛出异常）
    ➐。否则，返回`response`。
- en: Within `main`, you invoke your `request` function with the `www.arcyber.army.mil`
    host and an `io_context` object ➑. Finally, you print the response to stdout ➒.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，你调用`request`函数，传入`www.arcyber.army.mil`主机和一个`io_context`对象 ➑。最后，你将响应打印到标准输出
    ➒。
- en: '***Asynchronous Reading and Writing***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***异步读取与写入***'
- en: 'You can also read and write asynchronously with Boost Asio. The corresponding
    asynchronous functions are analogous to their blocking corollaries. For asynchronous
    reads, Boost Asio offers three functions:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用Boost Asio进行异步读写。相应的异步函数与它们的阻塞对应函数类似。对于异步读取，Boost Asio提供了三个函数：
- en: '`boost::asio::async_read` attempts to read a fixed-size data chunk.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::async_read`尝试读取固定大小的数据块。'
- en: '`boost::asio::async_read_at` attempts to read a fixed-size data chunk beginning
    at an offset.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::async_read_at`尝试从一个偏移量开始读取固定大小的数据块。'
- en: '`boost::asio::async_read_until` attempts to read until a delimiter, regular
    expression, or arbitrary predicate matches.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::async_read_until`尝试读取直到遇到分隔符、正则表达式或任意条件为止。'
- en: 'Boost Asio also offers two asynchronous write functions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Asio还提供了两个异步写入函数：
- en: '`boost::asio::async_write` attempts to write a fixed-size data chunk.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::async_write`尝试写入固定大小的数据块。'
- en: '`boost::asio::async_write_at` attempts to write a fixed-size data chunk beginning
    at an offset.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::async_write_at`尝试从一个偏移量开始写入固定大小的数据块。'
- en: 'All five of these asynchronous functions accept the same arguments as their
    blocking counterparts, except their final argument is always a callback function
    object that accepts two arguments: a `boost::system::error_code` indicating whether
    the function met an error and a `size_t` indicating the number of bytes it transferred.
    For the asynchronous `write` functions, you need to determine whether Asio wrote
    the entire payload. Because these calls are asynchronous, your thread doesn’t
    block while it’s waiting for I/O to complete. Instead, the operating system calls
    your thread back whenever a portion of your I/O request completes.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个异步函数接受与它们的阻塞函数相同的参数，唯一不同的是它们的最后一个参数总是一个回调函数对象，该对象接受两个参数：一个`boost::system::error_code`表示函数是否遇到错误，以及一个`size_t`表示传输的字节数。对于异步的`write`函数，你需要判断Asio是否写入了整个负载。因为这些调用是异步的，所以你的线程在等待I/O完成时不会被阻塞。相反，操作系统会在I/O请求的某个部分完成时回调你的线程。
- en: Because the callback’s second argument is a `size_t` corresponding to the number
    of transferred bytes, you can do the arithmetic to figure out whether you have
    anything left to write. If there is, you must invoke another asynchronous write
    function by passing the remaining data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于回调的第二个参数是一个`size_t`，表示已传输的字节数，你可以通过计算来确定是否还有数据需要写入。如果有，你必须通过传递剩余数据来调用另一个异步写入函数。
- en: '[Listing 20-11](ch20.xhtml#ch20ex11) contains an asynchronous version of the
    simple web client in [Listing 20-10](ch20.xhtml#ch20ex10). Note that using the
    asynchronous functions is a bit more complicated. But there’s a pattern with callbacks
    and handlers that’s consistent across the request’s lifetime.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20-11](ch20.xhtml#ch20ex11)包含了[示例 20-10](ch20.xhtml#ch20ex10)的一个异步版本。请注意，使用异步函数稍微复杂一些，但它有一个一致的模式，通过回调和处理程序贯穿整个请求的生命周期。'
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 20-11: An asynchronous refactor of [Listing 20-9](ch20.xhtml#ch20ex09)*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 20-11：一个[示例 20-9](ch20.xhtml#ch20ex09)的异步重构*'
- en: You first declare a `Request` class that will handle a web request. It has a
    single constructor that takes an `io_context` and a `string` containing the host
    you want to connect with ➊. Just as in [Listing 20-9](ch20.xhtml#ch20ex09), you
    create an HTTP GET request using a `std::stringstream` and save the resulting
    `string` into the `request` field ➋. Next, you use `async_resolve` to request
    the endpoints corresponding to the requested `host`. Within the callback, you
    invoke the `resolution_handler` method on the current `Request` ➌.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先你声明一个 `Request` 类来处理 Web 请求。它有一个构造函数，接受一个 `io_context` 和一个包含你要连接的主机的 `string`
    ➊。就像在 [示例 20-9](ch20.xhtml#ch20ex09) 中一样，你使用 `std::stringstream` 创建一个 HTTP GET
    请求，并将结果 `string` 保存在 `request` 字段中 ➋。接下来，你使用 `async_resolve` 请求与所请求的 `host` 对应的端点。在回调函数中，你调用当前
    `Request` 的 `resolution_handler` 方法 ➌。
- en: The `resolution_handler` receives the callback from `async_resolve`. It first
    checks for an error condition, printing to stderr and returning if it finds one
    ➍. If `async_resolve` didn’t pass an error, `resolution_handler` invokes `async_connect`
    using the endpoints contained in its `results` variable. It also passes the `socket`
    field of the current `Request`, which will store the connection that `async_connect`
    is about to create. Finally, it passes a connection callback as the third parameter.
    Within the callback, you invoke the `connection_handler` method of the current
    request ➎.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolution_handler` 接收来自 `async_resolve` 的回调。它首先检查是否有错误条件，如果发现错误，则将错误输出到 stderr
    并返回 ➍。如果 `async_resolve` 没有返回错误，`resolution_handler` 会使用 `results` 变量中包含的端点调用
    `async_connect`。它还会传入当前 `Request` 的 `socket` 字段，`async_connect` 将在其中创建连接。最后，它会将一个连接回调作为第三个参数传递。在回调函数中，你调用当前请求的
    `connection_handler` 方法 ➎。'
- en: 'The `connection_handler` ➏ follows a similar pattern to the `resolution_handler`
    method. It checks for an error condition, and if one exists, it prints to stderr
    and returns; otherwise, it proceeds to process the request by invoking `async_write`,
    which takes three parameters: the active `socket`, a mutable buffer-wrapping `request`,
    and a callback function. The callback function, in turn, invokes the `write_handler`
    method on the current request.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`connection_handler` ➏ 的模式与 `resolution_handler` 方法类似。它检查是否存在错误条件，如果有，就将错误输出到
    stderr 并返回；否则，它会通过调用 `async_write` 来继续处理请求，`async_write` 接受三个参数：活动的 `socket`、一个可变缓冲区包装的
    `request` 和一个回调函数。回调函数将调用当前请求的 `write_handler` 方法。'
- en: Are you seeing a pattern here in these handler functions? The `write_handler`
    ➐ checks for an error and proceeds to determine whether the entire request has
    been sent. If it hasn’t, you still need to write some of the request, so you adjust
    the `request` accordingly and invoke `async_write` again. If `async_write` has
    written the entire request into `socket`, it’s time to read the response. For
    this, you invoke `async_read` using your `socket`, a dynamic buffer wrapping the
    `response` field, and a callback function that invokes the `read_handler` method
    on the current request.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这些处理函数中看到了模式吗？`write_handler` ➐ 会检查是否有错误，然后继续判断整个请求是否已经发送。如果没有，你仍然需要写入一些请求内容，因此你需要相应地调整
    `request` 并再次调用 `async_write`。如果 `async_write` 已经将整个请求写入了 `socket`，那么就该读取响应了。为此，你调用
    `async_read`，使用你的 `socket`、一个动态缓冲区来包装 `response` 字段，并传入一个回调函数，该函数会在当前请求上调用 `read_handler`
    方法。
- en: 'The `read_handler` ➑ first checks for an error. Because your request used the
    `Connection: close` header, you expect an end-of-file error (value 2) as in [Listing
    20-10](ch20.xhtml#ch20ex10) and so ignore it. If it encounters a different kind
    of error, you print it to stderr and return. Your request is complete at this
    point. (Phew.)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_handler` ➑ 首先检查是否有错误。由于你的请求使用了 `Connection: close` 头部，你预计会遇到文件结束错误（错误码为
    2），就像在 [示例 20-10](ch20.xhtml#ch20ex10) 中一样，因此你忽略它。如果遇到其他类型的错误，你会将错误打印到 stderr
    并返回。此时，你的请求已经完成。（呼，终于结束了。）'
- en: Within `main`, you declare your `io_context` and initialize a `Request` to *[www.arcyber.army.mil](http://www.arcyber.army.mil)*
    ➒. Because you’re using asynchronous functions, you invoke the `run` method on
    `io_context` ➓. After `io_context` returns, you know that no asynchronous operations
    are pending, so you print the contents of the response on your `Request` object
    to stdout.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 中，你声明了一个 `io_context` 并初始化一个 `Request` 对象，目标是 *[www.arcyber.army.mil](http://www.arcyber.army.mil)*
    ➒。由于你使用了异步函数，因此你在 `io_context` 上调用 `run` 方法 ➓。当 `io_context` 返回时，你就知道没有异步操作在等待，因此你将当前
    `Request` 对象中的响应内容打印到标准输出（stdout）。
- en: '***Serving***'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***服务***'
- en: Building a server atop Boost Asio is essentially similar to building a client.
    To accept TCP connections, you use the `boost::asio::ip::tcp::acceptor` class,
    which takes a `boost::asio::io_context` object as its only constructor argument.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Boost Asio 上构建一个服务器本质上与构建客户端类似。为了接受 TCP 连接，你使用 `boost::asio::ip::tcp::acceptor`
    类，该类的构造函数唯一的参数是 `boost::asio::io_context` 对象。
- en: To accept a TCP connection using a blocking approach, you use the `acceptor`
    object’s `accept` method, which takes a `boost::asio::ip::tcp::socket` reference,
    which will hold the client’s socket, and an optional `boost::error_code` reference,
    which will hold any error conditions that arise. If you don’t provide a `boost::error_code`
    and an error arises, `accept` will throw a `boost::system_error` instead. Once
    `accept` returns without error, you can use the `socket` you passed in to read
    and write with the same read and write methods you used with the client in the
    previous sections.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用阻塞方式接受 TCP 连接时，你使用 `acceptor` 对象的 `accept` 方法，该方法接收一个 `boost::asio::ip::tcp::socket`
    引用，该引用将保存客户端的套接字，另有一个可选的 `boost::error_code` 引用，用来保存任何发生的错误条件。如果你没有提供 `boost::error_code`，且发生了错误，`accept`
    会抛出一个 `boost::system_error` 异常。一旦 `accept` 返回且没有错误，你可以使用传入的 `socket` 来进行读写，使用之前在处理客户端时使用的相同读写方法。
- en: For example, [Listing 20-12](ch20.xhtml#ch20ex12) illustrates how to build an
    echo server that receives a message and sends it back uppercased to the client.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[示例 20-12](ch20.xhtml#ch20ex12) 演示了如何构建一个回显服务器，它接收一条消息并将其大写后发送回客户端。
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 20-12: An uppercasing echo server*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 20-12：一个大写回显服务器*'
- en: You declare the `handle` function that accepts a `socket` reference corresponding
    to a client and handles messages from it ➊. Within a `do`-`while` loop, you read
    a line of text from the client into a `string` called `message` ➋, you convert
    it to uppercase using the `to_upper` function illustrated in [Listing 15-31](ch15.xhtml#ch15ex31)
    ➌, and write it back to the client ➍. If the client sent a blank line, you exit
    from `handle` ➎; otherwise, you clear the contents of the message and loop if
    no error condition occurred ➏.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了一个接受 `socket` 引用的 `handle` 函数，该引用对应客户端，并处理来自客户端的消息 ➊。在一个 `do`-`while` 循环中，你从客户端读取一行文本到一个名为
    `message` 的 `string` 变量中 ➋，然后使用 [示例 15-31](ch15.xhtml#ch15ex31) 中展示的 `to_upper`
    函数将其转换为大写 ➌，并将其写回客户端 ➍。如果客户端发送了一个空行，你会退出 `handle` ➎；否则，如果没有发生错误条件，你会清空消息内容并继续循环
    ➏。
- en: Within `main`, you initialize an `io_context` and an `acceptor` so that the
    program binds to the `localhost:1895` socket ➐. Within an infinite loop, you create
    a `socket` and call `accept` on the acceptor ➑. As long as this doesn’t throw
    an exception, the `socket` will represent a new client, and you can pass this
    `socket` to `handle` to service the request ➒.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 中，你初始化了一个 `io_context` 和一个 `acceptor`，使程序绑定到 `localhost:1895` 套接字 ➐。在一个无限循环中，你创建一个
    `socket` 并在 `acceptor` 上调用 `accept` ➑。只要没有抛出异常，`socket` 就代表了一个新的客户端，你可以将这个 `socket`
    传递给 `handle` 来处理请求 ➒。
- en: '**NOTE**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In [Listing 20-12](ch20.xhtml#ch20ex12), the choice was to listen on port
    1895\. This choice is technically immaterial, as long as no other program running
    on your computer is currently using that port. However, there are guidelines about
    how to decide which port your program will listen on. IANA maintains a list of
    registered ports at* [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt)
    *that you might want to avoid. Additionally, modern operating systems typically
    require that a program have elevated privileges to bind to a port with a value
    of 1023 or below, a* system port. *The ports 1024 to 49151 don’t typically require
    elevated privileges and are called* user ports. *The ports 49152 to 65535 are
    the* dynamic/private ports, *which are generally safe to use because they won’t
    be registered with IANA.*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*在[示例 20-12](ch20.xhtml#ch20ex12)中，选择监听端口 1895。这个选择在技术上并不重要，只要你电脑上没有其他程序正在使用这个端口。然而，关于如何决定程序监听的端口，有一些指导原则。IANA
    维护了一个注册端口的列表，地址是* [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt)
    *，你可能想避免使用其中的端口。另外，现代操作系统通常要求程序拥有提升的权限，才能绑定到端口值为 1023 或以下的* 系统端口。* 端口 1024 到 49151
    通常不需要提升权限，称为* 用户端口。* 端口 49152 到 65535 是* 动态/私有端口，* 因为这些端口通常不会被 IANA 注册，因此使用它们一般是安全的。*'
- en: To interact with the server in [Listing 20-12](ch20.xhtml#ch20ex12), you can
    use *GNU Netcat*, a network utility that allows you to create inbound and outbound
    TCP and UDP connections and then read and write data. If you’re using a Unix-like
    system, you probably have it installed. If you don’t, see [*https://nmap.org/ncat/*](https://nmap.org/ncat/).
    [Listing 20-13](ch20.xhtml#ch20ex13) shows a sample session that connects to the
    uppercasing echo server.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要与[Listing 20-12](ch20.xhtml#ch20ex12)中的服务器交互，你可以使用*GNU Netcat*，这是一个网络工具，允许你创建入站和出站的TCP和UDP连接，并读写数据。如果你使用的是类Unix系统，你可能已经安装了它。如果没有，请访问[*https://nmap.org/ncat/*](https://nmap.org/ncat/)。[Listing
    20-13](ch20.xhtml#ch20ex13)展示了一个连接到大写回显服务器的示例会话。
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 20-13: Interacting with the uppercasing echo server using Netcat*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 20-13：使用Netcat与大写回显服务器交互*'
- en: 'Netcat (`ncat`) takes two arguments: a host and a port ➊. Once you’ve invoked
    the program, each line you enter results in an uppercased result from the server.
    When you type text into stdin, Netcat sends it to the server ➋, which responds
    in uppercase. Once you send it an empty line ➌, the server terminates the socket
    and you get a `Broken pipe` ➍.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat（`ncat`）需要两个参数：主机和端口 ➊。启动程序后，每次输入的行都会从服务器返回一个大写结果。当你将文本输入到标准输入（stdin）时，Netcat将其发送到服务器
    ➋，服务器将以大写形式响应。当你发送一个空行 ➌时，服务器终止套接字连接，你将看到`Broken pipe` ➍。
- en: 'To accept connections using an asynchronous approach, you use the `async_accept`
    method on the `acceptor`, which takes a single argument: a callback object that
    accepts an `error_code` and a `socket`. If an error occurs, the `error_code` contains
    an error condition; otherwise, the `socket` represents the successfully connected
    client. From there, you can use the socket in the same way you did in the blocking
    approach.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用异步方式接受连接，可以在`acceptor`上使用`async_accept`方法，该方法接受一个参数：一个回调对象，该对象接受`error_code`和`socket`。如果发生错误，`error_code`将包含错误信息；否则，`socket`代表成功连接的客户端。之后，你可以像在阻塞方式中一样使用这个套接字。
- en: A common pattern for asynchronous, connection-oriented servers is to use the
    `std::enable_shared_from_this` template discussed in “Advanced Patterns” on [page
    362](ch11.xhtml#page_362). The idea is to create a shared pointer to a session
    object for each connection. When you register callbacks for reading and writing
    within the session object, you capture a shared pointer “from `this`” within the
    callback object so that while I/O is pending, the session stays alive. Once no
    I/O is pending, the session object dies along with all the shared pointers. [Listing
    20-14](ch20.xhtml#ch20ex14) illustrates how to reimplement the upper-casing echo
    server using asynchronous I/O.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 异步连接导向型服务器的常见模式是使用`std::enable_shared_from_this`模板，具体讨论可参见《高级模式》一章中的[第362页](ch11.xhtml#page_362)。其思想是为每个连接创建一个会话对象的共享指针。当你在会话对象内注册读取和写入回调时，你会在回调对象中捕获一个指向`this`的共享指针，这样在I/O操作等待期间，会话对象依然存活。一旦没有I/O操作待处理，会话对象和所有共享指针一起销毁。[Listing
    20-14](ch20.xhtml#ch20ex14)展示了如何使用异步I/O重新实现大写回显服务器。
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 20-14: An asynchronous version of [Listing 20-12](ch20.xhtml#ch20ex12)*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 20-14：使用异步版本的[Listing 20-12](ch20.xhtml#ch20ex12)*'
- en: You first define a `Session` class to manage connections. Within the constructor,
    you take ownership of the `socket` corresponding to the connecting client and
    store it as a member ➊.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要定义一个`Session`类来管理连接。在构造函数中，你将对应连接客户端的`socket`的所有权转移过来，并将其存储为成员 ➊。
- en: Next, you declare a `read` method that invokes `async_read_until` on the `socket`
    so it reads into a `dynamic_buffer` wrapping the `message` member `string` up
    to the next newline character `\n` ➋. The callback object captures this as a `shared_ptr`
    using the `shared_from_this` method. When invoked, the function checks for either
    an error condition or an empty line, in which case it returns ➌. Otherwise, the
    callback converts `message` to uppercase and invokes the `write` method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，声明一个`read`方法，它会在`socket`上调用`async_read_until`，将数据读取到`dynamic_buffer`中，直到遇到下一个换行符`\n`
    ➋。回调对象使用`shared_from_this`方法将其捕获为`shared_ptr`。当回调被触发时，函数检查是否存在错误条件或空行，如果是，返回 ➌。否则，回调会将`message`转换为大写，并调用`write`方法。
- en: The `write` method follows a similar pattern as the `read` method. It invokes
    `async_read`, passing the `socket`, the `message` (now uppercase), and a callback
    function ➍. Within the callback function, you check for an error condition and
    return immediately if one exists ➎. Otherwise, you know that Asio successfully
    sent your uppercased `message` to the client, so you invoke `clear` on it to prepare
    for the next message from the client. Then you invoke the `read` method, which
    starts the process over.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`方法遵循与`read`方法类似的模式。它调用`async_read`，传入`socket`、`message`（现在为大写）和回调函数
    ➍。在回调函数内，您检查是否存在错误条件，如果有则立即返回➎。否则，您知道Asio成功地将大写的`message`发送到了客户端，因此您调用`clear`方法来准备处理客户端的下一个消息。接着，您调用`read`方法，重新开始这个过程。'
- en: 'Next, you define a `serve` function that accepts an `acceptor` object. Within
    the function, you invoke `async_accept` on the acceptor object and pass a callback
    function to handle connections ➏. The callback function first invokes `serve`
    again using the acceptor so your program can handle new connections immediately
    ➐. This is the secret sauce that makes the asynchronous handling so powerful on
    the server side: you can handle many connections at once because the running thread
    doesn’t need to service one client before handling another. Next, you check for
    an error condition and exit if one exists; otherwise, you create a `shared_ptr`
    owning a new `Session` object ➑. This `Session` object will own the `socket` that
    the `acceptor` just set up for you. You invoke the `read` method on the new `Session`
    object, which creates a second reference within the `shared_ptr` thanks to the
    `shared_from_this` capture. Now you’re all set! Once the `read` and `write` cycle
    ends due to an empty line from the client or some error condition, the `shared_ptr`
    reference will go to zero and the `Session` object will destruct.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您定义一个接受`acceptor`对象的`serve`函数。在该函数内，您调用`async_accept`方法并传入一个回调函数来处理连接➏。回调函数首先使用`acceptor`再次调用`serve`，这样程序就可以立即处理新的连接➐。这就是使异步处理在服务器端如此强大的秘密所在：您可以同时处理多个连接，因为运行中的线程无需在处理另一个连接之前服务于一个客户端。接下来，您检查是否存在错误条件，如果有则退出；否则，您创建一个拥有新`Session`对象的`shared_ptr`
    ➑。该`Session`对象将拥有`acceptor`为您设置的`socket`。然后，您在新的`Session`对象上调用`read`方法，由于`shared_from_this`捕获，它会在`shared_ptr`中创建第二个引用。现在一切准备就绪！一旦由于客户端的空行或某些错误条件导致`read`和`write`周期结束，`shared_ptr`引用会归零，`Session`对象将被销毁。
- en: Finally, within `main` you construct an `io_context` and an `acceptor` as in
    [Listing 20-12](ch20.xhtml#ch20ex12). You then pass the `acceptor` to your `serve`
    function to begin the service loop and invoke `run` on the `io_context` to start
    servicing asynchronous operations ➒.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main`中，您构造一个`io_context`和一个`acceptor`，与[示例20-12](ch20.xhtml#ch20ex12)中的定义相同。然后，您将`acceptor`传递给`serve`函数以开始服务循环，并在`io_context`上调用`run`以启动异步操作的服务➒。
- en: '**Multithreading Boost Asio**'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**多线程Boost Asio**'
- en: To make your Boost Asio program multithreaded, you can simply spawn tasks that
    invoke `run` on your `io_context` object. Of course, this doesn’t make your program
    safe, and all the admonitions in “Sharing and Coordinating” on [page 647](ch19.xhtml#page_647)
    are in full effect. [Listing 20-15](ch20.xhtml#ch20ex15) illustrates how to multithread
    your server from [Listing 20-14](ch20.xhtml#ch20ex14).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的Boost Asio程序支持多线程，您可以简单地创建任务，调用`run`方法在您的`io_context`对象上运行。当然，这并不会让您的程序变得安全，所有在“共享与协调”章节中关于[第647页](ch19.xhtml#page_647)的警告依然有效。[示例20-15](ch20.xhtml#ch20ex15)演示了如何根据[示例20-14](ch20.xhtml#ch20ex14)将您的服务器进行多线程处理。
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 20-15: Multithreading your asynchronous echo server*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例20-15：为您的异步回声服务器启用多线程*'
- en: Your `Session` and `serve` definitions are identical. Within `main`, you declare
    `n_threads` constant representing the number of threads you’ll use to serve, an
    `io_context`, and an `acceptor` with parameters identical to those in [Listing
    12-12](ch12.xhtml#ch12ex12) ➊. Next, you invoke `serve` to begin the `async_accept`
    loop ➋.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`Session`和`serve`定义是相同的。在`main`中，您声明`n_threads`常量，表示您将用于服务的线程数，一个`io_context`对象，以及与[示例12-12](ch12.xhtml#ch12ex12)中相同参数的`acceptor`对象
    ➊。接下来，您调用`serve`以开始`async_accept`循环 ➋。
- en: More or less, `main` is almost identical to [Listing 12-12](ch12.xhtml#ch12ex12).
    The difference is that you’ll dedicate multiple threads to running the `io_context`
    rather than just one. First, you initialize a `vector` to store each `future`
    corresponding to the tasks you’ll launch. Second, you use a similar approach with
    `std::generate_n` to create tasks ➌. As the generative function object, you pass
    a lambda that invokes `std::async` ➍. Within the `std::async` call, you pass the
    execution policy `std::launch::async` and a function object that invokes `run`
    on your `io_context`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 或多或少，`main` 函数几乎与[示例 12-12](ch12.xhtml#ch12ex12)相同。不同之处在于，你将为运行 `io_context`
    分配多个线程，而不仅仅是一个。首先，你初始化一个 `vector` 来存储每个 `future`，对应于你将启动的任务。其次，你使用类似的方法，通过 `std::generate_n`
    创建任务 ➌。作为生成函数对象，你传递一个 lambda，调用 `std::async` ➍。在 `std::async` 调用中，你传递执行策略 `std::launch::async`
    和一个函数对象，该对象调用 `run` 来运行你的 `io_context`。
- en: Boost Asio is off to the races now that you’ve assigned some tasks to running
    your `io_context`. You’ll want to wait for all asynchronous operations to complete,
    so you call `get` on each `future` you stored in `futures` ➎. Once this loop completes,
    each `Request` has finished and you’re ready to print a summary of the resulting
    responses ➏.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为运行 `io_context` 分配了一些任务，Boost Asio 就开始运行了。你将希望等待所有异步操作完成，因此你需要对存储在 `futures`
    中的每个 `future` 调用 `get` ➎。此循环完成后，每个 `Request` 都已完成，你准备好打印结果响应的摘要 ➏。
- en: Sometimes it makes sense to create additional threads and assign them to processing
    I/O. Often, one thread will suffice. You must measure whether the optimization
    (and attendant difficulties arising from concurrent code) are worth it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有时创建额外的线程并将它们分配给处理 I/O 是有意义的。通常，一个线程就足够了。你必须衡量这种优化（以及并发代码带来的相关困难）是否值得。
- en: '**Summary**'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter covered Boost Asio, a library for low-level I/O programming. You
    learned the basics of queuing asynchronous tasks and providing a thread pool in
    Asio, as well as how to interact with its basic networking facilities. You built
    several programs, including a simple HTTP client using synchronous and asynchronous
    approaches and an echo server.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Boost Asio，一个用于低级 I/O 编程的库。你学习了如何在 Asio 中排队异步任务并提供线程池的基础知识，以及如何与其基本的网络功能进行交互。你编写了几个程序，包括一个使用同步和异步方法的简单
    HTTP 客户端和一个回声服务器。
- en: '**EXERCISES**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**20-1.** Use the Boost Asio documentation to investigate the UDP class analogs
    to the TCP classes you’ve learned about in this chapter. Rewrite the uppercasing
    echo server in [Listing 20-14](ch20.xhtml#ch20ex14) as a UDP service.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**20-1.** 使用 Boost Asio 文档调查 UDP 类与本章中学习的 TCP 类的类似功能。将[示例 20-14](ch20.xhtml#ch20ex14)中的大写回声服务器重写为一个
    UDP 服务。'
- en: '**20-2.** Use the Boost Asio documentation to investigate the ICMP classes.
    Write a program that pings all hosts on a given subnetwork to perform network
    analysis. Investigate *Nmap*, a network-mapping program available for free at
    *[https://nmap.org/](https://nmap.org/)*.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**20-2.** 使用 Boost Asio 文档调查 ICMP 类。编写一个程序，对给定子网中的所有主机进行 ping 测试，执行网络分析。调查
    *Nmap*，一款免费的网络映射程序，网址为 *[https://nmap.org/](https://nmap.org/)*。'
- en: '**20-3.** Investigate the Boost Beast documentation. Rewrite [Listings 20-10](ch20.xhtml#ch20ex10)
    and [20-11](ch20.xhtml#ch20ex11) using Beast.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**20-3.** 调查 Boost Beast 文档。使用 Beast 重写[示例 20-10](ch20.xhtml#ch20ex10)和[20-11](ch20.xhtml#ch20ex11)。'
- en: '**20-4.** Use Boost Beast to write an HTTP server that serves files from a
    directory. For help, refer to the Boost Beast example projects available in the
    documentation.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**20-4.** 使用 Boost Beast 编写一个 HTTP 服务器，从目录中提供文件。有关帮助，请参考文档中提供的 Boost Beast
    示例项目。'
- en: '**FURTHER READING**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*The TCP/IP Guide* by Charles M. Kozierok (No Starch Press, 2005)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TCP/IP 指南*，作者：Charles M. Kozierok（No Starch Press，2005）'
- en: '*Tangled Web: A Guide to Securing Modern Web Applications* by Michal Zalewski
    (No Starch Press, 2012)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错综复杂的网络：现代 Web 应用程序安全指南*，作者：Michal Zalewski（No Starch Press，2012）'
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Boost C++ 库*（第二版），作者：Boris Schäling（XML Press，2014）'
- en: '*Boost.Asio C++ Network Programming*, 2nd Edition, by Wisnu Anggoro and John
    Torjo (Packt, 2015)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Boost.Asio C++ 网络编程*（第二版），作者：Wisnu Anggoro 和 John Torjo（Packt，2015）'
