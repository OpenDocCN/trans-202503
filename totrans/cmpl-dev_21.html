<html><head></head><body>
<section epub:type="appendix" role="doc-appendix" aria-labelledby="appC">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="appC">&#13;
<span class="CN" id="appendix-C"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_289" aria-label=" Page 289. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">C</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">COMMON MATCHERS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In Jest, <i>matchers</i> let us check a specific condition, such as whether two values are equal or whether an HTML element exists in the current DOM. Jest comes with a set of built-in 		matchers. In addition, the <i>JEST-DOM</i> package from 		the testing library provides DOM-specific matchers.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-101"/><samp class="SANS_Futura_Std_Bold_B_11">Built-in Matchers</samp></h3>&#13;
<p class="TNI">This section covers the most common built-in Jest matchers. You can find a complete list in the official JEST documentation at <a href="https://jestjs.io/docs/expect"><i>https://<wbr/>jestjs<wbr/>.io<wbr/>/docs<wbr/>/expect</i></a>.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toBe  </samp>This matcher is the simplest and by far the most common. It’s a simple equality check to determine whether two values are identical. It behaves similarly to the strict equality (<samp class="SANS_TheSansMonoCd_W5Regular_11">===</samp>) operator, as it considers type differences. Unlike the strict equality operator, however, it considers <samp class="SANS_TheSansMonoCd_W5Regular_11">+0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-0</samp> to be different.</p>&#13;
&#13;
<pre class="pre-303"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_290" aria-label=" Page 290. "/>test('toBe',  () =&gt; {&#13;
    expect(1 + 1).toBe(2);&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toEqual  </samp>We use <samp class="SANS_TheSansMonoCd_W5Regular_11">toEqual</samp> to perform a deep-equality check between objects and arrays, comparing all of their properties or items. This matcher ignores undefined values and items. Furthermore, it does not check the object’s types (for example, whether they are instances or children of the same class or parent object). If you require such a check, consider using the <samp class="SANS_TheSansMonoCd_W5Regular_11">toStrictEqual</samp> matcher instead.</p>&#13;
&#13;
<pre class="pre-304"><code>test('toEqual', () =&gt; {&#13;
    expect([undefined, 1]).toEqual([1]);&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toStrictEqual  </samp>The <samp class="SANS_TheSansMonoCd_W5Regular_11">toStrictEqual</samp> matcher performs a structure and type comparison for objects and arrays; passing this test requires that the objects are of the same type. In addition, the matcher considers <samp class="SANS_TheSansMonoCd_W5Regular_11">undefined</samp> values and <samp class="SANS_TheSansMonoCd_W5Regular_11">undefined</samp> array items.</p>&#13;
&#13;
<pre class="pre-305"><code>test('toStrictEqual', () =&gt; {&#13;
    expect([undefined, 1]).toStrictEqual([undefined, 1]);&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toBeCloseTo  </samp>For floating-point numbers, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">toBeCloseTo</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">toBe</samp>. This is because JavaScript’s internal calculations of floating-point numbers are flawed, and this matcher considers those rounding errors.</p>&#13;
&#13;
<pre class="pre-306"><code>test('toBeCloseTo', () =&gt; {&#13;
    expect(0.1 + 0.2).toBeCloseTo(0.3);&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toBeGreaterThan/toBeGreaterThanOrEqual  </samp>For numeric values, we use these matchers to verify that the result is greater than or equal to a value, similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</samp> operators.</p>&#13;
&#13;
<pre class="pre-307"><code>test('toBeGreaterThan', () =&gt; {&#13;
    expect(1 + 1).toBeGreaterThan(1);&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toBeLessThan/toBeLessThanOrEqual  </samp>These are the opposite of the <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan...</samp> matchers for numeric values, similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp> operators.</p>&#13;
&#13;
<pre class="pre-308"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_291" aria-label=" Page 291. "/>test('toBeLessThan', () =&gt; {&#13;
    expect(1 + 1).toBeLessThan(3);&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toBeTruthy/toBeFalsy  </samp>These matchers check if a value exists, regardless of its value. They consider the six JavaScript values <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">' '</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">undefined</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> to be falsy and everything else to be truthy.</p>&#13;
&#13;
<pre class="pre-309"><code>test('toBeTruthy', () =&gt; {&#13;
    expect(1 + 1).toBeTruthy();&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toMatch  </samp>This matcher accepts a string or a regular expression, then checks if a value contains the given string or if the regular expression returns the given result.</p>&#13;
&#13;
<pre class="pre-310"><code>test('toMatch, () =&gt; {&#13;
    expect('apples and oranges').toMatch('apples');&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toContain  </samp>The <samp class="SANS_TheSansMonoCd_W5Regular_11">toContain</samp> matcher is similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">toMatch</samp>, but it accepts either an array or a string and checks these for a given string value. When used on an array, the matcher verifies that the array contains the given string.</p>&#13;
&#13;
<pre class="pre-311"><code>test('toMatch, () =&gt; {&#13;
    expect(['apples', 'oranges']).toContain('apples');&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toThrow  </samp>This matcher verifies that a function throws an error. The function being checked requires a wrapping function or the assertion will fail. We can pass it a string or a regular expression, similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">toMatch</samp> function.</p>&#13;
&#13;
<pre class="pre-312"><code>function functionThatThrows() {&#13;
    throw new Error();&#13;
}&#13;
&#13;
test('toThrow', () =&gt; {&#13;
    expect(<b>()</b> <b>=&gt;</b> <b>functionThatThrows()).toThrow()</b>;&#13;
})&#13;
</code></pre>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-102"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_292" aria-label=" Page 292. "/><samp class="SANS_Futura_Std_Bold_B_11">The JEST-DOM Matchers</samp></h3>&#13;
<p class="TNI">The <i>JEST-DOM</i> package provides matchers to work directly with the DOM, allowing us to easily write tests that run assertions on the DOM, such as checking for an element’s presence, HTML contents, CSS classes, or attributes.</p>&#13;
<p class="TX">Say we want to check that our logo element has the class name <samp class="SANS_TheSansMonoCd_W5Regular_11">center</samp>. Instead of manually checking for the presence of an element and then checking its class name attribute with <samp class="SANS_TheSansMonoCd_W5Regular_11">toMatch</samp>, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">toHaveClass</samp> matcher, as shown in <a href="appendix-C.xhtml#LisC-1">Listing C-1</a>.</p>&#13;
<span id="LisC-1"/>&#13;
<pre class="pre-313"><code>&lt;img data-testid="image"<b> </b>class="center full" alt="The Logo" src="logo.svg" /&gt;&#13;
&#13;
test('toHaveClass', () =&gt; {&#13;
    const element = getByTestId('image');&#13;
    expect(element).toHaveClass('center');&#13;
})&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing C-1: The basic syntax for testing with the DOM</span></p>&#13;
<p class="TX">First we add the data attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">testid</samp> to our image element. Then, in the test, we get the element using this ID and store the reference in a constant. Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">toHaveClass</samp> matcher on the element’s reference to see if the element’s class names contain the class <samp class="SANS_TheSansMonoCd_W5Regular_11">center</samp>.</p>&#13;
<p class="TX">Let’s take a look at the most common DOM-related matchers.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">getByTestId  </samp>This matcher lets us directly access a DOM element and store a reference to it, which we then use with custom matchers to assert things about this element.</p>&#13;
&#13;
<pre class="pre-314"><code>&lt;img <b>data-testid="image"</b> class="center full" alt="The Logo" src="logo.svg" /&gt;&#13;
&#13;
test('toHaveClass', () =&gt; {&#13;
    const element = <b>getByTestId('image')</b>;&#13;
<var>--snip--</var>&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toBeInTheDocument  </samp>This matcher verifies that an element was added to the document tree. This matcher works only on elements that are currently part of the DOM and ignores detached elements.</p>&#13;
&#13;
<pre class="pre-315"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;img </samp><b>data-testid="image"</b><samp class="SANS_TheSansMonoCd_W5Regular_11"> class="center full" alt="The Logo" src="logo.svg" /&gt;</samp>&#13;
&#13;
test('toHaveClass', () =&gt; {&#13;
    const element = getByTestId('image');&#13;
    expect(element)<b>.toBeInTheDocument();</b>&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_293" aria-label=" Page 293. "/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toContainElement  </samp>This matcher tests our assumptions about the element’s child elements, letting us verify, for example, whether an element is a descendant of the first.</p>&#13;
&#13;
<pre class="pre-316"><code>&lt;div data-testid="parent"&gt;&#13;
    &lt;img <b>data-testid="image"</b> class="center full" alt="The Logo" src="logo.svg" /&gt;&#13;
&lt;/div&gt;&#13;
&#13;
test('toHaveClass', () =&gt; {&#13;
    const parent = getByTestId('parent');&#13;
    const element = getByTestId('image');&#13;
    expect(parent)<b>.toContainElement(element);</b>&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toHaveAttribute  </samp>This matcher lets us run assertions on the element’s attributes, such as an image’s <samp class="SANS_TheSansMonoCd_W5Regular_11">alt</samp> attribute and the <samp class="SANS_TheSansMonoCd_W5Regular_11">checked</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">disabled</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">error</samp> state of form elements.</p>&#13;
&#13;
<pre class="pre-317"><code>&lt;img data-testid="image" class="center full" <b>alt="The Logo"</b> src="logo.svg" /&gt;&#13;
&#13;
test('toHaveClass', () =&gt; {&#13;
    const element = <b>getByTestId('image')</b>;&#13;
    expect(element).<b>toHaveAttribute('alt', 'The Logo')</b>;&#13;
})&#13;
</code></pre>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">toHaveClass</samp>  The <samp class="SANS_TheSansMonoCd_W5Regular_11">toHaveClass</samp> matcher is a specific variant of the <samp class="SANS_TheSansMonoCd_W5Regular_11">toHave Attribute</samp> matcher. It lets us explicitly assert that an element has a particular class name, allowing us to write clean tests.</p>&#13;
&#13;
<pre class="pre-318"><code>&lt;img data-testid="image" <b>class</b>="<b>center</b> full" alt="The Logo" src="logo.svg" /&gt;&#13;
&#13;
test('toHaveClass', () =&gt; {&#13;
    const element = <b>getByTestId('image')</b>;&#13;
    expect(element).<b>toHaveClass('center')</b>;&#13;
})&#13;
</code></pre>&#13;
</section>&#13;
</section>&#13;
</body></html>