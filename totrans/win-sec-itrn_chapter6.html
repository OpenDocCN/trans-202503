<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>6. Reading and Assigning Security Descriptors</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch6" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch6">
<span class="CN"><span aria-label=" Page 177. " epub:type="pagebreak" id="pg_177" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">READING AND ASSIGNING SECURITY DESCRIPTORS</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">In the previous chapter, we discussed the various structures that make up a security descriptor. You also learned how to manipulate security descriptors in PowerShell and how to represent them using the SDDL format. In this chapter, we’ll discuss how to read security descriptors from kernel objects, as well as the more complex process of assigning security descriptors to these objects.</p>
<p class="TX">We’ll focus our discussion on the security descriptors assigned to kernel objects. However, as mentioned in <span class="Xref">“Absolute and Relative Security Descriptors” on page 149</span>, it’s also possible to store a security descriptor in persistent storage, such as in a file or as a registry key value. In this case, the security descriptor must be stored in the relative format and read as a stream of bytes before we can convert it into a format we can inspect.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-52"></span><span aria-label=" Page 178. " epub:type="pagebreak" id="pg_178" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Reading Security Descriptors</samp></h3>
<p class="TNI1">To access a kernel object’s security descriptor, you can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp> system call. This system call accepts a handle to the kernel object, as well as a set of flags that describe the components of the security descriptor you want to access. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> enumeration represents these flags.</p>
<p class="TX"><a href="chapter6.xhtml#tab6-1">Table 6-1</a> shows the list of available flags in the latest versions of Windows, as well as the location of the information in the security descriptor and the handle access required to query it.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab6-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> <samp class="SANS_Futura_Std_Book_11">Flags and Their Required Access</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Location</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Handle access required</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Query the owner SID.</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Owner</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Query the group SID.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Group</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Dacl</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Query the DACL.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">DACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Sacl</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Query the SACL (auditing ACEs only).</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Query the mandatory label.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Attribute</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Query the system resource attribute.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Scope</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Query the scoped policy ID.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTrustLabel</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Query the process trust label.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AccessFilter</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Query the access filter.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Backup</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Query everything except the process trust label and access filter.</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">All</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">You only need <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access to read most of this information, except for the auditing ACEs from the SACL, which require <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> access. (<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access is sufficient for other ACEs stored in the SACL.)</p>
<p class="TX">The only way to get <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> access is to first enable the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp> privilege, then explicitly request the access when opening a kernel object. <a href="chapter6.xhtml#Lis6-1">Listing 6-1</a> shows this behavior. You must run these commands as an administrator.</p>
<span id="Lis6-1"></span><pre><code>PS&gt; <b>$dir = Get-NtDirectory "\BaseNamedObjects" -Access AccessSystemSecurity</b>
Get-NtDirectory : (0xC0000061) - A required privilege is not held by
the client.
<var>--snip--</var>

PS&gt; <b>Enable-NtTokenPrivilege SeSecurityPrivilege</b>
PS&gt; <b>$dir = Get-NtDirectory "\BaseNamedObjects" -Access AccessSystemSecurity</b>
PS&gt; <b>$dir.GrantedAccess</b>
AccessSystemSecurity
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-1: Requesting AccessSystemSecurity access and enabling SeSecurityPrivilege</span></p>
<p class="TX"><span aria-label=" Page 179. " epub:type="pagebreak" id="pg_179" role="doc-pagebreak"></span>Our first attempt to open the BNO directory with <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> access fails, because we don’t have the required <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp> privilege. Next, we enable that privilege and try again. This time we are able to open the directory, and printing its <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccess</samp> parameter confirms we’ve been granted <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> access.</p>
<p class="TX">It’s not entirely clear why the designers of Windows made the decision to guard the reading of audit information with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>. While we should consider modifying and removing audit information to be privileged actions, there is no obvious reason that reading that information should be. Unfortunately, we’re stuck with this design.</p>
<p class="TX">You can query an object’s security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp> PowerShell command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp>. The system call returns the security descriptor in the relative format as a byte array, which the PowerShell command parses into a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> object and returns to the caller. The command accepts either an object or a path to the resource you want to query, as shown in <a href="chapter6.xhtml#Lis6-2">Listing 6-2</a>, which displays the security descriptor for the BNO directory.</p>
<span id="Lis6-2"></span><pre><code>PS&gt; <b>Use-NtObject($d = Get-NtDirectory "\BaseNamedObjects" -Access </b>
<b>ReadControl) {</b>
    <b>Get-NtSecurityDescriptor -Object $d</b>
<b>}</b>
Owner                  DACL ACE Count SACL ACE Count Integrity Level
-----                  -------------- -------------- ---------------
BUILTIN\Administrators 4              1              Low
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-2: Querying the security descriptor for the BNO directory</span></p>
<p class="TX">Here, we open the BNO directory with <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access, then use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp> to query the security descriptor from the open <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> object.</p>
<p class="TX">By default, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp> command queries for the owner, group, DACL, mandatory label, and process trust label. If you want to query any other field (or omit some of the returned information), you need to specify this through the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> parameter, which accepts the values in <a href="chapter6.xhtml#tab6-1">Table 6-1</a>. For example, <a href="chapter6.xhtml#Lis6-3">Listing 6-3</a> uses a path instead of an object and requests only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> field.</p>
<span id="Lis6-3"></span><pre><code>PS&gt; <b>Get-NtSecurityDescriptor "\BaseNamedObjects" -SecurityInformation Owner</b>
Owner                  DACL ACE Count SACL ACE Count Integrity Level
-----                  -------------- -------------- ---------------
BUILTIN\Administrators NONE           NONE           NONE
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-3: Querying the owner of the BNO directory</span></p>
<p class="TX">In the output, you can see that only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> column contains valid information; all other columns now have the value <samp class="SANS_TheSansMonoCd_W5Regular_11">NONE</samp>, which indicates that no value is present, because we haven’t requested that information.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="h1-53"></span><span aria-label=" Page 180. " epub:type="pagebreak" id="pg_180" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Assigning Security Descriptors</samp></h3>
<p class="TNI1">Reading a security descriptor is easy; you just need the correct access to a kernel resource and the ability to parse the relative security descriptor format returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp> system call. Assigning a security descriptor is a more complex operation. The security descriptor assigned to a resource depends on multiple factors:</p>
<ul class="ul">
<li class="ListBullet">Is the resource being created?</li>
<li class="ListBullet">Did the creator specify a security descriptor during creation?</li>
<li class="ListBullet">Is the new resource stored in a container, such as a directory or registry key?</li>
<li class="ListBullet">Is the new resource a container or an object?</li>
<li class="ListBullet">What control flags are set on the parent or current security descriptor?</li>
<li class="ListBullet">What user is assigning the security descriptor?</li>
<li class="ListBullet">What ACEs does the existing security descriptor contain?</li>
<li class="ListBullet">What kernel object type is being assigned?</li>
</ul>
<p class="TX">As you can see from the list, this process involves many variables and is one of the big reasons Windows security can be so complex.</p>
<p class="TX">We can assign a resource’s security at creation time or via an open handle. Let’s start with the more complex case first: assignment at creation time.</p>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-66"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning a Security Descriptor During Resource Creation</samp></h4>
<p class="TNI1">When creating a new resource, the kernel needs to assign it a security descriptor. Also, it must store the security descriptor differently depending on the kind of resource being created. For example, object manager resources are ephemeral, so the kernel will store their security descriptors in memory. In contrast, a filesystem driver’s security descriptor must be persisted to disk; otherwise, it will disappear when you reboot your computer.</p>
<p class="TX">While the mechanism to store the security descriptor might differ, the kernel must still follow many common procedures when handling it, such as enforcing the rules of inheritance. To provide a consistent implementation, the kernel exports a couple of APIs that calculate the security descriptor to assign to a new resource. The most used of these APIs is <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>, which takes the following seven parameters:</p>
<p class="RunInPara1"><b>Creator security descriptor    </b>An optional security descriptor on which to base the new assigned security descriptor</p>
<p class="RunInPara"><b>Parent security descriptor    </b>An optional security descriptor for the new resource’s parent object</p>
<p class="RunInPara"><b>Object type    </b>An optional GUID that represents the type of object being created</p>
<p class="RunInPara"><b>Container    </b>A Boolean value indicating whether the new resource is a container</p>
<p class="RunInPara"><span aria-label=" Page 181. " epub:type="pagebreak" id="pg_181" role="doc-pagebreak"></span><b>Auto-inherit    </b>A set of bit flags that define the automatic inheritance behavior</p>
<p class="RunInPara"><b>Token    </b>A handle to the token to use as the creator’s identity</p>
<p class="RunInPara2"><b>Generic mapping    </b>A mapping from generic access to specific access rights for the kernel type</p>
<p class="TX">Based on these parameters, the API calculates a new security descriptor and returns it to the caller. By investigating how these parameters interact, we can understand how the kernel assigns security descriptors to new objects.</p>
<p class="TX">Let’s consider this assignment process for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object. (This object will be deleted once the PowerShell instance closes, ensuring that we don’t accidentally leave unnecessary files or registry keys lying around.) <a href="chapter6.xhtml#tab6-2">Table 6-2</a> provides an example of how we might set the parameters when creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object with <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab6-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Example Parameters for a New</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> <samp class="SANS_Futura_Std_Book_11">Object</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Parameter</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Setting value</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator security descriptor</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The value of the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> <samp class="SANS_Futura_Std_Book_11">field in the object attributes structure.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Parent security descriptor</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The security descriptor of the parent</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp><samp class="SANS_Futura_Std_Book_11">; not set for an unnamed</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Object type</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Not set.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Container</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp><samp class="SANS_Futura_Std_Book_11">, as a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> <samp class="SANS_Futura_Std_Book_11">isn’t a container.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Auto-inherit</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoInheritDacl</samp> <samp class="SANS_Futura_Std_Book_11">if the parent security descriptor’s control flags include the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> <samp class="SANS_Futura_Std_Book_11">flag and the creator DACL is missing or there is no creator</samp> <samp class="SANS_Futura_Std_Book_11">security descriptor; set to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoInheritSacl</samp> <samp class="SANS_Futura_Std_Book_11">if the</samp> <samp class="SANS_Futura_Std_Book_11">parent security descriptor’s control flags include the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherited</samp> <samp class="SANS_Futura_Std_Book_11">flag and the creator SACL is missing or there is no creator security descriptor.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Token</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">If the caller is impersonating, set to an impersonation token; otherwise, set to the primary token of the caller’s process.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Generic mapping</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set to the generic mapping for the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> <samp class="SANS_Futura_Std_Book_11">type.</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">You might be wondering why the object type isn’t set in <a href="chapter6.xhtml#tab6-2">Table 6-2</a>. The API supports the parameter, but neither the object manager nor the I/O manager uses it. Its primary purpose is to let Active Directory control inheritance, so we’ll discuss it separately in <span class="Xref">“Determining Object Inheritance” on page 203</span>.</p>
<p class="TX"><a href="chapter6.xhtml#tab6-2">Table 6-2</a> shows only two possible auto-inherit flags, but we can pass many others to the API. <a href="chapter6.xhtml#tab6-3">Table 6-3</a> lists the available auto-inherit flags, some of which we’ll encounter in this chapter’s examples.</p>
<p class="Anchor"><span aria-label=" Page 182. " epub:type="pagebreak" id="pg_182" role="doc-pagebreak"></span></p>
<table class="Basic-Table">
<caption><p class="TT" id="tab6-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">The Auto-inherit Flags</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Auto-inherit the DACL.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Auto-inherit the SACL.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultDescriptorForObject</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Use the default security descriptor for the new security descriptor.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidPrivilegeCheck</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Don’t check for privileges when setting the mandatory label or SACL.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerCheck</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Avoid checking whether the owner is valid for the current token.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultOwnerFromParent</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Copy the owner SID from the parent security descriptor.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultGroupFromParent</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Copy the group SID from the parent security descriptor.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Auto-inherit the mandatory label with the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp> <samp class="SANS_Futura_Std_Book_11">policy.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Auto-inherit the mandatory label with the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp> <samp class="SANS_Futura_Std_Book_11">policy.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoExecuteUp</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Auto-inherit the mandatory label with the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NoExecuteUp</samp> <samp class="SANS_Futura_Std_Book_11">policy.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerRestriction</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Ignore restrictions placed on the new DACL by the parent security descriptor.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ForceUserMode</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Enforce all checks as if called from user mode (only applicable for kernel callers).</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The most important <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp> parameters to consider are the values assigned to the parent and creator security descriptors. Let’s go through a few configurations of these two security descriptor parameters to understand the different outcomes.</p>
<section aria-labelledby="sec4" epub:type="division">
<h5 class="H3" id="sec4"><span id="h3-3"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Only the Creator Security Descriptor</samp></h5>
<p class="TNI1">In the first configuration we’ll consider, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> with the object attribute’s <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> field set to a valid security descriptor. If the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object is not given a name, it will be created without a parent directory, and the corresponding parent security descriptor won’t be set. If there is no parent security descriptor, the auto-inherit flags won’t be set, either.</p>
<p class="TX">Let’s test this behavior to see the security descriptor generated when we create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object. Rather than creating the object itself, we’ll use the user-mode implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>, which <i>NTDLL</i> exports as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>. We can access <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp> PowerShell command, as shown in <a href="chapter6.xhtml#Lis6-4">Listing 6-4</a>.</p>
<span id="Lis6-4"></span><pre><code><span aria-label=" Page 183. " epub:type="pagebreak" id="pg_183" role="doc-pagebreak"></span>PS&gt; <b>$creator = New-NtSecurityDescriptor -Type Mutant</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Add-NtSecurityDescriptorAce $creator -Name "Everyone" -Access GenericRead </b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Format-NtSecurityDescriptor $creator </b>
Type: Mutant
Control: DaclPresent
&lt;DACL&gt;
 - Type  : Allowed
 - Name  : Everyone
 - SID   : S-1-1-0
 - Mask  : 0x80000000
 - Access: GenericRead
 - Flags : None

PS&gt; <b>$token = Get-NtToken -Effective -Pseudo</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Token $token -Creator $creator </b>
<b>-Type Mutant </b>
PS&gt; <b>Format-NtSecurityDescriptor $sd</b>
Type: Mutant
Control: DaclPresent
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> &lt;Owner&gt;
 - Name  : GRAPHITE\user
 - Sid   : S-1-5-21-2318445812-3516008893-216915059-1002

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> &lt;Group&gt;
 - Name  : GRAPHITE\None
 - Sid   : S-1-5-21-2318445812-3516008893-216915059-513

&lt;DACL&gt;
- Type  : Allowed
- Name  : Everyone
- SID   : S-1-1-0
- Mask  : 0x00020001
<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> - Access: ModifyState|ReadControl
- Flags : None
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-4: Creating a new security descriptor from a creator security descriptor</span></p>
<p class="TX">We first build a creator security descriptor with only a single ACE, granting the <i>Everyone</i> group <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> access <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. By formatting the security descriptor <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, we can confirm that only the DACL is present in the formatted output. Next, using the creator security descriptor, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp> command <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, passing the current effective token and specifying the final object type as <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>. This object type determines the generic mapping. Finally, we format the new security descriptor.</p>
<p class="TX">You might notice that the security descriptor has changed during the creation process: it has gained <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> values <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, and the specified access mask has changed from <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|ReadControl</samp> <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>.</p>
<p class="TX">Let’s start by considering where those new owner and group values come from. When we don’t specify an <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> value, the creation process copies these from the supplied token’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PrimaryGroup</samp> SIDs. We can confirm this by checking the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s properties using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</samp> PowerShell command, as shown in <a href="chapter6.xhtml#Lis6-5">Listing 6-5</a>.</p>
<span id="Lis6-5"></span><pre><code><span aria-label=" Page 184. " epub:type="pagebreak" id="pg_184" role="doc-pagebreak"></span>PS&gt; <b>Format-NtToken $token -Owner -PrimaryGroup</b>
OWNER INFORMATION
----------------
Name          Sid
----          ---
GRAPHITE\user S-1-5-21-2318445812-3516008893-216915059-1002

PRIMARY GROUP INFORMATION
-------------------------
Name          Sid
----          ---
GRAPHITE\None S-1-5-21-2318445812-3516008893-216915059-513
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-5: Displaying the Owner and PrimaryGroup SIDs for the current effective token</span></p>
<p class="TX">If you compare the output in <a href="chapter6.xhtml#Lis6-5">Listing 6-5</a> with the security descriptor values in <a href="chapter6.xhtml#Lis6-4">Listing 6-4</a>, you can see that the owner and group SIDs match.</p>
<p class="TX">In <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, you learned that it’s not possible to set an arbitrary owner SID on a token; this value must be either the user’s SID or a SID marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> flag. You might wonder: As the token’s SID is being used to set the security descriptor’s default owner, can we use this behavior to specify an arbitrary owner SID in the security descriptor? Let’s check. In <a href="chapter6.xhtml#Lis6-6">Listing 6-6</a>, we first set the security descriptor to the <i>SYSTEM</i> user’s SID, then try to create the security descriptor again.</p>
<span id="Lis6-6"></span><pre><code>PS&gt; <b>Set-NtSecurityDescriptorOwner $creator -KnownSid LocalSystem</b>
PS&gt; <b>New-NtSecurityDescriptor -Token $token -Creator $creator -Type Mutant</b>
New-NtSecurityDescriptor : (0xC000005A) - Indicates a particular Security ID
may not be assigned as the owner of an object.
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-6: Setting the</span> <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp> <span class="Futura_Std_Book_Oblique_I_11">user as the Mutant object’s security descriptor owner</span></p>
<p class="TX">This time, the creation fails with an exception and the status code <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_OWNER</samp>. This is because the API checks whether the owner SID being assigned is valid for the supplied token. It doesn’t have to be the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s owner SID, but it must be either the user’s SID or a group SID with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> flag set.</p>
<p class="TX">You can set an arbitrary owner SID only when the token used to create the security descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp> privilege enabled. Note that this token doesn’t necessarily have to belong to the caller of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp> API. You can also disable the owner check by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidOwnerCheck</samp> auto-inherit flag; however, the kernel will never specify this flag when creating a new object, so it will always enforce the owner check.</p>
<p class="TX">This is not to say that there’s no way to set a different owner as a normal user. However, any method of setting an arbitrary owner that you discover is a security vulnerability that Microsoft will likely fix. An example of such a bug is CVE-2018-0748, which allowed users to set an arbitrary owner when creating a file. The user had to create the file via a local filesystem share, causing the owner check to be bypassed.</p>
<p class="TX"><span aria-label=" Page 185. " epub:type="pagebreak" id="pg_185" role="doc-pagebreak"></span>There are no restrictions on the value of the group SID, as the group doesn’t contribute to the access check. However, restrictions apply to the SACL. If you specify any audit ACEs in the SACL as part of the creator security descriptor, the kernel will require <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>.</p>
<p class="TX">Remember that when we created the security descriptor, the access mask changed? This is because the security descriptor assignment process maps all generic access rights in the access mask to type-specific access rights using the object type’s generic mapping information. In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> mapping converts the access mask to <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|ReadControl</samp>. There is one exception to this rule: if the ACE has the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> flag set, then generic access rights won’t be mapped. You’ll understand why the exception exists shortly, when we discuss inheritance.</p>
<p class="TX">We can confirm this mapping behavior by using <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp> to create an unnamed <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object, as shown in <a href="chapter6.xhtml#Lis6-7">Listing 6-7</a>.</p>
<span id="Lis6-7"></span><pre><code>PS&gt; <b>$creator = New-NtSecurityDescriptor -Type Mutant</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $creator -Name "Everyone" -Access GenericRead</b>
PS&gt; <b>Use-NtObject($m = New-NtMutant -SecurityDescriptor $creator) {</b>
    <b>Format-NtSecurityDescriptor $m</b>
<b>}</b>
Type: Mutant
Control: DaclPresent
&lt;Owner&gt;
 - Name  : GRAPHITE\user
 - Sid   : S-1-5-21-2318445812-3516008893-216915059-1002

&lt;Group&gt;
 - Name  : GRAPHITE\None
 - Sid   : S-1-5-21-2318445812-3516008893-216915059-513

&lt;DACL&gt;
 - Type  : Allowed
 - Name  : Everyone
 - SID   : S-1-1-0
 - Mask  : 0x00020001
 - Access: ModifyState|ReadControl
 - Flags : None
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-7: Verifying security descriptor assignment rules by creating a Mutant object</span></p>
<p class="TX">As you can see, the output security descriptor is the same as the one created in <a href="chapter6.xhtml#Lis6-4">Listing 6-4</a>.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h5 class="H3" id="sec5"><span id="h3-4"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Neither the Creator nor the Parent Security Descriptor</samp></h5>
<p class="TNI1">Let’s explore another simple case. In this scenario, neither the creator nor the parent security descriptor is set. This case corresponds to calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> without a name or a specified <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> field. The script to test it is even simpler than the previous one, as shown in <a href="chapter6.xhtml#Lis6-8">Listing 6-8</a>.</p>
<span id="Lis6-8"></span><pre><code><span aria-label=" Page 186. " epub:type="pagebreak" id="pg_186" role="doc-pagebreak"></span>PS&gt; <b>$token = Get-NtToken -Effective -Pseudo</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Token $token -Type Mutant</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -HideHeader</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> &lt;Owner&gt;
 - Name  : GRAPHITE\user
 - Sid   : S-1-5-21-2318445812-3516008893-216915059-1002

&lt;Group&gt;
 - Name  : GRAPHITE\None
 - Sid   : S-1-5-21-2318445812-3516008893-216915059-513

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> &lt;DACL&gt;
 - Type  : Allowed
 - Name  : GRAPHITE\user
 - SID   : S-1-5-21-2318445812-3516008893-216915059-1002
 - Mask  : 0x001F0001
 - Access: Full Access
 - Flags : None

 - Type  : Allowed
 - Name  : NT AUTHORITY\SYSTEM
 - SID   : S-1-5-18
 - Mask  : 0x001F0001
 - Access: Full Access
 - Flags : None

 - Type  : Allowed
 - Name  : NT AUTHORITY\LogonSessionId_0_137918
 - SID   : S-1-5-5-0-137918
 - Mask  : 0x00120001
 - Access: ModifyState|ReadControl|Synchronize
 - Flags : None
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-8: Creating a new security descriptor with no creator or parent security descriptor</span></p>
<p class="TX">This call to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp> requires only the token and kernel object type <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> fields in the final security descriptor are set to default values based on the token’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PrimaryGroup</samp> properties <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">But where did the DACL <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> come from? We haven’t specified either a parent or a creator security descriptor, so it couldn’t have come from either of those. Instead, it’s based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s <i>default DACL</i>, an ACL stored in the token that acts as a fallback when there is no other DACL specified. You can display a token’s default DACL by passing the token to <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultDacl</samp> parameter, as in <a href="chapter6.xhtml#Lis6-9">Listing 6-9</a>.</p>
<span id="Lis6-9"></span><pre><code>PS&gt; <b>Format-NtToken $token -DefaultDacl</b>
DEFAULT DACL
------------
GRAPHITE\user: (Allowed)(None)(GenericAll)
NT AUTHORITY\SYSTEM: (Allowed)(None)(GenericAll)
NT AUTHORITY\LogonSessionId_0_137918: (Allowed)(None)(GenericExecute|GenericRead)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-9: Displaying a token’s default DACL</span></p>
<p class="TX"><span aria-label=" Page 187. " epub:type="pagebreak" id="pg_187" role="doc-pagebreak"></span>Other than its <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>-specific access rights, the DACL in <a href="chapter6.xhtml#Lis6-9">Listing 6-9</a> matches the one in <a href="chapter6.xhtml#Lis6-8">Listing 6-8</a>. We can conclude that, if we specify neither the parent nor the creator security descriptor during creation, we’ll create a new security descriptor based on the token’s owner, primary group, and default DACL. However, just to be certain, let’s verify this behavior by creating an unnamed <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> with no security descriptor (<a href="chapter6.xhtml#Lis6-10">Listing 6-10</a>).</p>
<span id="Lis6-10"></span><pre><code>PS&gt; <b>Use-NtObject($m = New-NtMutant) {</b>
    <b>Format-NtSecurityDescriptor $m</b>
<b>}</b>
Type: Mutant
Control: None
&lt;NO SECURITY INFORMATION&gt;
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-10: Creating an unnamed Mutant to verify the default security descriptor creation behavior</span></p>
<p class="TX">Wait—the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object has no security information at all! That’s not what we expected.</p>
<p class="TX">The issue here is that the kernel allows certain object types to have no security when the object doesn’t have a name. You can learn whether an object requires security by querying its <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityRequired</samp> property, as shown in <a href="chapter6.xhtml#Lis6-11">Listing 6-11</a>.</p>
<span id="Lis6-11"></span><pre><code>PS&gt; <b>Get-NtType "Mutant" | Select-Object SecurityRequired</b>
SecurityRequired
----------------
          <b> </b>False
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-11: Querying for the Mutant type’s SecurityRequired property</span></p>
<p class="TX">As you can see, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> type doesn’t require security. So, if we specify neither the creator nor the parent security descriptor when creating an unnamed <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object, the kernel won’t generate a default security descriptor.</p>
<p class="TX">Why would the kernel support the ability to create an object without a security descriptor? Well, if applications won’t share that object with each other, the security descriptor would serve no purpose; it would only use up additional kernel memory. Only if you created an object with a name, so that it can be shared, would the kernel require security.</p>
<aside aria-label="box-5" class="box">
<p class="BoxTitle" id="box-5"><samp class="SANS_Dogma_OT_Bold_B_11">DUPLICATING UNNAMED OBJECT HANDLES</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You can duplicate a handle to an unnamed resource and share it with another process without giving the resource a name. However, this should be done with care. While handle duplication allows you to remove access from a handle if</samp> <span aria-label=" Page 188. " epub:type="pagebreak" id="pg_188" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">the object has no security descriptor, the receiving process can easily reduplicate the handle to retrieve the access that was removed.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Prior to Windows 8, there was no way to assign security to an unnamed object that had</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityRequired</samp> <samp class="SANS_Futura_Std_Book_11">set to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp><samp class="SANS_Futura_Std_Book_11">. This has changed, and if you specify a security descriptor during creation, you’ll assign it to the resulting object. Windows 8 also introduced a new, undocumented flag to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp> <samp class="SANS_Futura_Std_Book_11">to separately deal with the issue. Specifying the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NoRightsUpgrade</samp> <samp class="SANS_Futura_Std_Book_11">flag while duplicating a handle tells the kernel to deny any further duplication operations that request additional access rights.</samp></p>
</aside>
<p class="TX">To verify the generation of a default security descriptor, let’s now create an object that requires security, such as a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> object (<a href="chapter6.xhtml#Lis6-12">Listing 6-12</a>).</p>
<span id="Lis6-12"></span><pre><code>PS&gt; <b>Get-NtType Directory | Select-Object SecurityRequired</b>
SecurityRequired
----------------
            True

PS&gt; <b>Use-NtObject($dir = New-NtDirectory) {</b>
    <b>Format-NtSecurityDescriptor $dir -Summary</b>
<b>}</b>
GRAPHITE\user: (Allowed)(None)(Full Access)
NT AUTHORITY\SYSTEM: (Allowed)(None)(Full Access)
NT AUTHORITY\LogonSessionId_0_137918: (Allowed)(None)(Query|Traverse|ReadControl)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-12: Creating an unnamed Directory to verify the default security descriptor</span></p>
<p class="TX"><a href="chapter6.xhtml#Lis6-12">Listing 6-12</a> shows that the default security descriptor matches our assumptions.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h5 class="H3" id="sec6"><span id="h3-5"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Only the Parent Security Descriptor</samp></h5>
<p class="TNI1">The next case we’ll consider is much more complex. Say we call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> with a name but without specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> field. Because a named <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> must be created within a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> object (which, as we’ve just seen, requires security), the parent security descriptor will be set.</p>
<p class="TX">Yet when we specify a parent security descriptor, we also bring something else into play: <i>inheritance</i>, a process by which the new security descriptor copies a part of the parent security descriptor. Inheritance rules determine which parts of the parent get passed to the new security descriptor, and we call a parent security descriptor <i>inheritable</i> if its parts can be inherited.</p>
<p class="TX">The purpose of inheritance is to define a hierarchical security configuration for a tree of resources. Without inheritance, we would have to explicitly assign a security descriptor for each new object in the hierarchy, which would become unmanageable rather quickly. It would also make the resource tree impossible to manage, as each application might choose to behave differently.</p>
<p class="TX"><span aria-label=" Page 189. " epub:type="pagebreak" id="pg_189" role="doc-pagebreak"></span>Let’s test the inheritance rules that apply when we create new kernel resources. We’ll focus on the DACL, but these concepts apply to the SACL, as well. To minimize code duplication, <a href="chapter6.xhtml#Lis6-13">Listing 6-13</a> defines a few functions that run a test with the parent security descriptor and implement various options.</p>
<span id="Lis6-13"></span><pre><code>PS&gt; <b>function New-ParentSD($AceFlags = 0, $Control = 0) {</b>
    <b>$owner = Get-NtSid -KnownSid BuiltinAdministrators</b>
  <span aria-label="annotation1" class="CodeAnnotationCode2">❶</span><b> $parent = New-NtSecurityDescriptor -Type Directory -Owner $owner -Group $owner</b>
  <span aria-label="annotation2" class="CodeAnnotationCode2">❷</span><b> Add-NtSecurityDescriptorAce $parent -Name "Everyone" -Access GenericAll</b>
    <b>Add-NtSecurityDescriptorAce $parent -Name "Users" -Access GenericAll -Flags $AceFlags</b>
  <span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> Add-NtSecurityDescriptorControl $parent -Control $Control</b>
  <span aria-label="annotation4" class="CodeAnnotationCode2">❹</span><b> Edit-NtSecurityDescriptor $parent -MapGeneric</b>
    <b>return $parent</b>
<b>}</b>

PS&gt; <b>function Test-NewSD($AceFlags = 0,</b>
                        <b>$Control = 0,</b>
                        <b>$Creator = $null,</b>
                        <b>[switch]$Container) {</b>
  <span aria-label="annotation5" class="CodeAnnotationCode2">❺</span> <b>$parent = New-ParentSD -AceFlags $AceFlags -Control $Control</b>
    <b>Write-Output "-= Parent SD =-"</b>
    <b>Format-NtSecurityDescriptor $parent -Summary</b>

    <b>if ($Creator -ne $null) {</b>
        <b>Write-Output "`r`n-= Creator SD =-"</b>
        <b>Format-NtSecurityDescriptor $creator -Summary</b>
    <b>}</b>

  <span aria-label="annotation6" class="CodeAnnotationCode2">❻</span> <b>$auto_inherit_flags = @()</b>
    <b>if (Test-NtSecurityDescriptor $parent -DaclAutoInherited) {</b>
        <b>$auto_inherit_flags += "DaclAutoInherit"</b>
    <b>}</b>
    <b>if (Test-NtSecurityDescriptor $parent -SaclAutoInherited) {</b>
        <b>$auto_inherit_flags += "SaclAutoInherit"</b>
    <b>}</b>
    <b>if ($auto_inherit_flags.Count -eq 0) {</b>
        <b>$auto_inherit_flags += "None"</b>
    <b>}</b>

    <b>$token = Get-NtToken -Effective -Pseudo</b>
  <span aria-label="annotation7" class="CodeAnnotationCode2">❼</span> <b>$sd = New-NtSecurityDescriptor -Token $token -Parent $parent -Creator $creator -Type Mutant</b><b> </b><b>-Container:$Container -AutoInherit $auto_inherit_flags</b>
    <b>Write-Output "`r`n-= New SD =-"</b>
  <span aria-label="annotation8" class="CodeAnnotationCode2">❽</span> <b>Format-NtSecurityDescriptor $sd -Summary</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-13: Test function definitions for New-ParentSD and Test-NewSD</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ParentSD</samp> function creates a new security descriptor with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> fields set to the <i>Administrators</i> group <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This will allow us to <span aria-label=" Page 190. " epub:type="pagebreak" id="pg_190" role="doc-pagebreak"></span>check for inheritance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> field in any new security descriptor we create from this parent. We also set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>, as expected for the object manager. Next, we add two <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACEs, one for the <i>Everyone</i> group and one for the <i>Users</i> group <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, differentiated by their SIDs. We assign both ACEs <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access and add some extra flags for the <i>Users</i> ACE.</p>
<p class="TX">The function then sets some optional security descriptor control flags <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Normally, when we assign a security descriptor to a parent the generic access rights get mapped to type-specific access rights. Here, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapGeneric</samp> parameter to do this mapping for us <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NewSD</samp> function, we create the parent security descriptor <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> and calculate any auto-inherit flags <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. Then we create a new security descriptor, setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Container</samp> property if required, as well as the auto-inherit flags we calculated <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. You can specify a creator security descriptor for this function to use to create the new security descriptor. For now, we’ll leave this value as <samp class="SANS_TheSansMonoCd_W5Regular_11">$null</samp>, but we’ll come back to it in the next section. Finally, we print the parent, the creator (if specified), and the new security descriptors to the console to verify the input and output <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>.</p>
<p class="TX">Let’s start by testing the default case: running the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NewSD</samp> command with no additional parameters. The command will create a parent security descriptor with no control flags set, so there should be no auto-inherit flags present in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp> (<a href="chapter6.xhtml#Lis6-14">Listing 6-14</a>).</p>
<span id="Lis6-14"></span><pre><code>PS&gt; <b>Test-NewSD</b>
-= Parent SD =-
&lt;DACL&gt;
Everyone: (Allowed)(None)(Full Access)
BUILTIN\Users: (Allowed)(None)(Full Access)

-= New SD =-
&lt;Owner&gt; : GRAPHITE\user <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt;
GRAPHITE\user: (Allowed)(None)(Full Access) <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
NT AUTHORITY\SYSTEM: (Allowed)(None)(Full Access)
NT AUTHORITY\LogonSessionId_0_137918: (Allowed)(None)(ModifyState|ReadControl|...)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-14: Creating a new security descriptor with a parent security descriptor and no creator security descriptor</span></p>
<p class="TX">In the output, we can see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> do not derive from the parent security descriptor <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>; instead, they’re the defaults we observed earlier in this chapter. This makes sense: the caller, and not the user who created the parent object, should own the new resource.</p>
<p class="TX">However, the new DACL doesn’t look as we might have expected <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. It’s set to the default DACL we saw earlier, and it bears no relation to the DACL we built in the parent security descriptor. The reason we didn’t get any ACEs from the parent’s DACL is that we did not specify the ACEs as inheritable. To do so, we need to set one or both of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> ACE flags. The former applies only to non-container <span aria-label=" Page 191. " epub:type="pagebreak" id="pg_191" role="doc-pagebreak"></span>objects such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> objects, while the latter applies to container objects such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> objects. The distinction between the two types is important, because they affect how the inherited ACEs propagate to child objects.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object is a non-container, so let’s add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> flag to the ACE in the parent security descriptor (<a href="chapter6.xhtml#Lis6-15">Listing 6-15</a>).</p>
<span id="Lis6-15"></span><pre><code>PS&gt; <b>Test-NewSD -AceFlags "ObjectInherit" </b><span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
-= Parent SD =-
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt;
Everyone: (Allowed)(None)(Full Access)
BUILTIN\Users: (Allowed)(ObjectInherit)(Full Access)

-= New SD =-
&lt;Owner&gt; : GRAPHITE\user <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt; <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
BUILTIN\Users: (Allowed)(None)(ModifyState|Delete|ReadControl|WriteDac|WriteOwner)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-15: Adding an ObjectInherit ACE to the parent security descriptor</span></p>
<p class="TX">In this listing, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> ACE flag to the test function <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Observe that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> fields have not changed <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, but the DACL is no longer the default <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Instead, it contains a single ACE that grants the <i>Users</i> group <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState|Delete|ReadControl|WriteDac|WriteOwner</samp> access. This is the ACE that we set to be inherited.</p>
<p class="TX">However, you might notice a problem: the parent security descriptor’s ACE was granted <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>, while the new security descriptor’s ACE is not. Why has the access mask changed? In fact, it hasn’t; the inheritance process has merely taken the raw <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> access mask for the parent security descriptor’s ACE (the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000F000F</samp>) and copied it to the inherited ACE. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object’s valid access bits are <samp class="SANS_TheSansMonoCd_W5Regular_11">0x001F0001</samp>. Therefore, the inheritance process uses the closest mapping, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000F0001</samp>, as shown in <a href="chapter6.xhtml#Lis6-16">Listing 6-16</a>.</p>
<span id="Lis6-16"></span><pre><code>PS&gt; <b>Get-NtAccessMask (0x0001F0001 -band 0x0000F000F) -ToSpecificAccess Mutant</b>
ModifyState, Delete, ReadControl, WriteDac, WriteOwner
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-16: Checking the inherited access mask</span></p>
<p class="TX">This is a pretty serious issue. Notice, for example, that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> type is missing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Synchronize</samp> access right, which it needs for a caller to wait on the lock. Without this access, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object would be useless to an application.</p>
<p class="TX">We can solve this access mask problem by specifying a generic access mask in the ACE. This will map to a type-specific access mask when the new security descriptor is created. There is only one complication: we’ve taken the parent security descriptor from an existing object, so the generic access was already mapped when the security descriptor was assigned. We simulated this behavior in our test function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp> call.</p>
<p class="TX"><span aria-label=" Page 192. " epub:type="pagebreak" id="pg_192" role="doc-pagebreak"></span>To resolve this issue, the ACE can set the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> flag. As a result, any generic access will remain untouched during the initial assignment. The <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> flag marks the ACE for inheritance only, which prevents the generic access from being an issue for access checking. In <a href="chapter6.xhtml#Lis6-17">Listing 6-17</a>, we check this behavior by modifying the call to the test function.</p>
<span id="Lis6-17"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Test-NewSD -AceFlags "ObjectInherit, InheritOnly"</b>
-= Parent SD =-
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt;
Everyone: (Allowed)(None)(Full Access)
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> BUILTIN\Users: (Allowed)(ObjectInherit, InheritOnly)(GenericAll)

-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt;
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> BUILTIN\Users: (Allowed)(None)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-17: Adding an InheritOnly ACE</span></p>
<p class="TX">In this listing, we change the ACE flags to <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. In the parent security descriptor’s output, we can see that the access mask is no longer mapped from <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. As a result, the inherited ACE is now granted <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>, as we require <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">Presumably, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> flag works in the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp>, right? Not quite. We test its behavior in <a href="chapter6.xhtml#Lis6-18">Listing 6-18</a>.</p>
<span id="Lis6-18"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Test-NewSD -AceFlags "ContainerInherit, InheritOnly" -Container</b>
-= Parent SD =-
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt;
Everyone: (Allowed)(None)(Full Access)
BUILTIN\Users: (Allowed)(ContainerInherit, InheritOnly)(GenericAll)

-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt;
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> BUILTIN\Users: (Allowed)(None)(Full Access)
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> BUILTIN\Users: (Allowed)(ContainerInherit, InheritOnly)(GenericAll)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-18: Creating a new security descriptor with the ContainerInherit flag</span></p>
<p class="TX">Here, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> flags to the ACE and then pass the function the <samp class="SANS_TheSansMonoCd_W5Regular_11">Container</samp> parameter <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Unlike in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> case, we now end up with two ACEs in the DACL. The first ACE <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> grants access to the new resource based on the inheritable ACE. The second <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> is a copy of the inheritable ACE, with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access.</p>
<blockquote>
<span aria-label=" Page 193. " epub:type="pagebreak" id="pg_193" role="doc-pagebreak"></span>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>You might wonder how we can create a security descriptor for a container type when we’re using the Mutant type. The answer is that the API doesn’t care about the final type, as it uses only the generic mapping; when creating a real Mutant object, however, the kernel would never specify the Container flag.</i></p>
</blockquote>
<p class="TX">The ACE’s automatic propagation is useful, as it allows you to build a hierarchy of containers without needing to manually grant them access rights. However, you might sometimes want to disable this automatic propagation by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp> ACE flag, as shown in <a href="chapter6.xhtml#Lis6-19">Listing 6-19</a>.</p>
<span id="Lis6-19"></span><pre><code>PS&gt; <b>$ace_flags = "ContainerInherit, InheritOnly, NoPropagateInherit"</b>
PS&gt; <b>Test-NewSD -AceFlags $ace_flags -Container</b>
<var>--snip--</var>
-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt;
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> BUILTIN\Users: (Allowed)(None)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-19: Using NoPropagateInherit to prevent the automatic inheritance of ACEs</span></p>
<p class="TX">When we specify this flag, the ACE that grants access to the resource remains present, but the inheritable ACE disappears <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>.</p>
<p class="TX">Let’s try another ACE flag configuration to see what happens to <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> ACEs when they’re inherited by a container (<a href="chapter6.xhtml#Lis6-20">Listing 6-20</a>).</p>
<span id="Lis6-20"></span><pre><code>PS&gt; <b>Test-NewSD -AceFlags "ObjectInherit" -Container</b>
<var>--snip--</var>
-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt;
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> BUILTIN\Users: (Allowed)(ObjectInherit, InheritOnly)(ModifyState|...)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-20: Testing the ObjectInherit flag on a container</span></p>
<p class="TX">You might not expect the container to inherit the ACE at all, but in fact, it receives the ACE with the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> flag automatically set <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This allows the container to pass the ACE to non-container child objects.</p>
<p class="TX"><a href="chapter6.xhtml#tab6-4">Table 6-4</a> summarizes the inheritance rules for container and non-container objects based on the parent ACE flags. Objects are bolded where no inheritance occurs.</p>
<p class="Anchor"><span aria-label=" Page 194. " epub:type="pagebreak" id="pg_194" role="doc-pagebreak"></span></p>
<table class="Basic-Table">
<caption><p class="TT" id="tab6-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Parent ACE Flags and Flags Set on the Inherited ACEs</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Parent ACE flags</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Non-container object</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Container object</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Heavy_B_11">No inheritance</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Heavy_B_11">No inheritance</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp></p>
<p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Heavy_B_11">No inheritance</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp></p>
<p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Heavy_B_11">No inheritance</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp></p>
<p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Heavy_B_11">No inheritance</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp></p>
<p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp></p>
<p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp></p>
<p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp></p>
<p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NoPropagateInherit</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Finally, consider <i>auto-inherit flags</i>. If you return to <a href="chapter6.xhtml#tab6-3">Table 6-3</a>, you can see that if the DACL has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> control flag set, the kernel will pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp>, as there is no creator security descriptor. (The SACL has a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> flag, but we’ll focus on the DACL here.) What does the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> flag do? In <a href="chapter6.xhtml#Lis6-21">Listing 6-21</a>, we perform a test to find out.</p>
<span id="Lis6-21"></span><pre><code>PS&gt; <b>$ace_flags = "ObjectInherit, InheritOnly"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Test-NewSD -AceFlags $ace_flags -Control "DaclAutoInherited"</b>
-= Parent SD =-
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> &lt;DACL&gt; (Auto Inherited)
Everyone: (Allowed)(None)(Full Access)
BUILTIN\Users: (Allowed)(ObjectInherit, InheritOnly)(GenericAll)

-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> &lt;DACL&gt; (Auto Inherited)
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> BUILTIN\Users: (Allowed)(Inherited)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-21: Setting the DaclAutoInherited control flag in the parent security descriptor</span></p>
<p class="TX">We set the parent security descriptor’s control flags to contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> flag <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, and we confirm that it’s set by looking at the formatted DACL <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We can see that the new security descriptor contains the flag as well <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>; also, the inherited ACE has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> flag <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">How do the auto-inherit flags differ from the inheritance flags we discussed earlier? Microsoft conserves both inheritance types for compatibility reasons (as it didn’t introduce the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> flag until Windows 2000). From the kernel’s perspective, the two types of inheritance are not very different other than determining whether the new security has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> flag set and whether any inherited ACE gets the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> flag. But from a user-mode perspective, this inheritance model indicates which parts of the DACL were inherited from a parent security descriptor. That’s important <span aria-label=" Page 195. " epub:type="pagebreak" id="pg_195" role="doc-pagebreak"></span>information, and various Win32 APIs use it, as we’ll discuss in <span class="Xref">“Win32 Security APIs” on page 208.</span></p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h5 class="H3" id="sec7"><span id="h3-6"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Both the Creator and Parent Security Descriptors</samp></h5>
<p class="TNI1">In the final case, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> with a name and specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> field, setting both the creator and parent security descriptor parameters. To witness the resulting behavior, let’s define some test code. <a href="chapter6.xhtml#Lis6-22">Listing 6-22</a> writes a function to generate a creator security descriptor. We’ll reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NewSD</samp> function we wrote earlier to run the test.</p>
<span id="Lis6-22"></span><pre><code>PS&gt; <b>function New-CreatorSD($AceFlags = 0, $Control = 0, [switch]$NoDacl) {</b>
<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode">❶</span><b> $creator = New-NtSecurityDescriptor -Type Mutant</b>
<b>  </b><span aria-label="annotation2" class="CodeAnnotationCode">❷</span><b> if (!$NoDacl) {</b>
<b>      </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span><b> Add-NtSecurityDescriptorAce $creator -Name "Network" -Access GenericAll</b>
<b>        Add-NtSecurityDescriptorAce $creator -Name "Interactive"</b>
<b>-Access GenericAll -Flags $AceFlags</b>
<b>    }</b>
<b>    Add-NtSecurityDescriptorControl $creator -Control $Control</b>
<b>    Edit-NtSecurityDescriptor $creator -MapGeneric</b>
<b>    return $creator</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-22: The New-CreatorSD test function</span></p>
<p class="TX">This function differs from the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ParentSD</samp> function created in <a href="chapter6.xhtml#Lis6-13">Listing 6-13</a> in the following ways: we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> type when creating the security descriptor <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, we allow the caller to not specify a DACL <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, and we set a different SID for the DACL if it is used <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. These changes will allow us to distinguish the parts of a new security descriptor that come from the parent and those that come from the creator.</p>
<p class="TX">In some simple cases, the parent security descriptor has no inheritable DACL, and the API follows the same rules it uses when only the creator security descriptor is set. In other words, if the creator specifies the DACL, the new security descriptor will use it. Otherwise, it will use the default DACL.</p>
<p class="TX">If the parent security descriptor contains an inheritable DACL, the new security descriptor will inherit it, unless the creator security descriptor also has a DACL. Even an empty or NULL DACL will override the inheritance from the parent. In <a href="chapter6.xhtml#Lis6-23">Listing 6-23</a>, we verify this behavior.</p>
<span id="Lis6-23"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$creator = New-CreatorSD -NoDacl</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Test-NewSD -Creator $creator -AceFlags "ObjectInherit, InheritOnly"</b>
-= Parent SD =-
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt;
Everyone: (Allowed)(None)(Full Access)
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> BUILTIN\Users: (Allowed)(ObjectInherit, InheritOnly)(GenericAll)

-= Creator SD =-
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> &lt;NO SECURITY INFORMATION&gt;

<span aria-label=" Page 196. " epub:type="pagebreak" id="pg_196" role="doc-pagebreak"></span>-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt;
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> BUILTIN\Users: (Allowed)(None)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-23: Testing parent DACL inheritance with no creator DACL</span></p>
<p class="TX">We first build a creator security descriptor with no DACL <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, then run the test with an inheritable parent security descriptor <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In the output, we confirm the inheritable ACE for the <i>Users</i> group <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and that the creator has no DACL set <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. When we create the new security descriptor, it receives the inheritable ACE <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
<p class="TX">Let’s also check what happens when we set a creator DACL (<a href="chapter6.xhtml#Lis6-24">Listing 6-24</a>).</p>
<span id="Lis6-24"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$creator = New-CreatorSD</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Test-NewSD -Creator $creator -AceFlags "ObjectInherit, InheritOnly"</b>
-= Parent SD =-
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt;
Everyone: (Allowed)(None)(Full Access)
BUILTIN\Users: (Allowed)(ObjectInherit, InheritOnly)(GenericAll)

-= Creator SD =-
&lt;DACL&gt;
NT AUTHORITY\NETWORK: (Allowed)(None)(Full Access)
NT AUTHORITY\INTERACTIVE: (Allowed)(None)(Full Access)

-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt;
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> NT AUTHORITY\NETWORK: (Allowed)(None)(Full Access)
NT AUTHORITY\INTERACTIVE: (Allowed)(None)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-24: Testing the overriding of parent DACL inheritance by the creator DACL</span></p>
<p class="TX">Here, we build the creator security descriptor with a DACL <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and keep the same inheritable parent security descriptor as in <a href="chapter6.xhtml#Lis6-23">Listing 6-23</a> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In the output, we see that the ACEs from the creator’s DACL have been copied to the new security descriptor <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">The previous two tests haven’t specified any auto-inherit flags. If we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> control flag on the parent security descriptor but include no creator DACL, then the inheritance proceeds in the same way as in <a href="chapter6.xhtml#Lis6-24">Listing 6-24</a>, except that it sets the inherited ACE flags.</p>
<p class="TX">However, something interesting happens if we specify both a creator DACL and the control flag (<a href="chapter6.xhtml#Lis6-25">Listing 6-25</a>).</p>
<span id="Lis6-25"></span><pre><code><span aria-label=" Page 197. " epub:type="pagebreak" id="pg_197" role="doc-pagebreak"></span><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$creator = New-CreatorSD -AceFlags "Inherited"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Test-NewSD -Creator $creator -AceFlags "ObjectInherit, InheritOnly"</b>
<b>-Control "DaclAutoInherited"</b>
-= Parent SD =-
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt; (Auto Inherited)
Everyone: (Allowed)(None)(Full Access)
BUILTIN\Users: (Allowed)(ObjectInherit, InheritOnly)(GenericAll)

-= Creator SD =-
&lt;DACL&gt;
NT AUTHORITY\NETWORK: (Allowed)(None)(Full Access)
NT AUTHORITY\INTERACTIVE: (Allowed)(Inherited)(Full Access)

-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt; (Auto Inherited)
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> NT AUTHORITY\NETWORK: (Allowed)(None)(Full Access)
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> BUILTIN\Users: (Allowed)(Inherited)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-25: Testing parent DACL inheritance when the creator DACL and the DaclAutoInherited control flag are set</span></p>
<p class="TX">In this listing, we build a creator security descriptor and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">INTERACTIVE</samp> SID ACE to include the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> flag <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Next, we run the test with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> control flag on the parent security descriptor <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In the output, notice that there are two ACEs. The first ACE was copied from the creator <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, while the second is the inherited ACE from the parent <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. <a href="chapter6.xhtml#fig6-1">Figure 6-1</a> shows this auto-inheritance behavior.</p>
<figure class="IMG"><img alt="" class="img1" height="519" id="fig6-1" src="../images/Figure6-1.jpg" width="1340"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: The auto-inheritance behavior when the parent and creator security descriptors are both set</samp></p></figcaption>
</figure>
<p class="TX">When <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> is set, the new security descriptor’s DACL merges the non-inherited ACEs from the creator security descriptor with the inheritable ACEs from the parent. This auto-inheritance behavior allows you to rebuild a child’s security descriptor based on its parent without losing any <span aria-label=" Page 198. " epub:type="pagebreak" id="pg_198" role="doc-pagebreak"></span>ACEs that the user has explicitly added to the DACL. Additionally, the automatic setting of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> ACE flag lets us differentiate between these explicit and inherited ACEs.</p>
<p class="TX">Note that normal operations in the kernel do not set the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> flag, which is enabled only if the parent security descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> control flag set and the DACL isn’t present. In our test, we specified a DACL, so the auto-inherit flag was not set. The Win32 APIs use this behavior, as we’ll discuss later in this chapter.</p>
<p class="TX">If you want to suppress the merging of the explicit ACEs and the parent’s inheritable ACEs, you can set the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> and/or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> security descriptor control flags. If a protected control flag is set, the inheritance rules leave the respective ACL alone, other than setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoInherited</samp> control flag for the ACL and clearing any inherited ACE flags. In <a href="chapter6.xhtml#Lis6-26">Listing 6-26</a>, we test this behavior for the DACL.</p>
<span id="Lis6-26"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$creator = New-CreatorSD -AceFlags "Inherited" -Control "DaclProtected"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Test-NewSD -Creator $creator -AceFlags "ObjectInherit, InheritOnly"</b>
<b>-Control "DaclAutoInherited"</b>
-= Parent SD =-
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt; (Auto Inherited)
Everyone: (Allowed)(None)(Full Access)
BUILTIN\Users: (Allowed)(ObjectInherit, InheritOnly)(GenericAll)

-= Creator SD =-
&lt;DACL&gt; (Protected)
NT AUTHORITY\NETWORK: (Allowed)(None)(Full Access)
NT AUTHORITY\INTERACTIVE: (Allowed)(Inherited)(Full Access)

-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt; (Protected, Auto Inherited)
NT AUTHORITY\NETWORK: (Allowed)(None)(Full Access)
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> NT AUTHORITY\INTERACTIVE: (Allowed)(None)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-26: Testing the DaclProtected control flag</span></p>
<p class="TX">We start by generating a creator security descriptor with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> flag, and setting one of the ACE’s flags to <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then create a new security descriptor with an auto-inherited parent <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> flag, the new security descriptor’s DACL would have been a merged version of the creator DACL and the inheritable ACEs from the parent. Instead, we see only the creator DACL’s ACEs. Also, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> flag on the second ACE has been cleared <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">What if we don’t know whether the parent security descriptor will have inheritable ACEs, and we don’t want to end up with the default DACL? This might be important for permanent objects, such as files or keys, as the default DACL contains the ephemeral logon SID, which shouldn’t really be <span aria-label=" Page 199. " epub:type="pagebreak" id="pg_199" role="doc-pagebreak"></span>persisted to disk. After all, reusing the logon SID could end up granting access to an unrelated user.</p>
<p class="TX">In this case, we can’t set a DACL in the creator security descriptor; according to inheritance rules, this would overwrite any inherited ACEs. Instead, we can handle this scenario using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclDefaulted</samp> security descriptor control flag, which indicates that the provided DACL is a default. <a href="chapter6.xhtml#Lis6-27">Listing 6-27</a> demonstrates its use.</p>
<span id="Lis6-27"></span><pre><code>PS&gt; <b>$creator = New-CreatorSD -Control "DaclDefaulted"</b>
PS&gt; <b>Test-NewSD -Creator $creator -AceFlags "ObjectInherit, InheritOnly"</b>
= Parent SD =-
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt;
Everyone: (Allowed)(None)(Full Access)
BUILTIN\Users: (Allowed)(ObjectInherit, InheritOnly)(GenericAll)

-= Creator SD =-
&lt;DACL&gt; (Defaulted)
NT AUTHORITY\NETWORK: (Allowed)(None)(Full Access)
NT AUTHORITY\INTERACTIVE: (Allowed)(None)(Full Access)

-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt;
BUILTIN\Users: (Allowed)(None)(Full Access)

PS&gt; <b>Test-NewSD -Creator $creator</b>
-= Parent SD =-
&lt;Owner&gt; : BUILTIN\Administrators
&lt;Group&gt; : BUILTIN\Administrators
&lt;DACL&gt;
Everyone: (Allowed)(None)(Full Access)
BUILTIN\Users: (Allowed)(None)(Full Access)

-= Creator SD =-
&lt;DACL&gt; (Defaulted)
NT AUTHORITY\NETWORK: (Allowed)(None)(Full Access)
NT AUTHORITY\INTERACTIVE: (Allowed)(None)(Full Access)

-= New SD =-
&lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt;
NT AUTHORITY\NETWORK: (Allowed)(None)(Full Access)
NT AUTHORITY\INTERACTIVE: (Allowed)(None)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-27: Testing the DaclDefaulted flag</span></p>
<p class="TX">If the parent does not contain any inheritable DACL ACEs, the new security descriptor will use the creator’s DACL instead of the default. If the <span aria-label=" Page 200. " epub:type="pagebreak" id="pg_200" role="doc-pagebreak"></span>parent does contain inheritable ACEs, the inheritance process will overwrite the DACL, following the rules outlined previously.</p>
<p class="TX">To implement similar behavior for the SACL, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclDefaulted</samp> control flag. However, tokens don’t contain a default SACL, so this flag is somewhat less important.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h5 class="H3" id="sec8"><span id="h3-7"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Replacing the CREATOR OWNER and CREATOR GROUP SIDs</samp></h5>
<p class="TNI1">We’ve seen that, during inheritance, an inherited ACE retains the same SID as the original. In some scenarios, this isn’t desirable. For example, you might have a shared directory that allows any user to create a child directory. What security descriptor could you set on this shared directory so that only the creator of the child directory has access to it?</p>
<p class="TX">One solution would be to remove all inheritable ACEs. As a result, the new directory would use the default DACL. This would almost certainly secure the directory to prevent other users from accessing it. However, as mentioned in the previous section, the default DACL is designed for ephemeral resources, such as those in the object manager; persistent security descriptors shouldn’t use it.</p>
<p class="TX">To accommodate features such as shared directories, the inheritance implementation supports four special creator SIDs. When a security descriptor inherits an ACE with any of these SIDs, the inheritance implementation will replace the creator SID with a specific SID from the creator’s token:</p>
<p class="RunInPara1"><b><i>CREATOR OWNER</i></b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(S-1-3-0)  </samp>Replaced by the token’s owner</p>
<p class="RunInPara"><b><i>CREATOR GROUP</i></b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(S-1-3-1)  </samp>Replaced by the token’s primary group</p>
<p class="RunInPara"><b><i>CREATOR OWNER SERVER</i></b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">S-1-3-2)  </samp>Replaced by the server’s owner</p>
<p class="RunInPara2"><b><i>CREATOR GROUP SERVER</i></b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(S-1-3-3)  </samp>Replaced by the server’s primary group</p>
<p class="TX">We use the server SIDs only when creating a server security descriptor, which we’ll discuss in <span class="Xref">“Server Security Descriptors and Compound ACEs” on page 213</span>. The conversion from the creator SID to a specific SID is a one-way process: once the SID has been replaced, you can’t tell it apart from a SID you set explicitly. However, if a container has inherited the ACE, it will keep the creator SID in the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ACE. <a href="chapter6.xhtml#Lis6-28">Listing 6-28</a> provides an example.</p>
<span id="Lis6-28"></span><pre><code>PS&gt; <b>$parent = New-NtSecurityDescriptor -Type Directory</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $parent -KnownSid CreatorOwner</b>
<b>-Flags ContainerInherit, InheritOnly -Access GenericWrite</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $parent -KnownSid CreatorGroup</b>
<b>-Flags ContainerInherit, InheritOnly -Access GenericRead</b>
PS&gt; <b>Format-NtSecurityDescriptor $parent -Summary -SecurityInformation Dacl</b>
&lt;DACL&gt;
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> CREATOR OWNER: (Allowed)(ContainerInherit, InheritOnly)(GenericWrite)
CREATOR GROUP: (Allowed)(ContainerInherit, InheritOnly)(GenericRead)

<span aria-label=" Page 201. " epub:type="pagebreak" id="pg_201" role="doc-pagebreak"></span>PS&gt; <b>$token = Get-NtToken -Effective -Pseudo</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Token $token -Parent $parent</b>
<b>-Type Directory</b> <b>-Container</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -Summary -SecurityInformation Dacl</b>
&lt;DACL&gt;
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> GRAPHITE\user: (Allowed)(None)(CreateObject|CreateSubDirectory|ReadControl)
CREATOR OWNER: (Allowed)(ContainerInherit, InheritOnly)(GenericWrite)
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> GRAPHITE\None: (Allowed)(None)(Query|Traverse|ReadControl)
CREATOR GROUP: (Allowed)(ContainerInherit, InheritOnly)(GenericRead)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-28: Testing creator SIDs during inheritance</span></p>
<p class="TX">We first add two ACEs with the <i>CREATOR OWNER</i> and <i>CREATOR GROUP</i> SIDs to a parent security descriptor, giving the ACEs different levels of access to make them easy to distinguish <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then create a new security descriptor based on the parent, specifying that we’ll use it for a container <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In the formatted output, we see that the user’s SID has replaced the <i>CREATOR OWNER</i> SID. This SID is based on the owner SID in the token <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We also can see that the <i>CREATOR GROUP</i> SID has been replaced with the group SID from the token <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">As we’ve created the security descriptor for a container, we also see that there are two <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ACEs whose creator SID has not been changed. This behavior allows the creator SID to propagate to any future children.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h5 class="H3" id="sec9"><span id="h3-8"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Assigning Mandatory Labels</samp></h5>
<p class="TNI1">The mandatory label ACE contains the integrity level of a resource. But when we create a new security descriptor using a token whose integrity level is greater than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, the new security descriptor won’t receive a mandatory label by default. This behavior explains why we haven’t seen any mandatory label ACEs in our tests so far.</p>
<p class="TX">If the token’s integrity level is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, on the other hand, this label is automatically assigned to the new security descriptor, as shown in <a href="chapter6.xhtml#Lis6-29">Listing 6-29</a>.</p>
<span id="Lis6-29"></span><pre><code>PS&gt; <b>$token = Get-NtToken -Duplicate -IntegrityLevel Low</b>
PS&gt; <b>$sd = New-NtSecurityDescriptor -Token $token -Type Mutant</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -SecurityInformation Label -Summary</b>
&lt;Mandatory Label&gt;
Mandatory Label\Low Mandatory Level: (MandatoryLabel)(None)(NoWriteUp)
PS&gt; <b>$token.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-29: Assigning the mandatory label of the creator’s token</span></p>
<p class="TX">In this listing, we duplicate the current token and assign it a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity level. When we create a new security descriptor based on the token, we see that it has a mandatory label with the same integrity level.</p>
<p class="TX">An application can set a mandatory label ACE explicitly when creating a new resource through the creator security descriptor. However, the integrity level in the mandatory label ACE must be less than or equal to the token’s integrity level; otherwise, the creation will fail, as shown in <a href="chapter6.xhtml#Lis6-30">Listing 6-30</a>.</p>
<span id="Lis6-30"></span><pre><code><span aria-label=" Page 202. " epub:type="pagebreak" id="pg_202" role="doc-pagebreak"></span>PS&gt; <b>$creator = New-NtSecurityDescriptor -Type Mutant</b>
PS&gt; <b>Set-NtSecurityDescriptorIntegrityLevel $creator System</b>
PS&gt; <b>$token = Get-NtToken -Duplicate -IntegrityLevel Medium</b>
PS&gt; <b>New-NtSecurityDescriptor -Token $token -Creator $creator -Type Mutant</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> New-NtSecurityDescriptor : (0xC0000061) - A required privilege is not held
by the client.

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Token $token -Creator $creator </b>
<b>-Type Mutant -AutoInherit AvoidPrivilegeCheck</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -SecurityInformation Label -Summary</b>
&lt;Mandatory Label&gt;
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Mandatory Label\System Mandatory Level: (MandatoryLabel)(None)(NoWriteUp)

PS&gt; <b>$token.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-30: Assigning a mandatory label based on the creator security descriptor</span></p>
<p class="TX">First, we create a new creator security descriptor and add a mandatory label with the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> integrity level to it. We then get the caller’s token and set its integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> integrity level is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, if we attempt to use the creator security descriptor to create a new security descriptor, the operation fails with a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT_HELD</samp> error <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>.</p>
<p class="TX">To set a higher integrity level, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp> privilege must be enabled on the creator token, or you must specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidPrivilegeCheck</samp> auto-inherit flag. In this example, we set the auto-inherit flag when creating the new security descriptor <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. With this addition the creation succeeds, and we can see the mandatory label in the formatted output <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">We can make the mandatory label ACE inheritable by setting its <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> flag. It’s also possible to specify its <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> flag, which prevents the integrity level from being used as part of an access check, reserving it for inheritance only.</p>
<p class="TX">Keep in mind, though, that integrity-level restrictions apply to inherited mandatory label ACEs too. The inherited ACE must have an integrity level that is less than or equal to the token’s; otherwise, the security descriptor assignment will fail. Again, we can bypass this restriction with either the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp> privilege or the <samp class="SANS_TheSansMonoCd_W5Regular_11">AvoidPrivilegeCheck</samp> auto-inherit flag. <a href="chapter6.xhtml#Lis6-31">Listing 6-31</a> shows an example in which a security descriptor inherits the mandatory label ACE.</p>
<span id="Lis6-31"></span><pre><code>PS&gt; <b>$parent = New-NtSecurityDescriptor -Type Mutant</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Set-NtSecurityDescriptorIntegrityLevel $parent Low -Flags ObjectInherit</b>
PS&gt; <b>$token = Get-NtToken -Effective -Pseudo</b>
PS&gt; <b>$sd = New-NtSecurityDescriptor -Token $token -Parent $parent -Type Mutant</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -SecurityInformation Label -Summary</b>
&lt;Mandatory Label&gt;
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Mandatory Label\Low Mandatory Level: (MandatoryLabel)(Inherited)(NoWriteUp)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-31: Assigning a mandatory label from a parent security descriptor through inheritance</span></p>
<p class="TX"><span aria-label=" Page 203. " epub:type="pagebreak" id="pg_203" role="doc-pagebreak"></span>First, we create a parent security descriptor and assign it a mandatory label ACE with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity level and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> flag set <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then create a new security descriptor using the parent. The new security descriptor inherits the mandatory label, as indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> flag <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Certain kernel object types might receive the mandatory label automatically, even if the caller’s token has an integrity level greater than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>. By specifying certain auto-inherit flags, you can always assign the caller’s integrity level when creating a new security descriptor for the resource. These flags include <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoExecuteUp</samp>, which auto-inherit the token’s integrity level and set the mandatory policy to <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">NoExecuteUp</samp>, respectively. By combining these flags, you can get the desired mandatory policy.</p>
<p class="TX">In the latest versions of Windows, only four types are registered to use these auto-inherit flags, as shown in <a href="chapter6.xhtml#tab6-5">Table 6-5</a>.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab6-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Types with Integrity Level Auto-inherit Flags Enabled</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Type name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Auto-inherit flags</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Job</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">We can test the behavior of these auto-inherit flags by specifying them when we create a security descriptor. In <a href="chapter6.xhtml#Lis6-32">Listing 6-32</a>, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoReadUp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaclNoWriteUp</samp> auto-inherit flags.</p>
<span id="Lis6-32"></span><pre><code>PS&gt; <b>$token = Get-NtToken -Effective -Pseudo</b>
PS&gt; <b>$sd = New-NtSecurityDescriptor -Token $token -Type Mutant</b>
<b>-AutoInherit MaclNoReadUp, MaclNoWriteUp</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -SecurityInformation Label -Summary</b>
&lt;Mandatory Label&gt;
Mandatory Label\Medium Mandatory Level: (MandatoryLabel)(None)(NoWriteUp|
NoReadUp)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-32: Assigning a mandatory label by specifying auto-inherit flags</span></p>
<p class="TX">In the output, we can see a mandatory label ACE with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> integrity level, even though I mentioned at the start of this section that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> level wouldn’t normally be assigned. We can also see that the mandatory policy has been set to <samp class="SANS_TheSansMonoCd_W5Regular_11">NoWriteUp|NoReadUp</samp>, which matches the auto-inherit flags we specified.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h5 class="H3" id="sec10"><span id="h3-9"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Determining Object Inheritance</samp></h5>
<p class="TNI1">When we specify an object ACE type, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp>, in a parent security descriptor, the inheritance rules change slightly. This is because each object ACE can contain two optional GUIDs: <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>, used for access checking, and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>, used for inheritance.</p>
<p class="TX"><span aria-label=" Page 204. " epub:type="pagebreak" id="pg_204" role="doc-pagebreak"></span>The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx</samp> API uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> GUID in an ACE to calculate whether a new security descriptor should inherit that ACE. If this GUID exists and its value matches the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> GUID, the new security descriptor will inherit the ACE. By contrast, if the values don’t match, the ACE won’t be copied. <a href="chapter6.xhtml#tab6-6">Table 6-6</a> shows the possible combinations of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> parameter and <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> and whether the ACE is inherited.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab6-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Whether to Inherit the ACE Based on</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> <samp class="SANS_Futura_Std_Heavy_B_11">parameter specified?</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> <samp class="SANS_Futura_Std_Heavy_B_11">in ACE?</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Inherited</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">No</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">No</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">No</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Heavy_B_11">No</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">No</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Yes (and the values match)</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Yes</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Yes (and the values don’t match)</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Heavy_B_11">No</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">I’ve bolded the cases in <a href="chapter6.xhtml#tab6-6">Table 6-6</a> where inheritance doesn’t happen. Note that this doesn’t supersede any other inheritance decision: the ACE must have the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInherit</samp> and/or <samp class="SANS_TheSansMonoCd_W5Regular_11">ContainerInherit</samp> flag set to be considered for inheritance.</p>
<p class="TX">In <a href="chapter6.xhtml#Lis6-33">Listing 6-33</a>, we verify this behavior by adding some object ACEs to a security descriptor and using it as the parent.</p>
<span id="Lis6-33"></span><pre><code>PS&gt; <b>$owner = Get-NtSid -KnownSid BuiltinAdministrators</b>
PS&gt; <b>$parent = New-NtSecurityDescriptor -Type Directory -Owner $owner -Group $owner</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$type_1 = New-Guid</b>
PS&gt; <b>$type_2 = New-Guid</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Add-NtSecurityDescriptorAce $parent -Name "SYSTEM" -Access GenericAll</b>
<b>-Flags ObjectInherit -Type AllowedObject -ObjectType $type_1</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Add-NtSecurityDescriptorAce $parent -Name "Everyone" -Access GenericAll</b>
<b>-Flags ObjectInherit -Type AllowedObject -InheritedObjectType $type_1</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Add-NtSecurityDescriptorAce $parent -Name "Users" -Access GenericAll</b>
<b>-Flags ObjectInherit -InheritedObjectType $type_2 -Type AllowedObject</b>
PS&gt; <b>Format-NtSecurityDescriptor $parent -Summary -SecurityInformation Dacl</b>
&lt;DACL&gt;
NT AUTHORITY\SYSTEM: (AllowedObject)(ObjectInherit)(GenericAll) (OBJ:f5ee1953...)
Everyone: (AllowedObject)(ObjectInherit)(GenericAll)(IOBJ:f5ee1953...)
BUILTIN\Users: (AllowedObject)(ObjectInherit)(GenericAll)(IOBJ:0b9ed996...)

PS&gt; <b>$token = Get-NtToken -Effective -Pseudo</b>
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>$sd = New-NtSecurityDescriptor -Token $token -Parent $parent</b>
<b>-Type Directory -ObjectType $type_2</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -Summary -SecurityInformation Dacl</b>
&lt;DACL&gt;
<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> NT AUTHORITY\SYSTEM: (AllowedObject)(None)(Full Access)(OBJ:f5ee1953...)
<span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> BUILTIN\Users: (Allowed)(None)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-33: Verifying the behavior of the InheritedObjectType GUID</span></p>
<p class="TX"><span aria-label=" Page 205. " epub:type="pagebreak" id="pg_205" role="doc-pagebreak"></span>We first generate a couple of random GUIDs to act as our object types <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Next, we add three inheritable <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp> ACEs to the parent security descriptor. In the first ACE, we set <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> to the first GUID we created <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This ACE demonstrates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> GUID is not considered when inheriting the ACE. The second ACE sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> to the first GUID <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The final ACE uses the second GUID <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">We then create a new security descriptor, passing the second GUID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> parameter <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. When we check the new security descriptor, we can see that it inherited the ACE without the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. The second ACE in the output is a copy of the ACE with an <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> GUID that matches <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. Notice that, based on the output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> has been removed, as the ACE is no longer inheritable.</p>
<p class="TX">Having a single <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> GUID parameter is somewhat inflexible, so Windows also provides two APIs that take a list of GUIDs rather than a single GUID: the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignSecurityEx2</samp> kernel API and the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectWithMultipleInheritance</samp> user-mode API. Any ACE in the list with the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp> will be inherited; otherwise, the inheritance rules are basically the same as those covered here.</p>
<p class="TX">This concludes our discussion on assigning security descriptors during creation. As you’ve seen, the assignment process is complex, especially with regard to inheritance. We’ll now discuss assigning a security descriptor to an existing resource, a considerably simpler process.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H2" id="sec11"><span id="h2-67"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning a Security Descriptor to an Existing Resource</samp></h4>
<p class="TNI1">If a resource already exists, it’s not possible to set the security descriptor by calling a creation system call such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> and specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> field in the object attributes. Instead, you need to open a handle to the resource with one of three access rights, depending on what part of the security descriptor you want to modify. Once you have this handle, you can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp> system call to set specific security descriptor information. <a href="chapter6.xhtml#tab6-7">Table 6-7</a> shows the access rights needed to set each security descriptor field based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> enumeration.</p>
<p class="Anchor"><span aria-label=" Page 206. " epub:type="pagebreak" id="pg_206" role="doc-pagebreak"></span></p>
<table class="Basic-Table">
<caption><p class="TT" id="tab6-7"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-7:</samp></span> <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> <samp class="SANS_Futura_Std_Book_11">Flags and Required Access for Security Descriptor Creation</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Location</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Handle access required</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set the owner SID.</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Owner</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set the group SID.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Group</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Dacl</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set the DACL.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">DACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Sacl</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set the SACL (for auditing ACEs only).</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set the mandatory label.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Attribute</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set a system resource attribute.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Scope</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set a scoped policy ID.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTrustLabel</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set the process trust label.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AccessFilter</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set an access filter.</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">SACL</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Backup</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Set everything except the process trust label and access filter.</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">All</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">You might notice that the handle access required for setting this information is more complex than the access needed to merely query it (covered in <a href="chapter6.xhtml#tab6-1">Table 6-1</a>), as it is split across three access rights instead of two. Rather than trying to memorize these access rights, you can retrieve them using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp> PowerShell command, specifying the parts of the security descriptor you want to set with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> parameter, as shown in <a href="chapter6.xhtml#Lis6-34">Listing 6-34</a>.</p>
<span id="Lis6-34"></span><pre><code>PS&gt; <b>Get-NtAccessMask -SecurityInformation AllBasic -ToGenericAccess</b>
ReadControl

PS&gt; <b>Get-NtAccessMask -SecurityInformation AllBasic -ToGenericAccess</b>
<b>-SetSecurity</b>
WriteDac, WriteOwner
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-34: Discovering the access mask needed to query or set specific security descriptor information</span></p>
<p class="TX">To set a security descriptor, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp> system call invokes a type-specific security function. This type-specific function allows the kernel to support the different storage requirements for security descriptors; for example, a file must persist its security descriptor to disk, while the object manager can store a security descriptor in memory.</p>
<p class="TX">These type-specific functions eventually call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSetSecurityDescriptorInfoEx</samp> kernel API to build the updated security descriptor. User mode exports this kernel API as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetSecurityObjectEx</samp>. Once the security descriptor has been updated, the type-specific function can store it using its preferred mechanism.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSetSecurityDescriptorInfoEx</samp> API accepts the following five parameters and returns a new security descriptor:</p>
<p class="RunInPara1"><b>Modification security descriptor    </b>The new security descriptor passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp></p>
<p class="RunInPara"><b>Object security descriptor    </b>The current security descriptor for the object being updated</p>
<p class="RunInPara"><b>Security information    </b>Flags to specify what parts of the security descriptor to update, described in <a href="chapter6.xhtml#tab6-7">Table 6-7</a></p>
<p class="RunInPara"><b>Auto-inherit    </b>A set of bit flags that define the auto-inheritance behavior</p>
<p class="RunInPara2"><b>Generic mapping    </b>The generic mapping for the type being created</p>
<p class="TX"><span aria-label=" Page 207. " epub:type="pagebreak" id="pg_207" role="doc-pagebreak"></span>No kernel code uses the auto-inherit flags; therefore, the behavior of this API is simple. It merely copies the parts of the security descriptor specified in the security information parameter to the new security descriptor. It also maps any generic access to the type-specific access using the generic mapping, excluding <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnly</samp> ACEs.</p>
<p class="TX">Some security descriptor control flags introduce special behavior. For example, it’s not possible to explicitly set <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp>, but you can specify it along with <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInheritReq</samp> to set it on the new security descriptor.</p>
<p class="TX">We can test out the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetSecurityObjectEx</samp> API using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp> command, as shown in <a href="chapter6.xhtml#Lis6-35">Listing 6-35</a>.</p>
<span id="Lis6-35"></span><pre><code>PS&gt; <b>$owner = Get-NtSid -KnownSid BuiltinAdministrators</b>
PS&gt; <b>$obj_sd = New-NtSecurityDescriptor -Type Mutant -Owner $owner</b>
<b>-Group $owner</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $obj_sd -KnownSid World -Access GenericAll</b>
PS&gt; <b>Format-NtSecurityDescriptor $obj_sd -Summary -SecurityInformation Dacl</b>
&lt;DACL&gt;
Everyone: (Allowed)(None)(Full Access)

PS&gt; <b>Edit-NtSecurityDescriptor $obj_sd -MapGeneric</b>
PS&gt; <b>$mod_sd = New-NtSecurityDescriptor -Type Mutant</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $mod_sd -KnownSid Anonymous</b>
<b>-Access GenericRead</b>
PS&gt; <b>Set-NtSecurityDescriptorControl $mod_sd DaclAutoInherited,</b>
<b>DaclAutoInheritReq</b>
PS&gt; <b>Edit-NtSecurityDescriptor $obj_sd $mod_sd -SecurityInformation Dacl</b>
PS&gt; <b>Format-NtSecurityDescriptor $obj_sd -Summary -SecurityInformation Dacl</b>
&lt;DACL&gt; (Auto Inherited)
NT AUTHORITY\ANONYMOUS LOGON: (Allowed)(None)(ModifyState|ReadControl)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-35: Using Edit-NtSecurityDescriptor to modify an existing security descriptor</span></p>
<p class="TX">You can set the security for a kernel object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtSecurityDescriptor</samp> command. The command can accept either an object handle with the required access or an OMNS path to the resource. For example, you could use the following commands to try to modify the object <i>\BaseNamedObjects\ABC</i> by setting a new DACL:</p>
<pre><code>PS&gt; <b>$new_sd = New-NtSecurityDescriptor -Sddl "D:(A;;GA;;;WD)"</b>
PS&gt; <b>Set-NtSecurityDescriptor -Path "\BaseNamedObjects\ABC"</b>
<b>-SecurityDescriptor $new_sd -SecurityInformation Dacl</b>
</code></pre>
<p class="TX">Note the “try to”: even if you can open a resource with the required access to set a security descriptor component, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access, this doesn’t mean the kernel will let you do it. The same rules regarding owner SIDs and mandatory labels apply here as when assigning a security descriptor at creation time.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSetSecurityDescriptorInfoEx</samp> API enforces these rules. If no object security descriptor is specified, then the API returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NO_SECURITY _ON_OBJECT</samp> status code. Therefore, you can’t set the security descriptor for a type with <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityRequired</samp> set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>; that object won’t have a security descriptor, so any attempt to modify it causes the error.</p>
<blockquote>
<span aria-label=" Page 208. " epub:type="pagebreak" id="pg_208" role="doc-pagebreak"></span>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>One ACE flag I haven’t mentioned yet is Critical. The Windows kernel contains code to check the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Critical</samp> flag and block the removal of ACEs that have the flag set. However, which ACEs to deem <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Critical</samp> is up to the code assigning the new security descriptor, and APIs such as <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeSetSecurityInformationEx</samp> do not enforce it. Therefore, do not rely on the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Critical</samp> flag to do anything specific. If you’re using security descriptors in user mode, you can handle the flag any way you like.</i></p>
</blockquote>
<p class="TX">What happens if you change the inheritable ACEs on a container? Will the changes in the security descriptor propagate to all existing children? In a word, no. Technically, a type could implement this automatic propagation behavior, but none do. Instead, it’s up to the user-mode components to handle it. Next, we’ll look at the user-mode Win32 APIs that implement this propagation.</p>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="h1-54"></span><samp class="SANS_Futura_Std_Bold_B_11">Win32 Security APIs</samp></h3>
<p class="TNI1">Most applications don’t directly call the kernel system calls to read or set security descriptors. Instead, they use a range of Win32 APIs. While we won’t discuss every API you could use here, we’ll cover some of the additional functionality the APIs add to the underlying system calls.</p>
<p class="TX">Win32 implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKernelObjectSecurity</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetKernelObjectSecurity</samp> APIs, which wrap <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp>. Likewise, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreatePrivateObjectSecurityEx</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetPrivateObjectSecurityEx</samp> Win32 APIs wrap <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlSetSecurityObjectEx</samp>, respectively. Every property of the native APIs discussed in this chapter applies equally to these Win32 APIs.</p>
<p class="TX">However, Win32 also provides some higher-level APIs: most notably, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetNamedSecurityInfo</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>. These APIs allow an application to query or set a security descriptor by providing a path and the type of resource that path refers to, rather than a handle. The use of a path and type allows the functions to be more general; for example, these APIs support getting and setting the security of not only files and registry keys but also services, printers, and Active Directory Domain Services (DS) entries.</p>
<p class="TX">To query or set the security descriptor, the API must open the specified resource and then call the appropriate API to perform the operation. For example, to query a file’s security descriptor, the API would open the file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp> Win32 API and then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySecurityObject</samp> system call. However, to query a printer’s security descriptor, the Win32 API needs to open the printer using the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenPrinter</samp> print spooler API and then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetPrinter</samp> API on the opened printer handle (as a printer is not a kernel object).</p>
<p class="TX">PowerShell already uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetNamedSecurityInfo</samp> API through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp> command; however, the built-in command doesn’t support reading certain security descriptor ACEs, such as mandatory labels. Therefore, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module implements <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32SecurityDescriptor</samp>, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetNamedSecurityInfo</samp> and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> object.</p>
<p class="TX"><span aria-label=" Page 209. " epub:type="pagebreak" id="pg_209" role="doc-pagebreak"></span>If you merely want to display the security descriptor, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Win32SecurityDescriptor</samp> command, which takes the same parameters but doesn’t return a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> object. <a href="chapter6.xhtml#Lis6-36">Listing 6-36</a> provides a couple of examples of commands that leverage the underlying Win32 security APIs.</p>
<span id="Lis6-36"></span><pre><code>PS&gt; <b>Get-Win32SecurityDescriptor "$env:WinDir"</b>
Owner                       DACL ACE Count SACL ACE Count Integrity Level
-----                       -------------- -------------- ---------------
NT SERVICE\TrustedInstaller 13             NONE           NONE

PS&gt; <b>Format-Win32SecurityDescriptor "MACHINE\SOFTWARE" -Type RegistryKey</b>
<b>-Summary</b>
&lt;Owner&gt; : NT AUTHORITY\SYSTEM
&lt;Group&gt; : NT AUTHORITY\SYSTEM
&lt;DACL&gt; (Protected, Auto Inherited)
BUILTIN\Users: (Allowed)(ContainerInherit)(QueryValue|...)
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-36: An example usage of Get-Win32SecurityDescriptor and Format-Win32SecurityDescriptor</span></p>
<p class="TX">We start by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32SecurityDescriptor</samp> to query the security descriptor for the <i>Windows</i> directory, in this case <samp class="SANS_TheSansMonoCd_W5Regular_11">$env:WinDir</samp>. Note that we don’t specify the type of resource we want to query, as it defaults to a file. In the second example, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Win32Security Descriptor</samp> to display the security descriptor for the <i>MACHINE\SOFTWARE</i> key. This key path corresponds to the Win32 <i>HKEY_LOCAL_MACHINE\SOFTWARE</i> key path. We need to indicate that we’re querying a registry key by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> parameter; otherwise, the command will try to open the path as a file, which is unlikely to work.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>To find the path format for every supported type of object, consult the API documentation for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SE_OBJECT_TYPE</samp> enumeration, which is used to specify the type of resource in the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GetNamedSecurityInfo</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SetNamedSecurityInfo</samp> APIs.</i></p>
</blockquote>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp> API is more complex, as it implements auto-inheritance across hierarchies (for example, across a file directory tree). As we discussed earlier, if you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetSecurityObject</samp> system call to set a file’s security descriptor, any new inheritable ACEs won’t get propagated to any existing children. If you set a security descriptor on a file directory with <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>, the API will enumerate all child files and directories and attempt to update each child’s security descriptor.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp> API generates the new security descriptor by querying the child security descriptor and using it as the creator security descriptor in a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNewSecurityObjectEx</samp>, taking the parent security descriptor from the parent directory. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> flags are always set, to merge any explicit ACEs in the creator security descriptor into the new security descriptor.</p>
<p class="TX">PowerShell exposes the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp> API through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-Win32SecurityDescriptor</samp> command, as shown in <a href="chapter6.xhtml#Lis6-37">Listing 6-37</a>.</p>
<span id="Lis6-37"></span><pre><code><span aria-label=" Page 210. " epub:type="pagebreak" id="pg_210" role="doc-pagebreak"></span>PS&gt; <b>$path = Join-Path "$env:TEMP" "TestFolder"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Use-NtObject($f = New-NtFile $path -Win32Path -Options DirectoryFile</b>
<b>-Disposition OpenIf) {</b>
    <b>Set-NtSecurityDescriptor $f "D:AIARP(A;OICI;GA;;;WD)" Dacl</b>
<b>}</b>

PS&gt; <b>$item = Join-Path $path test.txt</b>
PS&gt; <b>"Hello World!" | Set-Content -Path $item</b>
PS&gt; <b>Format-Win32SecurityDescriptor $item -Summary -SecurityInformation Dacl</b>
&lt;DACL&gt; (Auto Inherited)
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Everyone: (Allowed)(Inherited)(Full Access)

PS&gt; <b>$sd = Get-Win32SecurityDescriptor $path</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $sd -KnownSid Anonymous -Access GenericAll</b>
<b>-Flags ObjectInherit,ContainerInherit,InheritOnly</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Set-Win32SecurityDescriptor $path $sd Dacl</b>
PS&gt; <b>Format-Win32SecurityDescriptor $item -Summary -SecurityInformation Dacl</b>
&lt;DACL&gt; (Auto Inherited)
Everyone: (Allowed)(Inherited)(Full Access)
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> NT AUTHORITY\ANONYMOUS LOGON: (Allowed)(Inherited)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-37: Testing auto-inheritance with Set-Win32SecurityDescriptor</span></p>
<p class="TX"><a href="chapter6.xhtml#Lis6-37">Listing 6-37</a> demonstrates the auto-inheritance behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp> for files. We first create the <i>TestFolder</i> directory in the root of the system drive, then set the security descriptor so that it contains one inheritable ACE for the <i>Everyone</i> group and has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> flags set <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Next, we create a text file inside the directory and print its security descriptor. The DACL contains the single ACE inherited from the parent by the text file <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">We then get the security descriptor from the directory and add a new inheritable ACE to it for the anonymous user. We use this security descriptor to set the DACL of the parent using <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-Win32SecurityDescriptor</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Printing the text file’s security descriptor again, we now see that it has two ACEs, as the anonymous user ACE has been added <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. If we had used <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtSecurityDescriptor</samp> to set the parent directory’s security descriptor, this inheritance would not have taken place.</p>
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp> always uses auto-inheritance, applying a protected security descriptor control flag, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp>, becomes an important way to block the automatic propagation of ACEs.</p>
<p class="TX">Oddly, the API doesn’t allow you to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> control flags directly in the security descriptor. Instead, it introduces some additional <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp> flags to handle setting and unsetting the control flags. To set a protected security descriptor control flag, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedDacl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedSacl</samp> flags for <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityInformation</samp>. To unset a flag, use <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedSacl</samp>. <a href="chapter6.xhtml#Lis6-38">Listing 6-38</a> provides examples of setting and unsetting the protected control flag for the DACL.</p>
<span id="Lis6-38"></span><pre><code><span aria-label=" Page 211. " epub:type="pagebreak" id="pg_211" role="doc-pagebreak"></span>PS&gt; <b>$path = Join-Path "$env:TEMP\TestFolder" "test.txt"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$sd = New-NtSecurityDescriptor "D:(A;;GA;;;AU)"</b>
PS&gt; <b>Set-Win32SecurityDescriptor $path $sd Dacl,ProtectedDacl</b>
PS&gt; <b>Format-Win32SecurityDescriptor $path -Summary -SecurityInformation Dacl</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> &lt;DACL&gt; (Protected, Auto Inherited)
NT AUTHORITY\Authenticated Users: (Allowed)(None)(Full Access)

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Set-Win32SecurityDescriptor $path $sd Dacl,UnprotectedDacl</b>
PS&gt; <b>Format-Win32SecurityDescriptor $path -Summary -SecurityInformation Dacl</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> &lt;DACL&gt; (Auto Inherited)
NT AUTHORITY\Authenticated Users: (Allowed)(None)(Full Access)
Everyone: (Allowed)(Inherited)(Full Access)
NT AUTHORITY\ANONYMOUS LOGON: (Allowed)(Inherited)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-38: Testing the ProtectedDacl and UnprotectedDacl SecurityInformation flags</span></p>
<p class="TX">This script assumes you’ve run <a href="chapter6.xhtml#Lis6-37">Listing 6-37</a> already, as it reuses the file created there. We create a new security descriptor with a single ACE for the <i>Authenticated Users</i> group and assign it to the file with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedDacl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Dacl</samp> flags <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. As a result, the protected control flag for the DACL is now set on the file <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Note that the inherited ACEs from <a href="chapter6.xhtml#Lis6-37">Listing 6-37</a> have been removed; only the new, explicit ACE is left.</p>
<p class="TX">We then assign the security descriptor again with the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp> flag <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This time, when we print the security descriptor we can see that it no longer has the protected control flag set <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Also, the API restores the inherited ACEs from the parent directory and merges them with the explicit ACE for the <i>Authenticated Users</i> group.</p>
<p class="TX">The behavior of the command when we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp> flag shows you how you can restore the inherited ACEs for any file. If you specify an empty DACL so no explicit ACEs will be merged, and additionally specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnprotectedDacl</samp> flag, you’ll reset the security descriptor to the version based on its parent. To simplify this operation, the PowerShell module contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset-Win32SecurityDescriptor</samp> command (<a href="chapter6.xhtml#Lis6-39">Listing 6-39</a>).</p>
<span id="Lis6-39"></span><pre><code>PS&gt; <b>$path = Join-Path "$env:TEMP\TestFolder" "test.txt"</b>
PS&gt; <b>Reset-Win32SecurityDescriptor $path Dacl</b>
PS&gt; <b>Format-Win32SecurityDescriptor $path -Summary -SecurityInformation Dacl</b>
&lt;DACL&gt; (Auto Inherited)
Everyone: (Allowed)(Inherited)(Full Access)
NT AUTHORITY\ANONYMOUS LOGON: (Allowed)(Inherited)(Full Access)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-39: Resetting the security of a directory using Reset-Win32SecurityDescriptor</span></p>
<p class="TX">In this listing, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset-Win32SecurityDescriptor</samp> with the path to the file and request that the DACL be reset. When we display the security descriptor of the file, we now find that it matches the parent directory’s security descriptor, shown in <a href="chapter6.xhtml#Lis6-37">Listing 6-37</a>.</p>
<aside aria-label="box-6" class="box">
<p class="BoxTitle" id="box-6"><span aria-label=" Page 212. " epub:type="pagebreak" id="pg_212" role="doc-pagebreak"></span><samp class="SANS_Dogma_OT_Bold_B_11">THE DANGERS OF AUTO-INHERITANCE</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The auto-inheritance features of the Win32 security APIs are convenient for applications, which can merely set an inheritable security descriptor to apply it to any child resources. However, auto-inheritance introduces a security risk, especially if used by privileged applications or services.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The risk occurs if the privileged application can be tricked into resetting the inherited security for a hierarchy when a malicious user has control over the parent security descriptor. For example, CVE-2018-0983 was a security vulnerability in the privileged storage service: it called</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp> <samp class="SANS_Futura_Std_Book_11">to reset the security of a file with the path specified by the user. By using some filesystem tricks, an attacker could link the file being reset to a system file that was writable by an administrator only. However, the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp> <samp class="SANS_Futura_Std_Book_11">API thought the file was in a directory controlled by the user, so it reset the security descriptor based on that directory’s security descriptor, granting the malicious user full access to the system file.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Microsoft has fixed this issue, and Windows no longer supports the filesystem tricks necessary to exploit it. However, there are other potential ways for a privileged service to be tricked. Therefore, if you’re writing code to set or reset the security descriptor of a resource, pay careful attention to where the path comes from. If it’s from an unprivileged user, make sure you impersonate the caller before calling any of the Win32 security APIs.</samp></p>
</aside>
<p class="TX">One final API to cover is <samp class="SANS_TheSansMonoCd_W5Regular_11">GetInheritanceSource</samp>, which allows you to identify the source of a resource’s inherited ACEs. One reason ACEs are marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> flag is to facilitate the analysis of inherited ACEs. Without the flag, the API would have no way of distinguishing between inherited and non-inherited ACEs.</p>
<p class="TX">For each ACE with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> flag set, the API works its way up the parent hierarchy until it finds an inheritable ACE that doesn’t have this flag set but contains the same SID and access mask. Of course, there is no guarantee that the found ACE is the actual source of the inherited ACE, which could potentially live further up the hierarchy. Thus, treat the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetInheritanceSource</samp> as purely informational, and don’t use it for security-critical decisions.</p>
<p class="TX">Like the other Win32 APIs, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetInheritanceSource</samp> supports different types. However, it’s limited to resources that have a child-parent relationship, such as files, registry keys, and DS objects. You can access the API through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Search-Win32SecurityDescriptor</samp> command, as shown in <a href="chapter6.xhtml#Lis6-40">Listing 6-40</a>.</p>
<span id="Lis6-40"></span><pre><code>PS&gt; <b>$path = Join-Path "$env:TEMP" "TestFolder"</b>
PS&gt; <b>Search-Win32SecurityDescriptor $path | Format-Table</b>
Name                Depth User                         Access
----                ----- ----                         ------
                    0    <b> </b>Everyone                     GenericAll
                    0    <b> </b>NT AUTHORITY\ANONYMOUS LOGON GenericAll

<span aria-label=" Page 213. " epub:type="pagebreak" id="pg_213" role="doc-pagebreak"></span>PS&gt; <b>$path = Join-Path $path "new.txt"</b>
PS&gt; <b>"Hello" | Set-Content $path</b>
PS&gt; <b>Search-Win32SecurityDescriptor $path | Format-Table</b>
Name                Depth User                         Access
----                ----- ----                         ------
C:\Temp\TestFolder\ 1     Everyone                     GenericAll
C:\Temp\TestFolder\ 1     NT AUTHORITY\ANONYMOUS LOGON GenericAll
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-40: Enumerating inherited ACEs using Search-Win32SecurityDescriptor</span></p>
<p class="TX">We first call <samp class="SANS_TheSansMonoCd_W5Regular_11">Search-Win32SecurityDescriptor</samp> with the path to the directory we created in <a href="chapter6.xhtml#Lis6-38">Listing 6-38</a>. The output is a list of the ACEs in the resource’s DACL, including the name of the resource from which each ACE was inherited and the depth of the hierarchy. We set two explicit ACEs on the directory. The output reflects this as a <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp> value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which indicates that the ACE wasn’t inherited. You can also see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column is empty.</p>
<p class="TX">We then create a new file in the directory and rerun the command. In this case, as you might have expected, the ACEs show that they were both inherited from the parent folder, with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp> of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.</p>
<p class="TX">This section covered the basics of the Win32 APIs. Keep in mind that there are clear differences in behavior between these APIs and the low-level system calls, especially regarding inheritance. When you interact with the security of resources via a GUI, it’s almost certainly calling one of the Win32 APIs.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H1" id="sec13"><span id="h1-55"></span><samp class="SANS_Futura_Std_Bold_B_11">Server Security Descriptors and Compound ACEs</samp></h3>
<p class="TNI1">Let’s finish this chapter with a topic I briefly mentioned when we discussed creator SIDs: server security descriptors. The kernel supports two very poorly documented security descriptor control flags for servers: <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclUntrusted</samp>. We use these flags only when generating a new security descriptor, either at object creation time or when assigning a security descriptor explicitly. The main control flag, <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>, indicates to the security descriptor generation code that the caller is expecting to impersonate another user.</p>
<p class="TX">When a new security descriptor is created during impersonation, the owner and group SIDs will default to the values from the impersonation token. This might not be desirable, as being the owner of a resource can grant a caller additional access to it. However, the caller can’t set the owner to an arbitrary SID, because the SID must be able to pass the owner check, which is based on the impersonation token.</p>
<p class="TX">This is where the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp> control flag comes in. If you set the flag on the creator security descriptor when creating a new security descriptor, the owner and group SIDs default to the primary token of the caller, and not to the impersonation token. This flag also replaces all <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACEs in the DACL with <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedCompound</samp> ACEs, the structure of which we defined back in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. In the compound ACE, the server SID is set to the owner SID from the primary token. <a href="chapter6.xhtml#Lis6-41">Listing 6-41</a> shows an example.</p>
<span id="Lis6-41"></span><pre><code><span aria-label=" Page 214. " epub:type="pagebreak" id="pg_214" role="doc-pagebreak"></span><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$token = Get-NtToken -Anonymous</b>
PS&gt; <b>$creator = New-NtSecurityDescriptor -Type Mutant</b>
PS&gt; <b>Add-NtSecurityDescriptorAce $creator -KnownSid World -Access GenericAll</b>
PS&gt; <b>$sd = New-NtSecurityDescriptor -Token $token -Creator $creator</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -Summary -SecurityInformation Owner,Group,Dacl</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> &lt;Owner&gt; : NT AUTHORITY\ANONYMOUS LOGON
&lt;Group&gt; : NT AUTHORITY\ANONYMOUS LOGON
&lt;DACL&gt;
Everyone: (Allowed)(None)(Full Access)

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Set-NtSecurityDescriptorControl $creator ServerSecurity</b>
PS&gt; <b>$sd = New-NtSecurityDescriptor -Token $token -Creator $creator</b>
PS&gt; <b>Format-NtSecurityDescriptor $sd -Summary -SecurityInformation Owner,Group,Dacl</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> &lt;Owner&gt; : GRAPHITE\user
&lt;Group&gt; : GRAPHITE\None
&lt;DACL&gt;
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> Everyone: (AllowedCompound)(None)(Full Access)(Server:GRAPHITE\user)
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-41: Testing the ServerSecurity security descriptor control flag</span></p>
<p class="TX">We first create a new security descriptor using the anonymous user token <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This initial test doesn’t set the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp> flag. As expected, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> default to values based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp> user token, and the single ACE we added remains intact <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Next, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp> control flag to the creator security descriptor <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. After calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp> again, we now find that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp> are set to the defaults for the primary token, not to those of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp> user token <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Also, the single ACE has been replaced with a compound ACE, whose server SID is set to the primary token’s owner SID <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. We’ll discuss how changes to compound ACEs impact access checking in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclUntrusted</samp> control flag works in combination with <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp>. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp> assumes that any compound ACE in the DACL is trusted and will copy it verbatim into the output. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclUntrusted</samp> control flag is set, all compound ACEs instead have their server SID values set to the primary token’s owner SID.</p>
<p class="TX">If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerSecurity</samp> control flag is set on the creator security descriptor and the new security descriptor inherits ACEs from a parent, we can convert the <i>CREATOR OWNER SERVER</i> and <i>CREATOR GROUP SERVER</i> SIDs to their respective primary token values. Also, any inherited <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACEs will be converted to compound ACEs, except for those of the default DACL.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H1" id="sec14"><span id="h1-56"></span><samp class="SANS_Futura_Std_Bold_B_11">A Summary of Inheritance Behavior</samp></h3>
<p class="TNI1">Inheritance is a very important topic to understand. <a href="chapter6.xhtml#tab6-8">Table 6-8</a> summarizes the ACL inheritance rules we’ve discussed in this chapter, to help you make sense of them.</p>
<p class="Anchor"><span aria-label=" Page 215. " epub:type="pagebreak" id="pg_215" role="doc-pagebreak"></span></p>
<table class="Basic-Table">
<caption><p class="TT" id="tab6-8"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Summary of Inheritance Rules for the DACL</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TBF" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Parent ACL</samp></p></th>
<th class="Basic-Table TBF" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Creator ACL</samp></p></th>
<th class="Basic-Table TBF" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Auto-inherit set</samp></p></th>
<th class="Basic-Table TBF" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Auto-inherit not set</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Default</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Default</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Present</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Default</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Default</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Inheritable</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">None</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Parent</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Parent</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Present</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Inheritable</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Present</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Parent and creator</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Protected</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Inheritable</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Protected</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Non-inheritable</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Defaulted</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Creator</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Inheritable</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Defaulted</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Parent</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Parent</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The first two columns in this table describe the state of the parent ACL and the creator ACL; the last two describe the resulting ACL, depending on whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherit</samp> and/or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherit</samp> flag was set. There are six ACL types to consider:</p>
<p class="RunInPara1"><b>None    </b>The ACL isn’t present in the security descriptor.</p>
<p class="RunInPara"><b>Present    </b>The ACL is present in the security descriptor (even if it is a NULL or empty ACL).</p>
<p class="RunInPara"><b>Non-inheritable    </b>The ACL has no inheritable ACEs.</p>
<p class="RunInPara"><b>Inheritable    </b>The ACL has one or more inheritable ACEs.</p>
<p class="RunInPara"><b>Protected    </b>The security descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> control flag set.</p>
<p class="RunInPara2"><b>Defaulted    </b>The security descriptor has the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclDefaulted</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclDefaulted</samp> control flag set.</p>
<p class="TX">Additionally, there are four possible resulting ACLs:</p>
<p class="RunInPara1"><b>Default    </b>The default DACL from the token, or nothing in the case of a SACL</p>
<p class="RunInPara"><b>Creator    </b>All ACEs from the creator ACL</p>
<p class="RunInPara"><b>Parent    </b>The inheritable ACEs from the parent ACL</p>
<p class="RunInPara2"><b>Parent and creator    </b>The inheritable ACEs from the parent and explicit ACEs from the creator</p>
<p class="TX">When an auto-inherit flag is set, the new security descriptor will have the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclAutoInherited</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclAutoInherited</samp> control flag set. Also, all ACEs that were inherited from the parent ACL will have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherited</samp> ACE flag set. Note that this table doesn’t consider the behavioral changes due to object ACEs, mandatory labels, server security, and creator SIDs, which add more complexity.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="H1" id="sec15"><span id="h1-57"></span><span aria-label=" Page 216. " epub:type="pagebreak" id="pg_216" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp></h3>
<p class="TNI1">Let’s walk through some worked examples that use the commands you’ve learned about in this chapter.</p>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="h2-68"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Object Manager Resource Owners</samp></h4>
<p class="TNI1">As you’ve seen in this chapter, the owner of a resource’s security descriptor is usually the user who created the resource. For administrators, however, it’s typically the built-in <i>Administrators</i> group. The only way to set a different owner SID is to use another token group SID that has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> flag set, or to enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>. Neither option is available to non-administrator users.</p>
<p class="TX">Thus, knowing the owner of a resource can indicate whether a more privileged user created and used the resource. This could help you identify potential misuses of the Win32 security APIs in privileged applications, or find shared resources that a lower-privileged user might write to; a privileged user could mishandle these, causing a security issue.</p>
<p class="TX"><a href="chapter6.xhtml#Lis6-42">Listing 6-42</a> shows a simple example: finding object manager resources whose owner SID differs from the caller’s.</p>
<span id="Lis6-42"></span><pre><code>PS&gt; <b>function Get-NameAndOwner {</b><span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
<b>     [CmdletBinding()]</b>
<b>     param(</b>
<b>         [parameter(Mandatory, ValueFromPipeline)]</b>
<b>         $Entry,</b>
<b>         [parameter(Mandatory)]</b>
<b>         $Root</b>
<b>    </b><b>  </b><b>)</b>

<b>      begin {</b>
<b>         $curr_owner = Get-NtSid -Owner </b><span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
<b>     }</b>

<b>     process {</b>
<b>        $sd = Get-NtSecurityDescriptor -Path $Entry.Name -Root $Root </b><span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
<b>-TypeName $Entry.NtTypeName -ErrorAction SilentlyContinue</b>
<b>        if ($null -ne $sd -and $sd.Owner.Sid -ne $curr_owner) {</b>
<b>            [PSCustomObject] @{</b>
<b>                Name = $Entry.Name</b>
<b>  </b><b>              NtTypeName = $Entry.NtTypeName</b>
<b>                Owner = $sd.Owner.Sid.Name</b>
<b>  </b><b>              SecurityDescriptor = $sd</b>
<b>            }</b>
<b>        }</b>
<b>    }</b>
<b>}</b>

PS&gt; <b>Use-NtObject($dir = Get-NtDirectory \BaseNamedObjects) {</b><span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
<b>     Get-NtDirectoryEntry $dir | Get-NameAndOwner -Root $dir</b>
<b>}</b>
<span aria-label=" Page 217. " epub:type="pagebreak" id="pg_217" role="doc-pagebreak"></span>Name<b>                       </b>NtTypeName  Owner                   SecurityDescriptor
----<b>  </b><b>                     </b>----------  -----                   ------------------
CLR_PerfMon_DoneEnumEvent  Event       NT AUTHORITY\SYSTEM     O:SYG:SYD:(A;;...
WAMACAPO;3_Read            Event       BUILTIN\Administrators  O:SYG:SYD:(A;;...
WAMACAPO;8_Mem             Section     BUILTIN\Administrators  O:SYG:SYD:(A;;...
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-42: Finding objects in</span> <samp class="SANS_Futura_Std_Book_11">BaseNamedObjects</samp> <span class="Futura_Std_Book_Oblique_I_11">that are owned by a different user</span></p>
<p class="TX">We first define a function to query the name and owner of an object manager directory entry <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The function initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">$curr_owner</samp> variable with the owner SID of the caller’s token <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We’ll compare this SID with the owner of a resource to return only resources owned by a different user.</p>
<p class="TX">For each directory entry, we query its security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp> command <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We can specify a path and a root <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> object to the command to avoid having to manually open the resource. If we successfully query the security descriptor, and if the owner SID does not match the current user’s owner SID, we return the resource’s name, object type, and owner SID.</p>
<p class="TX">To test the new function, we open a directory (in this case, the global <i>BaseNamedObjects</i> directory <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>) and use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectoryEntry</samp> to query for all entries, piping them through the function we defined. We receive a list of resources not owned by the current user.</p>
<p class="TX">For example, the output includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">WAMACAPO;8_Mem</samp> object, which is a shared memory <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object. If a normal user can write to this <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object, we should investigate it further, as it might be possible to trick a privileged application into performing an operation that would elevate a normal user’s privileges.</p>
<p class="TX">We can test our ability to get write access on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> property of the object, as shown in <a href="chapter6.xhtml#Lis6-43">Listing 6-43</a>.</p>
<span id="Lis6-43"></span><pre><code>PS&gt; <b>$entry</b>
Name            NtTypeName  Owner                   SecurityDescriptor
----            ----------  -----                   ------------------
WAMACAPO;8_Mem  Section     BUILTIN\Administrators  O:SYG:SYD:(A;;...

PS&gt; <b>Get-NtGrantedAccess -SecurityDescriptor $entry.SecurityDescriptor</b>
Query, MapWrite, MapRead, ReadControl
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-43: Getting the granted access for a Section object</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">$entry</samp> variable contains the object we want to inspect. We pass its security descriptor to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp> command to return the maximum granted access for that resource. In this case, we can see that <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> is present, which indicates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object could be mapped as writable.</p>
<p class="TX">The example I’ve shown in <a href="chapter6.xhtml#Lis6-42">Listing 6-42</a> should provide you with an understanding of how to query for any resource. You can replace the directory with a file or registry key, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSecurityDescriptor</samp> with the <span aria-label=" Page 218. " epub:type="pagebreak" id="pg_218" role="doc-pagebreak"></span>path and the root object to query the owner for each of these resource types.</p>
<p class="TX">For the object manager and registry, however, there is a much simpler way of finding the owner SID. For the registry, we can look up the security descriptor for the entries returned from the <i>NtObject</i> drive provider using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> property. For example, we can select the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> SID fields for the root registry key using the following script:</p>
<pre><code>PS&gt; <b>ls NtKey:\ | Select Name, {$_.SecurityDescriptor.Owner.Sid}</b>
</code></pre>
<p class="BodyContinued">We can also specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Recurse</samp> parameter to perform the check recursively.</p>
<p class="TX">If you want to query the owner SIDs of files, you can’t use this technique, as the file provider does not return the security provider in its entries. Instead, you need to use the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp> command. Here, for example, we query a file’s ACL:</p>
<pre><code>PS&gt; <b>ls C:\ | Get-Acl | Select Path, Owner</b>
</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp> command returns the owner as a username, not a SID. You’ll have to look up the SID manually using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> command and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> parameter if you need it. Alternatively, you can convert the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Acl</samp> command to a <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityDescriptor</samp> object used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module, as shown in <a href="chapter6.xhtml#Lis6-44">Listing 6-44</a>.</p>
<span id="Lis6-44"></span><pre><code>PS&gt; <b>(Get-Acl C:\ | ConvertTo-NtSecurityDescriptor).Owner.Sid</b>
Name                        Sid
----                        ---
NT SERVICE\TrustedInstaller S-1-5-80-956008885-3418522649-1831038044-...
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-44: Converting Get-Acl output to a SecurityDescriptor object</span></p>
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertTo-NtSecurityDescriptor</samp> PowerShell command to perform the conversion.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H2" id="sec17"><span id="h2-69"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Changing the Ownership of a Resource</samp></h4>
<p class="TNI1">Administrators commonly take ownership of resources. This allows them to easily modify a resource’s security descriptor and gain full access to it. Windows comes with several tools for doing this, such as <i>takeown.exe</i>, which sets the owner of a file to the current user. However, you’ll find it instructive to go through the process of changing the owner manually, so you can understand exactly how it works. Run the commands in <a href="chapter6.xhtml#Lis6-45">Listing 6-45</a> as an administrator.</p>
<span id="Lis6-45"></span><pre><code>PS&gt; <b>$new_dir = New-NtDirectory "ABC" -Win32Path</b>
PS&gt; <b>Get-NtSecurityDescriptor $new_dir | Select {$_.Owner.Sid.Name}</b>
$_.Owner.Sid.Name
-----------------
BUILTIN\Administrators

<span aria-label=" Page 219. " epub:type="pagebreak" id="pg_219" role="doc-pagebreak"></span>PS&gt; <b>Enable-NtTokenPrivilege SeRestorePrivilege</b>
PS&gt; <b>Use-NtObject($dir = Get-NtDirectory "ABC" -Win32Path -Access WriteOwner) {</b>
<b>    $sid = Get-NtSid -KnownSid World</b>
<b>    $sd = New-NtSecurityDescriptor -Owner $sid</b>
<b>    Set-NtSecurityDescriptor $dir $sd -SecurityInformation Owner</b>
<b>}</b>

PS&gt; <b>Get-NtSecurityDescriptor $new_dir | Select {$_.Owner.Sid.Name}</b>
$_.Owner.Sid.Name
-----------------
Everyone

PS&gt; <b>$new_dir.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 6-45: Setting an arbitrary owner for a Directory object</span></p>
<p class="TX">We start by creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> object on which to perform the operations. (We’ll avoid modifying an existing resource, which might risk breaking your system.) We then query the resource’s current owner SID. In this case, because we’re running this script as an administrator, it’s set to the <i>Administrators</i> group.</p>
<p class="TX">Next, we enable the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp> privilege. We need to do this only if we want to set an arbitrary owner SID. If we want to set a permitted SID, we can skip this line. We then open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> again, but only for <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access.</p>
<p class="TX">We can now create a security descriptor with just the owner SID set to the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> SID. To do this, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtSecurityDescriptor</samp> PowerShell command, specifying only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> flag. If you haven’t enabled <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>, this operation will fail with a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID_OWNER</samp> status code. To confirm that we’ve changed the owner SID, we query it again, which confirms that it’s now set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Everyone</samp> (the name of the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> SID).</p>
<p class="TX">You can apply this same set of operations to any resource type, including registry keys and files: simply change the command used to open the resource. Whether you’ll be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access depends on the specifics of the access check process. In <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, you’ll learn about a few cases in which the access check automatically grants <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access based on certain criteria.</p>
</section>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="h1-58"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">This chapter began with an overview of how to read the security descriptor of an existing kernel resource using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectSecurity</samp> command. We covered the security information flags that define what parts of the security descriptors the command should read and outlined the special rules for accessing audit information stored in the SACL.</p>
<p class="TX">We then discussed how we can assign security descriptors to resources, either during the resource creation process or by modifying an existing resource. In the process, you learned about ACL inheritance and auto-inheritance. We also discussed the behavior of the Win32 APIs, specifically <span aria-label=" Page 220. " epub:type="pagebreak" id="pg_220" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W5Regular_11">SetNamedSecurityInfo</samp>, and how that API implements auto-inheritance even though the kernel doesn’t explicitly implement it. We concluded with an overview of the poorly documented server security descriptor and compound ACEs. In the next chapter, we’ll (finally) discuss how Windows combines the token and security descriptor to check whether a user can access a resource.</p>
</section>
</section>
</div></body>
</html>