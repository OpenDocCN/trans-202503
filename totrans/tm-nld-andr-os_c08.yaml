- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java
  prefs: []
  type: TYPE_NORMAL
- en: '![g08001](image_fi/502680c08/g08001.png)'
  prefs: []
  type: TYPE_IMG
- en: We came back from Christmas break. I got in pretty early, bright eyed and bushy
    tailed, and talked to Rubin. He informed me that he and Brian had dinner during
    the week off and that they’d decided that we were going to write everything in
    Java.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Joe Onorato
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Language Choices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The choice of a programming language for Android was probably more tied to
    Android’s growth than might otherwise be obvious. After all, a programming language
    is just the medium to input the information to the computer: Does it really matter?'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, it does. Experienced programmers can and do pick up new languages all the
    time. But even these experts develop patterns that make them more efficient with
    languages that they know well. And the effect of middleware, or utility libraries
    that developers can carry from project to project, can’t be discounted. The fact
    that a programmer can depend on some library^([1](#c08-footnote-1)) in one project
    and then use it to bootstrap other projects means that they can be more efficient
    and productive on every new project because they don’t have to keep re-inventing
    the world.
  prefs: []
  type: TYPE_NORMAL
- en: The choice to use the Java programming language^([2](#c08-footnote-2)) was important,
    because at the time Android was released, Java was one of the major languages
    used by software developers around the world. The fact that Android allowed these
    developers to use their existing language skills to write applications on Android
    meant that many developers could avoid the ramp-up time that learning a new language
    would have entailed.
  prefs: []
  type: TYPE_NORMAL
- en: But this language choice was not obvious or immediate in the early days of Android.
    There were actually three languages being debated internally.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, there was JavaScript. In fact, in the beginning there was *only*
    JavaScript, because Android, at the start, was a desktop app written on and around
    the web’s programming language.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is the programming language that developers use to write the code
    that is on the web pages that we visit. When we see something moving on a browser
    page, that animation is usually powered by JavaScript code. But JavaScript is
    a bit, er, messy, as real programming languages go. It’s easy for a developer
    to get things basically working with JavaScript, but some of its fundamental concepts^([3](#c08-footnote-3))
    make it more difficult to program larger systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'After work began on the real platform for Android, there was a choice of which
    language to use: JavaScript , C++, or Java.'
  prefs: []
  type: TYPE_NORMAL
- en: C++ was attractive because many developers know it and it’s used in low-level
    programming tasks to this day. C++ developers have a lot of control over important
    aspects of their application’s operation, such as memory allocation. But the flip
    side is that developers have to manage this kind of information in their applications.
    If they allocate memory to store an object (say, an image), they have to make
    sure they deallocate it when they are finished. Failing to do this (an all-too-common
    problem in software) can lead to *memory* *leaks* where memory is dribbled away
    and the application simply grows without bound until it uses up everything available
    in the system and fails when the system has no more memory to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Java is a programming language built around the concept of a *runtime* or *virtual
    machine (VM)*, which handles all of the tedious bits about memory management that
    C++ programmers have to handle on their own. In the image example above, the Java
    programmer simply loads an image, which causes the memory to be allocated. When
    the image is no longer being used, the runtime automatically *collects* that memory,
    which is known as *garbage collection*. Java developers can ignore details of
    memory collection (and leaks) and get down to the business of writing their actual
    application logic.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for the team to consider Java was the existence of J2ME,^([4](#c08-footnote-4))
    the Java-based platform that ran on various devices already. Ficus Kirkpatrick
    said, “At the time, to be on a phone and to get these carrier deals, you had to
    have support for J2ME.” Choosing Java provided some ability to run J2ME code on
    the platform, which was considered useful at the time that Android was first being
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, powerful tools for writing Java code were available for free, including
    Eclipse and NetBeans. On the other hand, C++ didn’t have good free IDE^([5](#c08-footnote-5))
    support. Microsoft offered VisualStudio, which was a great tool for C++ development,
    but it wasn’t free, and Android wanted to appeal to all developers without requiring
    expensive tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first plan was not to have just one language, but to offer a choice. Again,
    Ficus: “Our original idea was that we were going to do everything in a language-independent
    way. You were going to be able to write your apps in JavaScript, C++, and Java.
    Eventually we realized there were like twelve of us and we were never going to
    make that work. So we said ‘OK, we have to pick a language.’”'
  prefs: []
  type: TYPE_NORMAL
- en: Andy Rubin saw the choice of just one language as a simplification for developers.
    Swetland said, “We were toying with some concepts of doing Java and C++. Andy
    felt very strongly that we needed one language, one API, so as to not confuse
    things. He saw Symbian^([6](#c08-footnote-6)) with their *n* different toolkits^([7](#c08-footnote-7))
    as confusing.”
  prefs: []
  type: TYPE_NORMAL
- en: These were the technical details and merits that factored into the debate. The
    actual decision was a bit less formal; Andy made the call and told Swetland over
    dinner one evening.
  prefs: []
  type: TYPE_NORMAL
- en: The language choice was a good example of how quickly decisions were made on
    Android. In part, it was because it was Andy’s call, and Andy tended to make hard
    decisions that the organization would then scramble to execute. But more important,
    decisions were made quickly so that the organization could simply move on and
    do the rest of the infinite set of things that needed doing. The language choice
    had been debated internally for a while, and there was no right answer, but simply
    having a decision was more important than everyone being happy with whatever decision
    that was. So Java was it, and the team moved on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ficus said, of the decision: “It didn’t really feel like much of a choice,
    given that the carriers wanted to see support for J2ME^([8](#c08-footnote-8))
    apps and this kind of ecosystem that existed at the time. And some of us had worked
    at Danger before, on the Hiptop, and we knew that we could make Java perform on
    a low-end device.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dianne Hackborn remembers when the decision was made: “Andy, very rightly,
    said, ‘We cannot do three different languages. That’s ridiculous, and we need
    to pick one. So we’re going to do Java.’ There was a lot of drama about that.
    No one cared about JavaScript, but a lot of people cared about C++.”'
  prefs: []
  type: TYPE_NORMAL
- en: The choice of Java made sense for various reasons, including team expertise.
    For example, the engineers from Danger had learned how to write an operating system
    with that language in an efficient way for those earlier, very constrained devices.
    In the end, with this and many other decisions, the team took a pragmatic approach.
    As Dianne said, “Not because anyone loved it, but because it’s what made sense
    to make the platform successful, and then the team adjusts.”
  prefs: []
  type: TYPE_NORMAL
- en: Although Java was chosen as the primary language for Android development, there
    was (and still is) a lot of code written for Android in other languages. Much
    of the platform itself is written in C++ (and even some limited parts in assembly
    language). Also, most games are written in C++, as are some other apps, in full
    or in part. C++ is a popular language with many developers, because it offers
    some performance advantages for low-level code, as well as integration with existing
    C++ libraries and tools. But the main language, especially for most non-game applications,
    became Java, and that’s what all of the Android APIs were written in and for.
  prefs: []
  type: TYPE_NORMAL
- en: Not everybody was happy with the language decision. San Mehat wasn’t a big fan
    of Java, especially for the low-level systems programming that he did. “I didn’t
    have a problem with the language itself. Well, maybe I did, inasmuch as it hid
    all the details that were important to writing code that scaled and ran well.”
    He ordered a new license plate for his car, JAVA SUX. “When you go to get the
    license plate, they [the Department of Motor Vehicles] ask you what it stands
    for. I said that I used to work for Sun and we made this Java thing, and it stands
    for Secondary User Extensions, and they said ‘Okay.’”
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502680c08/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: San’s license plate. San was not a fan of Android’s language choice. (Picture
    courtesy Eric Fischer.)
  prefs: []
  type: TYPE_NORMAL
- en: Runtimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand runtimes, you need to understand something about programming languages.
    Programmers write their code in whatever language they choose (C, Java, C++, Kotlin,
    Python, assembly . . . whatever). Computers don’t understand these languages;
    they understand binary code (0s and 1s) . . . and that’s it. The binary code represents
    instructions that the computer executes, like “add these two numbers.” In order
    to convert from typical programming languages into the binary-encoded instructions
    that the computer understands, programmers use tools called compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Compilers translate from whatever language the programmer uses into binary instructions
    that the computer understands. So, for example, you can take a chunk of code written
    in C and compile it into a binary representation for a PC such that that compiled
    C code will run on that PC.
  prefs: []
  type: TYPE_NORMAL
- en: That same compiled code may not run on a different kind of computer, like a
    Mac, or a Linux server, because that other computer may not have the same kind
    of CPU, so the binary instructions the compiler generated won’t make sense on
    that other system. Instead, the original source code needs to be compiled into
    a different binary version for each different type of hardware you want to run
    it on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502680c08/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: Separate compilers create unique executables for every type of machine on which
    the code will be run.
  prefs: []
  type: TYPE_NORMAL
- en: Along comes Java. The Java compiler translates source code not into machine-readable
    code, but into an intermediate representation called *bytecode*. This code can
    be executed on any computer platform that has an additional piece of software
    running on it called a *runtime*. The runtime interprets the bytecode and translates
    it into the binary representation of that computer, essentially compiling it on
    the fly. This ability to run on different hardware is what Sun Microsystems (the
    company where James Gosling was working when he created Java) called, “Write once,
    run anywhere.” Code would be compiled into bytecode that could then run on any
    target computer with a Java runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502680c08/f08003.png)'
  prefs: []
  type: TYPE_IMG
- en: Java code only needs to be compiled once. This produces a single executable
    that can run on all target machines that have a Java runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Android team wanted to use Java, they also needed a runtime. In fact,
    they went through several of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, the team simply used existing runtimes. The first of these was Waba.^([9](#c08-footnote-9))
    Later on, the JamVM^([10](#c08-footnote-10)) virtual machine was substituted for
    Waba. Mike Fleming had joined by this time and helped get JamVM going: “Dan Bornstein’s
    VM wasn’t going to be ready for a while and we were going to write an awful lot
    of code. If we were going to be a Java platform, we needed to have something to
    run with for a while. Swetland and Fadden helped me out.” JamVM was used by Android
    until, in 2007, the Android runtime (Dalvik) was up and running.'
  prefs: []
  type: TYPE_NORMAL
- en: Dan Bornstein and the Dalvik Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open a file, bang a few keys at random, then debug until complete.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Dan Bornstein (according to Andy McFadden)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although Waba and JamVM were sufficient for prototyping and early development,
    the team wanted their own runtime that they could control and customize as they
    needed. Brian Swetland was involved in the runtime that was written at Danger,
    but he had his hands full with kernel and systems work for Android. So the team
    hired Dan Bornstein, whom Brian had worked with at Danger.
  prefs: []
  type: TYPE_NORMAL
- en: Dan (known to the team as “danfuzz”) had taken over the runtime from Brian at
    Danger. “Not long after I was hired, I started referring to myself as ‘Brian Jr.’
    He really didn’t like it . . . which is why I kept saying it.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Dan was introduced to programming at the age of seven. He and his brother just
    wanted to play video games, so they eventually talked their parents into getting
    an Apple II, which the parents thought would be both a game and an education machine.
    The parents apparently won, because Dan didn’t just play games; he started programming
    them: “I totally wrote crappy video games, mostly text and low-res graphics.”
    Both Dan and his brother eventually became software engineers.'
  prefs: []
  type: TYPE_NORMAL
- en: Dan worked at various companies in Silicon Valley through the 90s and early
    2000s, including Danger, where he worked on (wait for it . . . ) a runtime for
    the Java programming language. So he was a natural candidate for that work on
    the Android team when he joined in October of 2005.
  prefs: []
  type: TYPE_NORMAL
- en: Dan’s first task was to evaluate the possible options. It wasn’t obvious to
    the small team on Android at that time whether they could simply use something
    that already existed (either open source or some technology that they could acquire)
    or whether they needed to build something in-house. Dan started working on both
    of these options in parallel, evaluating existing runtimes while also building
    a runtime from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Although Waba and JamVM worked well for quickly enabling the team’s use of Java,
    they were not seriously considered as long-term options. Both runtimes interpreted
    Java bytecode directly. But the team felt that there were performance and memory
    gains to be had by converting the Java code to another, more optimal format. A
    new bytecode format meant a new runtime, so Dan got busy making that happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dan began work on a new runtime, which he named *Dalvik*: “I had just finished
    reading an issue [of *McSweeney’s*], which consisted of English translations of
    modern Icelandic fiction. So I had Iceland on the brain. I looked at a map of
    Iceland and tried to find something that was short and pronounceable, and didn’t
    have any of the weird characters, and I found Dalvík^([11](#c08-footnote-11))
    (or ‘Dal-veek,’ as it’s pronounced). It sounded like a nice little town.”'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502680c08/f08004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Java code written for Android went through two compilation steps: one to create
    Java bytecode, and the next to convert that to Dalvik bytecode, which would then
    run on Android’s Dalvik runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of running Java bytecode, the Dalvik VM ran another form of bytecode
    compiled from Java bytecode. There were efficiencies in size to be gained in having
    their own bytecode format, and space on the device at that time was at a premium.
    The Dalvik bytecode required an additional compilation step (using another compiler,
    called DX) to get it into the form readable by Dalvik, called dex.^([12](#c08-footnote-12))
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502680c08/f08005.png)'
  prefs: []
  type: TYPE_IMG
- en: Dan Bornstein, outside of the town of Dalvík, Iceland. In the period between
    finishing work on the G1 and the device actually shipping, Dan took a break from
    working on Dalvik to visit Dalvík. (Picture courtesy Dan Bornstein.)
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, Fadden pitched in to help with the runtime. “Danfuzz had the bytecode
    converter working reasonably well and needed someone to step up and write the
    VM. I volunteered, but pointed out that I knew very little about Java and VMs,
    and wasn’t quite sure where to start. He said, ‘Open a file, bang a few keys at
    random, then debug until complete.’”
  prefs: []
  type: TYPE_NORMAL
- en: Dave Bort, another engineer on the team, wrote the first version of the Dalvik
    garbage collector. That garbage collector shipped with the runtime in 1.0 and
    was the basis for several years of refinement and optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this time, the runtime was constantly changing out from under all
    of the Java code being written for the platform. From Waba to JamVM to the nascent
    Dalvik runtime, major shifts were happening, but code kept running. Romain Guy
    remarked that even though the team was changing a huge and critical part of the
    system,^([13](#c08-footnote-13)) “I don’t remember running into showstopper bugs,
    or even bugs at all. I don’t remember anything else on Android being that stable.”
    Dan replied, “Some amount of the nature of that layer of the system helps with
    that—if the VM’s not working, shit just falls over.”
  prefs: []
  type: TYPE_NORMAL
- en: Zygote
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the things that the Dalvik team created to make Android work for 1.0
    was (and still is) called Zygote.^([14](#c08-footnote-14)) Zygote is like the
    loaf of bread you slice when making a sandwich. You could, of course, bake the
    bread from scratch every time you made a sandwich, but that’s a lot of effort
    and time spent every time you want a sandwich. It’s obviously much faster and
    easier to have a loaf that you can just cut slices from to jump-start each sandwich.
    Zygote is like sandwich bread for applications.
  prefs: []
  type: TYPE_NORMAL
- en: Dan had this idea, which came from a feature of Emacs^([15](#c08-footnote-15))
    (a popular text editor on Unix systems), where it would allow you to dump the
    state at any time and then start up Emacs later from this saved state (cleverly
    called *undump*). This meant that Emacs could start much faster because it just
    sucked in the state from disk instead of running a bunch of code logic at startup
    time. “My idea was that we implement an undumper-type system as made most ‘famous’
    (at least to me) by Emacs. Mike [Fleming] said, ‘How about we skip the part where
    we dump to disk and reload?’ And he ran with it.” Mike got the system up and running,
    dramatically changing the way that applications started. Instead of each app loading
    in all of the code they required, and initializing it as it was loaded in, the
    Zygote system created a single process with much of the core platform code, essentially
    pre-loading and initializing all of it. Whenever an application launched, the
    Zygote process would be *forked* (duplicating itself into a new process), resulting
    in an almost immediate launch to that early stage of the new application.
  prefs: []
  type: TYPE_NORMAL
- en: Bob Lee (who worked on core libraries, the subject of the next chapter) said
    of Zygote, “It was just so simple! It’s like one API call! The reason we were
    able to do that was that the memory was copy-on-write.^([16](#c08-footnote-16))
    So as long as you didn’t touch those memory pages from that initial Zygote process,
    all that memory would be shared across the whole OS. It was just such a clever,
    beautiful solution to leverage stuff that was already there.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The system didn’t quite work as intended at first. Bob chased down a problem
    with the garbage collector: “After one garbage collection, I was like, ‘My app’s
    taking up so much memory again!’ It was because the garbage collector would touch
    every memory page.” That is, the normal efforts of the runtime would write to
    pages in memory that needed to stay read-only for the shared-memory approach of
    Zygote to work.'
  prefs: []
  type: TYPE_NORMAL
- en: Fadden came in with a fix for this. Each new process would separate the heap
    from the garbage collector after the Zygote stage, excluding it from the memory
    that the garbage collector examined. The shared memory portion didn’t even exist
    in the new app, so it wouldn’t get touched.
  prefs: []
  type: TYPE_NORMAL
- en: After this, Bob and Fadden continued to work on Zygote, to figure out which
    classes^([17](#c08-footnote-17)) needed to live in Zygote to get optimal sharing
    out of all applications. Bob said, “I modified the VM and added some instrumentation,
    so I could say, like, how long every class initializer is taking, and figure out
    how much memory each class is allocating, and then an algorithm would decide which
    classes to preload. You don’t want to take up too much memory for the shared processes
    that’s only ever going to be used by one app.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob credits Zygote for Android being at all functional at that time: “The Zygote
    thing helped a lot, just being able to share memory, going from having just a
    couple Java processes running to having dozens running on a really small device.
    And rather than having to wait for a whole VM to start up, our apps actually looked
    faster; they would launch instantly, because we’d just fork a process and start
    right there. Everything was already warmed up.” Eventually, Zygote contained not
    just code, but also shared data such as images, and continued providing memory
    and startup benefits to Android as the platform grew.'
  prefs: []
  type: TYPE_NORMAL
