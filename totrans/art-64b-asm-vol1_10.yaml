- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Arithmetic
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter covers extended-precision arithmetic, arithmetic on operands whose
    sizes are different, and decimal arithmetic. By the conclusion of this chapter,
    you will know how to apply arithmetic and logical operations to integer operands
    of any size, including those larger than 64 bits, and how to convert operands
    of different sizes into a compatible format. Finally, you’ll learn to perform
    decimal arithmetic by using the x86-64 BCD instructions on the x87 FPU, which
    lets you use decimal arithmetic in those few applications that absolutely require
    base-10 operations.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Extended-Precision Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One big advantage of assembly language over high-level languages is that assembly
    language does not limit the size of integer operations. For example, the standard
    C programming language defines three integer sizes: `short int`, `int`, and `long
    int`.^([1](#c08-footnote-1)) On the PC, these are often 16- and 32-bit integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the x86-64 machine instructions limit you to processing 8-, 16-, 32-,
    or 64-bit integers with a single instruction, you can use multiple instructions
    to process integers of any size. If you want to add 256-bit integer values together,
    it’s no problem. This section describes how to extend various arithmetic and logical
    operations from 16, 32, or 64 bits to as many bits as you please.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1 Extended-Precision Addition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The x86-64 `add` instruction adds two 8-, 16-, 32-, or 64-bit numbers. After
    the execution of `add`, the x86-64 carry flag is set if you have an overflow out
    of the HO bit of the sum. You can use this information to do extended-precision
    addition operations.^([2](#c08-footnote-2)) Consider the way you manually perform
    a multiple-digit addition operation (as shown in [Figure 8-1](#figure8-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08001](image_fi/501089c08/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: Multi-digit addition'
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 handles extended-precision arithmetic the same way, except instead
    of adding the numbers a digit at a time, it adds them together a byte, word, double
    word, or quad word at a time. Consider the three-quad-word (192-bit) addition
    operation in [Figure 8-2](#figure8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08002](image_fi/501089c08/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: Adding two 192-bit objects together'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the idea is to break a larger operation into a sequence of
    smaller ones. Since the x86 processor family is capable of adding together at
    most 64 bits at a time (using general-purpose registers), the operation must proceed
    in blocks of 64 bits or fewer. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the two LO quad words together just as you would add the two LO digits of
    a decimal number together in the manual algorithm, using the `add` instruction.
    If there is a carry out of the LO addition, `add` sets the carry flag to `1`;
    otherwise, it clears the carry flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add together the second pair of quad words in the two 192-bit values, plus
    the carry out of the previous addition (if any), using the `adc` (*add with carry*)
    instruction. The `adc` instruction uses the same syntax as `add` and performs
    almost the same operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only difference is that `adc` adds in the value of the carry flag along
    with the source and destination operands. It sets the flags the same way `add`
    does (including setting the carry flag if there is an unsigned overflow). This
    is exactly what we need to add together the middle two double words of our 192-bit
    sum.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the HO double words of the 192-bit value with the carry out of the sum of
    the middle two quad words, once again using `adc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To summarize, the `add` instruction adds the LO quad words together, and `adc`
    adds all other quad word pairs together. At the end of the extended-precision
    addition sequence, the carry flag indicates unsigned overflow (if set), a set
    overflow flag indicates signed overflow, and the sign flag indicates the sign
    of the result. The zero flag doesn’t have any real meaning at the end of the extended-precision
    addition (it simply means that the sum of the two HO quad words is 0 and does
    not indicate that the whole result is 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose that you have two 128-bit values you wish to add together,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose also that you want to store the sum in a third variable, `Z`, which
    is also an `oword`. The following x86-64 code will accomplish this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first three instructions add the LO quad words of `X` and `Y` together and
    store the result into the LO quad word of `Z`. The last three instructions add
    the HO quad words of `X` and `Y` together, along with the carry from the LO word,
    and store the result in the HO quad word of `Z`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, `X`, `Y`, and `Z` are `oword` objects (128 bits), and an instruction
    of the form `mov rax, X` would attempt to load a 128-bit value into a 64-bit register.
    To load a 64-bit value, specifically the LO 64 bits, the `qword ptr` operator
    coerces symbols `X`, `Y`, and `Z` to 64 bits. To load the HO qwords, you use address
    expressions of the form `X[8]`, along with the `qword ptr` operator, because the
    x86 memory space addresses bytes, and it takes 8 consecutive bytes to form a quad
    word.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can extend this algorithm to any number of bits by using `adc` to add in
    the higher-order values. For example, to add together two 256-bit values declared
    as arrays of four quad words, you could use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.2 Extended-Precision Subtraction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as it does addition, the x86-64 performs multi-byte subtraction the same
    way you would manually, except it subtracts whole bytes, words, double words,
    or quad words at a time rather than decimal digits. You use the `sub` instruction
    on the LO byte, word, double word, or quad word and the `sbb` (*subtract with
    borrow*) instruction on the high-order values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a 128-bit subtraction using the 64-bit registers
    on the x86-64:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates a 256-bit subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.3 Extended-Precision Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, there isn’t a “compare with borrow” instruction that you can
    use to perform extended-precision comparisons. Fortunately, you can compare extended-precision
    values by using just a `cmp` instruction, as you’ll soon see.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the two unsigned values 2157h and 1293h. The LO bytes of these two
    values do not affect the outcome of the comparison. Simply comparing the HO bytes,
    21h with 12h, tells us that the first value is greater than the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to look at both bytes of a pair of values only if the HO bytes are
    equal. In all other cases, comparing the HO bytes tells you everything you need
    to know about the values. This is true for any number of bytes, not just two.
    The following code compares two signed 128-bit integers by comparing their HO
    quad words first and comparing their LO quad words only if the HO quad words are
    equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To compare unsigned values, use the `ja` and `jb` instructions in place of `jg`
    and `jl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can synthesize any comparison from the preceding sequence, as shown in
    the following examples that demonstrate signed comparisons; just substitute `ja`,
    `jae`, `jb`, and `jbe` for `jg`, `jge`, `jl`, and `jle` (respectively) if you
    want unsigned comparisons. Each of the following examples assumes these declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code implements a 128-bit test to see if `OW1 < OW2` (signed).
    Control transfers to the `IsLess` label if `OW1 < OW2`. Control falls through
    to the next statement if this is not true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a 128-bit test to see if `OW1 <= OW2` (signed). This code jumps to
    `IsLessEq` if the condition is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a 128-bit test to see if `OW1 > OW2` (signed). It jumps to `IsGtr`
    if this condition is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a 128-bit test to see if `OW1 >= OW2` (signed). This code
    jumps to label `IsGtrEQ` if this is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a 128-bit test to see if `OW1 == OW2` (signed or unsigned). This code
    branches to the label `IsEqual` if `OW1 == OW2`. It falls through to the next
    instruction if they are not equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a 128-bit test to see if `OW1 != OW2` (signed or unsigned).
    This code branches to the label `IsNotEqual` if `OW1 != OW2`. It falls through
    to the next instruction if they are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To generalize the preceding code for objects larger than 128 bits, start the
    comparison with the objects’ HO quad words and work your way down to their LO
    quad words, as long as the corresponding double words are equal. The following
    example compares two 256-bit values to see if the first is less than or equal
    (unsigned) to the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.4 Extended-Precision Multiplication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although an 8×8-, 16×16-, 32×32-, or 64×64-bit multiplication is usually sufficient,
    sometimes you may want to multiply larger values. You use the x86-64 single-operand
    `mul` and `imul` instructions for extended-precision multiplication operations,
    using the same techniques that you employ when manually multiplying two values.
    Consider the way you perform multi-digit multiplication by hand ([Figure 8-3](#figure8-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08003](image_fi/501089c08/f08003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: Multi-digit multiplication'
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 does extended-precision multiplication in the same manner except
    that it works with bytes, words, double words, and quad words rather than digits,
    as shown in [Figure 8-4](#figure8-4).
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most important thing to remember when performing an extended-precision
    multiplication is that you must also perform an extended-precision addition at
    the same time. Adding up all the partial products requires several additions.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08004](image_fi/501089c08/f08004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: Extended-precision multiplication'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-1](#listing8-1) demonstrates how to multiply two 64-bit values (producing
    a 128-bit result) by using 32-bit instructions. Technically, you can do a 64-bit
    multiplication with a single instruction, but this example demonstrates a method
    you can easily extend to 128 bits by using the x86-64 64-bit registers rather
    than the 32-bit registers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: Extended-precision multiplication'
  prefs: []
  type: TYPE_NORMAL
- en: The code works only for unsigned operands. To multiply two signed values, you
    must note the signs of the operands before the multiplication, take the absolute
    value of the two operands, do an unsigned multiplication, and then adjust the
    sign of the resulting product based on the signs of the original operands. Multiplication
    of signed operands is left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: The example in [Listing 8-1](#listing8-1) was fairly straightforward because
    it was possible to keep the partial products in various registers. If you need
    to multiply larger values together, you will need to maintain the partial products
    in temporary (memory) variables. Other than that, the algorithm that [Listing
    8-1](#listing8-1) uses generalizes to any number of double words.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.5 Extended-Precision Division
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot synthesize a general *n*-bit / *m*-bit division operation by using
    the `div` and `idiv` instructions—though a less general operation, dividing an
    *n*-bit quantity by a 64-bit quantity can be done using the `div` instruction.
    A generic extended-precision division requires a sequence of shift and subtract
    instructions (which takes quite a few instructions and runs much slower). This
    section presents both methods (using `div` and shift and subtract) for extended-precision
    division.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.5.1 Special Case Form Using div Instruction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dividing a 128-bit quantity by a 64-bit quantity is handled directly by the
    `div` and `idiv` instructions, as long as the resulting quotient fits into 64
    bits. However, if the quotient does not fit into 64 bits, then you have to perform
    extended-precision division.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to divide 0004_0000_0000_1234h by 2\. The naive
    approach would look something like the following (assuming the value is held in
    a pair of qword variables named `dividend`, and `divisor` is a quad word containing
    2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Although this code is syntactically correct and will compile, it will raise
    a divide error exception when run. The quotient must fit into the RAX register
    when using `div`, and 2_0000_091Ah will not fit, being a 66-bit quantity (try
    dividing by 8 if you want to see it produce a result that will fit).
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the trick is to divide the (zero- or sign-extended) HO double word
    of the dividend by the divisor and then repeat the process with the remainder
    and the LO dword of the dividend, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `quotient` variable is 128 bits because it’s possible for the result to
    require as many bits as the dividend (for example, if you divide by 1). Regardless
    of the size of the `dividend` and `divisor` operands, the remainder is never larger
    than 64 bits (in this case). Hence, the `remainder` variable in this example is
    just a quad word.
  prefs: []
  type: TYPE_NORMAL
- en: To correctly compute the 128 / 64 quotient, begin by computing the 64 / 64 quotient
    of `dividend[8]` / `divisor`. The quotient from this first division becomes the
    HO double word of the final quotient. The remainder from this division becomes
    the extension in RDX for the second half of the division operation. The second
    half of the code divides `rdx:dividend[0]` by `divisor` to produce the LO quad
    word of the quotient and the remainder from the division. The code does not zero-extend
    RAX into RDX prior to the second `div` instruction, because RDX already contains
    valid bits that must not be disturbed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding 128 / 64 division operation is a special case of the general
    division algorithm to divide an arbitrary-size value by a 64-bit divisor. The
    general algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the HO quad word of the dividend into RAX and zero-extend it into RDX.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Divide by the divisor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the value in RAX into the corresponding qword position of the quotient
    result variable (position of the dividend qword loaded into RAX prior to the division).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load RAX with the next-lower quad word in the dividend, without modifying RDX.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 to 4 until you’ve processed all the quad words in the dividend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end, the RDX register will contain the remainder, and the quotient will
    appear in the destination variable, where step 3 was storing the results. [Listing
    8-2](#listing8-2) demonstrates how to divide a 256-bit quantity by a 64-bit divisor,
    producing a 256-bit quotient and a 64-bit remainder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: Unsigned 128 / 32-bit extended-precision division'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output (note that you can verify that
    the division was correct by simply looking at the result, noting that each digit
    is one-half the original value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can extend this code to any number of bits by adding additional `mov`-`div`-`mov`
    instructions to the sequence. Like the extended-precision multiplication in the
    previous section, this extended-precision division algorithm works only for unsigned
    operands. To divide two signed quantities, you must note their signs, take their
    absolute values, do the unsigned division, and then set the sign of the result
    based on the signs of the operands.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.5.2 Generic N-bit by M-bit Division
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use a divisor larger than 64 bits, you have to implement the division by
    using a shift-and-subtract strategy, which works but is very slow. As with multiplication,
    the best way to understand how the computer performs division is to study how
    you were taught to do long division by hand. Consider the operation 3456 / 12
    and the steps you would take to manually perform this operation, as shown in [Figure
    8-5](#figure8-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08005](image_fi/501089c08/f08005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: Manual digit-by-digit division operation'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is actually easier in binary because at each step you do not
    have to guess how many times 12 goes into the remainder, nor do you have to multiply
    12 by your guess to obtain the amount to subtract. At each step in the binary
    algorithm, the divisor goes into the remainder exactly 0 or 1 time. As an example,
    consider the division of 27 (11011) by 3 (11) that is shown in [Figure 8-6](#figure8-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08006](image_fi/501089c08/f08006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: Longhand division in binary'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following algorithm implements this binary division operation in a way
    that computes the quotient and the remainder at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`NumberBits` is the number of bits in the `Remainder`, `Quotient`, `Divisor`,
    and `Dividend` variables. `SHL` is the left-shift operator. The `Quotient := Quotient
    + 1;` statement sets the LO bit of `Quotient` to `1` because this algorithm previously
    shifts `Quotient` 1 bit to the left. [Listing 8-3](#listing8-3) implements this
    algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: Extended-precision division'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does not check for division by 0 (it will produce the value 0FFFF_FFFF_FFFF_FFFFh
    if you attempt to divide by 0); it handles only unsigned values and is very slow
    (an order of magnitude or two worse than the `div` and `idiv` instructions). To
    handle division by 0, check the divisor against 0 prior to running this code and
    return an appropriate error code if the divisor is 0\. Dealing with signed values
    is the same as the earlier division algorithm: note the signs, take the operands’
    absolute values, do the unsigned division, and then fix the sign afterward.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the following technique to boost the performance of this division
    by a fair amount. Check to see if the divisor variable uses only 32 bits. Often,
    even though the divisor is a 128-bit variable, the value itself fits into 32 bits
    (that is, the HO double words of `Divisor` are 0) and you can use the `div` instruction,
    which is much faster. The improved algorithm is a bit more complex because you
    have to first compare the HO quad words for 0, but on average, it runs much faster
    while remaining capable of dividing any two pairs of values.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.6 Extended-Precision Negation Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `neg` instruction doesn’t provide a generic extended-precision form. However,
    a negation is equivalent to subtracting a value from 0, so we can easily simulate
    an extended-precision negation by using the `sub` and `sbb` instructions. The
    following code provides a simple way to negate a (320-bit) value by subtracting
    that value from 0, using an extended-precision subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A slightly more efficient way to negate smaller values (128 bits) uses a combination
    of `neg` and `sbb` instructions. This technique uses the fact that `neg` subtracts
    its operand from 0\. In particular, it sets the flags the same way the `sub` instruction
    would if you subtracted the destination value from 0\. This code takes the following
    form (assuming you want to negate the 128-bit value in RDX:RAX):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first two instructions negate the HO and LO qwords of the 128-bit result.
    However, if there is a borrow out of the LO negation (think of `neg rax` as subtracting
    0 from RAX, possibly producing a carry/borrow), that borrow is not subtracted
    from the HO qword. The `sbb` instruction at the end of this sequence subtracts
    nothing from RDX if no borrow occurs when negating RAX; it subtracts 1 from RDX
    if a borrow was needed when subtracting 0 from RAX.
  prefs: []
  type: TYPE_NORMAL
- en: With a lot of work, it is possible to extend this scheme to more than 128 bits.
    However, around 256 bits (and certainly, once you get beyond 256 bits), it actually
    takes fewer instructions to use the general subtract-from-zero scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.7 Extended-Precision AND Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Performing an *n*-byte AND operation is easy: simply AND the corresponding
    bytes between the two operands, saving the result. For example, to perform the
    AND operation with all operands 128 bits long, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To extend this technique to any number of qwords, logically AND the corresponding
    bytes, words, double words, or quad words together in the operands.
  prefs: []
  type: TYPE_NORMAL
- en: This sequence sets the flags according to the value of the last `and` operation.
    If you AND the HO quad words last, this sets all but the zero flag correctly.
    If you need to test the zero flag after this sequence, logically OR the two resulting
    double words together (or otherwise compare them both against 0).
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.8 Extended-Precision OR Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multi-byte logical OR operations are performed in the same way as multi-byte
    AND operations. You OR the corresponding bytes in the two operands together. For
    example, to logically OR two 192-bit values, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous example, this does not set the zero flag properly for the
    entire operation. If you need to test the zero flag after an extended-precision
    OR, you must logically OR all the resulting double words together.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.9 Extended-Precision XOR Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with other logical operations, extended-precision XOR operations exclusive-ORs
    the corresponding bytes in the two operands to obtain the extended-precision result.
    The following code sequence operates on two 64-bit operands, computes their exclusive-or,
    and stores the result into a 64-bit variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The comment about the zero flag in the previous two sections, as well as the
    comment about the XMM and YMM registers, apply here.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.10 Extended-Precision NOT Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `not` instruction inverts all the bits in the specified operand. An extended-precision
    NOT is performed by executing the `not` instruction on all the affected operands.
    For example, to perform a 128-bit NOT operation on the value in RDX:RAX, execute
    the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that if you execute the NOT instruction twice, you wind up with
    the original value. Also, exclusive-ORing a value with all 1s (0FFh, 0FFFFh, 0FFFF_FFFFh,
    or 0FFFF_FFFF_FFFF_FFFFh) performs the same operation as the `not` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.11 Extended-Precision Shift Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extended-precision shift operations require a shift and a rotate instruction.
    This section describes how to construct these operations.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.11.1 Extended-Precision Shift Left
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A 128-bit `shl` (*shift left*) takes the form shown in [Figure 8-7](#figure8-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08007](image_fi/501089c08/f08007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: 128-bit shift-left operation'
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this with machine instructions, we must first shift the LO qword
    to the left (for example, using the `shl` instruction) and capture the output
    from bit 63 (conveniently, the carry flag does this for us). We must then shift
    this bit into the LO bit of the HO qword while simultaneously shifting all the
    other bits to the left (and capturing the output by using the carry flag).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `shl` and `rcl` instructions to implement this 128-bit shift.
    For example, to shift the 128-bit quantity in RDX:RAX one position to the left,
    you’d use the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `shl` instruction shifts a 0 into bit 0 of the 128-bit operand and shifts
    bit 63 into the carry flag. The `rcl` instruction then shifts the carry flag into
    bit 64 and shifts bit 127 into the carry flag. The result is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Using this technique, you can shift an extended-precision value only 1 bit at
    a time. You cannot shift an extended-precision operand several bits by using the
    CL register, nor can you specify a constant value greater than 1 when using this
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a shift left on an operand larger than 128 bits, use additional
    `rcl` instructions. An extended-precision shift-left operation always starts with
    the least-significant quad word, and each succeeding `rcl` instruction operates
    on the next-most-significant double word. For example, to perform a 192-bit shift-left
    operation on a memory location, you could use the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to shift your data by 2 or more bits, you can either repeat the
    preceding sequence the desired number of times (for a constant number of shifts)
    or place the instructions in a loop to repeat them a certain number of times.
    For example, the following code shifts the 192-bit value `Operand` to the left
    by the number of bits specified in CL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.11.2 Extended-Precision Shift Right and Shift Arithmetic Right
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You implement `shr` (*shift right*) and `sar` (*shift arithmetic right*) in
    a similar way, except you must start at the HO word of the operand and work your
    way down to the LO word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The extended-precision shifts set the flags differently than their 8-, 16-,
    32-, and 64-bit counterparts, because the rotate instructions affect the flags
    differently than the shift instructions. Fortunately, the carry flag is the one
    you’ll test most often after a shift operation, and the extended-precision shift
    operations (that is, rotate instructions) properly set this flag.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.11.3 Efficient Multi-bit Extended-Precision Shifts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `shld` and `shrd` instructions let you efficiently implement extended-precision
    shifts of several bits. These instructions have the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `shld` instruction works as shown in [Figure 8-8](#figure8-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08008](image_fi/501089c08/f08008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8: `shld` operation'
  prefs: []
  type: TYPE_NORMAL
- en: '`Operand`2 must be a 16-, 32-, or 64-bit register. `Operand`1 can be a register
    or a memory location. Both operands must be the same size. The third operand,
    `constant` or `cl`, specifies the number of bits to shift, and may be a value
    in the range 0 through *n* – 1, where *n* is the size of the first two operands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shld` instruction shifts a copy of the bits in `Operand`2 to the left
    by the number of bits specified by the third operand, storing the result into
    the location specified by the first operand. The HO bits shift into the carry
    flag, and the HO bits of `Operand`2 shift into the LO bits of `Operand`1. The
    third operand specifies the number of bits to shift. If the count is *n*, then
    `shld` shifts bit *n* – 1 into the carry flag (obviously, this instruction maintains
    only the last bit shifted into the carry). The `shld` instruction sets the flag
    bits as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the shift count is 0, `shld` doesn’t affect any flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The carry flag contains the last bit shifted out of the HO bit of `Operand`1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the shift count is 1, the overflow flag will contain 1 if the sign bit of
    `Operand`1 changes during the shift. If the count is not 1, the overflow flag
    is undefined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zero flag will be 1 if the shift produces a 0 result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sign flag will contain the HO bit of the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `shrd` instruction is similar to `shld` except, of course, it shifts its
    bits right rather than left. To get a clear picture of the `shrd` instruction,
    consider [Figure 8-9](#figure8-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08009](image_fi/501089c08/f08009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9: `shrd` operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shrd` instruction sets the flag bits as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the shift count is 0, `shrd` doesn’t affect any flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The carry flag contains the last bit shifted out of the LO bit of `Operand`1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the shift count is 1, the overflow flag will contain 1 if the HO bit of `Operand`1
    changes. If the count is not 1, the overflow flag is undefined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zero flag will be 1 if the shift produces a 0 result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sign flag will contain the HO bit of the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first `shld` instruction shifts the bits from `ShiftMe[8]` into `ShiftMe[16]`
    without affecting the value in `ShiftMe[8]`. The second `shld` instruction shifts
    the bits from `ShiftMe` into `ShiftMe[8]`. Finally, the `shl` instruction shifts
    the LO double word the appropriate amount.
  prefs: []
  type: TYPE_NORMAL
- en: There are two important things to note about this code. First, unlike the other
    extended-precision shift-left operations, this sequence works from the HO quad
    word down to the LO quad word. Second, the carry flag does not contain the carry
    from the HO shift operation. If you need to preserve the carry flag at that point,
    you will need to push the flags after the first `shld` instruction and pop the
    flags after the `shl` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: You can do an extended-precision shift-right operation by using the `shrd` instruction.
    It works almost the same way as the preceding code sequence, except you work from
    the LO quad word to the HO quad word. The solution is left as an exercise for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.12 Extended-Precision Rotate Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `rcl` and `rcr` operations extend in a manner similar to `shl` and `shr`.
    For example, to perform 192-bit `rcl` and `rcr` operations, use the following
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this code and the code for the extended-precision
    shift operations is that the first instruction is a `rcl` or `rcr` rather than
    a `shl` or `shr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing an extended-precision `rol` or `ror` operation isn’t quite as simple
    because of the way the incoming bit is processed. You can use the `bt`, `shld`,
    and `shrd` instructions to implement an extended-precision `rol` or `ror` instruction.^([3](#c08-footnote-3))
    The following code shows how to use the `shld` and `bt` instructions to do a 128-bit
    extended-precision `rol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: An extended-precision `ror` instruction is similar; just keep in mind that you
    work on the LO end of the object first, and the HO end last.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Operating on Different-Size Operands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally, you may need to do a computation on a pair of operands that are
    not the same size. For example, you may need to add a word and a double word together
    or subtract a byte value from a word value. To do so, extend the smaller operand
    to the size of the larger operand and then operate on two same-size operands.
    For signed operands, you sign-extend the smaller operand to the same size as the
    larger operand; for unsigned values, you zero-extend the smaller operand. This
    works for any operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples demonstrate adding a byte variable and a word variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the byte variable was loaded into the AL register, extended to
    16 bits, and then added to the word operand. This code works out really well if
    you can choose the order of the operations (for example, adding the 8-bit value
    to the 16-bit value).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you cannot specify the order of the operations. Perhaps the 16-bit
    value is already in the AX register, and you want to add an 8-bit value to it.
    For unsigned addition, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first `add` instruction adds the byte at `var1` to the LO byte of the value
    in the accumulator. The `adc` instruction adds the carry from the addition of
    the LO bytes into the HO byte of the accumulator. If you leave out `adc`, you
    may not get the correct result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding an 8-bit signed operand to a 16-bit signed value is a little more difficult.
    Unfortunately, you cannot add an immediate value (as in the preceding example)
    to the HO word of AX, because the HO extension byte can be either 0 or 0FFh. If
    a register is available, the best thing to do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If an extra register is not available, you might try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because the x86-64 can push 16-bit registers. One word of advice:
    don’t leave the RSP register misaligned (not on an 8-byte boundary) for very long.
    If you’re working with 32- or 64-bit registers, you’ll have to push the full 64-bit
    register and add 8 to RSP when you’re done with the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative is to store the 16-bit value in the accumulator into a
    memory location and then proceed as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: All these examples add a byte value to a word value. By zero- or sign-extending
    the smaller operand to the size of the larger operand, you can easily add any
    two different-size variables together.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last example, consider adding an 8-bit signed value to an oword (128-bit)
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 8.3 Decimal Arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The x86-64 CPUs use the binary numbering system for their native internal representation.
    In the early days of computing, designers thought that decimal (base-10) arithmetic
    was more accurate for business calculations. Mathematicians have shown that this
    is not the case; nevertheless, some algorithms depend on decimal calculations
    to produce correct results. Therefore, although decimal arithmetic is generally
    less efficient and less accurate than using binary arithmetic, the need for decimal
    arithmetic persists.
  prefs: []
  type: TYPE_NORMAL
- en: To represent decimal numbers in the native binary format, the most common technique
    is to use the *binary-coded decimal (**BCD)* representation. This uses 4 bits
    to represent the 10 possible decimal digits (see [Table 8-1](#table8-1)). The
    binary value of those 4 bits is equal to the corresponding decimal value in the
    range 0 to 9\. Of course, with 4 bits we can actually represent 16 different values;
    the BCD format ignores the remaining six bit combinations. Because each BCD digit
    requires 4 bits, we can represent a two-digit BCD value with a single byte. This
    means that we can represent the decimal values in the range 0 to 99 by using a
    single byte (as opposed to 0 to 255 with a byte in binary format).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1: Binary-Coded Decimal Representation'
  prefs: []
  type: TYPE_NORMAL
- en: '| **BCD representation** | **Decimal equivalent** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0001 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0010 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 0011 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 0100 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 0101 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 0110 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 0111 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 1000 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 1001 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 1010 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: '| 1011 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: '| 1100 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: '| 1101 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: '| 1110 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: 8.3.1 Literal BCD Constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MASM does not provide, nor do you need, a literal BCD constant. Because BCD
    is just a form of hexadecimal notation that does not allow the values 0Ah to 0Fh,
    you can easily create BCD constants by using MASM’s hexadecimal notation. For
    example, the following `mov` instruction copies the BCD value 99 into the AL register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to keep in mind is that you must not use MASM literal decimal
    constants for BCD values. That is, `mov al, 95` does not load the BCD representation
    for 95 into the AL register. Instead, it loads 5Fh into AL, and that’s an illegal
    BCD value.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2 Packed Decimal Arithmetic Using the FPU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To improve the performance of applications that rely on decimal arithmetic,
    Intel incorporated support for decimal arithmetic directly into the FPU. The FPU
    supports values with up to 18 decimal digits of precision, with computations using
    all the arithmetic capabilities of the FPU, from addition to transcendental operations.
    Assuming you can live with only 18 digits of precision and a few other restrictions,
    decimal arithmetic on the FPU is the right way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FPU supports only one BCD data type: a 10-byte 18-digit packed decimal
    value. The packed decimal format uses the first 9 bytes to hold the BCD value
    in a standard packed decimal format. The first byte contains the two LO digits,
    and the ninth byte holds the two HO digits. The HO bit of the tenth byte holds
    the sign bit, and the FPU ignores the remaining bits in the tenth byte (as using
    those bits would create possible BCD values that the FPU could not exactly represent
    in the native floating-point format).'
  prefs: []
  type: TYPE_NORMAL
- en: The FPU uses a one’s complement notation for negative BCD values. The sign bit
    contains a 1 if the number is negative, and it contains a 0 if the number is positive.
    If the number is 0, the sign bit may be either 0 or 1, because, like the binary
    one’s complement format, there are two distinct representations for 0.
  prefs: []
  type: TYPE_NORMAL
- en: MASM’s `tbyte` type is the standard data type used to define packed BCD variables.
    The `fbld` and `fbstp` instructions require a `tbyte` operand (which you can initialize
    with a hexadecimal/BCD value).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of fully supporting decimal arithmetic, the FPU provides two instructions,
    `fbld` and `fbstp`, that convert between packed decimal and binary floating-point
    formats when moving data to and from the FPU. The `fbld` (*float/BCD load*) instruction
    loads an 80-bit packed BCD value onto the top of the FPU stack after converting
    that BCD value to the binary floating-point format. Likewise, the `fbstp` (*float/BCD
    store and pop*) instruction pops the floating-point value off the top of stack,
    converts it to a packed BCD value, and stores the BCD value into the destination
    memory location. This means calculations are done using binary arithmetic. If
    you have an algorithm that absolutely, positively depends on the use of decimal
    arithmetic, it may fail if you use the FPU to implement it.^([4](#c08-footnote-4))
  prefs: []
  type: TYPE_NORMAL
- en: The conversion between packed BCD and the floating-point format is not a cheap
    operation. The `fbld` and `fbstp` instructions can be quite slow (more than two
    orders of magnitude slower than `fld` and `fstp`, for example). Therefore, these
    instructions can be costly if you’re doing simple additions or subtractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the FPU converts packed decimal values to the internal floating-point
    format, you can mix packed decimal, floating point, and (binary) integer formats
    in the same calculation. The following code fragment demonstrates how you might
    achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The FPU treats packed decimal values as integer values. Therefore, if your calculations
    produce fractional results, the `fbstp` instruction will round the result according
    to the current FPU rounding mode. If you need to work with fractional values,
    you need to stick with floating-point results.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 For More Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Donald Knuth’s *The Art of Computer Programming*, Volume 2: *Seminumerical
    Algorithms* (Addison-Wesley Professional, 1997) contains a lot of useful information
    about decimal arithmetic and extended-precision arithmetic, though that text is
    generic and doesn’t describe how to do this in x86-64 assembly language. Additional
    information on BCD arithmetic can also be found at the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BCD Arithmetic, a Tutorial, [http://homepage.divms.uiowa.edu/~jones/bcd/bcd.html](http://homepage.divms.uiowa.edu/~jones/bcd/bcd.html)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**   *General Decimal Arithmetic, [http://speleotrove.com/decimal/](http://speleotrove.com/decimal/)***   *Intel
    Decimal Floating-Point Math Library, [https://software.intel.com/en-us/articles/intel-decimal-floating-point-math-library/](https://software.intel.com/en-us/articles/intel-decimal-floating-point-math-library/)***'
  prefs: []
  type: TYPE_NORMAL
- en: '***## 8.5 Test Yourself'
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide the code to compute *x* = *y* + *z*, assuming the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x*, *y*, and *z* are 128-bit integers'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* and *y* are 96-bit integers, and *z* is a 64-bit integer'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x*, *y*, and *z* are 48-bit integers'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the code to compute *x* = *y* − *z*, assuming the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x*, *y*, and *z* are 192-bit integers'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x*, *y*, and *z* are 96-bit integers'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the code to compute *x* = *y* × *z*, assuming *x*, *y*, and *z* are
    128-bit unsigned integers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the code to compute *x* = *y* / *z*, assuming *x* and *y* are 128-bit
    signed integers, and *z* is a 64-bit signed integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assuming *x* and *y* are unsigned 128-bit integers, convert the following to
    assembly language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: if(*x* == *y*) `then code`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: if(*x* < *y*) `then code`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: if(*x* > *y*) `then code`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: if(*x* ≠ *y*) `then code`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assuming *x* and *y* are signed 96-bit integers, convert the following to assembly
    language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: if(*x* == *y*) `then code`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: if(*x* < *y*) `then code`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: if(*x* > *y*) `then code`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assuming *x* and *y* are signed 128-bit integers, provide two distinct ways
    to convert the following to assembly language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* = –*x*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* = –*y*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assuming *x*, *y*, and *z* are all 128-bit integer values, convert the following
    to assembly language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* = *y* & *z* (bitwise logical AND)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* = *y* | *z* (bitwise logical OR)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* = *y* ^ *z* (bitwise logical XOR)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* = ~*y* (bitwise logical NOT)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* = *y* << 1 (bitwise shift left)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* = *y* >> 1 (bitwise shift right)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming *x* and *y* are signed 128-bit values, convert *x* = *y* >> 1 to assembly
    language (bitwise arithmetic shift right).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the assembly code to rotate the 128-bit value in *x* through the carry
    flag (left by 1 bit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the assembly code to rotate the 128-bit value in *x* through the carry
    flag (right by 1 bit).***
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
