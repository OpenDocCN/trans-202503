- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming the Microcontroller
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve written and run a “Hello World” program in the IDE, we’ll do
    the same on the STM32 NUCLEO-F030R8 development board, which contains the STM32F030R8
    processor and several other components needed to use the processor. On an embedded
    system, the equivalent of “Hello World” is a program that makes an LED blink.
    By making an LED blink, you’ll learn the steps needed to make a complex program
    at a smaller scale.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, you’ll learn how to use the System Workbench for STM32, which
    we explored in the last chapter, to create an embedded program. To assist us,
    we’ll use STMicroelectronics software called the hardware abstraction layer (HAL),
    which hides some of the more annoying details of the hardware from you. (However,
    the details aren’t hidden very deep, and you can examine the source code to see
    what was done.) We’ll also get into what the IDE is doing behind the scenes with
    a detailed explanation of the options it’s using to compile the code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, like we did in Chapter 2, we’ll run the debugger to see our program
    execute one statement at a time, which will prove extremely useful when we start
    to make larger and larger programs.
  prefs: []
  type: TYPE_NORMAL
- en: The NUCLEO-F030R8 Development Board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Development boards* are circuit boards that contain a processor chip and various
    other components required to develop applications for that processor, including
    a lot of useful items for developing programs and circuits that use the chip.
    In addition to programming and debugging support, the development board includes
    numerous *connectors*, which allow you to hook up your prototype hardware. It
    also includes a few *peripherals* such as a serial port, a push button switch,
    and an LED, although some of the fancier boards will have additional peripherals.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the development board provides you with an instant prototype for developing
    the initial software with breadboarded hardware. Microprocessor manufacturers
    generally sell development boards with all that stuff included to get people to
    use their chips.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32 NUCLEO-F030R8 board bundles the STM32F030R8 chip with a clock circuit,
    a power supply, and some devices to talk to, including an LED, a button, and a
    serial I/O device. [Figure 3-1](#figure3-1) shows the basic building blocks of
    our processor board.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03001](image_fi/501621c03/f03001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: The processor board'
  prefs: []
  type: TYPE_NORMAL
- en: The power and clock drive the CPU, the reset button restarts the CPU, the user
    LED and push button are for user interaction, and the serial port and connectors
    are for programming and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Programming and Debugging the Board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The development board contains three devices useful for programming and debugging
    the chip—a flash programmer, a JTAG pod, and a serial I/O device—all of which
    connect to your computer through a single USB cable. (One cable, three devices.)
  prefs: []
  type: TYPE_NORMAL
- en: To program the chip, we use the *flash programmer*, a device that allows our
    PC to reprogram the memory of the chip. Reprogramming memory is how we get our
    program into the machine.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate debugging, the chip has a JTAG port. JTAG, which stands for Joint
    Test Action Group, is a standard debugging interface. Before this standard came
    out, everyone created their own debugging interface or, more often, left it out,
    leaving programmers to get very creative when it came to debugging programs. To
    debug with the JTAG port, we need to connect it to our computer. This is done
    through a *debug pod*, which has a connection to the JTAG port on our development
    board on one end and a connection to our computer’s USB port on the other.
  prefs: []
  type: TYPE_NORMAL
- en: Another very useful debugging and maintenance tool is the printing of diagnostic
    messages. The problem when it comes to embedded programs is where to print them.
    You don’t have a screen, so printing to the screen is out. Printing the messages
    in a logfile is difficult because you don’t have a filesystem. What most device
    designers do is put a *serial port*, a simple three-wire communication interface,
    on the board. Chapter 9 goes into the details of this device.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bottom half of the Nucleo board contains the chip and support circuitry,
    with lots and lots of pins broken out to connectors on the sides of the board
    (for connecting peripherals). Above that is the support board containing a programmer,
    a debugger, a serial-to-USB device, and a USB storage device.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-2](#figure3-2) shows how the board is put together.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03002](image_fi/501621c03/f03002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: The NUCLEO-F030R8 board'
  prefs: []
  type: TYPE_NORMAL
- en: 'The board also contains several jumpers and LEDs. *Jumpers* are small plastic
    devices that short two pins together. They are used to select hardware options,
    such as enabling the onboard debugger (ST-LINK), and should be installed as shown
    in [Figure 3-3](#figure3-3). Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the ST-LINK with two jumpers (CN2). Doing so configures the onboard
    debugging pod (ST-LINK) to debug the onboard microcontroller. If you remove these
    two jumpers, you can use the ST-LINK pod to debug other boards instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not install the power supply jumper (JP1). This configuration allows the
    Nucleo board to draw up to 300mA of power through the USB port, letting you power
    the device using the USB port. If you connected lots of power-hungry peripherals
    to the board, you could use JP1 to enable an external power supply. This book
    doesn’t use any external hardware, so leave JP1 out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not install RX-TX, a debug option that shorts the input and output of the
    serial port together. We’ll use the serial port as an actual serial port later,
    so leave this jumper off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the JP5 jumper to the right position (U5V). Doing so ensures the board
    will be powered through the USB port instead of through an external power source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Power the measurement jump (JP6). This is a lower-power device. The two pins
    shorted by JP6 supply power to the chip. Remove the jumper and connect an amp
    meter to measure power consumption.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CN11 and CN12 are places to store jumpers when not in use. Installing jumpers
    there won’t affect the circuitry.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03003](image_fi/501621c03/f03003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: Jumper and LED locations'
  prefs: []
  type: TYPE_NORMAL
- en: Now plug the device into your computer using a mini USB cable. LD1 should turn
    red, indicating the programmer has power. LD2 should blink, because the board
    comes with a preinstalled program that blinks LD2\. (This is true assuming you
    bought the board new. If, like me, you got your first board from your buddy down
    the hall, it will contain your buddy’s last experiment.) LD3 should also turn
    red, indicating that the chip has power.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up an Embedded Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you begin programming, close any open editing windows in System Workbench
    for STM32\. The editing window identifies the filename, not the project name,
    which causes a problem; all our projects will have a *main.c* file, and things
    would get pretty confusing with half a dozen *main.c* editing windows open.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create an embedded project by selecting **File**▶**New**▶**C Project**.
    (A checklist detailing these steps can be found in the appendix.) The C Project
    dialog should appear (see [Figure 3-4](#figure3-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03004](image_fi/501621c03/f03004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-4: The C Project dialog'
  prefs: []
  type: TYPE_NORMAL
- en: For the project name, enter **03.blink**. For the project type, select **Ac6
    STM32 MCU Project**. On first startup, the IDE downloads the GCC ARM toolchain
    to the directory where you installed the IDE, as well as the entire STM32 firmware
    library, a portion of which will get copied to your project. If you’d like to
    explore this library’s code and examples further, the cache directory it uses
    is *~/.ac6* on Linux and macOS and *C:\Users\<username>\AppData\Roaming\Ac6* on
    Windows. Be warned, however, that these examples are designed to show off the
    STM chips and aren’t easily understood by novice programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next**. The Select Configurations dialog, shown in [Figure 3-5](#figure3-5),
    should appear.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03005](image_fi/501621c03/f03005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-5: The Select Configurations dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Leave **Debug** selected and deselect **Release**. To keep things simple, we’ll
    perform only one type of build. Click **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the Target Configuration dialog (see [Figure 3-6](#figure3-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03006](image_fi/501621c03/f03006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-6: The Target Configuration dialog'
  prefs: []
  type: TYPE_NORMAL
- en: For the series, select **STM32F0**, and for the board, select **NUCLEO-F030R8**.
    Click **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the Project Firmware Configuration dialog (see [Figure 3-7](#figure3-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03007](image_fi/501621c03/f03007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-7: The Project Firmware Configuration dialog'
  prefs: []
  type: TYPE_NORMAL
- en: The project firmware configuration options let us use free standard code available
    from STMicroelectronics and other suppliers. Since someone else has written most
    of the hard stuff, let’s use their work. Select **Hardware Abstraction Layer (Cube
    HAL)** and then click the button labeled **Download Target Firmware** when it
    appears. Accept the license agreement, and the IDE will download the firmware
    library.
  prefs: []
  type: TYPE_NORMAL
- en: After the long download completes, the system displays additional options. Leave
    them to the default values and click **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the C/C++ Project view, you should see an entry in the project list
    for *blink*. Click the triangle next to *blink* to see a list of directories that
    make up the project, and click the triangle next to *src* to expand that directory.
    Double-click *main.c* to make it appear in the editing window, as shown in [Figure
    3-8](#figure3-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03008](image_fi/501621c03/f03008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-8: The editing window, showing *main.c*'
  prefs: []
  type: TYPE_NORMAL
- en: Your First Embedded Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The IDE has conveniently supplied you with a main file that has the minimal
    features of your program filled in: a comment, the code libraries for the Nucleo
    board, and a generic `main` function. The + icon next to line 3 indicates that
    some program lines have been *folded*, or hidden from view. Click the + icon to
    expand the long comment describing the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may wish to update this comment with your name and information. The keywords
    that begin with `@` are designed to work with *Doxygen*, a complex and full-featured
    system that extracts documentation out of large programs. We won’t be using this
    tool for our small programs, so you can edit the comment any way you want.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function doesn’t have a `return` statement because the `return` statement
    returns control from the program to the operating system, but a bare metal system
    doesn’t have an operating system. One of the jobs of the operating system is to
    start and stop programs (among other things). Since we don’t have an operating
    system, the processor halts whenever our program stops and does absolutely nothing.
    So we don’t stop. Ever. To see how we accomplish this, notice the `for(;;);` on
    line 19\. This is C code for “loop forever” (`for(;;)`) and “do nothing” (the
    closing semicolon).
  prefs: []
  type: TYPE_NORMAL
- en: But without an operating system, how do we start? Our program starts when the
    processor is turned on or is reset (hence the need for a big black reset button
    on the board).
  prefs: []
  type: TYPE_NORMAL
- en: As it stands now, our program doesn’t do anything and takes forever to do it.
    Let’s put in some code to do something.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we need to initialize the hardware. To do so, we’ll make our first use
    of the HAL library. The HAL software layer is designed to hide all the ugly details
    involved with getting the chip to work. For example, we have to initialize the
    on-chip clock before we can use it to time the blinks of an LED. Doing this ourselves
    would require programming specific *I/O* *registers* that directly control how
    an I/O device acts. They are part of the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Although we could go through the chip’s 700-page reference manual to determine
    what registers to program, and then do all the calculations to figure out what
    values to program them with, this would take a lot of work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can use the HAL software, and specifically the `HAL_Init` function,
    to do all that work for us. The `HAL_Init` function programs the system clock
    so we can use it later to time our LED. Insert a call to `HAL_Init` just after
    the first curly bracket in the `main` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In general, it’s best practice to indent by four spaces for every set of curly
    brackets you use. The C language does not require this, but it makes understanding
    the program easier. (There’s nothing magical about four spaces. Some programs
    use two, some eight, and a few strange people use three.)
  prefs: []
  type: TYPE_NORMAL
- en: That takes care of the basic hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Programming a GPIO Pin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The chip has a number of *general-purpose input/output pins*, referred to as
    *GPIO pins*, which we can program to either receive input or send output for a
    variety of things. For example, we can program a pin for output and connect it
    to an LED (which is exactly what we’ll do in this program). Alternatively, we
    can program a pin for input and connect it to a switch (which we’ll do in the
    next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Some of the microcontroller’s pins can be used as analog input or output. Most
    GPIO pins can be either on or off. Analog pins can handle voltages between on
    and off, such as 32765/65536 on. Others can be connected to a *USART* (serial
    I/O controller) or an *I2C bus* (simple I/O bus) to communicate with I2C peripheral
    chips. The good news is that these pins can do a lot of things. The bad news is
    that we have to program our chip to tell it, “Don’t do all that fancy stuff. Just
    turn on when I want you to turn on and turn off when I want you to turn off.”
  prefs: []
  type: TYPE_NORMAL
- en: 'We will program the GPIO pin that is connected to the user LED (LED2). We need
    to tell the chip that we are using this pin for output; then we must tell it a
    lot about how we are going to use it. This includes setting up a GPIO clock, which
    controls how fast it reacts. The HAL firmware can do most of this work, but we
    have to tell the HAL what to do by passing a structure of configuration information
    to the `HAL_GPIO_Init` function (C’s structure concept is covered in more detail
    in Chapter 7):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We set the pin on in order to transmit data to `LED2_PIN`, which is the one
    connected to the user LED. Next, we specify that the pin will be used for output
    because we’re sending data to the LED rather than retrieving data, and we set
    the mode to push/pull. This mode is determined by what you connect to the output
    pin. In this case, our circuit needs push/pull. This option controls the internal
    hardware used to drive the GPIO pin. The STM chip reference shows you how this
    circuit is organized (or, better put, it shows your hardware person how the chip
    is organized, and they can tell you which mode to use).
  prefs: []
  type: TYPE_NORMAL
- en: The pullup flags configure the GPIO pin so that, in input mode, a pullup resister
    is part of the circuit. This is irrelevant for output pins, but it still needs
    to be set. We set it to `GPIO_PULLUP`, which means absolutely nothing. Finally,
    we set the speed to high with `GPIO_SPEED_FREQ_HIGH`.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling the LED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now remove the final `;` after the `for(;;)` statement. Remember that this
    semicolon essentially means “do nothing.” To introduce code that the `for` loop
    should execute, add these new lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function `HAL_GPIO_TogglePin` toggles the `LED2` GPIO pin. On our chip,
    GPIO pins are organized into groups of 32 bits, collectively called a *GPIO register*.
    Our pin is in register `LED2_GPIO_PORT`. To tell the function which of the 32
    GPIO pins to toggle, we specify `LED2_PIN`.
  prefs: []
  type: TYPE_NORMAL
- en: After we toggle the pin, we need to do nothing for a while; otherwise, the LED
    will blink so fast we can’t see it. We use the `HAL_Delay` function to delay for
    400 milliseconds (ms).
  prefs: []
  type: TYPE_NORMAL
- en: Building the Completed Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our full program looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now build the project by selecting **Project**▶**Build Project**. If everything
    went okay, you should see no problems in the Problems window. If there are problems,
    fix them and try again.
  prefs: []
  type: TYPE_NORMAL
- en: In the Console window, you’ll see that the IDE invoked `make`, which then invoked
    the GCC compiler named `arm-none-eabi-gcc`. This is the compiler for our embedded
    chip.
  prefs: []
  type: TYPE_NORMAL
- en: Start the program by selecting **Run**▶**Run**. (Be sure to click **Run** on
    the main menu. You can also right-click the project, but that runs a slightly
    different command.) The Run command hides a lot of work. First, the IDE checks
    whether the project needs to be built. Then it runs a program that takes the program
    file and communicates with the flash programmer on our development board to flash
    the program in memory. Finally, the programmer tells the chip to reset and start
    our program.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, you should see the green LED blink slowly.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Build Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Console window shown in [Figure 3-9](#figure3-9) contains the output of
    the build process. (If this window is empty, you can re-create the contents with
    **Project**▶**Clean** followed by **Project**▶**Build Project**.)
  prefs: []
  type: TYPE_NORMAL
- en: '![f03009](image_fi/501621c03/f03009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-9: The Console window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s scroll up and look at one line in the build process, a typical invocation
    of the GCC compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a single line in the Console window, broken apart for formatting. As
    you can see, the compiler is being given a lot of additional options. The following
    are the key items on this command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arm-none-eabi-gcc` This is a GCC compiler, but unlike the native GCC, which
    compiles for your computer, it is a cross-compiler producing code for the ARM
    processor. There is no underlying operating system (hence the `none` option),
    and the system is designed for an embedded application binary interface (`eabi`),
    which defines how pieces of the program communicate with one another and with
    the outside world.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-mcpu=cortex-m0` This produces code for the `cortex-m0` version of the CPU.
    ARM has multiple processor variations, and this flag tells GCC which version to
    use.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-mthumb` Some ARM processors can execute two different instruction sets. There
    is the full 32-bit RISC instruction set, which executes very quickly but uses
    lots and lots of memory, and there is the *thumb* set, which is slower but far
    more compact. This directive tells GCC that we want thumb code (a good idea if
    you are using a cheap chip with limited memory, which we are).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-mfloat-abi=soft` Our processor does not have floating-point hardware, so
    this flag tells GCC to fake it with software. (More on floating point can be found
    in Chapter 16.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-O0` Specifies level `0` (that is, no) optimization. This turns off a compiler
    feature where the compiler analyzes your code and performs all sorts of tricks
    to make it go faster. These tricks make the underlying code harder to understand
    and debug.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-g3` Turns on debugging.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-Wall` Turns on the set of warnings named `all`, which contains almost all
    of the useful warnings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-c` Compiles a single source file into a single object file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-o"HALDriver/Src/stm32f0xxll_tim.o"` Stores the object file in the given file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"../HALDriver/Src/stm32f0xxll_tim.c"` Specifies name of the source file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other options tell the compiler where the included files are for the library
    and how these files should be configured. (We discuss the `-D` directive in Chapter
    12.) The `-I` directive tells the compiler to search for include files in the
    specified directory in addition to the standard include file directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the compilation commands, we can see the linker command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The key directive, `-T"/home/sdo/bare/workspace/blink/LinkerScript.ld"`, tells
    the linker to use *LinkerScript.ld* to tell it where to put the various pieces
    of the program. (This is discussed in detail in Chapter 11.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The build process ends with the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `arm-none-eabi-objcopy` command takes the *.elf* file and turns it into
    a raw binary image. ELF is a complex file format that tells the loader where to
    place various things. The raw binary image is exactly what’s going into your flash
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `arm-none-eabi-size` prints out the size of the resulting program ([Table
    3-1](#table3-1)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3-1: Program Memory Section Sizes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Segment** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | Size of read-only data (goes into flash) |'
  prefs: []
  type: TYPE_TB
- en: '| `data` | Size of read/write data that requires initialization (goes into
    RAM) |'
  prefs: []
  type: TYPE_TB
- en: '| `bss` | Size of read/write data that is initialized to zero (goes into RAM)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `dec` | Total size in decimal |'
  prefs: []
  type: TYPE_TB
- en: '| `hex` | Total size in hexadecimal |'
  prefs: []
  type: TYPE_TB
- en: We will explore the different types of memory, like flash and RAM, in later
    chapters. For now, understand that this step is done to answer the question, “If
    I keep programming, when will I run out of memory?”
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Project Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System Workbench for STM32 has created and downloaded a lot of files for our
    project. Let’s go through the key files.
  prefs: []
  type: TYPE_NORMAL
- en: We can view our *src* directory by clicking the triangle next to the directory
    name. It contains the files listed in [Table 3-2](#table3-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3-2: The *src* Directory Files'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *main.c* | The main program, where all our code goes. |'
  prefs: []
  type: TYPE_TB
- en: '| *stm32f0xxit.c* | The interrupt service routines. You will learn about interrupts
    in Chapter 10. For this simple program, the only interrupt we care about is the
    system clock, and even then, we don’t see the details of it directly. It’s used
    by `HAL_Delay`. |'
  prefs: []
  type: TYPE_TB
- en: '| *syscalls.c* | Dummy functions that are not used. |'
  prefs: []
  type: TYPE_TB
- en: '| *Systemstm32f0xx.c* | Code that supports the system clock (explained in later
    chapters). |'
  prefs: []
  type: TYPE_TB
- en: 'The *startup* directory contains one file: *startup_stm32f030x8.S*. This is
    an assembly language file that performs just enough initialization that the processor
    can run C code; it then jumps to the C startup code. This program contains the
    first instruction executed when you press the reset button.'
  prefs: []
  type: TYPE_NORMAL
- en: The *inc* directory contains one file, *stm32f0xx_it.h*, which is used to tell
    other programs about the interrupt handlers in *stm32f0xx_it.c*. It’s a very small
    and boring file.
  prefs: []
  type: TYPE_NORMAL
- en: Now we come to the *HAL_Driver* directory. This directory contains approximately
    130 files that provide a HAL library for use in the program. The HAL hides (abstracts)
    the fact that different ARM CPUs have different capabilities. For example, the
    function `HAL_Init` will initialize all the hardware. If you have a Cortex-M0
    processor, the Cortex-M0 version will initialize all the Cortex-M0 hardware. If
    you have a Cortex-M4 processor, all the Cortex-M4 hardware will be set up. There
    are so many files in this directory because the board we are using has lots of
    hardware. (And this is the simple version of the system.)
  prefs: []
  type: TYPE_NORMAL
- en: The *CMSIS* directory contains low-level code designed to support the HAL layer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *Debug* directory contains all the files related to our Debug build.
    In particular, it contains a `make` input file called *Makefile* and some generated
    files (see [Table 3-3](#table3-3)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3-3: Generated Files in the *Debug* Directory'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *blink.elf* | Our program in ELF format (a file format for executables) |'
  prefs: []
  type: TYPE_TB
- en: '| *blink.bin* | Our program as a memory image (raw code) |'
  prefs: []
  type: TYPE_TB
- en: '| *output.map* | The memory map for the program |'
  prefs: []
  type: TYPE_TB
- en: 'The last file on our list is at the top level: *LinkerScript.ld*. It tells
    the linker what the memory layout of our chip looks like and where to load the
    various pieces of the program. More on this in Chapter 11.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our blink program is simple and it works, but later we’re going to make more
    complex programs, and they will have bugs in them. Since the board we are programming
    has such a good debugger, we might as well get started learning how to use it.
    Start the debugger by selecting **Run**▶**Debug**, as shown in [Figure 3-10](#figure3-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03010](image_fi/501621c03/f03010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-10: Starting the debugger'
  prefs: []
  type: TYPE_NORMAL
- en: The IDE will then ask you for what type of debugger to run, as shown in [Figure
    3-11](#figure3-11). Select **Ac6 STM32 C/C++ Application**.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03011](image_fi/501621c03/f03011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-11: Debugger selection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The system will ask if you want to “Switch to the Debug Perspective.” Answer
    **Yes**. The system then goes through a number of steps automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: It builds the software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IDE downloads the program to the chip using the flash programmer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A debugger is attached to the device through the JTAG interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The debugger sets a breakpoint at the first line of `main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The breakpoint tells the chip to stop just before the first line of `main` is
    executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The microprocessor resets, and the program runs up to `main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The debugger regains control when the program reaches the breakpoint at `main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the debugger reaches the breakpoint, you are ready to debug the program,
    as seen in [Figure 3-12](#figure3-12). At this point, the program has executed
    until the first statement of the `main` function and is paused before the call
    to `HAL_Init`.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03012](image_fi/501621c03/f03012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-12: Debugging the program'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got control, let’s use it. Use the command **Run**▶**Step Over**
    to start executing the program one line at a time. We’ll do this a number of times,
    so remember the shortcut key F6\. Keep stepping over lines using F6 until you
    get into the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that every time you execute the `HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN)`
    function, the LED turns on or off. Since you are in the `for` loop, you ping-pong
    back and forth indefinitely between the toggling and the delay. If you are really
    observant, you’ll notice that it takes a little over 400 ms (two-fifths of a second)
    to execute the call to `HAL_Delay`. You can change this value to something really
    big if you would like to better observe the delay.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping Through the Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’ll get into some of the details of this program. Most of the concepts
    are covered in more depth in future chapters, but I’ll give you a taste of them
    now. First, let’s abort the current debugging session with **Run**▶**Terminate**.
    Now let’s start all over again, with **Run**▶**Debug**. You should be back to
    the line that calls `HAL_Init`. To step through the program, use a different command,
    **Run**▶**Step Into** (or shortcut key F5).
  prefs: []
  type: TYPE_NORMAL
- en: All of a sudden, the file *stm32f0xx_hal.c* appears in our editing window (see
    [Figure 3-13](#figure3-13)). Where did this file come from?
  prefs: []
  type: TYPE_NORMAL
- en: '![f03013](image_fi/501621c03/f03013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-13: Debugging *stm32f0xx_hal.c*'
  prefs: []
  type: TYPE_NORMAL
- en: Well, we called the procedure `HAL_Init`. That procedure is defined in *stm32f0xx_hal.c*,
    so the debugger automatically opened that file when we stepped into the call to
    `HAL_Init`. Alternatively, the Step Over command would treat the statement (in
    this case, `HAL_INIT();`) as a single unit and step over the function, hiding
    all the details.
  prefs: []
  type: TYPE_NORMAL
- en: The Step Into command knows we are calling a function and steps into its code.
    As you can see, it takes a lot of extra code to support our little program. When
    you program on a PC, the code is hidden from you, and it’s very difficult to get
    its source. The STM32 Workbench supplies all that code for you in the *HAL_Driver/Src*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to showing the code inside functions, the debugger can show us the
    status of all program variables. To see this in action, select **Run**▶**Step
    Over** (or press F6) about half a dozen times until you wind up back in *main.c*
    at the line that selects the pin to use. In the upper-right corner of the screen,
    you’ll see a panel titled Variables (see [Figure 3-14](#figure3-14)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03014](image_fi/501621c03/f03014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-14: The Variables panel'
  prefs: []
  type: TYPE_NORMAL
- en: In our program, we’ve defined a variable called `GPIO_InitStruct`. In the Variables
    panel, the + before the name indicates that `GPIO_InitStruct` is a *complex* variable,
    which means that it contains more than a simple integer, Boolean, or other single
    value. To see the all the components inside, expand it by clicking the + icon
    (see [Figure 3-15](#figure3-15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03015](image_fi/501621c03/f03015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-15: An expanded variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll learn about the components of `GPIO_InitStruct`, and how to create variables
    yourself, in later chapters. The `GPIO_InitStruct` variable was created by a programmer
    who read the 700-page reference manual on our chip and designed a variable to
    hold this information. Believe it or not, this variable significantly simplifies
    what’s presented in the manual: about 30 pages of compressed technical information
    on just the GPIO subsystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Now step through the next few statements to see the values of the components
    of this variable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve tried to make this program as simple as possible, but as you can see, with
    today’s complex chips, even the simplest operation takes a bit of work. Getting
    a program running requires a lot of support.
  prefs: []
  type: TYPE_NORMAL
- en: In the first chapter, our “Hello World” program required pretty much the same
    number of files mentioned here, but they existed behind the scenes. For example,
    the initialization file was installed as part of the GCC package. In our blink
    project, the file *startup_stm32f030x8.S* must be explicitly included.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter threw a ton of new concepts at you. Don’t worry if you don’t understand
    them all yet. We’ll dive deeper into them in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Experiment with changing the delay in the `Hal_Delay();` statement to make the
    blink frequency longer and shorter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine *LinkerScript.ld* to find the answers to the following questions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How much flash (read-only) memory do you have?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How much RAM (read/write memory) do you have?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine the file *output.map* and determine the actual address of `Reset_Handler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For intermediate readers: Change the program so it turns the LED on for a short
    time, then off for a longer time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What files are generated by the IDE, and what do they contain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where on your system did the IDE stash the compiler?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a commercial JTAG debugger look like? How much does it cost? What
    does it take to hook it up to a typical development board? (And be glad you got
    an integrated system!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
