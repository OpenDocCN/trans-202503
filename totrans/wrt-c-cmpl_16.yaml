- en: '![](../images/pg347.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-35.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">POINTERS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far, you’ve implemented only *arithmetic types*. These types have a lot in
    common; they all support the same basic mathematical operations, and you can always
    implicitly convert from one type to another. In the rest of [Part II](part2.xhtml),
    we’ll add several non-arithmetic types, like pointers, arrays, and structures.
    These types are quite different both from the arithmetic types and from each other.
    They don’t support ordinary arithmetic. Instead, each type supports its own distinct
    set of operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll implement *pointer types*, which represent memory addresses.
    You’ll also add two new operators for working with pointers: the address operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, and the dereference operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>. You’ll learn how to parse
    complex type specifiers and how to detect several new kinds of type errors. During
    TACKY and assembly generation, you’ll add a few new constructs to read from and
    write to locations in memory. You’ll continue to build on these changes as you
    add more non-arithmetic types in later chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s discuss a few key concepts that I’ll refer to throughout this
    chapter: objects, values, and lvalue conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Objects and Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects and values have come up in earlier chapters, but I never precisely defined
    either term or explained how they differ from each other. You can think of a *value*
    as a sequence of bits with a type. For example, the bits
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: with the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> have
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>. So far, we’ve
    encountered only integer and floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: An *object* is a location in memory that contains a value. Variables are the
    only objects we’ve seen so far. From the programmer’s perspective, every object
    has a memory address, which is fixed throughout its lifetime, and a value, which
    you can update using an assignment expression. (In practice, some objects may
    be stored in registers rather than memory, and you can’t update every object’s
    value, but we can ignore those exceptions for now.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](chapter5.xhtml), I described an lvalue as an expression that
    can appear on the left side of an assignment expression. Now we can use the more
    precise definition from section 6.3.2.1, paragraph 1, of the C standard: “An lvalue
    is an expression … that potentially designates an object.” (Note that an lvalue
    is *not* a value, in spite of its name; it’s an expression.) Evaluating a non-lvalue
    expression produces a value. Evaluating an lvalue, on the other hand, “determin[es]
    the identity of the designated object,” according to section 5.1.2.3, paragraph
    2, of the standard. If an expression designates an object, you can assign to it.
    Otherwise, you can’t.'
  prefs: []
  type: TYPE_NORMAL
- en: When you use an object in an expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    you’re actually using its current value. But when you assign to an object, you
    don’t care about its current value, which you’re just going to overwrite; you
    care about its location, which you’re trying to write to. In other words, if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    you sometimes treat it like a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and sometimes like a container where you can store a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    The C standard refers to the first case, where you use an object’s value in an
    expression, as *lvalue conversion*. This is a “conversion” in the sense that you’re
    converting an lvalue, which designates an object, into an ordinary value. If an
    lvalue appears as the left operand of an assignment expression or as the operand
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator, it doesn’t
    undergo lvalue conversion. If it appears anywhere else in an expression, it does.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is an lvalue
    in the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>, but it’s not an lvalue
    in the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(x)</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    In later chapters, we’ll encounter other expressions that aren’t lvalue converted.
  prefs: []
  type: TYPE_NORMAL
- en: This terminology lets us talk about pointers without getting hopelessly confused.
    Now we can discuss precisely what operations pointers support.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Operations on Pointers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section I’ll introduce the address operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>,
    which gets a pointer to an object, and the dereference operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    which you use to access an object through a pointer. I’ll also discuss casting
    and comparing pointers, plus one special case involving the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator. I won’t talk about pointer addition or subtraction yet; we’ll implement
    those in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Address and Dereference
    Operations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To see how the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operations work, let’s walk through
    the program in [Listing 14-1](chapter14.xhtml#list14-1). We’ll pay special attention
    to which expressions in this program designate objects and which ones result in
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: A simple program
    using</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">&</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">*</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by declaring a variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is an object, it
    has an address, although that address won’t be the same every time you run the
    program. Let’s say that, during one run of [Listing 14-1](chapter14.xhtml#list14-1),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> winds up at memory address
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>. It also has
    a value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. Since the type
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    we’ll interpret its value as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    which is also an object. The type of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, or “pointer to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,” which represents the
    address of an object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Like <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    has an address; let’s say it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b940</samp>.
    It also has a value: the result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator takes the
    address of its operand, which implies that its operand must designate an object
    with an address. In other words, the operand must be an lvalue. The result of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator, however,
    is not an object; it’s a value of pointer type.'
  prefs: []
  type: TYPE_NORMAL
- en: In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>, the
    operand is the lvalue <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    Evaluating <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp> results in
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>,
    which is the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    We assign this value to the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    just like we can assign any value to a variable with a compatible type. To help
    us keep things straight, [Figure 14-1](#fig14-1) shows the contents of the stack
    at this point in the program.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: The addresses
    and initial values of the objects declared in [Listing 14-1](chapter14.xhtml#list14-1)
    [Description](description-36.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As this figure shows, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>
    is both the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>. I said
    earlier that a value is a sequence of bits with a type; the type of the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> because it’s the address of an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: On the next line of [Listing 14-1](chapter14.xhtml#list14-1), we have the assignment
    expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, which consists of several
    subexpressions. On the right, we have the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>;
    on the left, we have the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    itself part of the dereference expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>.
    The constant isn’t particularly interesting, but the other two subexpressions
    are. The innermost of these expressions, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    designates an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. We don’t assign to it or take its address; we just read its value. Therefore,
    we implicitly lvalue convert it, which results in a *value* of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>.
    We use this value in a dereference expression, <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>.
    A dereference expression is an lvalue, so its result is an object. In this case,
    it’s the object at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>,
    since that’s the value being dereferenced. Because we’re assigning to the object
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>, rather than using its
    value, it doesn’t undergo lvalue conversion. [Figure 14-2](#fig14-2) shows the
    contents of the stack after this statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig14-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: The contents of
    the stack after assignment through a dereferenced pointer [Description](description-37.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We dereference <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> one
    more time in the final <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. Once again, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">*ptr</samp>
    is the object at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>.
    This time, however, we aren’t assigning to this object or applying the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator to it. Therefore, we perform lvalue conversion, which results in the
    object’s current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operate on objects
    and values, let’s talk about conversions to and from pointer types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Null Pointers and
    Type Conversions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An integer constant expression whose value is 0, called a *null pointer constant*,
    can be converted implicitly to any pointer type. The result of this conversion
    is a *null pointer*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because a null pointer is not a valid memory address, the result of dereferencing
    it is undefined. In practice, dereferencing a null pointer will likely crash your
    program. The C standard permits constant expressions like <samp class="SANS_TheSansMonoCd_W5Regular_11">(long)
    0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">10 - 10</samp> as null
    pointer constants, but we’ll support only constant literals like <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">0ul</samp>. (This is the same
    limitation we placed on static initializers in [Chapter 10](chapter10.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: 'With the exception of null pointer constants, it’s illegal to implicitly convert
    integers to pointers or vice versa. Consider this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, it’s illegal to assign it
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>, which has type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. For the same reason, it’s
    illegal to assign a nonzero constant to a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These declarations of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2</samp> are both illegal
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>
    are integers, not pointers. Note that the type of an expression has nothing to
    do with whether its value is a valid memory address. Even if <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>
    happens to be a valid address, the constant expression <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>
    is still a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> rather than
    a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also illegal to implicitly convert from one pointer type to another (with
    the exception of conversions to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>, which I’ll introduce in [Chapter 17](chapter17.xhtml)). For example,
    you can’t implicitly convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double
    *</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long *</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: GCC warns about the implicit conversions in the previous three code snippets,
    but it still compiles them. We’ll take a stricter approach and treat these implicit
    conversions as errors.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, *explicit* casts between pointer types, and between pointer
    and integer types, are legal. [Listing 14-2](chapter14.xhtml#list14-2) shows an
    example of an explicit cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">double
    *</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long *</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: An explicit pointer
    type conversion</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After the explicit cast and assignment ❶, <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> contain the same memory
    address, interpreted as two different pointer types.
  prefs: []
  type: TYPE_NORMAL
- en: One important caveat is that dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    after this cast would result in undefined behavior. With a few exceptions, if
    we declare an object with some type (called its *effective type*) and then access
    it using an expression of a different type, the result is undefined. In other
    words, casting from one pointer type to another is always legal, but using the
    result of that cast expression may not be. In [Listing 14-2](chapter14.xhtml#list14-2),
    the effective type of <samp class="SANS_TheSansMonoCd_W5Regular_11">negative_zero</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, so we can’t access
    it with the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*l</samp>,
    which has type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. The complete set of rules
    about which types of expressions you can use to access an object—unofficially
    called the *strict aliasing rules*—are spelled out in section 6.5, paragraphs
    6–7, of the C standard. Luckily, since we don’t need to detect undefined behavior
    or handle it gracefully, we can ignore these rules; our implementation will happily
    compile programs that violate them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can explicitly cast between pointer types and integer types. When
    you cast a null pointer constant to a pointer type, the result is a null pointer.
    When you cast any other integer to a pointer type, or any pointer to an integer
    type, the result is implementation-defined. On an x64 system, memory addresses
    are unsigned 64-bit integers, like <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7ffeee67b938</samp>.
    Therefore, if you convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> to a pointer (or vice versa), its value won’t change. Casting any
    other integer type to or from a pointer type has the same effect as casting to
    or from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. For
    example, if you cast a signed <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> with value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> to a pointer type, it will result
    in the largest representable memory address, <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>.
    This address is unlikely to hold a valid object, so dereferencing it will probably
    result in undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Casting a pointer type to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    or a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to a pointer
    type is illegal.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Comparisons</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can compare pointers of the same type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> operators. Two non-null
    pointers compare equal if they point to the same object (or just past the end
    of the same array, once we implement arrays). They compare unequal otherwise.
    A pointer to a valid object always compares unequal to a null pointer, and two
    null pointers always compare equal to each other. You can also use a pointer in
    any construct that compares an expression to zero, including logical <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    expressions; the condition in a conditional expression; and the controlling condition
    in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement or loop.
    In each of these cases, a null pointer counts as zero, and any non-null pointer
    is nonzero.
  prefs: []
  type: TYPE_NORMAL
- en: You can also compare pointers using the other relational operators, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp>, but we won’t support that yet.
    This sort of pointer comparison is most useful when you’re working with pointers
    to array elements, so we’ll implement it when we add arrays in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">& Operations on Dereferenced
    Pointers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We saw earlier that the operand of the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator must be an lvalue. Since a dereferenced pointer is an lvalue, you can
    take its address with this operator, like we do in [Listing 14-3](chapter14.xhtml#list14-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-3: Taking the address
    of a dereferenced pointer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&*ptr</samp> is
    valid, but it’s not very useful. The inner expression designates the object stored
    at some address, and the outer expression takes the address of that object. You
    just end up with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    which is the address you dereferenced to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the C standard treats <samp class="SANS_TheSansMonoCd_W5Regular_11">&*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp> as a special case:
    section 6.5.3.2, paragraph 3, states that “neither [the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    operator] nor the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator
    is evaluated and the result is as if both were omitted, except that the constraints
    on the operators still apply and the result is not an lvalue.” In other words,
    the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">&*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>
    is always the value of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>.
    Usually, like in [Listing 14-3](chapter14.xhtml#list14-3), it doesn’t matter whether
    we evaluate the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operators; we end up with <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp> either way. The
    one exception is when <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>
    is not a valid memory address, like in [Listing 14-4](chapter14.xhtml#list14-4).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-4: Taking the address
    of a dereferenced null pointer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp>
    would usually cause a runtime error. However, since the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> expressions in [Listing
    14-4](chapter14.xhtml#list14-4) aren’t evaluated, this code is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, [Listing 14-4](chapter14.xhtml#list14-4) runs without error; it initializes
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2</samp>
    as null pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re experts on pointer semantics, let’s start on the lexer!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll add a single token:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&</samp> An ampersand, the address
    operator
  prefs: []
  type: TYPE_NORMAL
- en: You already added the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    token to support multiplication. If you implemented the bitwise operators for
    extra credit in [Chapter 3](chapter3.xhtml), you’ve already added the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    token too, so you won’t need to modify the lexer at all.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we’ll add pointer types and the two new pointer operators to the AST.
    A pointer type is constructed recursively from the type of the object it points
    to; <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">double
    *</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long *</samp>
    are all valid types. You can also declare pointers to pointers, so <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    **</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long ***</samp>, and
    so on are valid types as well. Therefore, the AST defines pointer types recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In C, types that are built up from simpler types are called *derived types*.
    Pointer types and function types are both derived types. The array and structure
    types we’ll implement in later chapters are derived types too. The type that a
    pointer points to is its *referenced type*. For example, the referenced type of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST
    node to represent the dereference and address operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Syntactically, these are both unary operators, so you can extend <samp class="SANS_TheSansMonoCd_W5Regular_11">unary
    _operator</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    if you want. But I think it’s easier to make them distinct expressions because
    we’ll handle these quite differently from the other unary operators during type
    checking and TACKY generation. [Listing 14-5](chapter14.xhtml#list14-5) shows
    the updated AST, with this chapter’s additions bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-5: The abstract
    syntax tree with pointer types and the dereference and address operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll update the grammar and figure out how to parse it. We can parse
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operators like any other unary operator, so we add them to the <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop></samp>
    grammar rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Parsing pointer types in declarations and cast expressions is more challenging.
    We need an approach that we can extend to handle derived types in general, not
    just pointers; otherwise, we’ll have to completely rewrite it to deal with arrays
    in the next chapter. We’ll start by updating the parser to support derived types
    in declarations. Then, we’ll handle derived types in cast expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Declarations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function or variable declaration consists of three parts: a list of specifiers,
    a declarator, and an optional initializer or function body. You already know what
    initializers and function bodies look like, so I won’t talk about them here. The
    specifiers are also familiar from earlier chapters: they include storage class
    specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>, which
    determine the identifier’s storage class and linkage, and type specifiers like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, which determine what
    I’ll call its *basic type*. The basic type is either the type of the identifier
    or the starting point for deriving its type. (This particular term doesn’t appear
    in the C standard, but it sometimes shows up in other discussions of C declarations.)
    The *declarator* is everything else: it indicates the identifier being declared
    and the sequence of derivations we’ll apply to the basic type. For example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">*var</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(int a)</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">foo[3]</samp>
    are all declarators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest declarator is an identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, the basic type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and the declarator is <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>,
    so it declares a variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. This declaration
    doesn’t include any type derivations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To derive a new type, we nest a declarator like <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    inside another declarator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a pointer declarator, <samp class="SANS_TheSansMonoCd_W5Regular_11">*(var)</samp>,
    which contains the nested declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>.
    A pointer declarator takes some type *t* and derives the type “pointer to *t*,”
    so this declaration declares <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    with the type “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.”
    Note that C’s syntax allows us to wrap any declarator in parentheses. I’ve wrapped
    <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> in parentheses to make
    the nesting here explicit, but the declaration has the same meaning if we omit
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We use multiple layers of nested declarators to specify multiple type derivations;
    these are applied from the outside in to determine the final type. The innermost
    declarator is always a plain identifier. Here’s an example with three nested declarators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The full declarator is <samp class="SANS_TheSansMonoCd_W5Regular_11">*(*(var))</samp>,
    which contains <samp class="SANS_TheSansMonoCd_W5Regular_11">*(var)</samp>, which
    contains <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>. As in the previous
    example, the parentheses in this declarator have no effect; I’ve just included
    them for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the type derivations here. Working from the outside in, we
    start with the basic type, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Next, we see a pointer declarator, so we derive the type “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.”
    Then, we see another pointer declarator, so we derive “pointer to pointer to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.” Finally, we encounter the
    identifier, which completes the declaration but doesn’t add any type information.
    We end up with a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    whose type is “pointer to pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The other two kinds of declarators are *function declarators*, which we already
    support, and *array declarators*, which we’ll add in the next chapter. A function
    declarator takes a type *t* and derives the type “function returning *t*.” Let’s
    break down a function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The full declarator here is <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(void)</samp>,
    which contains the nested declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
    Parenthesizing each declarator gives us the following equivalent declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with the basic type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    The outer declarator tells us to derive the type “function returning <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,”
    and the inner declarator indicates that we’re declaring the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
    Of course, a function declarator also declares the function’s parameters. Each
    parameter, much like a declaration, includes a basic type and a declarator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we already know, a parameter list of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">(void)</samp>
    is a special case: it declares that the function has no parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, an array declarator starts with type *t* and derives the type “array
    of *n* elements of type *t*.” For example, the following code includes the declarator
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[3]</samp>, which has a nested
    declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This declares that <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    is an array of three elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: More complicated declarations can include a mix of nested pointer, array, and
    function declarators. The function and array declarators, which we indicate with
    postfix expressions, have higher precedence than the pointer declarator, so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To interpret this declaration, we start with <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    apply the outer pointer declarator to derive “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,”
    apply the inner array declarator to derive “array of three pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,”
    and end with the innermost declarator, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>.
    To declare a pointer to an array instead, we override this precedence with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Along the same lines, this declaration declares a pointer to a function with
    a single parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Function pointers are legal in C, but we won’t implement them in this book.
    You can also nest declarators to specify types that are straight-up illegal. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">int foo(void)(void);</samp>
    declares a function that returns a function that returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    This declaration is syntactically well formed but semantically invalid; a function
    can’t return another function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the basic syntax of declarators, we’re ready to write
    grammar rules for them. For the full description of declarators, see section 6.7.6
    of the C standard. I also recommend “Reading C Type Declarations” by Steve Friedl,
    which describes their syntax in a more comprehensible way than the standard does
    (*[http://<wbr>unixwiz<wbr>.net<wbr>/techtips<wbr>/reading<wbr>-cdecl<wbr>.html](http://unixwiz.net/techtips/reading-cdecl.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since declarators have several precedence levels, we need several grammar rules
    to define their syntax. At the highest precedence level, a <samp class="SANS_TheSansMonoCd_W5Regular_11"><simple-declarator></samp>
    is a single identifier or parenthesized declarator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At the next precedence level, we have what the C grammar calls *direct declarators*,
    including function and array declarators. We support only function declarators
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11"><direct-declarator></samp>,
    a direct declarator may be either a simple declarator or a function declarator,
    indicated by the presence of a parameter list. Notice that we’ve changed <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp> a bit from previous
    chapters, refactoring this symbol to include the parentheses around the parameter
    list and moving the definition of a single parameter into a separate <samp class="SANS_TheSansMonoCd_W5Regular_11"><param></samp>
    symbol. Most importantly, the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11"><param></samp>
    now includes a declarator instead of a plain identifier. This lets us parse parameters
    with pointer types (and eventually with array types as well). Finally, we’ll define
    a top-level <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator></samp>
    that includes pointer declarators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this grammar doesn’t really correspond with our AST definition.
    One minor problem is that it allows us to specify types we don’t support, including
    function pointers, functions that return functions, and functions that take other
    functions as arguments. A more serious problem is that in our grammar, type derivations
    are applied from the outside in, but in the AST definition, they’re applied from
    the inside out. Let’s revisit a declaration we looked at earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We want to parse this declaration and construct the type “pointer to array of
    three elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.”
    What happens if we try to construct this type using recursive descent parsing?
    First, we’ll encounter the basic type, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Then, we’ll see an open parenthesis, which indicates the start of a direct declarator.
    Inside that direct declarator, we’ll find a pointer declarator—and then we’ll
    be stuck. We should derive a pointer type, but a pointer to what? The basic type
    we’ve seen so far is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    but “pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>” is incorrect.
    Because type derivations are applied from the outside in, we ought to derive the
    array type first. But we can’t, because the parser has to consume the inner, parenthesized
    declarator before it can reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>
    that specifies the array type.
  prefs: []
  type: TYPE_NORMAL
- en: We get stuck here because the order in which we can recognize grammar symbols
    doesn’t match the order in which we apply type derivations. When we parse a declaration,
    we can’t derive its type as we go. Instead, we’ll first parse each declarator
    to a one-off representation that more closely mirrors the grammar, like the one
    in [Listing 14-6](chapter14.xhtml#list14-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-6: Representing
    the syntax of a declarator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    construct with standard recursive descent parsing, following the grammar rules
    we just introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to traverse that <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    and derive all the information we’ll use to construct an AST node: the declaration’s
    type, its identifier, and the identifiers of any parameters. At every layer, we’ll
    apply the appropriate type derivation, then recursively handle the inner declarator.
    [Listing 14-7](chapter14.xhtml#list14-7) presents the pseudocode for this step.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-7: Deriving type
    and identifier information from a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">declarator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>
    function takes two arguments. The first is the declarator itself. The second,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>, is the type we’ve
    derived so far. Initially, this will be the basic type indicated by the list of
    specifiers at the start of the declaration. For example, if we were processing
    the declaration <samp class="SANS_TheSansMonoCd_W5Regular_11">double **fun(int
    x)</samp>, we’d start with a <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. The result of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp> will be
    a tuple of three values: the declaration’s identifier, its derived type, and the
    names of any parameters. If the declaration declares a variable, or if it declares
    a function with no parameters, the list of parameter names will be empty. Using
    these three values, we’ll be able to construct a <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    AST node.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through how to extract these values from a <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    construct. In the simplest case, the declarator is an identifier ❶. We don’t need
    to apply any type derivations or introduce any parameters, so we return the identifier,
    the unchanged <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>,
    and an empty list of parameter names. For example, while processing the declaration
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int x;</samp>, we’d immediately
    reach this case and return <samp class="SANS_TheSansMonoCd_W5Regular_11">("x",
    Int, [])</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we handle pointer declarators ❷. In this case, we derive
    a pointer type from <samp class="SANS_TheSansMonoCd_W5Regular_11">base_type</samp>.
    We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>
    recursively on the type we just derived and the inner declarator that still needs
    to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: In the last case, we handle function declarators ❸. This case is a little different
    because the inner declarator must be a plain identifier. If it’s another function
    declarator, we’ll end up with a function that returns a function, which isn’t
    legal. If it’s a pointer declarator, we’ll end up with a function pointer, which
    we aren’t implementing. Therefore, we validate that the inner declarator is a
    plain identifier instead of parsing it recursively ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the inner declarator is valid, the next step is figuring out the function
    type and parameter names. We’ll iterate over the parameters in the declarator,
    recursively calling <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>
    to get the type and name of each one ❺. While we’re at it, we’ll validate that
    none of these function parameters are functions themselves. (The C standard actually
    lets you declare parameters with function type, but it requires the compiler to
    implicitly adjust them to function pointer type. Since we don’t support function
    pointers, we’ll reject them.) Once we’ve handled every parameter, we construct
    the whole function type and return all the relevant information about this declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-8](chapter14.xhtml#list14-8) shows how to put all the pieces together
    to parse an entire declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-8: Parsing an entire
    declaration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first determine the declaration’s base type in the usual way: we consume
    a list of specifiers from <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>,
    then convert those specifiers to a type and storage class. Next, we parse the
    declarator, and then we call <samp class="SANS_TheSansMonoCd_W5Regular_11">process
    _declarator</samp> to determine its complete type and name. Finally, we examine
    the resulting type to determine whether it’s a function or variable declaration
    and parse the rest of the declaration accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Type Names</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pointer types can also appear in cast expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: But you can’t use a declarator in a cast expression, because a declarator must
    contain an identifier. C syntax solves this problem with *abstract declarators*,
    which are declarators without identifiers. We’ll add abstract pointer declarators
    now and abstract array declarators in the next chapter. (We won’t need abstract
    function declarators, because they’re used only to specify function pointers.)
  prefs: []
  type: TYPE_NORMAL
- en: 'An abstract declarator might be a sequence of one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    tokens, indicating a sequence of pointer type derivations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Abstract declarators can be parenthesized, like their non-abstract counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And an outer abstract declarator can contain an inner parenthesized one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The parentheses are pointless at the moment. They’ll be more useful when we
    add arrays in the next chapter. For example, the expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'casts <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> to an array
    of three pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    because the abstract array declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>
    is parsed with higher precedence. This cast expression is illegal because you
    can’t cast expressions to array type. On the other hand, this expression is fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This casts <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> to a pointer
    to an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    elements; the parenthesized pointer declarator has higher precedence, so the array
    declarator is applied to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define abstract declarators using two grammar rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: An <samp class="SANS_TheSansMonoCd_W5Regular_11"><abstract-declarator></samp>,
    like a regular <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator></samp>,
    consists of either a pointer declarator or a direct declarator. The key difference
    between the two is that in an abstract pointer declarator, the inner declarator
    is optional. In other words, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    by itself is a valid abstract declarator but not a valid regular declarator.
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11"><direct-abstract-declarator></samp>
    is an <samp class="SANS_TheSansMonoCd_W5Regular_11"><abstract-declarator></samp>
    wrapped in parentheses. In the next chapter, this symbol will cover abstract array
    declarators too. We’ll parse abstract declarators to a one-off <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>
    structure, like we did with normal declarators. [Listing 14-9](chapter14.xhtml#list14-9)
    defines this structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-9: Representing
    the syntax of an abstract declarator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">AbstractBase</samp> represents
    the base case, where a <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    token isn’t followed by an inner declarator. For example, we’d parse the abstract
    declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">*(*)</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AbstractPointer(AbstractPointer(AbstractBase))</samp>.
    At the moment, <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract _declarator</samp>
    just tells us how many layers of pointer indirection we found (two, in this example).
    This is a fairly elaborate way to convey a single number, but it lays the groundwork
    for array declarators in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type name in a cast expression is a sequence of type specifiers followed
    by an optional abstract declarator, all wrapped in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: To handle cast expressions, you’ll need a <samp class="SANS_TheSansMonoCd_W5Regular_11">process_abstract_declarator</samp>
    function, similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>
    from [Listing 14-7](chapter14.xhtml#list14-7), to convert a basic type and an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp> into
    a derived type. This function will be simpler than <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>;
    it won’t deal with function declarators and it will return only a type, not an
    identifier or a list of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve covered every change we’ll make to the parser. [Listing 14-10](chapter14.xhtml#list14-10)
    shows the full grammar, with this chapter’s changes bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-10: The grammar
    with pointer types and the dereference and address operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve made three major changes to the grammar. First, we’re using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><declarator></samp> symbol instead of
    simple identifiers in function, variable, and parameter declarations. Second,
    we use the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11"><abstract
    -declarator></samp> symbol to specify pointer types in cast expressions. Third,
    we’ve added the new unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operators.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On to semantic analysis! We’ll extend the type checker to validate expressions
    that involve pointers and infer the types of these expressions. The identifier
    resolution pass will change a little bit too; we’ll move one piece of validation
    from this pass into the type checker.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to detect three kinds of type errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying an operator to a type it doesn’t support. For example, you can’t multiply
    or divide pointers, and you can’t dereference arithmetic values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operating on values of two incompatible types. This includes errors like trying
    to compare a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    We run into this kind of error because C generally doesn’t allow implicit conversions
    to and from pointer types, the way it does for arithmetic types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not using an lvalue where one is required. We already require the left side
    of an assignment expression to be an lvalue. Now we’ll require the operand of
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression to be
    an lvalue too. We’ll also expand our definition of lvalue to include dereferenced
    pointers as well as variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This third kind of error is the one we currently handle during identifier resolution.
    Remove this validation from the identifier resolution pass now; you’ll add it
    to the type checker in a moment. (While you’re at it, make sure the identifier
    resolution pass traverses the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions.)
    Next, we’ll update the logic to type check expressions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Pointer
    Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need to tweak how we type check almost every expression we support. Let’s
    start with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions. Then,
    we’ll update the type checking logic for our existing constructs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dereference and AddrOf Expressions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> expression
    must take an operand of pointer type. It produces a result with its operand’s
    referenced type (the type it points to). [Listing 14-11](chapter14.xhtml#list14-11)
    demonstrates how to type check a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    expression and annotate it with the correct result type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-11: Type checking
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Dereference</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by type checking the expression’s operand, as usual. Then, we look
    up the operand’s type. If it’s a pointer to some type, <samp class="SANS_TheSansMonoCd_W5Regular_11">referenced_t</samp>,
    we set <samp class="SANS_TheSansMonoCd_W5Regular_11">referenced_t</samp> as the
    result type of the whole expression. Otherwise, we throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: To type check an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expression, we first check that its operand is an lvalue (that is, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp> expression).
    Then, we record its result type, which is a pointer to the type of its operand.
    [Listing 14-12](chapter14.xhtml#list14-12) demonstrates how to type check <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-12: Type checking
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddrOf</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll type check pointer comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp>. (We’ll deal
    with other pointer comparisons using <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>, and the other relational
    operators in [Chapter 15](chapter15.xhtml).) We’ll also handle conditional expressions,
    which follow similar typing rules.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparisons and Conditional
    Expressions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you learned in earlier chapters, both operands in a comparison must have
    the same type, or at least be implicitly converted to the same type. However,
    we can’t perform implicit conversions to or from pointer types. Therefore, if
    either operand to an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> operation is
    a pointer, we require the types of both operands to be the same. At the moment,
    null pointer constants are the one exception to this rule; they’re the only expressions
    that we can implicitly convert to a pointer type. (Once we implement <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    we’ll also permit implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> and other pointer types.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code snippet compares a pointer to a null pointer constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When we type check <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    in this example, we implicitly cast <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    to a null pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">double
    *</samp>. [Listing 14-13](chapter14.xhtml#list14-13) defines a helper function
    to identify null pointer constants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-13: Checking whether
    an expression is a null pointer constant</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function captures our three requirements for an expression to count as
    a null pointer constant: it must be a constant literal, it must be an integer,
    and its value must be 0\. (Remember that we’re defining null pointer constants
    more narrowly than the C standard does; the standard permits more complex constant
    expressions as well as constant literals.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-14](chapter14.xhtml#list14-14) defines another helper function
    to determine whether two expressions, at least one of which results in a pointer,
    have compatible types.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-14: Getting the
    common type of two expressions, where at least one has pointer type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When an expression that operates on pointers expects both its operands to have
    the same type, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>
    will determine what that type should be. If its arguments have different types
    and neither of them is a null pointer constant, they’re incompatible, so we throw
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve defined <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>,
    we’re finally ready to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> expressions.
    [Listing 14-15](chapter14.xhtml#list14-15) demonstrates how to type check an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> expression; we’ll handle
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-15: Type checking
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Equal</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This follows the usual pattern for type checking comparisons: we type check
    both operands, find their common type, convert them both to that type, and then
    set the type of the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>.
    The key change from earlier chapters is how we find the common type. If either
    operand is a pointer, we use the helper function that we just defined ❶. Otherwise,
    we’ll stick with <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp>
    ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we convert two operands to a common pointer type, we’ll see one of three
    possible outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: Both operands already have the same type, so neither <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp>
    call has any effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One operand is a null pointer constant, which we implicitly convert to the other
    operand’s type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operands have incompatible types, so <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>
    throws an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll use similar logic to type check conditional expressions. The second and
    third operands in the expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>
    are subject to the same type constraints as the operands in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp> expression. If
    either one is a pointer, we’ll validate both operands and find their common type
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>,
    then convert them to that type. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp>
    expression can be either a pointer or an arithmetic value, since we can compare
    it to zero either way.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Assignment and Conversion
    as if by Assignment</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll handle assignment expressions. We first validate that the left-hand
    side of an assignment expression is an lvalue. Then, we convert the value on the
    right side of the expression to the type of the object on the left, or fail if
    the conversion is illegal. What the C standard calls type conversion “as if by
    assignment” turns up in a few places, not just in assignment expressions, so we’ll
    write yet another helper function to handle it. [Listing 14-16](chapter14.xhtml#list14-16)
    defines this helper function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-16: Converting an
    expression to a target type as if by assignment</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules here are unsurprising: we can assign a value to an object of the
    same type, we can implicitly convert any arithmetic type to any other arithmetic
    type, and we can implicitly convert a null pointer constant to any pointer type.
    Otherwise, we’ll raise an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use this helper function to convert the right side of assignment expressions
    and in a few other spots too. To type check a function call, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    to convert each argument to the type of the corresponding parameter. We’ll also
    use it to convert variable initializers to the correct type and to detect initializers
    with invalid types, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    to convert the value in a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement to the function’s return type and detect functions that return the wrong
    type, like [Listing 14-17](chapter14.xhtml#list14-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-17: A function that
    returns a value with an incompatible type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Later, when we implement <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    we’ll extend both <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    to accept implicit conversions to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Other Expressions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We still need to deal with cast expressions, unary operators, and binary operators
    besides <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NotEqual</samp>.
    Let’s start with casts. As you learned earlier, it’s illegal to cast a pointer
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to a pointer. If your type checker encounters this kind of cast, it should throw
    an error. Otherwise, it can handle casts to and from pointer types exactly like
    any other cast expression.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll handle unary operators. Applying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp> operator to
    a pointer is illegal, since negating or taking the bitwise complement of a memory
    address won’t produce a meaningful result. Applying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    operator to a pointer is fine, since it makes sense to compare a memory address
    to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Binary operators deal with pointers in several different ways. First, we have
    the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Or</samp> operators. The type checking
    logic for these operators won’t change. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>,
    they both accept pointers. Since they don’t convert their operands to a common
    type, they can operate on any combination of pointer and arithmetic operands.
  prefs: []
  type: TYPE_NORMAL
- en: The arithmetic <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Remainder</samp>
    operators, on the other hand, don’t accept pointers. Applying any of these to
    an operand of pointer type should produce an error. Pointer addition and subtraction
    are legal, as are pointer comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp>, but we won’t
    implement them until the next chapter. They won’t come up in this chapter’s tests.
    For now, your compiler can either assume it will never see these expressions or
    explicitly reject them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tracking Static Pointer
    Initializers in the Symbol Table</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s talk about static initializers. Static variables of pointer type,
    like non-static variables, can be initialized to null pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We therefore need a way to represent a null pointer as a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    in the symbol table. Rather than defining a dedicated construct for null pointers,
    we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(0)</samp>
    initializer, since pointers are unsigned 64-bit integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also legal to initialize static variables of pointer type with the address
    of other static variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: However, our implementation won’t support this sort of static initializer; we’ve
    already decided that constant literals are the only static initializers we’ll
    accept.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll introduce three new TACKY instructions that operate on pointers in this
    chapter. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>,
    corresponds to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    operator in the AST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction copies the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>—which
    must be a variable, not a constant—into <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>.
    We’ll also add two instructions to dereference pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction takes
    a memory address, <samp class="SANS_TheSansMonoCd_W5Regular_11">src_ptr</samp>,
    as its source operand. It retrieves the current value at that memory address and
    copies it to <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction takes a memory
    address, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_ptr</samp>, as its
    destination operand and writes the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    to that address. [Listing 14-18](chapter14.xhtml#list14-18) defines the complete
    TACKY IR, with the three new instructions bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-18: Adding pointer
    operations to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s tricky to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> to TACKY, because
    these conversions depend on context. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    expression can be used in one of three ways: you can lvalue convert it, assign
    to it, or take its address. We’ll produce different TACKY instructions in each
    of these three cases. Similarly, we’ll process <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    one way if its operand is a variable and a different way if its operand is a dereferenced
    pointer. First, let’s see what instructions we should generate in each case. Then,
    I’ll present a strategy for TACKY conversion that minimizes the number of special
    cases we need to handle.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Operations
    in TACKY</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To dereference a pointer and then lvalue convert the result, we’ll use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction. In this case,
    we can translate the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp> to [Listing 14-19](chapter14.xhtml#list14-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-19: The TACKY implementation
    of a pointer dereference that undergoes lvalue conversion</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> when we
    want to assign to a dereferenced pointer instead of lvalue converting it. We’ll
    translate an assignment expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><left></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><right></samp> to [Listing
    14-20](chapter14.xhtml#list14-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-20: The TACKY implementation
    of a pointer dereference on the left-hand side of an assignment expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We first calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    which is the address of some object, and <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>,
    which is the value we want to assign to that object. Then, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    to perform the assignment. Note that the single <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction here implements both the deference and assignment operations from
    the original expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expression. If its operand is a variable, we’ll get a pointer to it with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>. Therefore, we’ll translate
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&var</samp> to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: But if the operand is a dereferenced pointer, neither the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    nor the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    expression is evaluated. When we see an expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">&*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>, we’ll translate
    only the inner <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp>
    to TACKY.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Strategy for TACKY
    Conversion</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To manage all these different cases, we’ll use two different functions to convert
    expressions to TACKY. The first is our existing <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>
    function. This function will no longer return a TACKY operand. Instead, it will
    return a new construct, <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>,
    which represents an expression result that hasn’t been lvalue converted. The second
    function, <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>,
    will call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>, lvalue
    convert the result (if it’s an lvalue rather than a constant), and return it as
    a TACKY operand. In most contexts, we’ll process expressions with <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>.
    But to process expressions that shouldn’t be lvalue converted—like the left-hand
    side of assignment expressions—we’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s define <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    represents the object designated by a dereferenced pointer, as the name suggests.
    It takes a single argument: a TACKY operand of pointer type. A <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>
    represents an ordinary constant or variable. Its argument is a TACKY operand of
    any type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>
    construct isn’t a TACKY operand itself, so it doesn’t appear in TACKY instructions.
    It just helps us process <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    and assignment expressions, which operate on objects instead of values. For each
    of these expressions, we’ll generate different instructions depending on whether
    its operand is a dereferenced pointer or a normal variable. In later chapters,
    we’ll add more operators that dereference pointers, like array subscripting and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator to access
    structure members. At that point, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    constructor will be especially useful because it will let us represent the results
    of all of these different operators in a uniform way.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s update <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>.
    We’ll make a couple of changes throughout this function. First, wherever we currently
    call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> recursively
    on a subexpression—except on the left-hand side of an assignment expression— we’ll
    instead call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>.
    This function will convert the subexpression to TACKY and then lvalue convert
    the result. Second, wherever we currently return a TACKY operand, we’ll wrap that
    operand in a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>
    constructor. [Listing 14-21](chapter14.xhtml#list14-21) shows how to handle unary
    expressions, with this chapter’s changes bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-21: Translating
    a unary expression to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make the same changes for every kind of expression that <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>
    currently handles.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s deal with <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>
    expressions. [Listing 14-22](chapter14.xhtml#list14-22) demonstrates how to handle
    these in <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-22: Translating
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Dereference</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">expression to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To process this expression, we first process and lvalue convert its operand.
    This produces a TACKY operand of pointer type, <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>.
    Then, we return a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    to represent the object <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    points to.
  prefs: []
  type: TYPE_NORMAL
- en: After <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> returns
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>, we either
    assign to it, get its address, or lvalue convert it. [Listing 14-23](chapter14.xhtml#list14-23)
    illustrates how to handle assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-23: Translating
    an assignment expression to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t lvalue convert the left side of the assignment expression ❶, but we
    do lvalue convert the right side ❷. If the left side is a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>,
    we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction,
    like in earlier chapters ❸. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>,
    we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction
    to write to the location that the inner pointer indicates ❹. Note that even when
    we assign through a pointer, we return a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp>
    as the result. That’s because the result of an assignment expression is the value
    stored in the object on the left-hand side, not the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: We use a similar pattern to process <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>.
    [Listing 14-24](chapter14.xhtml#list14-24) gives the pseudocode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-24: Translating
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddrOf</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">expression to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We process the expression’s operand without lvalue converting it ❶, then pattern
    match on the result to decide how to proceed. If it’s a normal value, we emit
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> instruction
    ❷. If it’s a dereferenced pointer, we drop the dereference and return the pointer
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in [Listing 14-25](chapter14.xhtml#list14-25), we define <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>,
    which performs lvalue conversions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-25: Translating
    an expression to TACKY and performing lvalue conversion</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To lvalue convert a dereferenced pointer, we’ll retrieve its value with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction. Other operands
    can be returned as is, without emitting any extra instructions. A *full expression*,
    which isn’t part of another expression, always undergoes lvalue conversion. That
    means you should use <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and
    _convert</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>,
    to process a full expression and get its result. For example, you’ll use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp> to process
    the controlling expressions in loops and <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: The results of some full expressions—specifically, expression statements and
    the first and third clauses in <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop headers—are not used. As an optimization, you can process these expressions
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp>, which saves
    you an unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up this section, we’ll implement casts to and from pointer types. For
    the purposes of casting, we treat pointer types exactly like <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. For example, we cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to any pointer type with a <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>
    instruction and from a pointer type to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>. The TACKY
    implementations of other expressions, like logical operations and comparisons,
    won’t change.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we added <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions that
    allow us to read from and write to memory. This means that TACKY has finally caught
    up with assembly, which we’ve been using to read from and write to memory since
    [Chapter 2](chapter2.xhtml). The operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>,
    for example, identifies a location in memory, which we can read or write with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s nothing special about RBP, though; we can access memory through an
    address stored in any register. Here’s how to read the value from an address stored
    in the RAX register and copy it into RCX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax)</samp> is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0(%rax)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The assembly AST will change slightly to handle operands like <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax)</samp>.
    First, we’ll add the RBP register to the AST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operand, which lets us access memory at some offset from the address in RBP, with
    a more generic <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> operand,
    which can use a base address stored in any register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This makes converting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction to assembly
    very simple. We’ll translate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the first instruction, we move the memory address <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    to a register. In the second instruction, we move the value stored at that address,
    which we access with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand, to the destination. In this example, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    into RAX, but any general-purpose register will do (aside from R10, R11, or a
    callee-saved register).
  prefs: []
  type: TYPE_NORMAL
- en: Along the same lines, we’ll translate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note that when we copy a pointer into a register, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    operand type, since pointers are 8 bytes. But when we copy a value to or from
    the memory location that a pointer indicates, the value’s type determines the
    type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll implement <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    using a new assembly instruction: <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>,
    which is short for *load effective address*. The instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">lea
    src, dst</samp> copies the *address* of its source (which must be a memory operand)
    to its destination. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">lea
    (%rbp), %rax</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    %rbp, %rax</samp>. You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>
    to get RIP-relative addresses, so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: stores the address of the symbol <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    in the RAX register.
  prefs: []
  type: TYPE_NORMAL
- en: With this new instruction, converting <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    to assembly is straightforward. We’ll translate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned earlier, <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    here must be a memory operand, not a constant or register, for obvious reasons.
    At the moment, we’re guaranteed to satisfy this constraint; we map every pseudoregister
    to a memory address, and the type checker catches any attempts to take the address
    of a constant. But in [Part III](part3.xhtml), when we implement register allocation,
    we’ll store some variables in registers instead of in memory. At that point, it
    will take some extra work to make sure that <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>
    never tries to load the address of a register.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-26](chapter14.xhtml#list14-26) defines the whole assembly AST,
    including the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand, <samp class="SANS_TheSansMonoCd_W5Regular_11">BP</samp> register, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-26: The assembly
    AST with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Memory</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">operand,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">BP</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">register, and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Lea</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we translate other TACKY instructions to assembly, we’ll treat pointer
    types exactly like <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>.
    We’ll convert pointer types to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    assembly type, compare pointers with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    instruction, pass return values of pointer type in the RAX register, and pass
    parameters of pointer type in the same general-purpose registers as integer parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also make one entirely mechanical change: everywhere we previously used
    an operand of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>,
    we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory(BP,</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    instead. [Tables 14-1](chapter14.xhtml#tab14-1) through [14-3](chapter14.xhtml#tab14-3)
    summarize this chapter’s updates to the conversion from TACKY to assembly; as
    usual, new constructs and changes to the conversions for existing constructs are
    bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Load(ptr, dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Store(src, ptr)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">GetAddress(src, dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Pointer(referenced_t)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Quadword</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Next, we’ll update the pseudoregister replacement and instruction fix-up passes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters
    with Memory Operands</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand instead of the old <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operand throughout this pass. We’ll also extend this pass to replace pseudoregisters
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction. We
    won’t make any other changes. When we converted TACKY pointer variables to pseudoregisters,
    we assigned them the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    assembly type; now we’ll allocate stack space for them like any other <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the lea
    and push Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The destination of the <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>
    instruction must be a register; we’ll rewrite it in the usual fashion. We’ll also
    add a new rewrite rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instructions. As I mentioned in the previous chapter, it’s illegal to <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    an XMM register, so we’ll rewrite an instruction like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction decrements
    the stack pointer by 8 bytes, then moves its operand to the top of the stack.
    When we can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>, we’ll
    perform the same operation in two instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rsp)</samp> operand designates the memory
    location at the top of the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we don’t generate any <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instructions that operate on XMM registers, this rewrite rule isn’t strictly necessary
    yet. It will become necessary once we implement register allocation in [Part III](part3.xhtml);
    then, values that we currently store in memory might be assigned to XMM registers
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our final task will be to update the code emission stage to handle the new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand, and <samp class="SANS_TheSansMonoCd_W5Regular_11">BP</samp> register.
    [Tables 14-4](chapter14.xhtml#tab14-4) and [14-5](chapter14.xhtml#tab14-5) summarize
    how to print out these new constructs. (I haven’t bolded new constructs and changes
    in these tables, because all three of these constructs are entirely new.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-4:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea(src, dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-5:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(BP)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%rbp</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory(reg, int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><reg></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: We’ll always use the 8-byte aliases for the base register in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand and the destination register in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp>
    instruction, because memory addresses are 8-byte integers.
  prefs: []
  type: TYPE_NORMAL
- en: When the offset in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    operand is zero, you can either print it or omit it; <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">0(%rax)</samp> are equally valid.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you added support for pointers to your compiler. You learned
    how to parse complex declarators into derived types and how to type check operations
    on pointers. During TACKY generation, you established a uniform way to process
    pointer dereference expressions, regardless of how they’re used. On the backend,
    you took the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp>
    operand that accessed memory relative to the address in RBP and tweaked it to
    work with addresses stored in any register.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll implement arrays, your first non-scalar type. You’ll
    also implement array subscripting and pointer arithmetic and explore the ways
    in which they’re equivalent. Because pointers and arrays are so closely related,
    the concepts, techniques, and instructions introduced in this chapter will be
    crucial in the next chapter too.
  prefs: []
  type: TYPE_NORMAL
