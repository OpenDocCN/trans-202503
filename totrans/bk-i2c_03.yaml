- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: I²C Protocol
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 协议
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'The I²C bus definition is quite a bit more than electrical levels appearing
    on a bus. Equally important is the definition of the signals appearing on those
    two lines. This chapter discusses the data protocols associated with the I²C bus—that
    is, the speed at which the data transmission takes place, how a device can force
    the controller to wait for it, and how controllers do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线的定义不仅仅是总线上出现的电气电平。同样重要的是定义出现在这两条线上的信号。本章讨论了与 I²C 总线相关的数据协议——即数据传输发生的速度，设备如何强制控制器等待，控制器如何执行以下操作：
- en: Transmit bits to and from devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向设备发送和接收位
- en: Specify the device’s address
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定设备的地址
- en: Specify the data direction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定数据方向
- en: Specify the end of the data transmission
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定数据传输的结束
- en: The order and definition of the bits appearing on the bus, and how they are
    clocked on the bus, are determined by the I²C *protocol*. This chapter describes
    that protocol and discusses some useful topics such as resetting the I²C bus and
    detecting peripherals on the bus.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总线上出现的位的顺序和定义，以及它们如何在总线上被时钟控制，由 I²C *协议* 决定。本章描述了该协议，并讨论了一些有用的主题，如重置 I²C 总线和检测总线上的外设。
- en: 2.1 Data on the I²C Bus
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 I²C 总线上的数据
- en: The I²C bus transmits data serially on the SDA line, clocked by the SCL signal
    (see [Figure 2-1](#figure2-1)). The data on the SDA line must be stable (0 or
    1) when SCL is high (1); data may change on the SDA line only while SCL is low
    (see [Figure 2-1](#figure2-1)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线通过 SDA 线串行传输数据，时钟由 SCL 信号控制（见[图 2-1](#figure2-1)）。当 SCL 线为高电平（1）时，SDA
    线上的数据必须保持稳定（0 或 1）；数据只能在 SCL 线为低电平时（见[图 2-1](#figure2-1)）发生变化。
- en: '![](image_fi/502468c02/f02001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c02/f02001.png)'
- en: 'Figure 2-1: Serial data transmission on the I²C bus'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：I²C 总线上的串行数据传输
- en: Data transmissions on the I²C bus consist of a start signal, followed by one
    or more bytes of data, and end with a stop signal. Between data transmissions,
    the SDA and SCL lines are in their unasserted state (that is, both signals are
    pulled high). As noted in the previous chapter, if the SCL line is high for longer
    than a one-half clock period, the bus is currently unused.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线上的数据传输由一个起始信号开始，随后是一个或多个字节的数据，最后以停止信号结束。在数据传输之间，SDA 和 SCL 线处于非激活状态（即两个信号都被拉高）。如前一章所述，如果
    SCL 线保持高电平超过半个时钟周期，表示总线当前未使用。
- en: A start condition consists of a controller pulling the SDA line low while the
    SCL line has been high for some period of time (see [Figure 2-2](#figure2-2)).
    As mentioned earlier (see [Figure 2-1](#figure2-1)), the SDA line normally must
    be stable while the clock line is high. This is to allow devices on the I²C bus
    to detect a start (and as you will soon see, a stop) condition.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 起始条件是控制器将 SDA 线拉低，而 SCL 线已经保持高电平一段时间（见[图 2-2](#figure2-2)）。如前所述（见[图 2-1](#figure2-1)），SDA
    线在时钟线高电平时通常必须保持稳定。这是为了让 I²C 总线上的设备能够检测到起始（以及稍后将看到的停止）条件。
- en: 'Generally, SCL must be high for the duration of between one-quarter and one-half
    clock period before SDA can go low to signal a start condition. Specifically,
    this start setup time is one of the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，SCL 必须在 SDA 线变低并发送起始条件之前保持高电平，持续时间在四分之一和半个时钟周期之间。具体而言，这个起始设置时间是以下之一：
- en: 'For standard mode (10-μsec clock period): 4.7 μsec'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于标准模式（10-微秒时钟周期）：4.7 微秒
- en: 'For fast mode (2.5-μsec clock period): 0.6 μsec'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于快速模式（2.5-微秒时钟周期）：0.6 微秒
- en: 'For fast-plus mode (1-μsec clock period): 0.26 μsec'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于快速增强模式（1-微秒时钟周期）：0.26 微秒
- en: 'Once the data line has gone low, signifying the start condition, the controller
    can pull the SCL line low to begin clocking in data after the following startup
    hold times:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据线变低，表示起始条件，控制器可以将 SCL 线拉低，开始在以下启动保持时间后进行数据时钟传输：
- en: 'For standard mode: 4.0 μsec'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于标准模式：4.0 微秒
- en: 'For fast mode: 0.6 μsec'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于快速模式：0.6 微秒
- en: 'For fast-plus mode: 0.26 μsec'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于快速增强模式：0.26 微秒
- en: '![](image_fi/502468c02/F02002.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c02/F02002.png)'
- en: 'Figure 2-2: Start condition on the I²C bus'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：I²C 总线上的起始条件
- en: A byte transmission consists of 8 data bits and an acknowledgment bit (see [Figure
    2-3](#figure2-3)). The 8-bit data byte is shipped with the most significant bit
    (MSB) appearing first on the SDA line and the least significant bit (LSB) following
    eight clock periods later. Immediately following the byte data is a single acknowledgment
    bit. This bit is always 0 if the receiving device is acknowledging the data. It
    is a 1 (NAK, or negative acknowledgment) if there was a transmission error.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字节的传输包括8个数据位和一个确认位（见[图2-3](#figure2-3)）。8位数据字节从SDA线上最重要的位（MSB）开始传输，最不重要的位（LSB）在八个时钟周期后传输。字节数据后紧跟一个确认位。如果接收设备确认数据，该位始终为0；如果发生传输错误，该位为1（NAK，或负确认）。
- en: '![](image_fi/502468c02/F02003.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c02/F02003.png)'
- en: 'Figure 2-3: Byte transmission on the I²C bus'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3：I²C总线上的字节传输
- en: 'Note that either the controller or the peripheral could be placing the data
    on the data bus. For a write operation, the controller is responsible for placing
    the data on the SDA line; for a read operation, the peripheral is responsible
    for placing the data on the SDA line. For the acknowledgment, the roles are reversed:
    for reads, the controller pulls the SDA low to acknowledge the read from the peripheral,
    while for writes, the peripheral pulls the SDA line low to acknowledge the write
    operation. If the transmission is bad for whatever reason, the device accepting
    the data does not pull the SDA line low for the acknowledgment. This leaves the
    SDA line high (which is a NAK). The next section, “I²C Addresses and Read/Write
    Control,” will discuss how the controller specifies whether a read or write operation
    is taking place.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数据总线上的数据可能由控制器或外设放置。在写操作中，控制器负责将数据放置到SDA线上；在读操作中，外设负责将数据放置到SDA线上。对于确认，角色是反转的：在读取时，控制器将SDA线拉低以确认从外设读取的数据；而在写入时，外设将SDA线拉低以确认写操作。如果由于某种原因传输失败，接收数据的设备将不会拉低SDA线进行确认。这样，SDA线保持高电平（即NAK）。下一节，“I²C地址与读写控制”，将讨论控制器如何指定是否进行读写操作。
- en: 'A stop condition consists of changing the SDA line from low to high while the
    SCL line is held high (remember, data normally must be stable while the clock
    line is high). This typically consists of setting the SDA line low before the
    last rising edge of the SCL line at the end of the data transmission and then
    pulling the SDA line high afterward, as [Figure 2-4](#figure2-4) shows. Similar
    to the start condition, the SCL line must be high for a certain amount of time
    (the *setup time for the stop condition*) before transitioning the SDA line from
    low to high. These setup times are the same as for the start condition, specifically:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 停止条件包括在保持SCL线为高电平的同时，将SDA线从低电平拉升到高电平（请记住，数据在时钟线为高电平时通常必须保持稳定）。这通常包括在数据传输结束时，将SDA线在SCL线最后的上升沿之前拉低，然后再将SDA线拉高，如[图2-4](#figure2-4)所示。与启动条件类似，SCL线必须在转换SDA线从低到高之前保持高电平一段时间（即*停止条件的设置时间*）。这些设置时间与启动条件相同，具体如下：
- en: 'For standard mode: 4.7 μsec'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于标准模式：4.7微秒
- en: 'For fast mode: 0.6 μsec'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于快速模式：0.6微秒
- en: 'For fast-plus mode: 0.26 μsec'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于快速增强模式：0.26微秒
- en: Once the controller generates the stop condition, the I²C bus is free, and after
    an appropriate start setup time, a controller can obtain it and use it again.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制器生成停止条件，I²C总线将空闲，经过适当的启动设置时间后，控制器可以重新占用并使用总线。
- en: '![](image_fi/502468c02/f02004.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c02/f02004.png)'
- en: 'Figure 2-4: I²C stop condition (S[p])'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4：I²C停止条件（S[p]）
- en: A stop condition does not occur after every byte. Instead, a stop condition
    marks the completion of a string of byte transmissions over the I²C bus. Specifically,
    a single (atomic) transmission consists of a start condition, followed by one
    or more byte transmissions (each with their own ACK or NAK bit), and a stop condition
    at termination. This transmission is considered atomic because the controller
    driving the transmission has complete control of the I²C bus for the entire duration
    of the transmission; during this time, no other controller can take possession
    of the I²C bus.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 停止条件并不是在每个字节之后都发生的。相反，停止条件标志着一串字节传输在I²C总线上完成。具体而言，一次单一（原子）传输包括一个启动条件，随后是一个或多个字节传输（每个字节都有其对应的确认或负确认位），最后是停止条件。这种传输被认为是原子的，因为驱动传输的控制器在整个传输过程中对I²C总线具有完全控制权；在此期间，其他控制器不能占用I²C总线。
- en: 2.2 I²C Addresses and Read/Write Control
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 I²C地址与读写控制
- en: The first byte appearing on the I²C bus after a start condition is special.
    This byte contains the I²C device address and the read/write state. [Figure 2-5](#figure2-5)
    shows the format for the peripheral address and R/W (read/write) byte (the overbar
    on the W indicates that the write signal is active low [0]).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 启动条件后，第一个出现在 I²C 总线上的字节是特殊的。该字节包含了 I²C 设备地址和读/写状态。[图 2-5](#figure2-5) 显示了外设地址和
    R/W（读/写）字节的格式（W 上的下划线表示写信号为低有效 [0]）。
- en: '![](image_fi/502468c02/f02005.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c02/f02005.png)'
- en: 'Figure 2-5: First byte following a start condition (peripheral address and
    R/W bit)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-5：启动条件后的第一个字节（外设地址和 R/W 位）
- en: The upper 7 bits of this byte contain the address of the peripheral for whom
    this transmission is intended. Because there are 7 bits, you can specify a maximum
    of 128 peripheral addresses in this peripheral address byte (though see section
    2.5, “Special Addresses,” later in this chapter for information about a 10-bit
    address on the I²C bus). The LO bit of the byte contains an R/W flag. A 0 in this
    bit position specifies a write operation, and a 1 in this position specifies a
    read operation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该字节的高 7 位包含了该传输的目标外设地址。由于是 7 位，你最多可以在这个外设地址字节中指定 128 个外设地址（不过请参见本章后面的 2.5 节，“特殊地址”，了解有关
    I²C 总线上的 10 位地址的信息）。该字节的 LO 位包含一个 R/W 标志。此位为 0 时，表示写操作；为 1 时，表示读操作。
- en: The R/W bit determines the data transfer directions of all the bytes following
    the peripheral address byte. If this bit is 0 (write operation), then the controller
    will supply all the data on the SDA line in the following bytes; if this bit is
    1 (read operation), then the peripheral will place the data on the SDA line during
    the transmission. Regardless of the data direction, the controller is still responsible
    for driving the SCL line (though see section 2.4, “Clock Stretching,” later in
    this chapter).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: R/W 位决定了在外设地址字节之后所有字节的数据传输方向。如果该位为 0（写操作），则控制器将在随后的字节中通过 SDA 线提供所有数据；如果该位为 1（读操作），则外设将在传输过程中通过
    SDA 线放置数据。无论数据方向如何，控制器仍然负责驱动 SCL 线（不过请参见本章后面的 2.4 节，“时钟延伸”）。
- en: Generally, this book will write I²C addresses as 7-bit binary or hexadecimal
    values (using C notation, 0x*nn* or 0b*nnnnnnn*). The full address and R/W byte
    will normally be written in 8-bit hexadecimal form.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，本书会将 I²C 地址表示为 7 位二进制或十六进制值（使用 C 表示法，0x*nn* 或 0b*nnnnnnn*）。完整的地址和 R/W 字节通常会以
    8 位十六进制形式表示。
- en: 2.3 Repeated Start Conditions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 重复启动条件
- en: In some special cases, a controller might need to write data to some particular
    peripheral and then immediately read data back from that peripheral as an atomic
    operation, without the possibility of some other controller accessing the peripheral
    between the write and read operations. Because the data direction is specified
    by the LO bit of the first byte after a start condition, a controller must send
    another start condition to change the direction. However, if the controller completes
    the current transfer by issuing a stop condition before sending another start
    condition, this gives a different controller the opportunity to seize the bus
    before the second transmission. This means the controller needs a way to hold
    onto the bus by not sending a stop condition. This is accomplished with a repeated
    start condition.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些特殊情况下，控制器可能需要向某个特定外设写入数据，然后立即从该外设读取数据，这一过程必须是原子操作，且写操作与读操作之间不能允许其他控制器访问该外设。由于数据方向是由启动条件后的第一个字节中的
    LO 位指定的，因此控制器必须发送另一个启动条件来改变方向。然而，如果控制器在发送另一个启动条件之前通过发出停止条件来完成当前传输，这将给其他控制器提供在第二次传输前抢占总线的机会。这意味着控制器需要通过不发送停止条件来保住总线。此操作通过重复启动条件来实现。
- en: A *repeated start condition*, as its name implies, is a second start condition
    (SDA high-to-low while SCL is high) without an intervening stop condition on the
    I²C bus. Until a stop condition comes along (which is what waiting controllers
    look for while waiting for the I²C bus), the current controller owns the bus.
    Therefore, a controller can use a sequence of repeated starts during a data transmission
    to reverse the data direction, or even to communicate with multiple peripherals,
    without giving up the I²C bus. When the atomic operations are complete, the controller
    can yield the bus by issuing a stop condition.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*重复启动条件*，顾名思义，是在没有中间停止条件的情况下（SDA从高到低，SCL保持高电平）第二次发起的启动条件。在直到出现停止条件之前（等待控制器在I²C总线上等待的条件），当前控制器拥有总线。因此，控制器可以在数据传输期间使用一系列重复启动来反转数据传输方向，甚至与多个外围设备进行通信，而无需放弃I²C总线。当原子操作完成时，控制器可以通过发出停止条件来释放总线。'
- en: In a multicontroller environment, a controller should take care not to monopolize
    the I²C bus. For operations that do not require atomicity, the controller should
    use stop conditions between transfers so that different controllers can gain access
    to the bus in a fair manner.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在多控制器环境中，控制器应当注意避免垄断I²C总线。对于不需要原子性操作的任务，控制器应当在传输之间使用停止条件，以便不同的控制器能够公平地访问总线。
- en: 2.4 Clock Stretching
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 时钟拉伸
- en: As mentioned in the previous chapter, clock stretching is a technique whereby
    a peripheral device can force the controller to wait while the peripheral is processing
    data. For example, a simple peripheral device polling the SDA and SCL lines and
    manually processing incoming data might need a small amount of time after each
    byte. During that time the controller might ship additional data that could be
    lost while the peripheral is busy processing the data. To resolve this problem,
    the peripheral can use clock stretching to force the controller to pause while
    the peripheral’s CPU deals with the incoming data. This effectively adds *wait
    states* to the data transmission.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，时钟拉伸是一种技术，允许外围设备在处理数据时迫使控制器等待。例如，一个简单的外围设备轮询SDA和SCL线并手动处理传入数据，在每个字节之后可能需要一点时间。在此期间，控制器可能会传输更多的数据，而这些数据可能会在外围设备忙于处理时丢失。为了解决这个问题，外围设备可以使用时钟拉伸强制控制器暂停，直到外围设备的CPU处理完传入的数据。这有效地为数据传输增加了*等待状态*。
- en: A peripheral can stretch the clock by pulling the SCL line low. Technically,
    this can occur at any time. However, when transmitting data from the controller
    to the peripheral, the peripheral usually pulls the SCL line low when the SCL
    line is also low just after the acknowledge bit, as this is when the peripheral
    has received the entire byte and will need to process it. Transmitting data from
    the peripheral to the controller is also a good time for the peripheral to pull
    the SCL line low after a complete byte transmission if the peripheral needs additional
    time to produce the next byte to transmit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 外围设备可以通过拉低SCL线来拉伸时钟。从技术角度讲，这可以在任何时候发生。然而，在从控制器向外围设备传输数据时，外围设备通常会在确认位后，SCL线处于低电平时拉低SCL线，因为这是外围设备接收完整字节并需要处理数据的时刻。从外围设备向控制器传输数据时，如果外围设备需要额外时间来生成下一个要传输的字节，那么在完成字节传输后，外围设备拉低SCL线也是一个合适的时机。
- en: Note that clock stretching is an optional feature in the I²C standard. In fact,
    most peripheral devices don’t support clock stretching, as they can handle the
    data transmissions as fast as the controller sends them. Although it should be
    rare, a controller might not support clock stretching in certain situations, such
    as when someone uses a simple microcontroller device to build a multifunction
    I²C controller that has to handle many different activities, which results in
    performance problems. See “For More Information” at the end of this chapter for
    details on how to deal with this situation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，时钟拉伸是I²C标准中的可选功能。事实上，大多数外围设备不支持时钟拉伸，因为它们可以以与控制器发送数据一样快的速度处理数据传输。虽然应该是比较少见的情况，但在某些情况下，控制器可能不支持时钟拉伸，例如当使用简单的微控制器设备构建一个多功能I²C控制器时，这个控制器必须处理许多不同的任务，从而导致性能问题。有关如何处理这种情况的详细信息，请参见本章末尾的“更多信息”。
- en: 2.5 Special Addresses
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 特殊地址
- en: With 7 address bits you would get the impression that the I²C bus supports up
    to 128 devices. In fact, this is not the case, for two reasons. First, the I²C
    standard reserves two groups of 8 addresses (0 through 7 and 120 through 127)
    for special purposes. Second, I²C uses a couple of those reserved addresses to
    allow extended addresses up to 10 bits in length. In theory, this allows an additional
    1,024 devices on the bus.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 7 位地址时，你可能会以为 I²C 总线最多支持 128 个设备。实际上并非如此，原因有二。首先，I²C 标准为特殊用途保留了两组 8 个地址（0
    到 7 和 120 到 127）。其次，I²C 使用其中一些保留地址来支持最多 10 位长度的扩展地址。理论上，这允许在总线上增加 1,024 个设备。
- en: '[Table 2-1](#table2-1) lists the special addresses currently defined for the
    I²C bus. Don’t-care bits (*xx*) appearing in these addresses can be 0b00, 0b01,
    0b10, or 0b11\. Most of the time, programs supply 0b00 for these bits.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-1](#table2-1) 列出了当前为 I²C 总线定义的特殊地址。这些地址中出现的“无关位”(*xx*)可以是 0b00、0b01、0b10
    或 0b11。大多数情况下，程序会为这些位提供 0b00。'
- en: 'Table 2-1: Special I²C Addresses'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：特殊 I²C 地址
- en: '| **Address bits** | **R/W** | **Description** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **地址位** | **读/写** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0000-000 | 0 | General call address |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 0000-000 | 0 | 通用呼叫地址 |'
- en: '| 0000-000 | 1 | Start byte |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 0000-000 | 1 | 启动字节 |'
- en: '| 0000-001 | x^([*](#c02-footnote-001)) | CBUS addresses |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 0000-001 | x^([*](#c02-footnote-001)) | CBUS 地址 |'
- en: '| 0000-010 | x | Reserved for different bus format |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 0000-010 | x | 为不同的总线格式保留 |'
- en: '| 0000-011 | x | Reserved for future purposes |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 0000-011 | x | 预留以备未来使用 |'
- en: '| 0000-1xx | x | High-speed mode controller code |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 0000-1xx | x | 高速模式控制器代码 |'
- en: '| 1111-0aa | R/W | 10-bit peripheral addressing (see section 2.5.6, “10-Bit
    Peripheral Addressing,” later in this chapter for discussion of aa bits) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 1111-0aa | 读/写 | 10 位外设寻址（关于 aa 位的讨论，请参见本章后面的第 2.5.6 节，“10 位外设寻址”） |'
- en: '| 1111-1xx | 1 | Device ID |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 1111-1xx | 1 | 设备 ID |'
- en: '| ^([*](#c02-footnoteref-001))x = “don’t care” and can be 0 or 1 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| ^([*](#c02-footnoteref-001))x = “无关”并且可以是 0 或 1 |'
- en: The following subsections describe the general call address (including hardware
    general calls), start byte, CBUS, high-speed controller mode, 10-bit addressing,
    and device ID special addresses in greater detail. Several addresses are also
    reserved for future device expansion. Existing controllers should not use these
    addresses until their use is defined within the I²C standard.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将更详细地描述通用呼叫地址（包括硬件通用呼叫）、启动字节、CBUS、高速控制器模式、10 位寻址和设备 ID 特殊地址。还有几个地址预留用于未来设备扩展。现有的控制器不应使用这些地址，直到其使用在
    I²C 标准中被定义。
- en: 2.5.1 The General Call Address
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 通用呼叫地址
- en: The *general call address* (0x00 with R/W = 0) is a special broadcast address
    that can address all devices on the bus. The R/W bit is always 0 (write) because
    you can never read from all the devices at the same time, as their return values
    would scramble one another.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用呼叫地址*（0x00，读/写 = 0）是一个特殊的广播地址，可以寻址总线上的所有设备。读/写位始终为 0（写），因为你不能同时从所有设备读取数据，否则它们的返回值会互相干扰。'
- en: 'The general call operation always consists of at least two bytes: the general
    call address (0x00) followed by a command byte (see [Figure 2-6](#figure2-6)).
    Generally, systems use this command to initialize all the peripherals that respond
    to the general call operation with a single bus command.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通用呼叫操作通常由至少两个字节组成：通用呼叫地址（0x00），后跟命令字节（参见 [图 2-6](#figure2-6)）。通常，系统使用此命令通过单一的总线命令初始化所有响应通用呼叫操作的外设。
- en: '![](image_fi/502468c02/F02006.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c02/F02006.png)'
- en: 'Figure 2-6: General call command format'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-6：通用呼叫命令格式
- en: 'When bit B is 0, the I²C protocol currently defines the following commands
    (`ccccccc` bits):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当 B 位为 0 时，I²C 协议当前定义了以下命令（`ccccccc` 位）：
- en: '`ccccccc` = 0b0000011: Reset and set peripheral programmable address.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ccccccc` = 0b0000011：重置并设置外设可编程地址。'
- en: '`ccccccc` = 0b0000010: Set peripheral programmable address but do not reset.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ccccccc` = 0b0000010：设置外设可编程地址，但不重置。'
- en: '`ccccccc` = 0b0000000: Illegal command code, not allowed as second byte.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ccccccc` = 0b0000000：非法命令代码，不允许作为第二个字节。'
- en: A *peripheral programmable address* is an address that can be set by hardware
    pins on the peripheral device. Many devices include pins on the IC package that
    can specify one of several different I²C addresses to which the device responds.
    This allows a designer, for example, to put several of the same ICs on the I²C
    bus and have them respond to different addresses by setting these pins high or
    low. For example, the MCP4725 DAC contains a pin that allows you to select one
    of two different I²C addresses by tying the pin to Vcc or Gnd. The general call
    commands 0x00/0x07 (`ccccccc` = 0b0000011, `B` = 0) and 0x00/0x05 (`ccccccc` =
    0b0000010, `B` = 0) instruct such chips to load the address from these pins, as
    appropriate (the 0x00/0x06 command also instructs the peripheral to reset itself).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*外围可编程地址*是一个可以通过外围设备上的硬件引脚设置的地址。许多设备在集成电路（IC）封装上包含引脚，可以指定多个不同的I²C地址，以便设备响应。这允许设计师例如将多个相同的IC连接到I²C总线上，并通过设置这些引脚的高电平或低电平来让它们响应不同的地址。例如，MCP4725
    DAC包含一个引脚，允许你通过将引脚连接到Vcc或Gnd来选择两个不同的I²C地址之一。通用调用命令0x00/0x07（`ccccccc` = 0b0000011，`B`
    = 0）和0x00/0x05（`ccccccc` = 0b0000010，`B` = 0）指示这些芯片从引脚加载地址（0x00/0x06命令也指示外围设备重置自身）。'
- en: Most peripheral ICs set their programmed addresses on a power-up operation,
    and the address never changes after that point, so most peripheral devices will
    ignore this command or simply do a reset operation for the (0x00, 0x06) command.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数外围IC会在上电时设置其编程地址，且该地址在此之后不会发生变化，因此大多数外围设备会忽略此命令，或仅对（0x00，0x06）命令执行复位操作。
- en: Note that peripheral devices do not have to support the general call command—that
    is, its implementation is optional. If a device does not support the general call
    command, it must ignore it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，外围设备不必支持通用调用命令——也就是说，其实现是可选的。如果设备不支持通用调用命令，它必须忽略此命令。
- en: Because of the open-drain nature of the I²C SDA line, if any device acknowledges
    the general call address and the command byte, the controller will see an ACK.
    Only if none of the devices acknowledge the general call command will the controller
    see a NAK response.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于I²C SDA线的开漏特性，如果任何设备响应了通用调用地址和命令字节，控制器将看到一个ACK响应。只有当没有设备响应通用调用命令时，控制器才会看到NAK响应。
- en: The commands other than (0x00, 0x00), (0x00, 0x04), and (0x00, 0x06) are reserved
    for future use and devices must ignore them. However, if you are creating your
    own custom peripherals for a custom system, you could create your own general
    call commands. You could even pass along additional data after the command byte
    to broadcast to all the devices you’ve created that respond to the commands. Just
    keep in mind that future revisions of the I²C protocol may conflict with your
    definitions. Also keep in mind that you can write data only with the broadcast
    (general call) command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除（0x00，0x00）、（0x00，0x04）和（0x00，0x06）外的命令保留用于未来使用，设备必须忽略它们。然而，如果你正在为自定义系统创建自定义外围设备，你可以创建自己的通用调用命令。你甚至可以在命令字节后面传递附加数据，广播给所有响应该命令的设备。只需记住，I²C协议的未来修订可能会与你的定义冲突。另外，请记住，你只能使用广播（通用调用）命令写入数据。
- en: 2.5.2 Hardware General Calls
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 硬件通用调用
- en: Hardware general calls are a special form of the general call that support peer-to-peer
    communication. If the `B` bit in [Figure 2-6](#figure2-6) is a 1, the 2-byte sequence
    is a *hardware general call*. The `ccccccc` bits specify the controller’s address
    that it is broadcasting to all the devices, which could be followed by 0 or more
    bytes of additional data. Some other device on the bus could read this data and
    interpret it accordingly. Generally, a hardware general call is a way for one
    controller device to communicate with a different controller device and pass it
    a block of data. However, for this scheme to work, the second controller device
    receiving the data must be looking for the first controller’s address within the
    hardware general call.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件通用调用是通用调用的一种特殊形式，支持点对点通信。如果[图2-6](#figure2-6)中的`B`位为1，则该2字节序列是*硬件通用调用*。`ccccccc`位指定了控制器的地址，控制器将该地址广播给所有设备，后面可以跟随0个或多个字节的附加数据。总线上的其他设备可以读取这些数据并进行相应的解释。通常，硬件通用调用是一个控制器设备与另一个控制器设备之间通信并传递数据块的方式。然而，为了使此方案有效，接收数据的第二个控制器设备必须在硬件通用调用中查找第一个控制器的地址。
- en: You won’t find too many commercially available devices that support the hardware
    general call. Typically, custom-programmed controllers that communicate with one
    another in the system would use these messages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 商用设备中不会找到支持硬件总线调用的设备。通常，系统中彼此通信的定制编程控制器会使用这些消息。
- en: To be honest, rather than design this protocol into your system, you’d probably
    be better off using the CANBUS or some other peer-to-peer networking scheme to
    transmit data between controllers in a system. As you might expect, very few devices
    take advantage of this feature in the I²C protocol. Most devices ignore hardware
    general calls.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，与其设计这种协议到您的系统中，您可能更好地使用 CANBUS 或其他点对点网络方案在系统中的控制器之间传输数据。正如您可能预期的那样，很少有设备利用
    I²C 协议中的此功能。大多数设备忽略硬件总线调用。
- en: 2.5.3 Start Byte
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 起始字节
- en: The start byte (adrs = 0, R/W = 1) is a software mechanism for introducing delays
    in an I²C communication between a fast controller and a slow-responding peripheral.
    Some low-cost peripheral devices poll only the SDA line occasionally to see if
    a start condition exists. If the peripheral is otherwise preoccupied when the
    actual start condition arrives, the peripheral could miss a message intended for
    it. A start byte is the sequence 0x01 (that is, address 0 with the R/W bit high).
    These seven 0 bits, which will be spread over 70 μsec when using a 100-kHz clock,
    should give the peripheral sufficient time to detect that the SDA line has gone
    low.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 起始字节（adrs = 0, R/W = 1）是在快速控制器和响应较慢的外设之间介入 I²C 通信的软件机制。一些低成本的外设设备偶尔只轮询 SDA 线，以查看是否存在起始条件。如果外设在实际起始条件到达时正忙于其他事务，则可能会错过其预期接收的消息。起始字节是序列
    0x01（即地址为 0 且 R/W 位为高）。这些七个 0 位将在使用 100 kHz 时钟时分布在 70 微秒内，应足以让外设检测到 SDA 线已变低。
- en: Start bytes are always followed by a repeated start condition and the actual
    peripheral address byte (see [Figure 2-7](#figure2-7)). Note that start bytes
    are never acknowledged—a NAK always follows in the ninth bit after the start byte.
    Also note that the start byte shares the same address as the general call function
    (see [Figure 2-6](#figure2-6)). The difference is in the R/W bit; the start byte
    sequence always has a 1 in the R/W position, and the general call operation has
    a 0 in this position.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 起始字节后总是跟随重复的起始条件和实际的外设地址字节（参见[图 2-7](#figure2-7)）。请注意，起始字节永远不会被确认 —— 在起始字节后的第九位始终会跟随一个
    NAK。同时请注意，起始字节与总线调用功能（参见[图 2-6](#figure2-6)）共享相同的地址。区别在于 R/W 位；起始字节序列的 R/W 位置始终为
    1，而总线调用操作在该位置为 0。
- en: '![](image_fi/502468c02/F02007.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c02/F02007.png)'
- en: 'Figure 2-7: Start byte sequence'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-7：起始字节序列
- en: If a peripheral device is slow and requires a start byte prefix, the controller
    must explicitly transmit the start byte before communicating with the peripheral.
    Likewise, if the peripheral device is slow, its software must recognize the tail
    end of a start sequence and be ready to read the following address from the bus.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外设设备速度较慢并且需要起始字节前缀，则控制器必须在与外设通信之前显式传输起始字节。同样地，如果外设设备速度较慢，则其软件必须识别起始序列的尾端，并准备好从总线上读取后续地址。
- en: Be aware that not all peripheral ICs support the start byte. This means that
    if you send a start byte on the I²C bus to communicate with a slow device, other
    devices on the bus may misinterpret this signal. If you’re going to use this feature
    in the I²C protocol, ensure that all the devices on the bus will respond properly
    (meaning, at the very least, they ignore the start byte).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有外设集成电路都支持起始字节。这意味着如果在 I²C 总线上发送起始字节来与响应较慢的设备通信，总线上的其他设备可能会误解此信号。如果要在
    I²C 协议中使用此功能，请确保总线上的所有设备都能正确响应（至少忽略起始字节）。
- en: 2.5.4 CBUS and Reserved Addresses
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 CBUS 和保留地址
- en: The CBUS (adrs = 1, R/W = x [don’t care]) is an old, obsolete variant of the
    I²C bus. The CBUS address was originally used to activate CBUS devices on the
    I²C bus. However, this address is no longer used for this purpose, and modern
    controllers should not place this address on the bus.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: CBUS（adrs = 1, R/W = x [不重要]）是 I²C 总线的一个旧的、废弃的变种。CBUS 地址最初用于在 I²C 总线上激活 CBUS
    设备。然而，现在不再使用此地址用于此目的，现代控制器不应将此地址放置在总线上。
- en: 2.5.5 High-Speed Mode Controller Code
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.5 高速模式控制器代码
- en: High-speed mode controller codes (adrs = 4 through 7, R/W = x) are special addresses
    that the I²C protocol uses to switch between high-speed and slower (standard,
    fast, fast+) modes. Because very few devices operate on the I²C bus in high-speed
    mode, this book largely ignores the high-speed and ultra-fast modes. For more
    information on the high-speed controller modes, consult the I²C bus specification
    and user manual (see “For More Information”).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 高速模式控制器代码（地址 = 4 至 7，读/写 = x）是 I²C 协议用于在高速模式和较慢模式（标准、快速、快速+）之间切换的特殊地址。由于在 I²C
    总线上实际使用高速模式的设备非常少，本书主要忽略了高速和超高速模式。有关高速控制器模式的更多信息，请参考 I²C 总线规范和用户手册（见“更多信息”）。
- en: 2.5.6 10-Bit Peripheral Addressing
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.6 10位外设寻址
- en: To many people, the 7-bit addressing scheme on the I²C bus, which supports up
    to 112 devices, seems limiting. For a variety of reasons, this turns out to be
    far more than sufficient. However, the I²C bus does define a special extension
    that allows the use of a 10-bit address on the bus, allowing up to 1,024 additional
    addresses on a single bus (adrs = 0x78 through 0x7B).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对许多人来说，I²C 总线上的 7 位寻址方案，支持最多 112 个设备，似乎有限制。从多个角度来看，这实际上远远足够。然而，I²C 总线确实定义了一个特殊扩展，允许在总线上使用
    10 位地址，从而在单个总线上增加最多 1,024 个地址（地址 = 0x78 至 0x7B）。
- en: When one of the special addresses 0b1111000 (0x78), 0b1111001 (0x79), 0b1111010
    (0x7A), or 0b1111011 (0x7B) appears as the first byte after a start condition,
    this is the start of a 2-byte address sequence. The LO two bits of this address
    become the most significant (HO) 2 bits of the result. A second byte follows this
    byte that contains the remaining (LO) 8 bits of the address. See [Figure 2-8](#figure2-8)
    for the details.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当特殊地址 0b1111000 (0x78)、0b1111001 (0x79)、0b1111010 (0x7A) 或 0b1111011 (0x7B)
    作为启动条件后的第一个字节出现时，表示这是一个 2 字节地址序列的开始。该地址的低两个比特将成为结果的最重要（高位）2位。随后会有第二个字节，包含地址的剩余（低位）8位。有关详细信息，请参见[图
    2-8](#figure2-8)。
- en: '![](image_fi/502468c02/F02008.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c02/F02008.png)'
- en: 'Figure 2-8: 10-bit address format'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-8：10位地址格式
- en: The peripheral device constructs the 10-bit address from the two bytes that
    begin with 0b11110*aa*. The remainder of the transmission starting with the third
    byte is identical to an I²C transmission with a 7-bit address, following the first
    byte.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 外设设备从以 0b11110*aa* 开头的两个字节构造 10 位地址。随后第三个字节开始的传输与使用 7 位地址的 I²C 传输相同，遵循第一个字节。
- en: Although having a 10-bit address scheme seems reasonable, in the real world
    it’s almost useless. First, few commercially available peripheral devices support
    10-bit addresses. In theory, you could create your own custom peripheral device
    that looks for a 10-bit address. However, this would buy you almost nothing, as
    it’s probably just as easy to find an unused 7-bit address in your system and
    use that. This saves the extra 100 μsec (at 100 kHz) required to transmit the
    extra address information, and I²C transmissions are slow enough as it is.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管拥有 10 位地址方案看起来合情合理，但在现实中几乎没有用。首先，很少有市售外设设备支持 10 位地址。理论上，你可以创建一个自定义外设设备来寻找
    10 位地址。然而，这几乎没什么意义，因为在系统中找到一个未使用的 7 位地址并使用它可能同样容易。这样可以节省传输额外地址信息所需的额外 100 微秒（在
    100 kHz 下），而 I²C 传输本身已经足够慢。
- en: Another issue is the fact that 112 unique addresses are far more than enough
    for the I²C bus. Because of bus capacitance limitations, it would be nearly impossible
    to put that many devices on the same physical bus lines. Forget about adding another
    1,024 devices; that’s way beyond the electrical capabilities of the bus.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，112 个独特地址已经远远足够 I²C 总线使用。由于总线电容的限制，在同一物理总线上连接这么多设备几乎是不可能的。更不用说再添加 1,024
    个设备了，这远远超出了总线的电气能力。
- en: The only argument for 10-bit addresses is that it expands the peripheral designer’s
    ability to put several copies of the same device on the bus with less chance of
    creating address conflicts with other devices. For example, you might want to
    put four copies of a digital-to-analog converter on the I²C bus, but doing so
    might create address conflict with other chips you’d like to use. Using 10-bit
    addresses gives you more breathing room to spread out the addresses of the peripherals.
    However, as almost no peripheral ICs support extended addressing, this isn’t useful.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 10 位地址的唯一优点是，它扩大了外设设计师在总线上放置多个相同设备的能力，从而减少了与其他设备发生地址冲突的可能性。例如，你可能希望将四个数模转换器放置在
    I²C 总线上，但这样做可能会与其他你想使用的芯片发生地址冲突。使用 10 位地址可以给你更多的空间来分配外设的地址。然而，由于几乎没有外设 IC 支持扩展地址，这种方法并不实用。
- en: 'Note that if you really want to include multiple copies of the same IC in your
    design with possible address conflicts, there is another solution: the I²C multiplexer.
    See Chapter 12 for more information.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你确实希望在设计中包括多个相同的 IC，并且可能发生地址冲突，另有一种解决方案：I²C 多路复用器。有关更多信息，请参见第 12 章。
- en: 2.5.7 Device ID
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.7 设备 ID
- en: 'The device ID is another really good idea that, unfortunately, a large percentage
    of devices don’t support. The concept is to have a controller transmit the “device
    bus ID” (0xF8, which is address 0x7C plus R/W = 0), followed by the peripheral
    address. Then the controller does a restart, transmits 0xF9 (0x7C plus R/W = 1),
    and then reads 3 bytes back from the peripheral device: 12 bits that specify the
    manufacturer (a value specified by NXP Semiconductors), 9 bits that specify the
    part number (assigned by the manufacturer), and 3 bits that specify the die (IC)
    revision.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 设备 ID 是另一个非常好的概念，但不幸的是，大部分设备并不支持该功能。其概念是让控制器传输“设备总线 ID”（0xF8，即地址 0x7C 加 R/W
    = 0），后面跟着外设地址。然后控制器进行重启，传输 0xF9（0x7C 加 R/W = 1），并从外设设备读取 3 字节数据：12 位指定制造商（由 NXP
    半导体公司指定的值）、9 位指定部件号（由制造商分配），以及 3 位指定芯片（IC）版本。
- en: In theory, this would be a nice feature to use to identify devices on the bus.
    In practice, because so few chips support it, it’s a nearly useless feature. Nevertheless,
    if a particular part does support it, obtaining the die revision information can
    be useful as it may help you program work-arounds for bugs in various revisions
    of the chip.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，这将是一个很好的功能，可以用于识别总线上的设备。实际上，由于很少有芯片支持该功能，因此它几乎是一个没用的功能。然而，如果某个特定部件支持该功能，获取芯片版本信息还是有用的，因为它可能帮助你为该芯片的不同版本的
    bug 编写工作绕过程序。
- en: For more information about the device ID command, see the I²C bus specifications
    and user manual in “For More Information.”
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设备 ID 命令的更多信息，请参阅“更多信息”中的 I²C 总线规范和用户手册。
- en: 2.6 Resetting the I²C Bus
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 复位 I²C 总线
- en: Because of bugs in application software, device drivers, or firmware or hardware
    on the device, some peripheral chips have been known to “latch up” and enter an
    unknown, that is, illegal state. Sometimes this means you lose the functionality
    of that chip until it is reset. Even worse, sometimes that chip stops while pulling
    the SDA or SCL line low, meaning the I²C bus is useless from that point forward.
    In such situations, you’ll want to reset the device.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用软件、设备驱动程序、固件或硬件中的错误，一些外设芯片可能会“锁死”并进入一个未知的，即非法的状态。有时，这意味着你失去了该芯片的功能，直到它被复位。更糟糕的是，有时该芯片会停机，同时拉低
    SDA 或 SCL 线，导致从那时起 I²C 总线无法使用。在这种情况下，你将需要复位设备。
- en: 'Of course, you can use the general call command to send a reset command to
    all the devices in the system. However, this approach suffers from a couple problems:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用通用调用命令向系统中的所有设备发送复位命令。然而，这种方法存在一些问题：
- en: Not all devices respond to the general call/reset command.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有设备都能响应通用调用/复位命令。
- en: The general call/reset command resets *every* device that is listening for it.
    You may not want to do this as you’d have to reinitialize all the devices on the
    bus.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用调用/复位命令会复位*每一个*正在监听该命令的设备。你可能不希望这样做，因为你需要重新初始化总线上的所有设备。
- en: If the device itself is hung up, it may not respond to a software command sent
    over the I²C bus. This is especially true if it is pulling the SDA or SCL line
    low, which means the command would never arrive.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设备本身发生故障，可能无法响应通过 I²C 总线发送的软件命令。尤其是当它拉低 SDA 或 SCL 线时，命令将无法到达。
- en: Resetting the I²C bus calls for a hardware solution. A few devices support a
    *reset pin* on the IC. Typically, pulling such a pin low will reset the device
    and initialize it to a power-up state. The device may require further initialization
    once it has reached that state, but this is better than having to reset the whole
    system to make the chip recover. Connecting the device’s reset pin to an available
    *general-purpose I/O (GPIO)* pin on the main CPU would allow you to programmatically
    reset the device under program control.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重置 I²C 总线需要硬件解决方案。一些设备支持 IC 上的*复位引脚*。通常，将该引脚拉低会重置设备并将其初始化为上电状态。一旦设备达到该状态，可能还需要进一步初始化，但这总比重置整个系统来恢复芯片要好。将设备的复位引脚连接到主
    CPU 上可用的*通用输入输出(GPIO)* 引脚，可以在程序控制下通过编程方式重置设备。
- en: Of course, you could run a single reset line to all the devices that provide
    a reset pin. However, this runs into the same problem as the general call/reset
    command—you reset all the devices and have to reinitialize all of them to correct
    the problems with a single IC.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以将一条复位线连接到所有提供复位引脚的设备。但是，这会遇到与通用调用/复位命令相同的问题——你需要重置所有设备，并且必须重新初始化它们，才能修复单个
    IC 的问题。
- en: The biggest problem with the hardware reset approach is that not every I²C peripheral
    device out there has a reset pin on it. For those devices that don’t have a reset
    chip, another solution is to temporarily turn off the power to the IC for a bit
    and then reapply power. This will certainly reset the chip to its power-on state.
    You could wire some transistors to do this. Another solution is an off-the-shelf
    device like the SparkFun Qwiic Power Switch ([https://www.sparkfun.com/products/16740](https://www.sparkfun.com/products/16740)).
    This is an I²C peripheral that lets you turn on and off the power to other I²C
    devices, either for resetting or for low-power standby operation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件复位方法的最大问题是，并非每个 I²C 外设都有复位引脚。对于没有复位引脚的设备，另一种解决方案是暂时切断 IC 的电源一段时间，然后重新恢复电源。这肯定会将芯片重置为上电状态。你可以使用一些晶体管来实现这一点。另一种解决方案是像
    SparkFun Qwiic Power Switch（[https://www.sparkfun.com/products/16740](https://www.sparkfun.com/products/16740)）这样的现成设备。这是一个
    I²C 外设，允许你开关其他 I²C 设备的电源，无论是为了重置还是低功耗待机操作。
- en: 2.7 Detecting I²C Peripherals on the Bus
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 在总线上检测 I²C 外设
- en: One common desire programmers have is to determine whether a peripheral is present
    at some address on the I²C bus. In theory, the Device ID operation (see section
    2.5.7, “Device ID,” earlier in this chapter) would provide this capability. A
    controller could send the Device ID special address (0xF8) on the bus followed
    by the device address to check. If the response is a NAK, then no device is at
    that address; if an ID response comes back, then the controller knows a device
    is present at that address, and the ID information exactly specifies the device.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员常常希望确定某个外设是否存在于 I²C 总线上的某个地址。理论上，设备 ID 操作（参见本章前面的 2.5.7 节“设备 ID”）可以提供这一功能。控制器可以在总线上发送设备
    ID 特殊地址（0xF8），然后跟随设备地址进行检查。如果响应是 NAK，则该地址没有设备；如果返回 ID 响应，则控制器知道该地址有设备存在，并且 ID
    信息准确地指定了设备。
- en: The only problem with using the Device ID approach is that supporting the Device
    ID command is optional in a peripheral. If a peripheral does not support the Device
    ID command, it simply doesn’t acknowledge the request. Therefore, although the
    peripheral is actually present, the Device ID command suggests that it is not.
    As a large percentage of I²C peripheral ICs do not support the Device ID command,
    this isn’t a practical way to detect such peripherals.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设备 ID 方法的唯一问题是，外设支持设备 ID 命令是可选的。如果外设不支持设备 ID 命令，它只是不会响应请求。因此，尽管外设实际存在，但设备
    ID 命令会表明它不存在。由于大量 I²C 外设 IC 不支持设备 ID 命令，这并不是检测这些外设的实用方法。
- en: A common solution is to send a start condition, an address byte with the R/W
    bit high (a read operation), and then immediately send a stop condition without
    waiting for any data from the peripheral. The peripheral will acknowledge the
    address byte. However, the stop condition will prevent the peripheral device from
    actually transmitting data back to the controller. The controller can check for
    an ACK or NAK and use that response to determine if a peripheral is present at
    the specified address. This won’t tell the controller which peripheral is present,
    but it will, at least, give a “something is there” or “nothing is there” response.
    This is how many utilities, such as the Linux `i2cdetect` utility, work.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的解决方案是发送一个启动条件，一个带有高 R/W 位的地址字节（即读取操作），然后立即发送停止条件，而不等待外设返回任何数据。外设将确认地址字节。然而，停止条件将阻止外设实际将数据传回控制器。控制器可以检查
    ACK 或 NAK 并使用该响应来确定指定地址处是否有外设存在。这不会告诉控制器哪个外设存在，但至少会给出“有设备”或“没有设备”的响应。这就是许多工具（如
    Linux 的 `i2cdetect` 工具）工作的方式。
- en: There are a couple show-stopper problems with this approach to detection. One
    issue is that SMBus peripherals (SMBus is a variant of the I²C bus; see section
    5.1, “SMBus,” in Chapter 5), according to the standard, can use the R/W bit as
    a data element. For example, the R/W bit can turn some external device on or off
    based on whether you read the address or write to it. If you send a read command
    immediately followed by a stop condition to such a peripheral, it could change
    the state of that device. If the state had previously been off, sending the read
    command might change the state to on (assuming the peripheral copies the value
    of the R/W bit directly to the state where 1 = on = R and 0 = off = W). Clearly,
    using a read command to detect the presence of the device is bad because the detection
    could also change its state.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种检测方法会遇到几个阻碍性问题。一个问题是，根据标准，SMBus 外设（SMBus 是 I²C 总线的一个变种；参见第 5 章第 5.1 节“SMBus”）可以将
    R/W 位作为数据元素。例如，R/W 位可以根据你是读取地址还是写入地址，打开或关闭某些外部设备。如果你向这样的外设发送一个读取命令，并立即跟随一个停止条件，它可能会改变该设备的状态。如果设备之前是关闭的，发送读取命令可能会将状态改为开启（假设外设直接将
    R/W 位的值复制到状态中，其中 1 = 开启 = R，0 = 关闭 = W）。显然，使用读取命令来检测设备的存在是不可取的，因为检测过程也可能改变设备的状态。
- en: One solution to this problem is to use both the Device ID and “read with immediate
    stop condition” commands. The SMBus standard requires all devices to support the
    Device ID command. If you *first* issue a Device ID command and an SMBus device
    is present, it will respond with appropriate identification information. If you
    get a NAK from the Device ID, then an SMBus device does not appear at that address,
    and you can try the read operation to see if you get a response. If you still
    get a NAK, you can probably assume that there is no device at the given address.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是同时使用设备 ID 和“带立即停止条件的读取”命令。SMBus 标准要求所有设备都支持设备 ID 命令。如果你*首先*发出设备
    ID 命令，并且存在 SMBus 设备，它会以适当的标识信息进行响应。如果从设备 ID 收到 NAK，则表示该地址没有 SMBus 设备，你可以尝试读取操作，看是否收到响应。如果仍然收到
    NAK，你可以假设该地址没有设备。
- en: This assumes, of course, that only the devices that use the R/W bit as data
    will also support the Device ID command. The only place I’ve ever seen using the
    R/W bit as data has been in the SMBus documentation, so it’s probably a safe assumption.
    Of course, if you create your own peripheral device and use the R/W bit as data,
    you should probably support the Device ID command to allow detection software
    to work around this issue.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这假设只有那些将 R/W 位作为数据的设备才会支持设备 ID 命令。我见过唯一将 R/W 位作为数据使用的地方是 SMBus 文档，所以这个假设可能是安全的。当然，如果你自己创建外设并使用
    R/W 位作为数据，你应该支持设备 ID 命令，以便检测软件能绕过这个问题。
- en: Another problem with putting a read command on the bus and checking for a response
    is that *write-only* devices may not respond to a read command. The Linux `i2cdetect`
    utility solves this problem by doing reads to certain addresses and writes to
    others, as well as providing command line options to force certain types of detection
    algorithms. Check out the source code for the `i2cdetect` application for more
    information on their technique (see “For More Information” for additional details
    on `i2cdetect`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将读取命令放到总线上并检查响应的另一个问题是，*只写*设备可能不会响应读取命令。Linux 的 `i2cdetect` 工具通过对某些地址进行读取、对其他地址进行写入，并提供命令行选项以强制执行特定类型的检测算法来解决这个问题。有关该技术的更多信息，请查看
    `i2cdetect` 应用程序的源代码（有关 `i2cdetect` 的更多详细信息，请参阅“更多信息”）。
- en: 'The bottom line is that there is no *perfect* way to detect peripheral devices
    on the I²C bus. Some schemes will fail to detect a device that is present; others
    may change the state of a device that is present. Ultimately, the best way to
    detect things is by design: know what devices are installed in your system and
    intentionally program for them.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，没有*完美*的方法来检测 I²C 总线上的外设设备。某些方案可能无法检测到已连接的设备；而其他方案则可能改变已连接设备的状态。最终，最好的检测方法是设计：了解系统中安装了哪些设备，并针对这些设备进行有意的编程。
- en: 2.8 Creating Custom Devices
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8 创建自定义设备
- en: 'For most real-world applications, you can probably find an IC that interfaces
    to the I²C bus and does just what you need. However, it’s also possible that you
    have such a specialized application that no such peripheral could possibly exist.
    Fortunately, you don’t have to rely solely on off-the-shelf parts: you can create
    your own I²C peripheral devices instead. There are several ways to do this, and
    this book covers a couple of them. The next chapter, for example, will discuss
    how to implement I²C controller and peripheral devices totally in software. Later
    chapters will discuss how to use the I²C hardware present on various SBCs to create
    such devices. You’re limited only by your imagination.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数实际应用，你可能能找到一个与 I²C 总线接口并完全符合需求的集成电路。然而，也有可能你的应用过于专业，以至于没有任何现成的外设能够满足。幸运的是，你不必仅仅依赖现成的零件：你还可以自己创建
    I²C 外设设备。有几种方法可以做到这一点，本书将介绍其中的几种。例如，下一章将讨论如何完全通过软件实现 I²C 控制器和外设设备。后续章节将讨论如何利用各种
    SBC 上的 I²C 硬件来创建这些设备。你的创意是唯一的限制。
- en: 2.9 Chapter Summary
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9 章节总结
- en: This chapter discussed the format of the data on the I²C bus—the I²C protocol.
    This includes a description of data on the I²C bus, I²C addresses and R/W control,
    and special patterns to start and end I²C transmissions (start and stop conditions).
    This chapter also described a small optimization, repeated start conditions, and
    how to introduce wait states in an I²C transmission via clock stretching.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 I²C 总线数据的格式——I²C 协议。这包括对 I²C 总线上的数据、I²C 地址和读写控制的描述，以及启动和结束 I²C 传输的特殊模式（启动和停止条件）。本章还描述了一种小优化：重复启动条件，并介绍了如何通过时钟拉伸在
    I²C 传输中引入等待状态。
- en: The I²C bus supports several features using special addresses. This includes
    the general call address, hardware general calls, the start byte, high-speed control,
    10-bit peripheral addressing, and device ID. See the appropriate sections in this
    chapter for more details.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线支持通过特殊地址实现多个功能，包括通用调用地址、硬件通用调用、启动字节、高速控制、10位外设寻址和设备 ID。有关详细信息，请参阅本章中的相关部分。
- en: This chapter concluded with a discussion of resetting the I²C bus and detecting
    peripherals on the I²C bus, along with a brief discussion of creating custom I²C
    peripherals.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后讨论了如何重置 I²C 总线并检测 I²C 总线上的外设设备，同时简要讨论了如何创建自定义 I²C 外设。
- en: The next chapter uses the information from this chapter to describe how to implement
    the I²C protocol using software. The code present in that chapter also provides
    another view of the I²C protocol, clarifying it for those who prefer to see a
    formal (code) description of the protocol.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章使用本章的信息，描述如何通过软件实现 I²C 协议。该章中的代码还提供了 I²C 协议的另一种视角，帮助那些倾向于查看正式（代码）描述的人更好地理解该协议。
