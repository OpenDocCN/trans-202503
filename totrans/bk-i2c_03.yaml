- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I²C Protocol
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'The I²C bus definition is quite a bit more than electrical levels appearing
    on a bus. Equally important is the definition of the signals appearing on those
    two lines. This chapter discusses the data protocols associated with the I²C bus—that
    is, the speed at which the data transmission takes place, how a device can force
    the controller to wait for it, and how controllers do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Transmit bits to and from devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the device’s address
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the data direction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the end of the data transmission
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order and definition of the bits appearing on the bus, and how they are
    clocked on the bus, are determined by the I²C *protocol*. This chapter describes
    that protocol and discusses some useful topics such as resetting the I²C bus and
    detecting peripherals on the bus.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Data on the I²C Bus
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I²C bus transmits data serially on the SDA line, clocked by the SCL signal
    (see [Figure 2-1](#figure2-1)). The data on the SDA line must be stable (0 or
    1) when SCL is high (1); data may change on the SDA line only while SCL is low
    (see [Figure 2-1](#figure2-1)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c02/f02001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: Serial data transmission on the I²C bus'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Data transmissions on the I²C bus consist of a start signal, followed by one
    or more bytes of data, and end with a stop signal. Between data transmissions,
    the SDA and SCL lines are in their unasserted state (that is, both signals are
    pulled high). As noted in the previous chapter, if the SCL line is high for longer
    than a one-half clock period, the bus is currently unused.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A start condition consists of a controller pulling the SDA line low while the
    SCL line has been high for some period of time (see [Figure 2-2](#figure2-2)).
    As mentioned earlier (see [Figure 2-1](#figure2-1)), the SDA line normally must
    be stable while the clock line is high. This is to allow devices on the I²C bus
    to detect a start (and as you will soon see, a stop) condition.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, SCL must be high for the duration of between one-quarter and one-half
    clock period before SDA can go low to signal a start condition. Specifically,
    this start setup time is one of the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'For standard mode (10-μsec clock period): 4.7 μsec'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For fast mode (2.5-μsec clock period): 0.6 μsec'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For fast-plus mode (1-μsec clock period): 0.26 μsec'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the data line has gone low, signifying the start condition, the controller
    can pull the SCL line low to begin clocking in data after the following startup
    hold times:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'For standard mode: 4.0 μsec'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For fast mode: 0.6 μsec'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For fast-plus mode: 0.26 μsec'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](image_fi/502468c02/F02002.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: Start condition on the I²C bus'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: A byte transmission consists of 8 data bits and an acknowledgment bit (see [Figure
    2-3](#figure2-3)). The 8-bit data byte is shipped with the most significant bit
    (MSB) appearing first on the SDA line and the least significant bit (LSB) following
    eight clock periods later. Immediately following the byte data is a single acknowledgment
    bit. This bit is always 0 if the receiving device is acknowledging the data. It
    is a 1 (NAK, or negative acknowledgment) if there was a transmission error.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c02/F02003.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: Byte transmission on the I²C bus'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that either the controller or the peripheral could be placing the data
    on the data bus. For a write operation, the controller is responsible for placing
    the data on the SDA line; for a read operation, the peripheral is responsible
    for placing the data on the SDA line. For the acknowledgment, the roles are reversed:
    for reads, the controller pulls the SDA low to acknowledge the read from the peripheral,
    while for writes, the peripheral pulls the SDA line low to acknowledge the write
    operation. If the transmission is bad for whatever reason, the device accepting
    the data does not pull the SDA line low for the acknowledgment. This leaves the
    SDA line high (which is a NAK). The next section, “I²C Addresses and Read/Write
    Control,” will discuss how the controller specifies whether a read or write operation
    is taking place.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'A stop condition consists of changing the SDA line from low to high while the
    SCL line is held high (remember, data normally must be stable while the clock
    line is high). This typically consists of setting the SDA line low before the
    last rising edge of the SCL line at the end of the data transmission and then
    pulling the SDA line high afterward, as [Figure 2-4](#figure2-4) shows. Similar
    to the start condition, the SCL line must be high for a certain amount of time
    (the *setup time for the stop condition*) before transitioning the SDA line from
    low to high. These setup times are the same as for the start condition, specifically:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'For standard mode: 4.7 μsec'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For fast mode: 0.6 μsec'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For fast-plus mode: 0.26 μsec'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the controller generates the stop condition, the I²C bus is free, and after
    an appropriate start setup time, a controller can obtain it and use it again.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c02/f02004.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: I²C stop condition (S[p])'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: A stop condition does not occur after every byte. Instead, a stop condition
    marks the completion of a string of byte transmissions over the I²C bus. Specifically,
    a single (atomic) transmission consists of a start condition, followed by one
    or more byte transmissions (each with their own ACK or NAK bit), and a stop condition
    at termination. This transmission is considered atomic because the controller
    driving the transmission has complete control of the I²C bus for the entire duration
    of the transmission; during this time, no other controller can take possession
    of the I²C bus.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 I²C Addresses and Read/Write Control
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first byte appearing on the I²C bus after a start condition is special.
    This byte contains the I²C device address and the read/write state. [Figure 2-5](#figure2-5)
    shows the format for the peripheral address and R/W (read/write) byte (the overbar
    on the W indicates that the write signal is active low [0]).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 启动条件后，第一个出现在 I²C 总线上的字节是特殊的。该字节包含了 I²C 设备地址和读/写状态。[图 2-5](#figure2-5) 显示了外设地址和
    R/W（读/写）字节的格式（W 上的下划线表示写信号为低有效 [0]）。
- en: '![](image_fi/502468c02/f02005.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c02/f02005.png)'
- en: 'Figure 2-5: First byte following a start condition (peripheral address and
    R/W bit)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-5：启动条件后的第一个字节（外设地址和 R/W 位）
- en: The upper 7 bits of this byte contain the address of the peripheral for whom
    this transmission is intended. Because there are 7 bits, you can specify a maximum
    of 128 peripheral addresses in this peripheral address byte (though see section
    2.5, “Special Addresses,” later in this chapter for information about a 10-bit
    address on the I²C bus). The LO bit of the byte contains an R/W flag. A 0 in this
    bit position specifies a write operation, and a 1 in this position specifies a
    read operation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该字节的高 7 位包含了该传输的目标外设地址。由于是 7 位，你最多可以在这个外设地址字节中指定 128 个外设地址（不过请参见本章后面的 2.5 节，“特殊地址”，了解有关
    I²C 总线上的 10 位地址的信息）。该字节的 LO 位包含一个 R/W 标志。此位为 0 时，表示写操作；为 1 时，表示读操作。
- en: The R/W bit determines the data transfer directions of all the bytes following
    the peripheral address byte. If this bit is 0 (write operation), then the controller
    will supply all the data on the SDA line in the following bytes; if this bit is
    1 (read operation), then the peripheral will place the data on the SDA line during
    the transmission. Regardless of the data direction, the controller is still responsible
    for driving the SCL line (though see section 2.4, “Clock Stretching,” later in
    this chapter).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: R/W 位决定了在外设地址字节之后所有字节的数据传输方向。如果该位为 0（写操作），则控制器将在随后的字节中通过 SDA 线提供所有数据；如果该位为 1（读操作），则外设将在传输过程中通过
    SDA 线放置数据。无论数据方向如何，控制器仍然负责驱动 SCL 线（不过请参见本章后面的 2.4 节，“时钟延伸”）。
- en: Generally, this book will write I²C addresses as 7-bit binary or hexadecimal
    values (using C notation, 0x*nn* or 0b*nnnnnnn*). The full address and R/W byte
    will normally be written in 8-bit hexadecimal form.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，本书会将 I²C 地址表示为 7 位二进制或十六进制值（使用 C 表示法，0x*nn* 或 0b*nnnnnnn*）。完整的地址和 R/W 字节通常会以
    8 位十六进制形式表示。
- en: 2.3 Repeated Start Conditions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 重复启动条件
- en: In some special cases, a controller might need to write data to some particular
    peripheral and then immediately read data back from that peripheral as an atomic
    operation, without the possibility of some other controller accessing the peripheral
    between the write and read operations. Because the data direction is specified
    by the LO bit of the first byte after a start condition, a controller must send
    another start condition to change the direction. However, if the controller completes
    the current transfer by issuing a stop condition before sending another start
    condition, this gives a different controller the opportunity to seize the bus
    before the second transmission. This means the controller needs a way to hold
    onto the bus by not sending a stop condition. This is accomplished with a repeated
    start condition.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些特殊情况下，控制器可能需要向某个特定外设写入数据，然后立即从该外设读取数据，这一过程必须是原子操作，且写操作与读操作之间不能允许其他控制器访问该外设。由于数据方向是由启动条件后的第一个字节中的
    LO 位指定的，因此控制器必须发送另一个启动条件来改变方向。然而，如果控制器在发送另一个启动条件之前通过发出停止条件来完成当前传输，这将给其他控制器提供在第二次传输前抢占总线的机会。这意味着控制器需要通过不发送停止条件来保住总线。此操作通过重复启动条件来实现。
- en: A *repeated start condition*, as its name implies, is a second start condition
    (SDA high-to-low while SCL is high) without an intervening stop condition on the
    I²C bus. Until a stop condition comes along (which is what waiting controllers
    look for while waiting for the I²C bus), the current controller owns the bus.
    Therefore, a controller can use a sequence of repeated starts during a data transmission
    to reverse the data direction, or even to communicate with multiple peripherals,
    without giving up the I²C bus. When the atomic operations are complete, the controller
    can yield the bus by issuing a stop condition.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: In a multicontroller environment, a controller should take care not to monopolize
    the I²C bus. For operations that do not require atomicity, the controller should
    use stop conditions between transfers so that different controllers can gain access
    to the bus in a fair manner.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Clock Stretching
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the previous chapter, clock stretching is a technique whereby
    a peripheral device can force the controller to wait while the peripheral is processing
    data. For example, a simple peripheral device polling the SDA and SCL lines and
    manually processing incoming data might need a small amount of time after each
    byte. During that time the controller might ship additional data that could be
    lost while the peripheral is busy processing the data. To resolve this problem,
    the peripheral can use clock stretching to force the controller to pause while
    the peripheral’s CPU deals with the incoming data. This effectively adds *wait
    states* to the data transmission.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: A peripheral can stretch the clock by pulling the SCL line low. Technically,
    this can occur at any time. However, when transmitting data from the controller
    to the peripheral, the peripheral usually pulls the SCL line low when the SCL
    line is also low just after the acknowledge bit, as this is when the peripheral
    has received the entire byte and will need to process it. Transmitting data from
    the peripheral to the controller is also a good time for the peripheral to pull
    the SCL line low after a complete byte transmission if the peripheral needs additional
    time to produce the next byte to transmit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Note that clock stretching is an optional feature in the I²C standard. In fact,
    most peripheral devices don’t support clock stretching, as they can handle the
    data transmissions as fast as the controller sends them. Although it should be
    rare, a controller might not support clock stretching in certain situations, such
    as when someone uses a simple microcontroller device to build a multifunction
    I²C controller that has to handle many different activities, which results in
    performance problems. See “For More Information” at the end of this chapter for
    details on how to deal with this situation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Special Addresses
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With 7 address bits you would get the impression that the I²C bus supports up
    to 128 devices. In fact, this is not the case, for two reasons. First, the I²C
    standard reserves two groups of 8 addresses (0 through 7 and 120 through 127)
    for special purposes. Second, I²C uses a couple of those reserved addresses to
    allow extended addresses up to 10 bits in length. In theory, this allows an additional
    1,024 devices on the bus.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-1](#table2-1) lists the special addresses currently defined for the
    I²C bus. Don’t-care bits (*xx*) appearing in these addresses can be 0b00, 0b01,
    0b10, or 0b11\. Most of the time, programs supply 0b00 for these bits.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-1: Special I²C Addresses'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address bits** | **R/W** | **Description** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| 0000-000 | 0 | General call address |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| 0000-000 | 1 | Start byte |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| 0000-001 | x^([*](#c02-footnote-001)) | CBUS addresses |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| 0000-010 | x | Reserved for different bus format |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| 0000-011 | x | Reserved for future purposes |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| 0000-1xx | x | High-speed mode controller code |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| 1111-0aa | R/W | 10-bit peripheral addressing (see section 2.5.6, “10-Bit
    Peripheral Addressing,” later in this chapter for discussion of aa bits) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| 1111-1xx | 1 | Device ID |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| ^([*](#c02-footnoteref-001))x = “don’t care” and can be 0 or 1 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: The following subsections describe the general call address (including hardware
    general calls), start byte, CBUS, high-speed controller mode, 10-bit addressing,
    and device ID special addresses in greater detail. Several addresses are also
    reserved for future device expansion. Existing controllers should not use these
    addresses until their use is defined within the I²C standard.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.1 The General Call Address
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *general call address* (0x00 with R/W = 0) is a special broadcast address
    that can address all devices on the bus. The R/W bit is always 0 (write) because
    you can never read from all the devices at the same time, as their return values
    would scramble one another.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The general call operation always consists of at least two bytes: the general
    call address (0x00) followed by a command byte (see [Figure 2-6](#figure2-6)).
    Generally, systems use this command to initialize all the peripherals that respond
    to the general call operation with a single bus command.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c02/F02006.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-6: General call command format'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'When bit B is 0, the I²C protocol currently defines the following commands
    (`ccccccc` bits):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`ccccccc` = 0b0000011: Reset and set peripheral programmable address.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ccccccc` = 0b0000010: Set peripheral programmable address but do not reset.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ccccccc` = 0b0000000: Illegal command code, not allowed as second byte.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *peripheral programmable address* is an address that can be set by hardware
    pins on the peripheral device. Many devices include pins on the IC package that
    can specify one of several different I²C addresses to which the device responds.
    This allows a designer, for example, to put several of the same ICs on the I²C
    bus and have them respond to different addresses by setting these pins high or
    low. For example, the MCP4725 DAC contains a pin that allows you to select one
    of two different I²C addresses by tying the pin to Vcc or Gnd. The general call
    commands 0x00/0x07 (`ccccccc` = 0b0000011, `B` = 0) and 0x00/0x05 (`ccccccc` =
    0b0000010, `B` = 0) instruct such chips to load the address from these pins, as
    appropriate (the 0x00/0x06 command also instructs the peripheral to reset itself).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Most peripheral ICs set their programmed addresses on a power-up operation,
    and the address never changes after that point, so most peripheral devices will
    ignore this command or simply do a reset operation for the (0x00, 0x06) command.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Note that peripheral devices do not have to support the general call command—that
    is, its implementation is optional. If a device does not support the general call
    command, it must ignore it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Because of the open-drain nature of the I²C SDA line, if any device acknowledges
    the general call address and the command byte, the controller will see an ACK.
    Only if none of the devices acknowledge the general call command will the controller
    see a NAK response.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The commands other than (0x00, 0x00), (0x00, 0x04), and (0x00, 0x06) are reserved
    for future use and devices must ignore them. However, if you are creating your
    own custom peripherals for a custom system, you could create your own general
    call commands. You could even pass along additional data after the command byte
    to broadcast to all the devices you’ve created that respond to the commands. Just
    keep in mind that future revisions of the I²C protocol may conflict with your
    definitions. Also keep in mind that you can write data only with the broadcast
    (general call) command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.2 Hardware General Calls
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hardware general calls are a special form of the general call that support peer-to-peer
    communication. If the `B` bit in [Figure 2-6](#figure2-6) is a 1, the 2-byte sequence
    is a *hardware general call*. The `ccccccc` bits specify the controller’s address
    that it is broadcasting to all the devices, which could be followed by 0 or more
    bytes of additional data. Some other device on the bus could read this data and
    interpret it accordingly. Generally, a hardware general call is a way for one
    controller device to communicate with a different controller device and pass it
    a block of data. However, for this scheme to work, the second controller device
    receiving the data must be looking for the first controller’s address within the
    hardware general call.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: You won’t find too many commercially available devices that support the hardware
    general call. Typically, custom-programmed controllers that communicate with one
    another in the system would use these messages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, rather than design this protocol into your system, you’d probably
    be better off using the CANBUS or some other peer-to-peer networking scheme to
    transmit data between controllers in a system. As you might expect, very few devices
    take advantage of this feature in the I²C protocol. Most devices ignore hardware
    general calls.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.3 Start Byte
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The start byte (adrs = 0, R/W = 1) is a software mechanism for introducing delays
    in an I²C communication between a fast controller and a slow-responding peripheral.
    Some low-cost peripheral devices poll only the SDA line occasionally to see if
    a start condition exists. If the peripheral is otherwise preoccupied when the
    actual start condition arrives, the peripheral could miss a message intended for
    it. A start byte is the sequence 0x01 (that is, address 0 with the R/W bit high).
    These seven 0 bits, which will be spread over 70 μsec when using a 100-kHz clock,
    should give the peripheral sufficient time to detect that the SDA line has gone
    low.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Start bytes are always followed by a repeated start condition and the actual
    peripheral address byte (see [Figure 2-7](#figure2-7)). Note that start bytes
    are never acknowledged—a NAK always follows in the ninth bit after the start byte.
    Also note that the start byte shares the same address as the general call function
    (see [Figure 2-6](#figure2-6)). The difference is in the R/W bit; the start byte
    sequence always has a 1 in the R/W position, and the general call operation has
    a 0 in this position.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c02/F02007.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-7: Start byte sequence'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: If a peripheral device is slow and requires a start byte prefix, the controller
    must explicitly transmit the start byte before communicating with the peripheral.
    Likewise, if the peripheral device is slow, its software must recognize the tail
    end of a start sequence and be ready to read the following address from the bus.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that not all peripheral ICs support the start byte. This means that
    if you send a start byte on the I²C bus to communicate with a slow device, other
    devices on the bus may misinterpret this signal. If you’re going to use this feature
    in the I²C protocol, ensure that all the devices on the bus will respond properly
    (meaning, at the very least, they ignore the start byte).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.4 CBUS and Reserved Addresses
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CBUS (adrs = 1, R/W = x [don’t care]) is an old, obsolete variant of the
    I²C bus. The CBUS address was originally used to activate CBUS devices on the
    I²C bus. However, this address is no longer used for this purpose, and modern
    controllers should not place this address on the bus.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.5 High-Speed Mode Controller Code
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: High-speed mode controller codes (adrs = 4 through 7, R/W = x) are special addresses
    that the I²C protocol uses to switch between high-speed and slower (standard,
    fast, fast+) modes. Because very few devices operate on the I²C bus in high-speed
    mode, this book largely ignores the high-speed and ultra-fast modes. For more
    information on the high-speed controller modes, consult the I²C bus specification
    and user manual (see “For More Information”).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 高速模式控制器代码（地址 = 4 至 7，读/写 = x）是 I²C 协议用于在高速模式和较慢模式（标准、快速、快速+）之间切换的特殊地址。由于在 I²C
    总线上实际使用高速模式的设备非常少，本书主要忽略了高速和超高速模式。有关高速控制器模式的更多信息，请参考 I²C 总线规范和用户手册（见“更多信息”）。
- en: 2.5.6 10-Bit Peripheral Addressing
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.6 10位外设寻址
- en: To many people, the 7-bit addressing scheme on the I²C bus, which supports up
    to 112 devices, seems limiting. For a variety of reasons, this turns out to be
    far more than sufficient. However, the I²C bus does define a special extension
    that allows the use of a 10-bit address on the bus, allowing up to 1,024 additional
    addresses on a single bus (adrs = 0x78 through 0x7B).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对许多人来说，I²C 总线上的 7 位寻址方案，支持最多 112 个设备，似乎有限制。从多个角度来看，这实际上远远足够。然而，I²C 总线确实定义了一个特殊扩展，允许在总线上使用
    10 位地址，从而在单个总线上增加最多 1,024 个地址（地址 = 0x78 至 0x7B）。
- en: When one of the special addresses 0b1111000 (0x78), 0b1111001 (0x79), 0b1111010
    (0x7A), or 0b1111011 (0x7B) appears as the first byte after a start condition,
    this is the start of a 2-byte address sequence. The LO two bits of this address
    become the most significant (HO) 2 bits of the result. A second byte follows this
    byte that contains the remaining (LO) 8 bits of the address. See [Figure 2-8](#figure2-8)
    for the details.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当特殊地址 0b1111000 (0x78)、0b1111001 (0x79)、0b1111010 (0x7A) 或 0b1111011 (0x7B)
    作为启动条件后的第一个字节出现时，表示这是一个 2 字节地址序列的开始。该地址的低两个比特将成为结果的最重要（高位）2位。随后会有第二个字节，包含地址的剩余（低位）8位。有关详细信息，请参见[图
    2-8](#figure2-8)。
- en: '![](image_fi/502468c02/F02008.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c02/F02008.png)'
- en: 'Figure 2-8: 10-bit address format'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-8：10位地址格式
- en: The peripheral device constructs the 10-bit address from the two bytes that
    begin with 0b11110*aa*. The remainder of the transmission starting with the third
    byte is identical to an I²C transmission with a 7-bit address, following the first
    byte.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 外设设备从以 0b11110*aa* 开头的两个字节构造 10 位地址。随后第三个字节开始的传输与使用 7 位地址的 I²C 传输相同，遵循第一个字节。
- en: Although having a 10-bit address scheme seems reasonable, in the real world
    it’s almost useless. First, few commercially available peripheral devices support
    10-bit addresses. In theory, you could create your own custom peripheral device
    that looks for a 10-bit address. However, this would buy you almost nothing, as
    it’s probably just as easy to find an unused 7-bit address in your system and
    use that. This saves the extra 100 μsec (at 100 kHz) required to transmit the
    extra address information, and I²C transmissions are slow enough as it is.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管拥有 10 位地址方案看起来合情合理，但在现实中几乎没有用。首先，很少有市售外设设备支持 10 位地址。理论上，你可以创建一个自定义外设设备来寻找
    10 位地址。然而，这几乎没什么意义，因为在系统中找到一个未使用的 7 位地址并使用它可能同样容易。这样可以节省传输额外地址信息所需的额外 100 微秒（在
    100 kHz 下），而 I²C 传输本身已经足够慢。
- en: Another issue is the fact that 112 unique addresses are far more than enough
    for the I²C bus. Because of bus capacitance limitations, it would be nearly impossible
    to put that many devices on the same physical bus lines. Forget about adding another
    1,024 devices; that’s way beyond the electrical capabilities of the bus.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，112 个独特地址已经远远足够 I²C 总线使用。由于总线电容的限制，在同一物理总线上连接这么多设备几乎是不可能的。更不用说再添加 1,024
    个设备了，这远远超出了总线的电气能力。
- en: The only argument for 10-bit addresses is that it expands the peripheral designer’s
    ability to put several copies of the same device on the bus with less chance of
    creating address conflicts with other devices. For example, you might want to
    put four copies of a digital-to-analog converter on the I²C bus, but doing so
    might create address conflict with other chips you’d like to use. Using 10-bit
    addresses gives you more breathing room to spread out the addresses of the peripherals.
    However, as almost no peripheral ICs support extended addressing, this isn’t useful.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you really want to include multiple copies of the same IC in your
    design with possible address conflicts, there is another solution: the I²C multiplexer.
    See Chapter 12 for more information.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.7 Device ID
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The device ID is another really good idea that, unfortunately, a large percentage
    of devices don’t support. The concept is to have a controller transmit the “device
    bus ID” (0xF8, which is address 0x7C plus R/W = 0), followed by the peripheral
    address. Then the controller does a restart, transmits 0xF9 (0x7C plus R/W = 1),
    and then reads 3 bytes back from the peripheral device: 12 bits that specify the
    manufacturer (a value specified by NXP Semiconductors), 9 bits that specify the
    part number (assigned by the manufacturer), and 3 bits that specify the die (IC)
    revision.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In theory, this would be a nice feature to use to identify devices on the bus.
    In practice, because so few chips support it, it’s a nearly useless feature. Nevertheless,
    if a particular part does support it, obtaining the die revision information can
    be useful as it may help you program work-arounds for bugs in various revisions
    of the chip.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the device ID command, see the I²C bus specifications
    and user manual in “For More Information.”
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Resetting the I²C Bus
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because of bugs in application software, device drivers, or firmware or hardware
    on the device, some peripheral chips have been known to “latch up” and enter an
    unknown, that is, illegal state. Sometimes this means you lose the functionality
    of that chip until it is reset. Even worse, sometimes that chip stops while pulling
    the SDA or SCL line low, meaning the I²C bus is useless from that point forward.
    In such situations, you’ll want to reset the device.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can use the general call command to send a reset command to
    all the devices in the system. However, this approach suffers from a couple problems:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Not all devices respond to the general call/reset command.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general call/reset command resets *every* device that is listening for it.
    You may not want to do this as you’d have to reinitialize all the devices on the
    bus.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the device itself is hung up, it may not respond to a software command sent
    over the I²C bus. This is especially true if it is pulling the SDA or SCL line
    low, which means the command would never arrive.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resetting the I²C bus calls for a hardware solution. A few devices support a
    *reset pin* on the IC. Typically, pulling such a pin low will reset the device
    and initialize it to a power-up state. The device may require further initialization
    once it has reached that state, but this is better than having to reset the whole
    system to make the chip recover. Connecting the device’s reset pin to an available
    *general-purpose I/O (GPIO)* pin on the main CPU would allow you to programmatically
    reset the device under program control.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you could run a single reset line to all the devices that provide
    a reset pin. However, this runs into the same problem as the general call/reset
    command—you reset all the devices and have to reinitialize all of them to correct
    the problems with a single IC.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with the hardware reset approach is that not every I²C peripheral
    device out there has a reset pin on it. For those devices that don’t have a reset
    chip, another solution is to temporarily turn off the power to the IC for a bit
    and then reapply power. This will certainly reset the chip to its power-on state.
    You could wire some transistors to do this. Another solution is an off-the-shelf
    device like the SparkFun Qwiic Power Switch ([https://www.sparkfun.com/products/16740](https://www.sparkfun.com/products/16740)).
    This is an I²C peripheral that lets you turn on and off the power to other I²C
    devices, either for resetting or for low-power standby operation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 2.7 Detecting I²C Peripherals on the Bus
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One common desire programmers have is to determine whether a peripheral is present
    at some address on the I²C bus. In theory, the Device ID operation (see section
    2.5.7, “Device ID,” earlier in this chapter) would provide this capability. A
    controller could send the Device ID special address (0xF8) on the bus followed
    by the device address to check. If the response is a NAK, then no device is at
    that address; if an ID response comes back, then the controller knows a device
    is present at that address, and the ID information exactly specifies the device.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The only problem with using the Device ID approach is that supporting the Device
    ID command is optional in a peripheral. If a peripheral does not support the Device
    ID command, it simply doesn’t acknowledge the request. Therefore, although the
    peripheral is actually present, the Device ID command suggests that it is not.
    As a large percentage of I²C peripheral ICs do not support the Device ID command,
    this isn’t a practical way to detect such peripherals.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: A common solution is to send a start condition, an address byte with the R/W
    bit high (a read operation), and then immediately send a stop condition without
    waiting for any data from the peripheral. The peripheral will acknowledge the
    address byte. However, the stop condition will prevent the peripheral device from
    actually transmitting data back to the controller. The controller can check for
    an ACK or NAK and use that response to determine if a peripheral is present at
    the specified address. This won’t tell the controller which peripheral is present,
    but it will, at least, give a “something is there” or “nothing is there” response.
    This is how many utilities, such as the Linux `i2cdetect` utility, work.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple show-stopper problems with this approach to detection. One
    issue is that SMBus peripherals (SMBus is a variant of the I²C bus; see section
    5.1, “SMBus,” in Chapter 5), according to the standard, can use the R/W bit as
    a data element. For example, the R/W bit can turn some external device on or off
    based on whether you read the address or write to it. If you send a read command
    immediately followed by a stop condition to such a peripheral, it could change
    the state of that device. If the state had previously been off, sending the read
    command might change the state to on (assuming the peripheral copies the value
    of the R/W bit directly to the state where 1 = on = R and 0 = off = W). Clearly,
    using a read command to detect the presence of the device is bad because the detection
    could also change its state.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this problem is to use both the Device ID and “read with immediate
    stop condition” commands. The SMBus standard requires all devices to support the
    Device ID command. If you *first* issue a Device ID command and an SMBus device
    is present, it will respond with appropriate identification information. If you
    get a NAK from the Device ID, then an SMBus device does not appear at that address,
    and you can try the read operation to see if you get a response. If you still
    get a NAK, you can probably assume that there is no device at the given address.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: This assumes, of course, that only the devices that use the R/W bit as data
    will also support the Device ID command. The only place I’ve ever seen using the
    R/W bit as data has been in the SMBus documentation, so it’s probably a safe assumption.
    Of course, if you create your own peripheral device and use the R/W bit as data,
    you should probably support the Device ID command to allow detection software
    to work around this issue.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with putting a read command on the bus and checking for a response
    is that *write-only* devices may not respond to a read command. The Linux `i2cdetect`
    utility solves this problem by doing reads to certain addresses and writes to
    others, as well as providing command line options to force certain types of detection
    algorithms. Check out the source code for the `i2cdetect` application for more
    information on their technique (see “For More Information” for additional details
    on `i2cdetect`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is that there is no *perfect* way to detect peripheral devices
    on the I²C bus. Some schemes will fail to detect a device that is present; others
    may change the state of a device that is present. Ultimately, the best way to
    detect things is by design: know what devices are installed in your system and
    intentionally program for them.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 2.8 Creating Custom Devices
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For most real-world applications, you can probably find an IC that interfaces
    to the I²C bus and does just what you need. However, it’s also possible that you
    have such a specialized application that no such peripheral could possibly exist.
    Fortunately, you don’t have to rely solely on off-the-shelf parts: you can create
    your own I²C peripheral devices instead. There are several ways to do this, and
    this book covers a couple of them. The next chapter, for example, will discuss
    how to implement I²C controller and peripheral devices totally in software. Later
    chapters will discuss how to use the I²C hardware present on various SBCs to create
    such devices. You’re limited only by your imagination.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 2.9 Chapter Summary
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter discussed the format of the data on the I²C bus—the I²C protocol.
    This includes a description of data on the I²C bus, I²C addresses and R/W control,
    and special patterns to start and end I²C transmissions (start and stop conditions).
    This chapter also described a small optimization, repeated start conditions, and
    how to introduce wait states in an I²C transmission via clock stretching.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The I²C bus supports several features using special addresses. This includes
    the general call address, hardware general calls, the start byte, high-speed control,
    10-bit peripheral addressing, and device ID. See the appropriate sections in this
    chapter for more details.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concluded with a discussion of resetting the I²C bus and detecting
    peripherals on the I²C bus, along with a brief discussion of creating custom I²C
    peripherals.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter uses the information from this chapter to describe how to implement
    the I²C protocol using software. The code present in that chapter also provides
    another view of the I²C protocol, clarifying it for those who prefer to see a
    formal (code) description of the protocol.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
