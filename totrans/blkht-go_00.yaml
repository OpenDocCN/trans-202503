- en: INTRODUCTION
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: For about six years, the three of us led one of North America’s largest dedicated
    penetration-testing consulting practices. As principal consultants, we executed
    technical project work, including network penetration tests, on behalf of our
    clients—but we also spearheaded the development of better tools, processes, and
    methodology. And at some point, we adopted Go as one of our primary development
    languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Go provides the best features of other programming languages, striking a balance
    between performance, safety, and user-friendliness. Soon, we defaulted to it as
    our language of choice when developing tools. Eventually, we even found ourselves
    acting as advocates of the language, pushing for our colleagues in the security
    industry to try it. We felt the benefits of Go were at least worthy of consideration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we’ll take you on a journey through the Go programming language
    from the perspective of security practitioners and hackers. Unlike other hacking
    books, we won’t just show you how to automate third-party or commercial tools
    (although we’ll touch on that a little). Instead, we’ll delve into practical and
    diverse topics that approach a specific problem, protocol, or tactic useful to
    adversaries. We’ll cover TCP, HTTP, and DNS communications, interact with Metasploit
    and Shodan, search filesystems and databases, port exploits from other languages
    to Go, write the core functions of an SMB client, attack Windows, cross-compile
    binaries, mess with crypto, call C libraries, interact with the Windows API, and
    much, much more. It’s ambitious! We’d better begin . . .
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Who This Book Is For
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book is for anyone who wants to learn how to develop their own hacking
    tools using Go. Throughout our professional careers, and particularly as consultants,
    we’ve advocated for programming as a fundamental skill for penetration testers
    and security professionals. Specifically, the ability to code enhances your understanding
    of how software works and how it can be broken. Also, if you’ve walked in a developer’s
    shoes, you’ll gain a more holistic appreciation for the challenges they face in
    securing software, and you can use your personal experience to better recommend
    mitigations, eliminate false positives, and locate obscure vulnerabilities. Coding
    often forces you to interact with third-party libraries and various application
    stacks and frameworks. For many people (us included), it’s hands-on experience
    and tinkering that leads to the greatest personal development.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: To get the most out of this book, we encourage you to clone the book’s official
    code repository so you have all the working examples we’ll discuss. Find the examples
    at [*https://github.com/blackhat-go/bhg/*](https://github.com/blackhat-go/bhg/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: What This Book Isn’t
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book is not an introduction to Go programming in general but an introduction
    to using Go for developing security tools. We are hackers and then coders—in that
    order. None of us have ever been software engineers. This means that, as hackers,
    we put a premium on function over elegance. In many instances, we’ve opted to
    code as hackers do, disregarding some of the idioms or best practices of software
    design. As consultants, time is always scarce; developing simpler code is often
    faster and, therefore, preferable over elegance. When you need to quickly create
    a solution to a problem, style concerns come secondary.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: This is bound to anger Go purists, who will likely tweet at us that we don’t
    gracefully handle all error conditions, that our examples could be optimized,
    or that better constructs or methods are available to produce the desired results.
    We’re not, in most cases, concerned with teaching you the best, the most elegant,
    or 100 percent idiomatic solutions, unless doing so will concretely benefit the
    end result. Although we’ll briefly cover the language syntax, we do so purely
    to establish a baseline foundation upon which we can build. After all, this isn’t
    *Learning to Program Elegantly with Go*—this is *Black Hat Go*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Why Use Go for Hacking?
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to Go, you could prioritize ease of use by using dynamically typed languages—such
    as Python, Ruby, or PHP—at the expense of performance and safety. Alternatively,
    you could choose a statically typed language, like C or C++, that offers high
    performance and safety but isn’t very user-friendly. Go is stripped of much of
    the ugliness of C, its primary ancestor, making development more user-friendly.
    At the same time, it’s a statically typed language that produces syntax errors
    at compile time, increasing your assurance that your code will actually run safely.
    As it’s compiled, it performs more optimally than interpreted languages and was
    designed with multicore computing considerations, making concurrent programming
    a breeze.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'These reasons for using Go don’t concern security practitioners specifically.
    However, many of the language’s features are particularly useful for hackers and
    adversaries:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**Clean package management system** Go’s package management solution is elegant
    and integrated directly with Go’s tooling. Through the use of the `go` binary,
    you can easily download, compile, and install packages and dependencies, which
    makes consuming third-party libraries simple and generally free from conflict.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-compilation** One of the best features in Go is its ability to cross-compile
    executables. So long as your code doesn’t interact with raw C, you can easily
    write code on your Linux or Mac system but compile the code in a Windows-friendly,
    Portable Executable format.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**Rich standard library** Time spent developing in other languages has helped
    us appreciate the extent of Go’s standard library. Many modern languages lack
    the standard libraries required to perform many common tasks such as crypto, network
    communications, database connectivity, and data encoding (JSON, XML, Base64, hex).
    Go includes many of these critical functions and libraries as part of the language’s
    standard packaging, reducing the effort necessary to correctly set up your development
    environment or to call the functions.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency** Unlike languages that have been around longer, Go was released
    around the same time as the initial mainstream multicore processors became available.
    For this reason, Go’s concurrency patterns and performance optimizations are tuned
    specifically to this model.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Why You Might Not Love Go
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We recognize that Go isn’t a perfect solution to every problem. Here are some
    of the downsides of the language:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary size** ’Nuff said. When you compile a binary in Go, the binary is
    likely to be multiple megabytes in size. Of course, you can strip debugging symbols
    and use a packer to help reduce the size, but these steps require attention. This
    can be a drawback, particularly for security practitioners who need to attach
    a binary to an email, host it on a shared filesystem, or transfer it over a network.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Verbosity** While Go is less verbose than languages like C#, Java, or even
    C/C++, you still might find that the simplistic language construct forces you
    to be overly expressive for things like lists (called *slices* in Go), processing,
    looping, or error handling. A Python one-liner might easily become a three-liner
    in Go.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Overview
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first chapter of this book covers a basic overview of Go’s syntax and philosophy.
    Next, we start to explore examples that you can leverage for tool development,
    including various common network protocols like HTTP, DNS, and SMB. We then dig
    into various tactics and problems that we’ve encountered as penetration testers,
    addressing topics including data pilfering, packet sniffing, and exploit development.
    Finally, we take a brief step back to talk about how you can create dynamic, pluggable
    tools before diving into crypto, attacking Microsoft Windows, and implementing
    steganography.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, there will be opportunities to extend the tools we show you to
    meet your specific objectives. Although we present robust examples throughout,
    our real intent is to provide you with the knowledge and foundation through which
    you can extend or rework the examples to meet your goals. We want to teach you
    to fish.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Before you continue with anything in this book, please note that we—the authors
    and publisher—have created this content for legal usage only. We won’t accept
    any liability for the nefarious or illegal things you choose to do. All the content
    here is for educational purposes only; do not perform any penetration-testing
    activities against systems or applications without authorized consent.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The sections that follow provide a brief overview of each chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1: Go Fundamentals](ch01.xhtml)'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The goal of this chapter is to introduce the fundamentals of the Go programming
    language and provide a foundation necessary for understanding the concepts within
    this book. This includes an abridged review of basic Go syntax and idioms. We
    discuss the Go ecosystem, including supporting tools, IDEs, dependency management,
    and more. Readers new to the programming language can expect to learn the bare
    necessities of Go, which will allow them to, hopefully, comprehend, implement,
    and extend the examples in later chapters.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2: TCP, Scanners, and Proxies](ch02.xhtml)'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This chapter introduces basic Go concepts and concurrency primitives and patterns,
    input/output (I/O), and the use of interfaces through practical TCP applications.
    We’ll first walk you through creating a simple TCP port scanner that scans a list
    of ports using parsed command line options. This will highlight the simplicity
    of Go code compared to other languages and will develop your understanding of
    basic types, user input, and error handling. Next, we’ll discuss how to improve
    the efficiency and speed of this port scanner by introducing concurrent functions.
    We’ll then introduce I/O by building a TCP proxy—a port forwarder—starting with
    basic examples and refining our code to create a more reliable solution. Lastly,
    we’ll re-create Netcat’s “gaping security hole” feature in Go, teaching you how
    to run operating system commands while manipulating stdin and stdout and redirecting
    them over TCP.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3: HTTP Clients and Remote Interaction with Tools](ch03.xhtml)'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HTTP clients are a critical component to interacting with modern web server
    architectures. This chapter shows you how to create the HTTP clients necessary
    to perform a variety of common web interactions. You’ll handle a variety of formats
    to interact with Shodan and Metasploit. We’ll also demonstrate how to work with
    search engines, using them to scrape and parse document metadata so as to extract
    information useful for organizational profiling activities.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4: HTTP Servers, Routing, and Middleware](ch04.xhtml)'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This chapter introduces the concepts and conventions necessary for creating
    an HTTP server. We’ll discuss common routing, middleware, and templating patterns,
    leveraging this knowledge to create a credential harvester and keylogger. Lastly,
    we’ll demonstrate how to multiplex command-and-control (C2) connections by building
    a reverse HTTP proxy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5: Exploiting DNS](ch05.xhtml)'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This chapter introduces you to basic DNS concepts using Go. First, we’ll perform
    client operations, including how to look for particular domain records. Then we’ll
    show you how to write a custom DNS server and DNS proxy, both of which are useful
    for C2 operations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6: Interacting with SMB and NTLM](ch06.xhtml)'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll explore the SMB and NTLM protocols, using them as a basis for a discussion
    of protocol implementations in Go. Using a partial implementation of the SMB protocol,
    we’ll discuss the marshaling and unmarshaling of data, the usage of custom field
    tags, and more. We’ll discuss and demonstrate how to use this implementation to
    retrieve the SMB-signing policy, as well as perform password-guessing attacks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7: Abusing Databases and Filesystems](ch07.xhtml)'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pillaging data is a critical aspect of adversarial testing. Data lives in numerous
    resources, including databases and filesystems. This chapter introduces basic
    ways to connect to and interact with databases across a variety of common SQL
    and NoSQL platforms. You’ll learn the basics of connecting to SQL databases and
    running queries. We’ll show you how to search databases and tables for sensitive
    information, a common technique used during post-exploitation. We’ll also show
    how to walk filesystems and inspect files for sensitive information.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8: Raw Packet Processing](ch08.xhtml)'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll show you how to sniff and process network packets by using the `gopacket`
    library, which uses `libpcap`. You’ll learn how to identify available network
    devices, use packet filters, and process those packets. We will then develop a
    port scanner that can scan reliably through various protection mechanisms, including
    syn-flood and syn-cookies, which cause normal port scans to show excessive false
    positives.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9: Writing and Porting Exploit Code](ch09.xhtml)'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This chapter focuses almost solely on creating exploits. It begins with creating
    a fuzzer to discover different types of vulnerabilities. The second half of the
    chapter discusses how to port existing exploits to Go from other languages. This
    discussion includes a port of a Java deserialization exploit and the Dirty COW
    privilege escalation exploit. We conclude the chapter with a discussion on creating
    and transforming shellcode for use within your Go programs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10: Go Plugins and Extendable Tools](ch10.xhtml)'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll introduce two separate methods for creating extendable tools. The first
    method, introduced in Go version 1.8, uses Go’s native plug-in mechanism. We’ll
    discuss the use cases for this approach and discuss a second approach that leverages
    Lua to create extensible tools. We’ll demonstrate practical examples showing how
    to adopt either approach to perform a common security task.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11: Implementing and Attacking Cryptography](ch11.xhtml)'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This chapter covers the fundamental concepts of symmetric and asymmetric cryptography
    using Go. This information focuses on using and understanding cryptography through
    the standard Go package. Go is one of the few languages that, instead of using
    a third-party library for encryption, uses a native implementation within the
    language. This makes the code easy to navigate, modify, and understand.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用 Go 实现的对称加密和非对称加密的基本概念。本文信息侧重于通过标准 Go 包使用和理解加密技术。Go 是少数几种不使用第三方加密库，而是采用语言内置加密实现的编程语言之一。这使得代码更易于浏览、修改和理解。
- en: We’ll explore the standard library by examining common use cases and creating
    tools. The chapter will show you how to perform hashing, message authentication,
    and encryption. Lastly, we’ll demonstrate how to brute-force decrypt an RC2-encrypted
    ciphertext.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过检查常见的使用案例和创建工具来探索标准库。本章将向你展示如何执行哈希、消息认证和加密操作。最后，我们将演示如何暴力破解 RC2 加密的密文。
- en: '[Chapter 12: Windows System Interaction and Analysis](ch12.xhtml)'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[第12章：Windows 系统交互与分析](ch12.xhtml)'
- en: In our discussion on attacking Windows, we’ll demonstrate methods of interacting
    with the Windows native API, explore the `syscall` package in order to perform
    process injection, and learn how to build a Portable Executable (PE) binary parser.
    The chapter will conclude with a discussion of calling native C libraries through
    Go’s C interoperability mechanisms.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论攻击 Windows 时，我们将演示如何与 Windows 原生 API 交互，探索 `syscall` 包以执行进程注入，并学习如何构建一个便携式可执行文件
    (PE) 解析器。本章最后将讨论如何通过 Go 的 C 语言互操作机制调用本地 C 库。
- en: '[Chapter 13: Hiding Data with Steganography](ch13.xhtml)'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[第13章：利用隐写术隐藏数据](ch13.xhtml)'
- en: '*Steganography* is the concealment of a message or file within another file.
    This chapter introduces one variation of steganography: hiding arbitrary data
    within a PNG image file’s contents. These techniques can be useful for exfiltrating
    information, creating obfuscated C2 messages, and bypassing detective or preventative
    controls.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐写术*是将信息或文件隐藏在另一个文件中的技术。本章介绍了一种隐写术变体：将任意数据隐藏在 PNG 图像文件的内容中。这些技术可以用于信息外泄、创建模糊的
    C2 消息，以及绕过侦测或预防性控制。'
- en: '[Chapter 14: Building a Command-and-Control RAT](ch14.xhtml)'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[第14章：构建命令与控制远控木马](ch14.xhtml)'
- en: The final chapter discusses practical implementations of command-and-control
    (C2) implants and servers in Go. We’ll leverage the wisdom and knowledge gained
    in previous chapters to build a C2 channel. The C2 client/server implementation
    will, by nature of being custom-made, avoid signature-based security controls
    and attempt to circumvent heuristics and network-based egress controls.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一章讨论了 Go 中命令与控制（C2）植入和服务器的实际实现。我们将利用之前章节中获得的智慧和知识来构建一个 C2 通道。由于 C2 客户端/服务器是定制化的，因此天然避免了基于签名的安全控制，并试图绕过启发式检测和基于网络的出口控制。
