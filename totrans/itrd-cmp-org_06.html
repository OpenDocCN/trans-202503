<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_107"/><strong><span class="big">6</span><br/>COMBINATIONAL LOGIC CIRCUITS</strong></h2>&#13;
<div class="image1"><img src="../images/pg23_Image_2.jpg" alt="Image" width="191" height="190"/></div>&#13;
<p class="noindentz">In the previous chapter, you learned about a computer’s basic component, the logic gate. Computers are constructed from assemblages of logic gates, called <em>logic circuits</em>, that process digital information.</p>&#13;
<p class="indent">In this and the following two chapters, we’ll look at how to build some of the logic circuits that make up CPUs, memory, and other devices. I won’t describe any of these units in their entirety; instead, we’ll look at a few small parts and discuss the concepts behind them. The goal is to provide an introductory overview of the ideas that underlie these logic circuits.</p>&#13;
<h3 class="h3" id="ch06lev1sec1"><strong>The Two Types of Logic Circuits</strong></h3>&#13;
<p class="noindent">There are two types of logic circuits. A <em>combinational logic circuit</em> has output that depends only on the inputs given at any specific time and not on any previous inputs. A <em>sequential logic circuit</em> has output that depends on both previous and current inputs.</p>&#13;
<p class="indent">To elucidate these two types, let’s consider a TV remote. You can select a specific channel by entering a number on the remote. The channel selection depends only on the number you entered and ignores the channels you were viewing before. Thus, the relationship between the input and the output is combinational.</p>&#13;
<span epub:type="pagebreak" id="page_108"/>&#13;
<p class="indent">The remote control also has an input for going up or down one channel. This input depends on the previously selected channel and the previous sequence of up/down button pushes. The channel up/down buttons illustrate a sequential input/output relationship.</p>&#13;
<p class="indent">We’ll explore sequential logic circuits in the next chapter. In this chapter, we’ll go through several examples of combinational logic circuits to see how they function.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>SIGNAL VOLTAGE LEVELS</strong></p>&#13;
<p class="noindenta">Electronic logic circuits represent <span class="literal">1</span>s and <span class="literal">0</span>s with either a high voltage or a low voltage. We call the voltage that represents <span class="literal">1</span> the <em>active voltage</em>. If we use a higher voltage to represent <span class="literal">1</span>, then the signal is called <em>active high</em>. If we use a lower voltage to represent <span class="literal">1</span>, then the signal is called <em>active low</em>.</p>&#13;
<p class="noindenta">An active-high signal can be connected to an active-low input, but the hardware designer must take the difference into account. For example, if the required logical input to an active-low input is <span class="literal">1</span>, the required voltage is the lower of the two voltages; if the signal to be connected to this input is active high, then a logical <span class="literal">1</span> is the higher of the two voltages, and the signal must first be complemented to be interpreted as a <span class="literal">1</span> at the active-low input.</p>&#13;
<p class="noindenta">I will use only logic levels—<span class="literal">0</span> and <span class="literal">1</span>—in the discussions of logic circuits in this book and avoid the actual voltage levels being used in the hardware, but you should know the terminology because it can come up when talking to others or reading component specification sheets.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec2"><strong>Adders</strong></h3>&#13;
<p class="noindent">We’ll start with one of the most fundamental operations performed in the CPU: adding two bits. Our eventual goal is to add two <em>n</em>-bit numbers.</p>&#13;
<p class="indent">Recall from <a href="ch02.xhtml">Chapter 2</a> that the bits in a binary number are numbered from right (the least significant bit) to left (the most significant bit), starting with 0. I’ll start by showing you how to add two bits in the <em>i</em>th bit position and complete the discussion by showing you how to add two 4-bit numbers, taking into account the carry from each bit position.</p>&#13;
<h4 class="h4" id="ch06lev2sec1"><em><strong>Half Adder</strong></em></h4>&#13;
<p class="noindent">Addition can be done with several kinds of circuits. We’ll start with the <em>half adder</em>, which simply adds the two bits in the current bit position of a number (expressed in binary). This is shown by the truth table in <a href="ch06.xhtml#ch6tab1">Table 6-1</a>, where <em>x<sub>i</sub></em> is the <em>i</em>th bit of the number <em>x</em> and the values in the <em>y<sub>i</sub></em> column represent the <em>i</em>th bit of the number <em>y</em>. <em>Sum<sub>i</sub></em> is the <em>i</em>th bit of the number <em>Sum</em>, and <em>Carry<sub>i</sub></em> <sub>+ 1</sub> is the carry from adding bits <em>x<sub>i</sub></em> and <em>y<sub>i</sub></em>.</p>&#13;
<span epub:type="pagebreak" id="page_109"/>&#13;
<p class="tabcap" id="ch6tab1"><strong>Table 6-1:</strong> A Truth Table for Adding Two Bits Using a Half Adder</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong><em>x</em></strong><em><strong><sub>i</sub></strong></em></th>&#13;
<th class="tab_th"><strong><em>y</em></strong><em><strong><sub>i</sub></strong></em></th>&#13;
<th class="tab_th"><strong><em>Carry</em></strong><strong><sub><em>i</em> + 1</sub></strong></th>&#13;
<th class="tab_th"><em><strong>Sum</strong></em><sub><em><strong>i</strong></em></sub></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The sum is the XOR of the two inputs, and the carry is the AND of the two inputs. <a href="ch06.xhtml#ch6fig1">Figure 6-1</a> shows the logic circuit for a half adder.</p>&#13;
<div class="image"><img id="ch6fig1" src="../images/pg137_Image_174.jpg" alt="Image" width="203" height="100"/></div>&#13;
<p class="figcap"><em>Figure 6-1: A half adder logic circuit</em></p>&#13;
<p class="indent">But there’s a flaw here: the half adder works with only two input bits. It can be used to add the two bits from the same bit position of two numbers, but it doesn’t take into account a possible carry from the next lower-order bit position. Including this carry as a third input will give us a full adder.</p>&#13;
<h4 class="h4" id="ch06lev2sec2"><em><strong>Full Adder</strong></em></h4>&#13;
<p class="noindent">Unlike the half adder, a <em>full adder</em> circuit has three 1-bit inputs: <em>Carry<sub>i</sub></em>, <em>x<sub>i</sub></em>, and <em>y<sub>i</sub></em>. <em>Carry<sub>i</sub></em> is the carry that resulted when you added the two bits in the previous bit position (the bit to the right). For example, if we’re adding the two bits in bit position 5, the inputs to the full adder are the two bits in position 5 plus the carry from adding the bits in position 4. <a href="ch06.xhtml#ch6tab2">Table 6-2</a> shows the results.</p>&#13;
<p class="tabcap" id="ch6tab2"><strong>Table 6-2:</strong> A Truth Table for Adding Two Bits Using a Full Adder</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:10%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><em><strong>Carry</strong><strong><sub>i</sub></strong></em></th>&#13;
<th class="tab_th"><strong><em>x</em></strong><em><strong><sub>i</sub></strong></em></th>&#13;
<th class="tab_th"><em><strong>y</strong><strong><sub>i</sub></strong></em></th>&#13;
<th class="tab_th"><strong><em>Carry</em></strong><sub><em><strong>i</strong></em> + 1</sub></th>&#13;
<th class="tab_th"><em><strong>Sum</strong></em><sub><em><strong>i</strong></em></sub></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<span epub:type="pagebreak" id="page_110"/>&#13;
<p class="indent">To design a full adder circuit, we start with the function that specifies when <em>Sum<sub>i</sub></em> is <span class="literal">1</span> as a sum of product terms from <a href="ch06.xhtml#ch6tab2">Table 6-2</a>:</p>&#13;
<div class="image1"><img src="../images/pg138_Image_175.jpg" alt="Image" width="652" height="52"/></div>&#13;
<p class="indent">There are no obvious simplifications in this equation, so let’s look at the Karnaugh map for <em>Sum<sub>i</sub></em>, shown in <a href="ch06.xhtml#ch6fig2">Figure 6-2</a>.</p>&#13;
<div class="image"><img id="ch6fig2" src="../images/pg138_Image_176.jpg" alt="Image" width="288" height="116"/></div>&#13;
<p class="figcap"><em>Figure 6-2: A Karnaugh map for the sum of three bits,</em> Carry<sub>i</sub>, x<sub>i</sub><em>, and</em> y<sub>i</sub></p>&#13;
<p class="indent">There are no obvious groupings in <a href="ch06.xhtml#ch6fig2">Figure 6-2</a>, so we are left with the four product terms to compute <em>Sum<sub>i</sub></em> in the previous equation.</p>&#13;
<p class="indent">You learned in <a href="ch04.xhtml">Chapter 4</a> that <em>Carry<sub>i</sub></em> <sub>+ 1</sub>(<em>Carry<sub>i</sub></em>, <em>x<sub>i</sub></em>, <em>y<sub>i</sub></em>) can be expressed by the equation:</p>&#13;
<div class="image1"><img src="../images/pg138_Image_177.jpg" alt="Image" width="540" height="21"/></div>&#13;
<p class="indent">Together, these two functions give the circuit for a full adder, as shown in <a href="ch06.xhtml#ch6fig3">Figure 6-3</a>.</p>&#13;
<div class="image"><img id="ch6fig3" src="../images/pg138_Image_178.jpg" alt="Image" width="501" height="411"/></div>&#13;
<p class="figcap"><em>Figure 6-3: A full adder circuit</em></p>&#13;
<p class="indent">The full adder uses nine logic gates. In the next section, we’ll see if we can find a simpler circuit.</p>&#13;
<span epub:type="pagebreak" id="page_111"/><h4 class="h4" id="ch06lev2sec3"><em><strong>Full Adder from Two Half Adders</strong></em></h4>&#13;
<p class="noindent">To see if we can find a simpler solution for adding two bits and the carry from the next lower-order bit position, let’s go back to the equation for <em>Sum<sub>i</sub></em>. Using the distribution rule, we can rearrange it as follows:</p>&#13;
<div class="image1"><img src="../images/pg139_Image_179.jpg" alt="Image" width="655" height="66"/></div>&#13;
<p class="indent">In <a href="ch04.xhtml">Chapter 4</a>, you learned that the quantity in the parentheses in the first product term is the XOR of <em>x<sub>i</sub></em> and <em>y<sub>i</sub></em>:</p>&#13;
<div class="image1"><img src="../images/pg139_Image_180.jpg" alt="Image" width="256" height="21"/></div>&#13;
<p class="noindent">Thus, we have:</p>&#13;
<div class="image1"><img src="../images/pg139_Image_181.jpg" alt="Image" width="658" height="26"/></div>&#13;
<p class="indent">Let’s manipulate the quantity in the parentheses in the second product term. Recall that in Boolean algebra <em>x ∧ ¬x</em> = 0, so we can write the following:</p>&#13;
<div class="image1"><img src="../images/pg139_Image_182.jpg" alt="Image" width="596" height="114"/></div>&#13;
<p class="noindent">Thus:</p>&#13;
<div class="image1"><img src="../images/pg139_Image_183.jpg" alt="Image" width="559" height="82"/></div>&#13;
<p class="indent">We’ll do something to develop a Boolean function for <em>Carry<sub>i</sub></em> <sub>+ 1</sub> that will probably seem counterintuitive. Let’s start with the Karnaugh map for carry when adding three bits (see <a href="ch04.xhtml#ch4fig14">Figure 4-14</a>), but remove two of the groupings, as shown by the dotted lines in <a href="ch06.xhtml#ch6fig4">Figure 6-4</a>.</p>&#13;
<div class="image"><img id="ch6fig4" src="../images/pg139_Image_184.jpg" alt="Image" width="351" height="141"/></div>&#13;
<p class="figcap"><em>Figure 6-4: The Karnaugh map for carry from <a href="ch04.xhtml#ch4fig14">Figure 4-14</a>, redrawn without two overlapping groupings (dotted lines)</em></p>&#13;
<p class="indent">This will give us the following equation:</p>&#13;
<div class="image1"><img src="../images/pg139_Image_185.jpg" alt="Image" width="643" height="83"/></div>&#13;
<span epub:type="pagebreak" id="page_112"/>&#13;
<p class="indent">Notice that two of the terms in this equation, (<em>x<sub>i</sub> ∧ y<sub>i</sub></em>) and (<em>x<sub>i</sub></em> ⊻ <em>y<sub>i</sub></em>), are already generated by a half adder (see <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>). With a second half adder and an OR gate, we can implement a full adder, as shown in <a href="ch06.xhtml#ch6fig5">Figure 6-5</a>.</p>&#13;
<div class="image"><img id="ch6fig5" src="../images/pg140_Image_186.jpg" alt="Image" width="488" height="167"/></div>&#13;
<p class="figcap"><em>Figure 6-5: A full adder using two half adders</em></p>&#13;
<p class="indent">Now you should understand where the terms <em>half adder</em> and <em>full adder</em> come from.</p>&#13;
<p class="indent">A simpler circuit is not always better. In truth, we cannot say which of the two full adder circuits in <a href="ch06.xhtml#ch6fig3">Figures 6-3</a> and <a href="ch06.xhtml#ch6fig6">6-5</a> is better just by looking at the logic circuits. Good engineering design depends on many factors, such as how each logic gate is implemented, the cost of the logic gates and their availability, and so forth. I’ve presented two alternatives here to show that different approaches can lead to different, but functionally equivalent, designs.</p>&#13;
<h4 class="h4" id="ch06lev2sec4"><em><strong>Ripple-Carry Addition and Subtraction Circuits</strong></em></h4>&#13;
<p class="noindent">Now you know how to add the two bits in a given bit position, plus a carry from the next lower-order bit position. But most values that a program works with have many bits, so we need a way to add the corresponding bits in each bit position of two <em>n</em>-bit numbers. This can be done with an <em>n-bit adder</em>, which can be implemented with <em>n</em> full adders. <a href="ch06.xhtml#ch6fig6">Figure 6-6</a> shows a 4-bit adder.</p>&#13;
<div class="image"><img id="ch6fig6" src="../images/pg140_Image_187.jpg" alt="Image" width="684" height="292"/></div>&#13;
<p class="figcap"><em>Figure 6-6: A 4-bit adder</em></p>&#13;
<p class="indent">Addition begins with the full adder on the right receiving the two lowest-order bits, <em>x</em><sub>0</sub> and <em>y</em><sub>0</sub>. Since this is the lowest-order bit, there is no carry, and <em>c</em><sub>0</sub> = <span class="literal">0</span>. The bit sum is <em>s</em><sub>0</sub>, and the carry from this addition, <em>c</em><sub>1</sub>, is connected to <span epub:type="pagebreak" id="page_113"/>the carry input of the next full adder to the left, where it is added to <em>x</em><sub>1</sub> and <em>y</em><sub>1</sub>. Thus, the <em>i</em>th full adder adds the two <em>i</em>th bits of the operands, plus the carry (which is either <span class="literal">0</span> or <span class="literal">1</span>) from the (<em>i</em> – 1)th full adder.</p>&#13;
<p class="indent">Each full adder handles one bit (often referred to as a <em>slice</em>) of the total width of the values being added. The carry from each bit position is added to the bits in the next higher-order bit position. The addition process flows from the lowest-order bit to the highest-order in a sort of rippling effect, which gives this method of adding the name <em>ripple-carry addition</em>.</p>&#13;
<p class="indent">Notice that in <a href="ch06.xhtml#ch6fig6">Figure 6-6</a>, we have <span class="literal">C</span> and <span class="literal">V</span>, the <em>carry flag</em> and <em>overflow flag</em>. You learned about carry and overflow in <a href="ch03.xhtml">Chapter 3</a>. The AArch64 architecture includes addition and subtraction instructions that record whether carry and overflow occurred in the CPU. You’ll learn more about this in <a href="ch09.xhtml">Chapter 9</a>.</p>&#13;
<p class="indent">Let’s see how we can use a similar idea to implement subtraction. Recall that in two’s complement, a number is negated by taking its two’s complement, flipping all the bits, and adding <span class="literal">1</span>. Thus, we can subtract <em>y</em> from <em>x</em> by doing this:</p>&#13;
<div class="image1"><img src="../images/pg141_Image_188.jpg" alt="Image" width="279" height="52"/></div>&#13;
<p class="indent">We can perform subtraction with our adder in <a href="ch06.xhtml#ch6fig5">Figure 6-5</a> if we complement each <em>y<sub>i</sub></em> and set the initial carry in to <span class="literal">1</span> instead of <span class="literal">0</span>. Each <em>y<sub>i</sub></em> can be complemented by XOR-ing it with <span class="literal">1</span>. This leads to the 4-bit circuit in <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>, which will add two 4-bit numbers when <em>func</em> = <span class="literal">0</span> and subtract them when <em>func</em> = <span class="literal">1</span>.</p>&#13;
<div class="image"><img id="ch6fig7" src="../images/pg141_Image_189.jpg" alt="Image" width="723" height="462"/></div>&#13;
<p class="figcap"><em>Figure 6-7: A 4-bit adder/subtractor</em></p>&#13;
<span epub:type="pagebreak" id="page_114"/>&#13;
<p class="indent">There is, of course, a time delay as the sum is computed from right to left. The computation time can be significantly reduced through circuit designs that make use of what can be known about the values of the intermediate carries, <em>c<sub>i</sub></em>, but I won’t go into such details in this book. Let’s turn to our next type of circuit.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch6exe1">6.1     In <a href="ch03.xhtml">Chapter 3</a>, you learned about the carry flag (<span class="literal">C</span>) and the overflow flag (<span class="literal">V</span>). The CPU also has a zero flag (<span class="literal">Z</span>) and a negative flag (<span class="literal">N</span>). The <span class="literal">Z</span> flag is <span class="literal">1</span> when the result of an arithmetic operation is zero, and the <span class="literal">N</span> flag is <span class="literal">1</span> when the result is a negative number if the number is considered to be in two’s complement notation. Design a circuit that uses the outputs of the full adders in <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>, <em>s</em><sub>0</sub>, <em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, <em>s</em><sub>3</sub>, <em>c</em><sub>3</sub>, and <em>c</em><sub>4</sub>, and outputs the <span class="literal">C</span>, <span class="literal">V</span>, <span class="literal">N</span>, and <span class="literal">Z</span> flags.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec3"><strong>Decoders</strong></h3>&#13;
<p class="noindent">Many places in a computer require selecting one of several connections based on a number. For example, as you will see in <a href="ch08.xhtml">Chapter 8</a>, the CPU has a small amount of memory organized in <em>registers</em>, which are used for computations. The AArch64 architecture provides 31 general-purpose 64-bit registers. If an instruction uses one of the registers, 5 bits in the instruction must be used to select which of the 31 registers should be used.</p>&#13;
<p class="indent">This selection can be done with a <em>decoder</em>. The input to the decoder is the 4-bit number of the register, and the output is one of 16 possible connections to the specified register.</p>&#13;
<p class="indent">A decoder has <em>n</em> binary inputs that can produce up to 2<em><sup>n</sup></em> binary outputs. The most common type of decoder, sometimes called a <em>line decoder</em>, selects only one of the output lines to set to <span class="literal">1</span> for each input bit pattern. It’s also common for a decoder to include an <em>Enable</em> input. <a href="ch06.xhtml#ch6tab3">Table 6-3</a> is a truth table for a 3×8 (three inputs, eight outputs) decoder with an <em>Enable</em> input that shows how this works.</p>&#13;
<p class="tabcap" id="ch6tab3"><strong>Table 6-3:</strong> A Truth Table for a 3×8 Decoder with <em>Enable</em></p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:12%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"/>&#13;
<th class="tab_th" colspan="3"><strong>Input</strong></th>&#13;
<th class="tab_th" colspan="8"><strong>Output</strong></th>&#13;
</tr>&#13;
<tr>&#13;
<th class="tab_th"><strong><em>Enable</em></strong></th>&#13;
<th class="tab_th"><strong><em>x</em></strong><sub>2</sub></th>&#13;
<th class="tab_th"><em><strong>x</strong></em><sub>1</sub></th>&#13;
<th class="tab_th"><em><strong>x</strong></em><sub>0</sub></th>&#13;
<th class="tab_th"><em><strong>y</strong></em><sub>7</sub></th>&#13;
<th class="tab_th"><em><strong>y</strong></em><sub>6</sub></th>&#13;
<th class="tab_th"><em><strong>y</strong></em><sub>5</sub></th>&#13;
<th class="tab_th"><em><strong>y</strong></em><sub>4</sub></th>&#13;
<th class="tab_th"><em><strong>y</strong></em><sub>3</sub></th>&#13;
<th class="tab_th"><em><strong>y</strong></em><sub>2</sub></th>&#13;
<th class="tab_th"><em><strong>y</strong></em><sub>1</sub></th>&#13;
<th class="tab_th"><em><strong>y</strong></em><sub>0</sub></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span><span epub:type="pagebreak" id="page_115"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">When <em>Enable</em> = <span class="literal">0</span>, all the output lines are <span class="literal">0</span>. When <em>Enable</em> = <span class="literal">1</span>, the 3-bit number at the input, <em>x</em> = <em>x</em><sub>2</sub><em>x</em><sub>1</sub><em>x</em><sub>0</sub>, selects which output line is set to <span class="literal">1</span>. So, this decoder could be used to select one of eight registers with a 3-bit number. (I’m not using all of the 31 registers in the AArch64 architecture to keep the table a reasonable size here.)</p>&#13;
<p class="indent">The 3×8 line decoder specified in <a href="ch06.xhtml#ch6tab3">Table 6-3</a> can be implemented with four-input AND gates, as shown in <a href="ch06.xhtml#ch6fig8">Figure 6-8</a>.</p>&#13;
<div class="image"><img id="ch6fig8" src="../images/pg143_Image_190.jpg" alt="Image" width="452" height="588"/></div>&#13;
<p class="figcap"><em>Figure 6-8: The circuit for a 3×8 decoder with</em> Enable</p>&#13;
<span epub:type="pagebreak" id="page_116"/>&#13;
<p class="indent">Decoders are more versatile than they might seem at first glance. Each possible input can be seen as a minterm (for a refresher on minterms, see “Canonical Sum or Sum of Minterms” on <a href="ch04.xhtml#ch04lev2sec3">page 62</a> in <a href="ch04.xhtml">Chapter 4</a>). The line decoder in <a href="ch06.xhtml#ch6tab3">Table 6-3</a> shows that only a single output is <span class="literal">1</span> when a minterm evaluates to <span class="literal">1</span> and <em>Enable</em> is <span class="literal">1</span>. Thus, a decoder can be viewed as a “minterm generator.”</p>&#13;
<p class="indent">We know from <a href="ch04.xhtml">Chapter 4</a> that any logical expression can be represented as the OR of minterms, so it follows that we can implement any logical expression by OR-ing the output(s) of a decoder. For example, if you look back at the Karnaugh maps for the full adder (<a href="ch06.xhtml#ch6fig2">Figures 6-2</a> and <a href="ch06.xhtml#ch6fig4">6-4</a>), you might see that <em>Sum<sub>i</sub></em>(<em>Carry<sub>i</sub></em>, <em>x<sub>i</sub></em>, <em>y<sub>i</sub></em>) and <em>Carry</em><sub><em>i</em> + 1</sub>(<em>Carry<sub>i</sub></em>, <em>x<sub>i</sub></em>, <em>y<sub>i</sub></em>) can be expressed as the OR of minterms,</p>&#13;
<div class="image1"><img src="../images/pg144_Image_191.jpg" alt="Image" width="478" height="58"/></div>&#13;
<p class="noindent">where the subscript <em>i</em> on <em>x</em>, <em>y</em>, and <em>Carry</em> refers to the bit slice and the subscripts on <em>m</em> are part of the minterm notation.</p>&#13;
<p class="indent">We can implement each bit slice of a full adder with a 3×8 decoder and two four-input OR gates, as shown in <a href="ch06.xhtml#ch6fig9">Figure 6-9</a>. An <em>n</em>-bit adder would require <em>n</em> of these circuits.</p>&#13;
<div class="image"><img id="ch6fig9" src="../images/pg144_Image_192.jpg" alt="Image" width="426" height="238"/></div>&#13;
<p class="figcap"><em>Figure 6-9: A 1-bit slice of a full adder implemented with a 3×8 decoder</em></p>&#13;
<p class="indent">The decoder circuit in <a href="ch06.xhtml#ch6fig8">Figure 6-8</a> requires eight AND gates and three NOT gates. The full adder in <a href="ch06.xhtml#ch6fig9">Figure 6-9</a> adds two OR gates, for a total of 13 logic gates. Comparing this with the full adder design in <a href="ch06.xhtml#ch6fig5">Figure 6-5</a>, which requires only five logic gates (two XOR, two AND, and one OR), it would seem that using a decoder to construct a full adder increases the complexity of the circuit. Keep in mind, however, that designs must take into account other factors, such as availability of components, cost of components, and so forth.</p>&#13;
<span epub:type="pagebreak" id="page_117"/>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch6exe2">6.2     You have probably seen seven-segment displays, which are used to display numerals. Each segment in a seven-segment display is lit by applying a <span class="literal">1</span> to the input pin connected to that segment. Suppose you have a seven-segment display with an 8-bit input that lights the segments and the decimal point, as shown in the following figure:</p>&#13;
<div class="box-parai"><img src="../images/pg145_Image_193.jpg" alt="Image" width="528" height="384"/></div>&#13;
<p class="box-parai">For example, you could display a 5 with the bit pattern <span class="literal">0110 1101</span>. However, it would be more convenient to write a program to use BCD for individual numerals. Design a decoder that transforms numerals in BCD to segment patterns on the seven-segment display.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec4"><strong>Multiplexers</strong></h3>&#13;
<p class="noindent">In the previous section, you learned how an <em>n</em>-bit number can be used to select which one of 2<em><sup>n</sup></em> output lines should be set to <span class="literal">1</span>. The opposite situation also occurs, where we need to select which of several inputs should be passed on. For example, when performing arithmetic operations, such as addition, the numbers can come from different locations within the CPU. (You will learn more about this in the next few chapters.) The operation itself will be performed by one arithmetic unit, and the CPU needs to select the inputs to the operation from all the possible locations.</p>&#13;
<p class="indent">A device that can make this selection is called a <em>multiplexer (MUX)</em>. It can switch between 2<em><sup>n</sup></em> input lines by using <em>n</em> selection lines. <a href="ch06.xhtml#ch6fig10">Figure 6-10</a> shows a circuit for a four-way multiplexer.</p>&#13;
<span epub:type="pagebreak" id="page_118"/>&#13;
<div class="image"><img id="ch6fig10" src="../images/pg146_Image_194.jpg" alt="Image" width="552" height="373"/></div>&#13;
<p class="figcap"><em>Figure 6-10: A four-way multiplexer circuit</em></p>&#13;
<p class="indent">The output is given by:</p>&#13;
<div class="image1"><img src="../images/pg146_Image_195.jpg" alt="Image" width="619" height="21"/></div>&#13;
<p class="indent">When using AND and OR gates, the number of transistors required to implement a multiplexer gets large as the number of inputs grows. A three-input AND gate is required for each input to the multiplexer, with the output of each AND gate connected to one of the inputs to the OR gate. So, the number of inputs to the OR gate equals the number of multiplexer inputs.</p>&#13;
<p class="indent">This four-way multiplexer requires a four-input OR gate. If we try to scale this up, the <em>n</em>-input OR gate will present some technical electronic problems for a large <em>n</em>. The use of an <em>n</em>-input OR gate can be avoided by using a type of gate that can disconnect its output signal from its input, which we’ll look at next.</p>&#13;
<h3 class="h3" id="ch06lev1sec5"><strong>Tristate Buffer</strong></h3>&#13;
<p class="noindent">The logic gate called a <em>tristate buffer</em> has three possible outputs: <span class="literal">0</span>, <span class="literal">1</span>, and “no connection.” The “no connection” output is actually a high-impedance connection, also called <em>high Z</em> or <em>open</em>. A tristate buffer has both a data input and an <em>Enable</em> input, which behaves as shown in <a href="ch06.xhtml#ch6fig11">Figure 6-11</a>.</p>&#13;
<div class="image"><img id="ch6fig11" src="../images/pg146_Image_196.jpg" alt="Image" width="403" height="145"/></div>&#13;
<p class="figcap"><em>Figure 6-11: A tristate buffer</em></p>&#13;
<p class="indent">When <em>Enable</em> = <span class="literal">1</span>, the output, which is equal to the input, is connected to whatever circuit element follows the tristate buffer. But when <em>Enable</em> = <span class="literal">0</span>, <span epub:type="pagebreak" id="page_119"/>the output is essentially disconnected. This is different from <span class="literal">0</span>; being disconnected means it has no effect on the circuit element to which it is connected.</p>&#13;
<p class="indent">The “no connection” output lets us physically connect the outputs of many tristate buffers but select only one to pass its input to the common output line. The four-way multiplexer in <a href="ch06.xhtml#ch6fig12">Figure 6-12</a> shows how we avoid using an <em>n</em>-input OR gate by using <em>n</em> tristate buffers.</p>&#13;
<div class="image"><img id="ch6fig12" src="../images/pg147_Image_197.jpg" alt="Image" width="306" height="265"/></div>&#13;
<p class="figcap"><em>Figure 6-12: A four-way multiplexer built from a decoder and tristate buffers</em></p>&#13;
<p class="indent">The 2×4 decoder in <a href="ch06.xhtml#ch6fig12">Figure 6-12</a> selects which of the tristate buffers connects one of the inputs, <em>w</em>, <em>x</em>, <em>y</em>, or <em>z</em>, to the output to create a four-way multiplexer. <a href="ch06.xhtml#ch6fig13">Figure 6-13</a> shows the circuit symbol used for a multiplexer, along with the truth table that shows its behavior.</p>&#13;
<div class="image"><img id="ch6fig13" src="../images/pg147_Image_198.jpg" alt="Image" width="454" height="179"/></div>&#13;
<p class="figcap"><em>Figure 6-13: A four-way multiplexer</em></p>&#13;
<p class="indent">As an example of where we might use a four-way multiplexer like this one, consider a computer with four registers and one adder. Let’s name the registers <em>w</em>, <em>x</em>, <em>y</em>, and <em>z</em>. If we connect the bits in the corresponding bit position from each register to a multiplexer, then we can use the 2-bit selector <em>s</em><sub>1</sub><em>s</em><sub>0</sub> to choose which register will provide the input to the adder. For example, each bit in position 5, <em>w</em><sub>5</sub>, <em>x</em><sub>5</sub>, <em>y</em><sub>5</sub>, and <em>z</em><sub>5</sub>, would be connected to one of the inputs in multiplexer 5. If <em>s</em><sub>1</sub><em>s</em><sub>0</sub> = <span class="literal">10</span>, the input to the adder would be <em>y</em><sub>5</sub>.</p>&#13;
<h3 class="h3" id="ch06lev1sec6"><strong>Programmable Logic Devices</strong></h3>&#13;
<p class="noindent">So far, we’ve been discussing hardware designs that use individual logic gates. If the design changes, the logic gate configuration changes. This almost always means that the circuit board that holds the logic gates and <span epub:type="pagebreak" id="page_120"/>connects them will need to be redesigned. A change also often means ordering a different kind of logic gate, which can be expensive and take time. These problems can be reduced by using <em>programmable logic devices (PLDs)</em> to implement the required logic function.</p>&#13;
<p class="indent">PLDs contain many AND gates and OR gates, which can be programmed to implement Boolean functions. The inputs, and their complemented value, are connected to the AND gates. The AND gates, taken together, are referred to as the <em>AND plane</em> or <em>AND array</em>. The outputs from the AND gates are connected to OR gates, which taken together are referred to as the <em>OR plane</em> or <em>OR array</em>. Depending on the type, one or both planes can be programmed to implement combinational logic. When using a PLD, a design change requires changing only how the device is programmed, not buying different devices, meaning the circuit board does not need to be redesigned.</p>&#13;
<p class="indent">PLDs come in several types. Most can be programmed by a user. Some are preprogrammed at the time of manufacture, and some can even be erased and reprogrammed by the user. Programming technologies range from specifying the manufacturing mask (for the preprogrammed devices) to inexpensive electronic programming systems. We’ll look at the three main categories of PLDs in this section.</p>&#13;
<h4 class="h4" id="ch06lev2sec5"><em><strong>Programmable Logic Array</strong></em></h4>&#13;
<p class="noindent">In a <em>programmable logic array (PLA)</em>, both the AND and OR planes are programmable. PLAs are used to implement logic functions. <a href="ch06.xhtml#ch6fig14">Figure 6-14</a> gives the general idea for a PLA that has two input variables and two possible output functions of these variables.</p>&#13;
<div class="image"><img id="ch6fig14" src="../images/pg148_Image_199.jpg" alt="Image" width="569" height="486"/></div>&#13;
<p class="figcap"><em>Figure 6-14: A simplified circuit for a programmable logic array</em></p>&#13;
<span epub:type="pagebreak" id="page_121"/>&#13;
<p class="indent">Each input variable, in both its uncomplemented and complemented form, is an input to the AND gates through fuses. A <em>fuse</em> is a thin piece of conductor used to protect an electrical circuit. If the current flowing through it is high enough, the conductor melts, opening the circuit and stopping current flow. PLDs can be programmed by breaking (or <em>blowing</em>) the appropriate fuses, removing the input to the logic gate. Some devices use <em>antifuses</em> instead of fuses; these are normally open, and programming them consists of completing the connection instead of removing it. Devices that can be reprogrammed have fuses that can be broken and then remade.</p>&#13;
<p class="indent">In <a href="ch06.xhtml#ch6fig14">Figure 6-14</a>, the S-shaped lines in the circuit diagram represent the fuses. The fuses can be blown or left in place so as to program each AND gate to output a product of the inputs, <em>x</em>,¬<em>x</em>, <em>y</em>, and ¬<em>y</em>. Since every input, plus its complement, is input to each AND gate, any of the AND gates can be programmed to output a minterm.</p>&#13;
<p class="indent">The products produced by the AND gate plane are all connected to the inputs of the OR gates, also through fuses. Thus, depending on which OR gate fuses are left in place, the output of each OR gate is a sum of products. There may be additional logic circuitry to select between the different outputs. You have already seen that any Boolean function can be expressed as a sum of products, so this logic device can be programmed to implement any Boolean function by blowing the fuses.</p>&#13;
<p class="indent">A PLA is typically larger than the one shown in <a href="ch06.xhtml#ch6fig14">Figure 6-14</a>, which is already complicated to draw. To simplify the drawing, it is typical to use a diagram similar to <a href="ch06.xhtml#ch6fig15">Figure 6-15</a> to specify the design.</p>&#13;
<div class="image"><img id="ch6fig15" src="../images/pg149_Image_200.jpg" alt="Image" width="579" height="472"/></div>&#13;
<p class="figcap"><em>Figure 6-15: A diagram for a programmable logic array where the dots represent connections</em></p>&#13;
<span epub:type="pagebreak" id="page_122"/>&#13;
<p class="indent">This diagram can be a little tricky to understand. In <a href="ch06.xhtml#ch6fig14">Figure 6-14</a>, each AND gate has multiple inputs: one for each variable and one for its complement. In <a href="ch06.xhtml#ch6fig15">Figure 6-15</a>, we use a single horizontal line leading to the input of each AND gate to represent multiple wires (variable and complement), so each AND gate in <a href="ch06.xhtml#ch6fig15">Figure 6-15</a> has eight inputs, even though we draw only one line.</p>&#13;
<p class="indent">The dots at the intersections of the vertical and horizontal lines represent places where the fuses have been left intact, thus creating a connection. For example, the three dots on the topmost horizontal line indicate that there are three inputs left connected to that AND gate. The output of the topmost AND gate is:</p>&#13;
<div class="image1"><img src="../images/pg150_Image_201.jpg" alt="Image" width="89" height="19"/></div>&#13;
<p class="indent">Referring again to <a href="ch06.xhtml#ch6fig14">Figure 6-14</a>, you can see that the output from each AND gate is connected to each of the OR gates (through fuses). Therefore, the OR gates also have multiple inputs—one for each AND gate—and the vertical lines leading to the OR gate inputs represent multiple wires. The PLA in <a href="ch06.xhtml#ch6fig15">Figure 6-15</a> has been programmed to provide these three functions:</p>&#13;
<div class="image1"><img src="../images/pg150_Image_202.jpg" alt="Image" width="355" height="83"/></div>&#13;
<p class="indent">Since the AND plane can produce all possible minterms and the OR plane can provide any sum of the minterms, a PLA can be used to implement any possible logical function. If we want to change the function, it’s a simple matter of programming another PLA and replacing the old one.</p>&#13;
<h4 class="h4" id="ch06lev2sec6"><em><strong>Read-Only Memory</strong></em></h4>&#13;
<p class="noindent">Although PLDs have no memory (meaning the current state isn’t affected by previous states of the inputs), they can be used to make <em>nonvolatile</em> memory—memory whose contents remain intact when the power is turned off. <em>Read-only memory (ROM)</em> is used to store bit patterns that can represent data or program instructions. A program can only read the data or program stored in ROM; the contents of the ROM cannot be changed by writing new data or program instructions to it. ROM is commonly used in devices that have a fixed set of functionalities, such as watches, automobile engine control units, and appliances. In fact, our lives are surrounded by devices that are controlled by programs stored in ROM.</p>&#13;
<p class="indent">ROM can be implemented as a PLD where only the OR gate plane can be programmed. The AND gate plane remains wired to provide all the min-terms. We can think of the inputs to the ROM as addresses; then, the OR gate plane is programmed to provide the bit pattern at each address. For example, the ROM diagrammed in <a href="ch06.xhtml#ch6fig16">Figure 6-16</a> has two inputs, <em>a</em><sub>1</sub> and <em>a</em><sub>0</sub>, which provide a 2-bit address.</p>&#13;
<span epub:type="pagebreak" id="page_123"/>&#13;
<div class="image"><img id="ch6fig16" src="../images/pg151_Image_203.jpg" alt="Image" width="657" height="457"/></div>&#13;
<p class="figcap"><em>Figure 6-16: A 4-byte ROM device</em></p>&#13;
<p class="indent">The <em>×</em> connections in <a href="ch06.xhtml#ch6fig16">Figure 6-16</a> represent permanent connections, showing that the AND gate plane is fixed. Each AND gate produces a min-term at each address in this ROM device. The OR gate plane produces up to 2<em><sup>n</sup></em> 8-bit bytes, where <em>n</em> is the width, in number of bits, of the address input to the AND gate plane. The connections (dots) to the OR gates represent the bit pattern stored at the corresponding address. <a href="ch06.xhtml#ch6tab4">Table 6-4</a> shows a ROM device in which the OR gate plane has been programmed to store the four characters 0, 1, 2, and 3 (in ASCII code).</p>&#13;
<p class="tabcap" id="ch6tab4"><strong>Table 6-4:</strong> A ROM Device Holding Four ASCII Characters</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Minterm</strong></th>&#13;
<th class="tab_th"><strong>Address</strong></th>&#13;
<th class="tab_th"><strong>Contents</strong></th>&#13;
<th class="tab_th"><strong>ASCII character</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">¬<em>a</em><sub>1</sub>¬<em>a</em><sub>0</sub></td>&#13;
<td class="bg1"><span class="literal">00</span></td>&#13;
<td class="bg1"><span class="literal">00110000</span></td>&#13;
<td class="bg1">0</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">¬<em>a</em><sub>1</sub><em>a</em><sub>0</sub></td>&#13;
<td class="bg"><span class="literal">01</span></td>&#13;
<td class="bg"><span class="literal">00110001</span></td>&#13;
<td class="bg">1</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><em>a</em><sub>1</sub> ¬<em>a</em><sub>0</sub></td>&#13;
<td class="bg1"><span class="literal">10</span></td>&#13;
<td class="bg1"><span class="literal">00110010</span></td>&#13;
<td class="bg1">2</td></tr>&#13;
<tr>&#13;
<td class="bg"><em>a</em><sub>1</sub><em>a</em><sub>0</sub></td>&#13;
<td class="bg"><span class="literal">11</span></td>&#13;
<td class="bg"><span class="literal">00110011</span></td>&#13;
<td class="bg">3</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Although we have stored only data in this example, computer instructions are bit patterns, so we could just as easily store an entire program in a ROM device. As with a PLA, if you need to change the program, you can just program another ROM device and replace the old one.</p>&#13;
<p class="indent">There are several types of ROM devices. While the bit pattern is set in a ROM device during manufacturing, a <em>programmable read-only memory (PROM)</em> device is programmed by the person who uses it. There are also <em>erasable programmable read-only memory (EPROM)</em> devices that can be erased with an ultraviolet light and then reprogrammed.</p>&#13;
<span epub:type="pagebreak" id="page_124"/>&#13;
<h4 class="h4" id="ch06lev2sec7"><em><strong>Programmable Array Logic</strong></em></h4>&#13;
<p class="noindent">In a <em>programmable array logic (PAL)</em> device, each OR gate is permanently wired to a group of AND gates. Only the AND gate plane is programmable. The PAL device diagrammed in <a href="ch06.xhtml#ch6fig17">Figure 6-17</a> has four inputs and two outputs, each of which can be the sum of up to four products.</p>&#13;
<div class="image"><img id="ch6fig17" src="../images/pg152_Image_204.jpg" alt="Image" width="505" height="709"/></div>&#13;
<p class="figcap"><em>Figure 6-17: A two-function programmable array logic device</em></p>&#13;
<p class="indent">The “<em>×</em>” connections in the OR gate plane show that the top four AND gates are OR-ed to produce <em>F</em><sub>1</sub>(<em>w</em>, <em>x</em>, <em>y</em>, <em>z</em>) and the lower four are OR-ed to produce <em>F</em><sub>2</sub>(<em>w</em>, <em>x</em>, <em>y</em>, <em>z</em>). The AND gate plane in this figure has been programmed to produce these two functions:</p>&#13;
<div class="image1"><img src="../images/pg152_Image_205.jpg" alt="Image" width="667" height="53"/></div>&#13;
<p class="indent">Of the three types of programmable logic devices presented here, the PLA device is the most flexible, as we can program both the OR and the <span epub:type="pagebreak" id="page_125"/>AND plane, but it is also the most expensive. The ROM device is less flexible: it can be programmed to produce any combination of minterms, which are then OR-ed together. We know that any function can be implemented as the OR of minterms, so we can produce any function with a ROM device, but a ROM device doesn’t allow us to minimize the function since all the product terms must be minterms.</p>&#13;
<p class="indent">The PAL device is the least flexible, because all the product terms programmed in the AND plane will be OR-ed together. So, we cannot select which minterms are in the function by programming the OR plane. However, PAL devices allow us to do some Boolean function minimization. If the required function can be implemented in a PAL device, this will be less expensive than using a ROM or PLA device.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch6exe3">6.3     Design a ROM device that holds the four characters a, b, c, and d.</p>&#13;
<p class="box-list" id="ch6exe4">6.4     Design a ROM device that holds the four characters A, B, C, and D.</p>&#13;
<p class="box-list" id="ch6exe5">6.5     Comparing two values to determine which is larger, or whether they are the same, is a common operation in computing. The hardware device used to perform such a comparison is called a <em>comparator</em>. Use a programmable logic device to design a comparator that compares two 2-bit values. Your comparator will have three outputs: equal, greater than, and less than.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec7"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Combinational logic circuits</strong>   These depend only on their input at any point in time. They have no memory of previous effects of the inputs. Examples include adders, decoders, multiplexers, and programmable logic devices.</p>&#13;
<p class="noindentin"><strong>Half adder</strong>   This circuit has two 1-bit inputs and produces two 1-bit outputs: the sum of the inputs and the carry from that sum.</p>&#13;
<p class="noindentin"><strong>Full adder</strong>   This circuit has three 1-bit inputs and produces two 1-bit outputs: the sum of the inputs and the carry from that sum.</p>&#13;
<p class="noindentin"><strong>Ripple-carry adder</strong>   This circuit uses <em>n</em> full adders to add <em>n</em>-bit numbers. The carry output from each full adder is one of the three inputs to the full adders in the next higher-order bit position.</p>&#13;
<p class="noindentin"><strong>Decoder</strong>   A device used to select one of <em>n</em> outputs based on 2<em><sup>n</sup></em> inputs.</p>&#13;
<p class="noindentin"><strong>Multiplexer (MUX)</strong>   A device used to select one of 2<em><sup>n</sup></em> inputs based on an <em>n</em>-bit selector signal.</p>&#13;
<p class="noindentin"><strong>Programmable logic array (PLA)</strong>   A device used to generate an OR-ed combination of minterms to implement Boolean functions in hardware.</p>&#13;
<span epub:type="pagebreak" id="page_126"/>&#13;
<p class="noindentin"><strong>Read-only memory (ROM)</strong>   Nonvolatile memory, with the input being the address of the data or instruction.</p>&#13;
<p class="noindentin"><strong>Programmable array logic (PAL)</strong>   A device used to implement Boolean functions in hardware. It’s less flexible than a PLA or ROM device, but also less expensive.</p>&#13;
<p class="indenta">In the next chapter, you will learn about sequential logic circuits, which use feedback to maintain a memory of their activity.</p>&#13;
</div>
</div>
</body></html>