- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**INTERPROCESS COMMUNICATION**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程间通信**'
- en: 'Interprocess communication (IPC) on iOS is, depending on your perspective,
    refreshingly simple or horribly limiting. I mostly consider it to be the former.
    While Android has flexible IPC mechanisms such as Intents, Content Providers,
    and Binder, iOS has a simple system based on two components: message passing via
    URLs and application extensions. The message passing helps other applications
    and web pages invoke your application with externally supplied parameters. Application
    extensions are intended to extend the functionality of the base system, providing
    services such as sharing, storage, and the ability to alter the functionality
    of the Today screen or keyboard.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 上，进程间通信（IPC）从不同的角度看，可以是令人耳目一新简单，也可以是极为有限的。我个人更倾向于认为它是前者。尽管 Android 拥有灵活的
    IPC 机制，如 Intents、Content Providers 和 Binder，但 iOS 的系统则较为简单，基于两种组件：通过 URL 传递消息和应用程序扩展。消息传递帮助其他应用程序和网页通过外部提供的参数调用您的应用程序。应用程序扩展旨在扩展基础系统的功能，提供诸如共享、存储以及改变“今日”屏幕或键盘功能的服务。
- en: In this chapter, you’ll learn about the various ways you can implement IPC on
    iOS, how people commonly get IPC wrong, and how to work around some of the limitations
    imposed by this system without compromising user security.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何在 iOS 上实现进程间通信（IPC）的各种方法，了解人们常犯的 IPC 错误，以及如何在不妥协用户安全的前提下，规避系统的一些限制。
- en: '**URL Schemes and the openURL Method**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**URL 方案和 openURL 方法**'
- en: The official IPC mechanism available to iOS application developers is via URL
    schemes, which are similar to protocol handlers such as `mailto:` on a desktop
    system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 提供的官方 IPC 机制是通过 URL 方案，这与桌面系统上的协议处理程序（如 `mailto:`）类似。
- en: On iOS, developers can define a URL scheme that they want their application
    to respond to, and other applications (or web pages, importantly) can invoke the
    application by passing in arguments as URL parameters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 上，开发者可以定义一个 URL 方案，指示他们的应用程序响应该方案，其他应用程序（或网页，尤其重要）可以通过将参数作为 URL 参数传递，来调用该应用程序。
- en: '***Defining URL Schemes***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义 URL 方案***'
- en: Custom URL schemes are described in a project’s *Info.plist* file. To add a
    new scheme, you can use Xcode’s plist editor, shown in [Figure 8-1](ch08.html#ch8fig1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 URL 方案在项目的 *Info.plist* 文件中描述。要添加新方案，您可以使用 Xcode 的 plist 编辑器，如[图 8-1](ch08.html#ch8fig1)所示。
- en: '![image](graphics/f08-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-01.jpg)'
- en: '*Figure 8-1: Defining a URL scheme within the Xcode plist editor*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：在 Xcode plist 编辑器中定义 URL 方案*'
- en: First, you add the URL types key, which will create a subkey, called Item 0\.
    A subkey will automatically be created for the URL identifier, which should be
    populated with a reverse DNS notated string such as `com.mycompany.myapp`. Then,
    you create a new subkey of Item 0, which is the URL Schemes key. Under Item 0,
    which was created under URL Schemes, enter the scheme you want other applications
    to call your application by. For example, entering `mynewapp` here makes it so
    that your application will respond to *mynewapp://* URLs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要添加 URL 类型键，这将创建一个名为 Item 0 的子键。URL 标识符的子键将自动创建，应该用反向 DNS 标记的字符串填充，例如 `com.mycompany.myapp`。然后，您在
    Item 0 下创建一个新的子键，即 URL Schemes 键。在 Item 0 下的 URL Schemes 下，输入您希望其他应用程序调用您的应用程序的方案。例如，在这里输入
    `mynewapp`，您的应用程序就会响应 *mynewapp://* 的 URL。
- en: You can also define these URL schemes manually within the plist file using an
    external editor, as shown in [Listing 8-1](ch08.html#ch8ex1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用外部编辑器手动在 plist 文件中定义这些 URL 方案，如[示例 8-1](ch08.html#ch8ex1)所示。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: URL schemes as shown in the plist*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-1：在 plist 中显示的 URL 方案*'
- en: The bold lines indicate the additions to the original plist after the creation
    of the URL scheme in [Figure 8-1](ch08.html#ch8fig1). Learn what’s in this file
    so that you can quickly grep for the information you need when examining a new
    and foreign codebase. When you’re hunting for a custom URL scheme, you should
    look for the `CFBundleURLSchemes` key.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体部分表示在[图 8-1](ch08.html#ch8fig1)中创建 URL 方案后对原始 plist 文件所做的修改。了解这个文件中的内容，以便在检查一个新的陌生代码库时，能快速使用
    grep 查找所需的信息。当您寻找自定义 URL 方案时，应该查找 `CFBundleURLSchemes` 键。
- en: Once you’ve defined a URL scheme or discovered a URL scheme you want to interact
    with, you’ll need to implement code to make or receive IPC calls. Thankfully,
    this is fairly simple, but there are a few pitfalls to watch out for. You’ll take
    a look at them now.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您定义了一个 URL 方案或发现了一个您想要交互的 URL 方案，您就需要实现代码来进行或接收 IPC 调用。幸运的是，这相对简单，但仍然有一些陷阱需要注意。接下来，我们将看看它们。
- en: '***Sending and Receiving URL/IPC Requests***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***发送和接收 URL/IPC 请求***'
- en: 'To send a message via a URL scheme, you simply create an `NSURL` object containing
    an `NSString` representing the URL you want to call and then invoke the `openURL:`
    method `[UIApplication sharedApplication]`. Here’s an example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 URL 协议发送消息，只需创建一个包含你希望调用的 URL 的 `NSString` 对象的 `NSURL` 对象，然后调用 `openURL:`
    方法 `[UIApplication sharedApplication]`。以下是一个示例：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Keys and values for the receiving application are passed in as they would be
    in an HTTP URL, using `?` to indicate parameters and `&` to separate key-value
    pairs. The only exception is that there doesn’t need to be any text before the
    `?` because you’re not talking to a remote site.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接收应用程序的键和值通过类似于 HTTP URL 的方式传递，使用 `?` 表示参数，`&` 分隔键值对。唯一的例外是，在 `?` 前不需要任何文本，因为你并不是在与远程站点进行通信。
- en: The receiving application can then extract any component of the URL with the
    standard `NSURL` object properties,^([1](footnote.html#fn74)) such as `host` (`somestuff`
    in my example), or the `query` (your key-value pairs).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接收应用程序随后可以使用标准的 `NSURL` 对象属性提取 URL 的任何组件，（^([1](footnote.html#fn74))）如 `host`（在我的示例中是
    `somestuff`），或者 `query`（你的键值对）。
- en: '***Validating URLs and Authenticating the Sender***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***验证 URL 和认证发送者***'
- en: When the receiving application is invoked with its custom URL scheme, it has
    the option to verify that it wants to open the URL to begin with, using the `application:didFinishLaunchingWithOptions:`
    method or `application:will-FinishLaunchingWithOptions:` method. Applications
    typically use the former, as in [Listing 8-2](ch08.html#ch8ex2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收应用程序通过其自定义 URL 协议被调用时，它可以选择验证是否希望首先打开该 URL，使用 `application:didFinishLaunchingWithOptions:`
    方法或 `application:will-FinishLaunchingWithOptions:` 方法。应用程序通常使用前者，如在 [清单 8-2](ch08.html#ch8ex2)
    中所示。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-2: Validating URLs within* `didFinishLaunchingWithOptions`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-2：在* `didFinishLaunchingWithOptions` 中验证 URL'
- en: If YES is returned, the `openURL` method will be called with the supplied URL.
    In the `openURL` method, the data passed (if any) is parsed and `openURL` makes
    decisions as to how the app will behave in response. The method is also where
    you can make decisions based on the application that called your app. [Listing
    8-3](ch08.html#ch8ex3) shows what an `openURL` method might look like.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回 YES，`openURL` 方法将使用提供的 URL 被调用。在 `openURL` 方法中，传递的数据（如果有）将被解析，并且 `openURL`
    会根据应用程序的反应做出决策。该方法也是你可以根据调用你应用程序的应用程序做出决策的地方。[清单 8-3](ch08.html#ch8ex3) 显示了一个可能的
    `openURL` 方法的示例。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 8-3: Parsing the data received by* `openURL`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-3：解析由* `openURL` 接收到的数据'
- en: At ➊, the method examines the source application to see whether it comes from
    the bundle ID that identifies Mobile Safari; since this application is meant to
    take input only from other applications, it returns `NO`. If your app is meant
    to be opened only by a specific application, you could restrict it to one valid
    bundle ID.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，该方法检查源应用程序是否来自标识 Mobile Safari 的捆绑 ID；由于该应用程序仅用于接收来自其他应用程序的输入，因此它返回 `NO`。如果你的应用程序只希望由特定应用程序打开，你可以将其限制为一个有效的捆绑
    ID。
- en: At ➋, the input is unescaped, in case there are URL-encoded characters in it
    (such as `%20` for a space). At ➌ and ➍, individual key-value pairs are separated
    out and broken down further into key-value pairs. The first key-value pair is
    grabbed at ➎, and it is parsed to inform whatever logic might be written at ➏.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋，输入内容被解码，以防其中包含 URL 编码字符（如 `%20` 代表空格）。在 ➌ 和 ➍，单独的键值对被分开，并进一步分解成键值对。在 ➎，获取第一个键值对，并对其进行解析，以告知任何可能编写的逻辑，在
    ➏ 处进行处理。
- en: 'The parsing and validation of the actual query string will depend on what type
    of data you’re receiving. If you’re expecting a numeric value, you can also use
    a regular expression to ensure that the string contains only numbers. Here’s an
    example of a check you might add to your `openURL` method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实际查询字符串的解析和验证将取决于你接收到的数据类型。如果你期待的是一个数字值，你也可以使用正则表达式来确保字符串只包含数字。以下是你可能会在 `openURL`
    方法中添加的检查示例：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just validate any parameters received via URL-based IPC to ensure that they
    contain only the type of data you expect. If you use these parameters to form
    database queries or change the content of the HTML, make extra sure you’re sanitizing
    the data and integrating the content properly. I’ll talk more about this in [Chapter
    12](ch12.html#ch12).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 只验证通过基于 URL 的 IPC 接收到的任何参数，确保它们仅包含你预期的数据类型。如果你使用这些参数来构建数据库查询或更改 HTML 内容，务必确保你在清理数据并正确集成内容。我将在
    [第 12 章](ch12.html#ch12) 中详细讲解。
- en: '**Watch for Deprecated Validation Code**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意过时的验证代码**'
- en: Note that you may sometimes see the deprecated (yet more sensibly named) `handleOpenURL`
    method used in some codebases; see [Listing 8-4](ch08.html#ch8ex4) for an example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你有时会在某些代码库中看到过时的（但命名更合理的）`handleOpenURL` 方法；参见[示例 8-4](ch08.html#ch8ex4)了解示例。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 8-4: Deprecated method for handling received URLs*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-4：处理接收到的 URL 的过时方法*'
- en: Using `handleOpenURL` is undesirable in many cases because the method blindly
    opens any URL given to it, and it gives you no way to identify where the URL came
    from. Of course, verifying the source application provides only limited guarantees.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用`handleOpenURL`并不理想，因为该方法会盲目地打开任何给定的 URL，且没有提供任何方法来识别该 URL 的来源。当然，验证源应用程序只能提供有限的保障。
- en: '**How Safe Is Sender Validation?**'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**发送者验证有多安全？**'
- en: 'Given what I’ve discussed in this section, you may well wonder whether you
    can trust the value of the `sourceApplication` parameter at all. Good question!
    While the sender check is merely a string comparison and is not directly cryptographic,
    Apple does ensure that all app IDs submitted to the App Store are unique: first
    come, first served. On a jailbroken device, however, you can’t guarantee this
    uniqueness, so be wary of blindly trusting a URL just because it claims to come
    from a particular application.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我在本节中讨论的内容，你可能会想知道是否能够完全信任`sourceApplication`参数的值。好问题！虽然发送者检查只是字符串比较，并不直接涉及加密，但
    Apple 确保所有提交到 App Store 的应用程序 ID 都是唯一的：先到先得。然而，在越狱设备上，你无法保证这种唯一性，因此不要盲目信任声称来自某个特定应用的
    URL。
- en: '***URL Scheme Hijacking***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***URL Scheme 劫持***'
- en: 'The relatively simple system of URL scheme definition that I described has
    a potential problem. What if another application tries to register your URL scheme?
    In the case of Apple’s built-in applications, other applications won’t be able
    to successfully register a duplicate scheme. For everyone else, though, the resultant
    behavior is ... undefined. Just ask Apple:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我描述的相对简单的 URL scheme 定义系统有一个潜在的问题。如果另一个应用程序尝试注册你的 URL scheme 会怎么样？对于 Apple 内建的应用程序，其他应用程序无法成功注册重复的
    scheme。然而，对于其他应用程序，结果行为是...未定义的。你可以问问 Apple：
- en: If more than one third-party app registers to handle the same URL scheme, there
    is currently no process for determining which app will be given that scheme.^([2](footnote.html#fn75))
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个第三方应用注册了相同的 URL scheme，目前没有办法确定哪个应用会处理该 scheme。^([2](footnote.html#fn75))
- en: In other words, you face two unpleasant possibilities. First, a malicious application
    installed before your application could register your URL scheme and retain it
    after your application is installed. Or, a malicious application installed after
    your application could successfully register your URL scheme, effectively hijacking
    it from your application. Either situation can result in data intended for your
    application going to a malicious third-party app. What can you do? I’ll let you
    know once I figure that out.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你面临两种不愉快的可能性。首先，安装在你应用程序之前的恶意应用可能会注册你的 URL scheme，并在你应用程序安装后仍然保留它。或者，安装在你应用程序之后的恶意应用可能会成功注册你的
    URL scheme，实际上劫持了你的应用程序的 URL scheme。这两种情况都可能导致原本应该发送给你应用程序的数据被发送到恶意的第三方应用。你能做什么？等我想明白了再告诉你。
- en: In recent versions of iOS, however, alternative mechanisms for passing data
    between applications have been made available, each appropriate for different
    circumstances. These may be a better fit for your app than `openURL`. Let’s look
    at a few of these newer methods now.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 iOS 的最新版本中，已经提供了用于应用程序之间传递数据的替代机制，每种机制适用于不同的情况。对于你的应用来说，这些可能比`openURL`更合适。现在让我们来看一下这些较新的方法。
- en: '**Universal Links**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通用链接**'
- en: URL scheme hijacking is one of the reasons that Apple introduced *Universal
    Links* in iOS 9\. Universal Links are a way to effectively provide deep linking
    in an iOS application and integration between websites and mobile applications.
    For example, imagine you’ve published an instant messaging application called
    HoopChat. If a user visits a website that has a “Message me in HoopChat!” button,
    this could link to a URL like *[https://www.hoopchat.com/im/send/?id=356372](https://www.hoopchat.com/im/send/?id=356372)*.
    If the user clicks this link and has your application installed, the link would
    open directly in your application, where the app could create a new message to
    the person with the user ID of 356372\. If the user doesn’t have the application
    installed, the same URL would be viewed in Mobile Safari, which would take you
    to a web-based UI to send a message.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: URL 协议劫持是苹果在 iOS 9 中引入*通用链接*的原因之一。通用链接是一种有效提供 iOS 应用深度链接的方式，并且可以实现网站与移动应用的集成。例如，假设你发布了一款即时通讯应用叫做
    HoopChat。如果用户访问一个网站，上面有一个“在 HoopChat 中给我发消息！”的按钮，这个按钮可以链接到一个像 *[https://www.hoopchat.com/im/send/?id=356372](https://www.hoopchat.com/im/send/?id=356372)*
    的 URL。如果用户点击这个链接并且安装了你的应用，链接将直接在应用中打开，应用可以为用户 ID 为 356372 的人创建一条新消息。如果用户没有安装应用，同样的
    URL 会在移动 Safari 中打开，带你到一个基于 Web 的界面来发送消息。
- en: Behind the scenes, the way this works is that the application has an entitlement
    that specifies how it handles links to particular domains, as shown in [Figure
    8-2](ch08.html#ch8fig2).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，这一工作方式是应用具有一个权限，指定它如何处理指向特定域的链接，如 [图 8-2](ch08.html#ch8fig2) 所示。
- en: '![image](graphics/f08-02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-02.jpg)'
- en: '*Figure 8-2: Enabling Universal Links under Associated Domains in Xcode*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：在 Xcode 中启用与关联域的通用链接*'
- en: When one of these domains is visited in Mobile Safari, a file called *apple
    -app-site-association* is downloaded from the web server. This takes the form
    of a signed blob of JSON, as in [Listing 8-5](ch08.html#ch8ex5).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问这些域中的一个时，在移动 Safari 中会从 Web 服务器下载一个名为 *apple-app-site-association* 的文件。这个文件是一个已签名的
    JSON 数据块，如 [列表 8-5](ch08.html#ch8ex5) 所示。
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 8-5: Format of the* apple-app-site-association *file*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：* apple-app-site-association *文件格式*'
- en: This file specifies the developer team ID, the bundle identifier (shown at ➊),
    and the URL paths that should be handled by the app (as opposed to the main website).
    In this case, all URLs should be handled by the app if it’s installed, so the
    file gives a value of `*` at ➋.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件指定了开发者团队 ID、捆绑标识符（在 ➊ 处显示）以及应由应用处理的 URL 路径（与主网站不同）。在这种情况下，如果应用已安装，则所有 URL
    应由应用处理，因此文件在 ➋ 处给出了 `*` 的值。
- en: As mentioned, this blob needs to be signed; the signing key is actually the
    private key to your production SSL certificate. If you have the private and public
    keys to your website, your JSON file can be signed from the command line, as shown
    in [Listing 8-6](ch08.html#ch8ex6).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个二进制文件需要签名；签名密钥实际上是你的生产 SSL 证书的私钥。如果你拥有网站的私钥和公钥，你可以通过命令行签署 JSON 文件，如 [列表
    8-6](ch08.html#ch8ex6) 所示。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 8-6: Signing the* apple-app-site-association *file*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-6：签署* apple-app-site-association *文件*'
- en: This example uses the `openssl` utility, providing it with the unsigned JSON
    file at ➊ and the output filename at ➋. At ➌ and ➍, a key pair is provided. If
    your key is protected by a passphrase, you’d enter that when prompted, and you’d
    receive a valid *apple-app-site-association* file as the output. This file would
    then be uploaded to the web root of your website, where iOS would fetch it over
    HTTPS to determine whether to pass the URL to your app. Within the application,
    logic as to what action your app will take upon receiving a universal link will
    depend on what you implement in the `application:continueUserActivity:restorationHandler:`
    method of your application delegate.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用 `openssl` 工具，将未签名的 JSON 文件提供给 ➊ 处，并提供输出文件名 ➋。在 ➌ 和 ➍ 处提供密钥对。如果你的密钥受到密码保护，系统会提示你输入密码，你将获得一个有效的
    *apple-app-site-association* 文件作为输出。然后，这个文件会上传到你网站的根目录，iOS 会通过 HTTPS 获取它，确定是否将
    URL 传递给你的应用。在应用内，应用在接收到通用链接后采取什么操作，将取决于你在应用代理的 `application:continueUserActivity:restorationHandler:`
    方法中实现的逻辑。
- en: This universal linking approach is preferable to custom URL handling schemes
    for a few reasons. First, Universal Links isn’t subject to URL scheme hijacking;
    only your website, authenticated over HTTPS, can specify what URLs will be opened
    in your application, and those calls can’t be sent to a separate bundle ID. Second,
    the links should work regardless of whether an app is installed. In earlier versions
    of iOS, you’d just get an error saying that the scheme isn’t recognized. With
    Universal Links, if the app isn’t installed, you’ll be sent to the equivalent
    on the website. Finally, Universal Links provide some privacy protections by preventing
    applications from enumerating what applications are present on a device. (Apps
    could previously use the `canOpenURL` method to enumerate installed applications;
    with Universal Links, no such mechanism exists.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通用链接方式比自定义URL处理方案更为优越，原因有几个。首先，通用链接不受URL方案劫持的影响；只有你的网站（通过HTTPS认证）可以指定哪些URL将在你的应用程序中打开，而且这些调用不能被发送到其他的Bundle
    ID。其次，无论应用是否安装，链接都应该能正常工作。在iOS的早期版本中，如果应用未安装，你会得到一个错误提示，表示该方案无法识别。而通过通用链接，如果应用未安装，你会被重定向到相应的网站。最后，通用链接提供了一些隐私保护，防止应用程序枚举设备上有哪些应用程序（以前应用可以通过`canOpenURL`方法枚举已安装的应用；而使用通用链接后，不再存在这种机制）。
- en: Now that you’ve seen how you can control interactions with your own application,
    let’s take a look at some ways to more deeply integrate your application with
    popular apps and services using `UIActivity`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何控制与你自己的应用程序的交互，让我们看看如何通过`UIActivity`更深入地将你的应用程序与流行的应用和服务进行集成。
- en: '**Sharing Data with UIActivity**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过UIActivity共享数据**'
- en: 'In iOS 6, Apple started allowing third-party applications to share information
    through a set of predefined methods, such as sending data via an email or posting
    to Facebook. This limited form of IPC allows developers to implement the most
    basic sharing functionality. You can get an idea of the types of data this is
    useful for by examining the following `UIActivity` types:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 6中，苹果开始允许第三方应用通过一组预定义的方法共享信息，如通过电子邮件发送数据或发布到Facebook。这个有限的进程间通信（IPC）形式让开发者能够实现最基本的共享功能。你可以通过检查以下`UIActivity`类型，了解这种方法适用于哪些类型的数据：
- en: • `UIActivityTypePostToFacebook`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypePostToFacebook`
- en: • `UIActivityTypePostToTwitter`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypePostToTwitter`
- en: • `UIActivityTypePostToWeibo`
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypePostToWeibo`
- en: • `UIActivityTypePostToTencentWeibo`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypePostToTencentWeibo`
- en: • `UIActivityTypePostToFlickr`
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypePostToFlickr`
- en: • `UIActivityTypePostToVimeo`
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypePostToVimeo`
- en: • `UIActivityTypeMessage`
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypeMessage`
- en: • `UIActivityTypeMail`
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypeMail`
- en: • `UIActivityTypePrint`
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypePrint`
- en: • `UIActivityTypeCopyToPasteboard`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypeCopyToPasteboard`
- en: • `UIActivityTypeAssignToContact`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypeAssignToContact`
- en: • `UIActivityTypeSaveToCameraRoll`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypeSaveToCameraRoll`
- en: • `UIActivityTypeAddToReadingList`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypeAddToReadingList`
- en: • `UIActivityTypeAirDrop`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: • `UIActivityTypeAirDrop`
- en: To share via `UIActivity`, just create a `UIActivityViewController` and pass
    it data such as text, a URL, an image, and so forth, as shown in [Listing 8-7](ch08.html#ch8ex7).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过`UIActivity`进行分享，只需创建一个`UIActivityViewController`并传递数据，如文本、URL、图片等，具体请参见[清单
    8-7](ch08.html#ch8ex7)。
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 8-7: Instantiating a* `UIActivityViewController`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-7：实例化一个* `UIActivityViewController`'
- en: Here, a `UIActivityViewController` called `controller` is passed some text and
    a URL. If certain modes of sharing aren’t appropriate for the data, you can exclude
    them. For example, if you want to ensure that users can only mail or print your
    content but not post to social networking sites, you can tell `UIActivityViewController`
    to exclude all other known types of sharing, as in [Listing 8-8](ch08.html#ch8ex8).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`UIActivityViewController`被传递了一些文本和一个URL。如果某些分享方式不适用于该数据，你可以排除它们。例如，如果你希望确保用户只能通过邮件或打印内容，而不能分享到社交网络，你可以告诉`UIActivityViewController`排除所有其他已知的分享类型，如[清单
    8-8](ch08.html#ch8ex8)所示。
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-8: Excluding certain types of sharing activities*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-8：排除某些类型的共享活动*'
- en: This exclusion approach is, unfortunately, not convenient or thorough, and any
    sharing types added in future versions of iOS will be included by default. If
    it’s important to disable parts of the sharing UI, be sure that you test with
    the most recent versions of iOS before they reach the general public.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种排除方法并不方便或彻底，未来版本的iOS中新增的任何共享类型都会默认包含在内。如果禁用某些共享UI部分很重要，请确保在这些版本正式发布之前，使用最新版本的iOS进行测试。
- en: 'In addition to URL schemes and `UIActivity` methods, there’s one more way to
    handle IPC in iOS: through extensions.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 URL 方案和`UIActivity`方法外，在 iOS 中还有另一种处理 IPC 的方式：通过扩展。
- en: '**Application Extensions**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**应用扩展**'
- en: In iOS 8 and later, developers can write various *extensions*, which behave
    like specialized forms of IPC. The extensions allow you to present data to other
    applications, have applications share data through your app, or alter system behavior.
    [Table 8-1](ch08.html#ch8tab1) shows the various kinds of *extension points* you
    can code for. An extension point defines what component of the OS the extension
    will have access to and how it will need to be coded.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 8 及更高版本中，开发者可以编写各种*扩展*，它们表现得像是专门的进程间通信（IPC）形式。这些扩展允许您向其他应用程序展示数据，或者通过您的应用程序共享数据，或更改系统行为。[表
    8-1](ch08.html#ch8tab1)显示了您可以为其编写的各种*扩展点*。扩展点定义了扩展将访问操作系统的哪个组件以及如何进行编码。
- en: '**Table 8-1:** Extension Points'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** 扩展点'
- en: '| **Type** | **Function** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **功能** |'
- en: '| --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Today | Manipulates widgets in the Today view of the Notification Center
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 今日 | 操作通知中心今日视图中的小部件 |'
- en: '| Share | Allows data to be sent to your app via Share buttons |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 分享 | 允许通过分享按钮将数据发送到您的应用程序 |'
- en: '| Action | Reads or manipulates data to be returned to the host app |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 动作 | 读取或操作要返回给主机应用程序的数据 |'
- en: '| Photo | Provides methods to manipulate photos within the Photos app |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 照片 | 提供在“照片”应用中操作照片的方法 |'
- en: '| Document Provider | Allows access to a library of files |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 文档提供者 | 允许访问文件库 |'
- en: '| Keyboard | Provides a custom keyboard |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 键盘 | 提供自定义键盘 |'
- en: While app extensions aren’t applications, they are required to come bundled
    with an application, referred to as the *containing app*. Third-party applications
    that use an extension (called *host apps*) can communicate with the extension
    bundled in the containing app, but the containing app itself does not directly
    talk to the extension. Apple also specifically excludes some functions from being
    accessible via extensions, such as using the HealthKit API, receiving AirDrop
    data, or accessing the camera or microphone.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用扩展不是独立的应用程序，但它们必须与一个应用程序捆绑在一起，称为*容器应用程序*。使用扩展的第三方应用程序（称为*主机应用程序*）可以与捆绑在容器应用程序中的扩展进行通信，但容器应用程序本身不会直接与扩展通信。苹果公司还明确排除了某些功能不允许通过扩展访问，例如使用
    HealthKit API、接收 AirDrop 数据或访问摄像头或麦克风。
- en: Extensions can be implemented in many ways, and they can be treated as applications
    in and of themselves. As shown in [Figure 8-3](ch08.html#ch8fig3), extensions
    are created as their own applications within Xcode.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展可以通过多种方式实现，它们也可以被视为独立的应用程序。如[图 8-3](ch08.html#ch8fig3)所示，扩展作为独立的应用程序在 Xcode
    中创建。
- en: '![image](graphics/f08-03.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-03.jpg)'
- en: '*Figure 8-3: Adding a new extension target to a project*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：将新的扩展目标添加到项目中*'
- en: For this book, however, let’s home in on the most important aspects to check
    from a security perspective.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本书中，我们将重点关注从安全角度检查最重要的方面。
- en: '***Checking Whether an App Implements Extensions***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查应用是否实现了扩展***'
- en: 'First, you can easily determine whether the app you’re examining implements
    an extension by searching for the `NSExtensionPointIdentifier` inside property
    lists. To search for that property, you can execute the following command in the
    project’s *root* directory:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以通过在属性列表中搜索`NSExtensionPointIdentifier`来轻松判断您正在检查的应用程序是否实现了扩展。要搜索该属性，您可以在项目的*根*目录中执行以下命令：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This greps all *.plist* files in the directory for `NSExtensionPointIdentifier`.
    You can also search for the property by checking the *.plist* file within Xcode,
    as in [Figure 8-4](ch08.html#ch8fig4).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在目录中搜索所有*.plist*文件以查找`NSExtensionPointIdentifier`。您还可以通过在 Xcode 中检查*.plist*文件来查找该属性，如[图
    8-4](ch08.html#ch8fig4)所示。
- en: '![image](graphics/f08-04.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-04.jpg)'
- en: '*Figure 8-4: The* Info.plist *of a newly created extension, viewed in Xcode*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：新创建的扩展的*Info.plist*文件，在 Xcode 中查看*'
- en: An extension’s *Info.plist* file will contain the type of extension being used,
    as well as optional definitions of the types of data that the extension is designed
    to handle. If you find the `NSExtensionPointIdentifier` property defined, you
    should dig in to the project and find the view controller for the defined extension.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的*Info.plist*文件将包含正在使用的扩展类型，以及可选的扩展设计来处理的数据类型定义。如果您发现定义了`NSExtensionPointIdentifier`属性，您应该深入项目，找到该扩展的视图控制器。
- en: '***Restricting and Validating Shareable Data***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***限制和验证可共享数据***'
- en: For share and action extensions, you can define an `NSExtensionActivationRule`,
    which contains a dictionary of data types that your application is restricted
    to handling (see [Figure 8-5](ch08.html#ch8fig5)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分享和操作扩展，您可以定义一个`NSExtensionActivationRule`，其中包含一个数据类型字典，限制您的应用程序只能处理这些数据类型（参见[图
    8-5](ch08.html#ch8fig5)）。
- en: '![image](graphics/f08-05.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-05.jpg)'
- en: '*Figure 8-5: Activation rules in an extension’s* .plist *file, viewed in Xcode*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：扩展的激活规则，位于 Xcode 中查看的*.plist *文件*'
- en: This dictionary will be evaluated to determine what data types your extension
    allows and the maximum number of these items you’ll accept. But apps aren’t limited
    to accepting predefined types of data; they can also implement custom `NSPredicate`s
    to define their own rules for what they’ll accept. If this is the case, you’ll
    see the `NSExtensionActivationRule` represented as a string rather than a numeric
    value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典将被评估，以确定您的扩展允许哪些数据类型，以及您将接受这些项的最大数量。但是，应用程序不仅限于接受预定义的数据类型；它们还可以实现自定义`NSPredicate`来定义它们自己的接受规则。如果是这种情况，您将看到`NSExtensionActivationRule`以字符串形式表示，而不是数字值。
- en: 'If you know you’re dealing with predefined data types, however, keep the following
    predefined activation rules in mind:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道自己正在处理预定义的数据类型，请记住以下预定义的激活规则：
- en: • `NSExtensionActivationSupportsAttachmentsWithMaxCount`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: • `NSExtensionActivationSupportsAttachmentsWithMaxCount`
- en: • `NSExtensionActivationSupportsAttachmentsWithMinCount`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: • `NSExtensionActivationSupportsAttachmentsWithMinCount`
- en: • `NSExtensionActivationSupportsFileWithMaxCount`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: • `NSExtensionActivationSupportsFileWithMaxCount`
- en: • `NSExtensionActivationSupportsImageWithMaxCount`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: • `NSExtensionActivationSupportsImageWithMaxCount`
- en: • `NSExtensionActivationSupportsMovieWithMaxCount`
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: • `NSExtensionActivationSupportsMovieWithMaxCount`
- en: • `NSExtensionActivationSupportsText`
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: • `NSExtensionActivationSupportsText`
- en: • `NSExtensionActivationSupportsWebURLWithMaxCount`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: • `NSExtensionActivationSupportsWebURLWithMaxCount`
- en: • `NSExtensionActivationSupportsWebPageWithMaxCount`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: • `NSExtensionActivationSupportsWebPageWithMaxCount`
- en: Because extensions can often receive unknown and arbitrary kinds of data, it’s
    important to ensure that your extension performs correct validation in the `isContentValid`
    method of its view controller, particularly in share or action extensions. Examine
    the logic in your app’s implementation of this method and determine whether the
    app is performing the necessary validation required.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于扩展通常会接收未知和任意类型的数据，因此确保扩展在其视图控制器的`isContentValid`方法中执行正确的验证非常重要，尤其是在分享或操作扩展中。检查应用程序在实现该方法时的逻辑，确定应用程序是否执行了所需的验证。
- en: Typically, an extension will examine the `NSExtensionContext` (which is passed
    in by the host app when it calls `beginRequestWithExtensionContext`), as in [Listing
    8-9](ch08.html#ch8ex9).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，扩展会检查`NSExtensionContext`（这是当主机应用调用`beginRequestWithExtensionContext`时传递的），如[示例
    8-9](ch08.html#ch8ex9)所示。
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 8-9: Creating an array of* `NSExtensionItem`*s from the* `NSExtensionContext`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-9：从`NSExtensionContext`创建`NSExtensionItem`数组*'
- en: This will give an array of `NSExtensionItem` objects, and each object will contain
    a different type of data passed in by the host app, such as images, URLs, text,
    and so on. Each of these items should be examined and validated before you use
    them to perform actions or allow the user to post the data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供一个`NSExtensionItem`对象数组，每个对象将包含主机应用程序传递的不同类型数据，例如图像、URL、文本等。在使用这些数据执行操作或允许用户发布数据之前，应该对每个项目进行检查和验证。
- en: '***Preventing Apps from Interacting with Extensions***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***防止应用程序与扩展交互***'
- en: Keyboard extensions have the unique characteristic that they read every keystroke
    that a user enters into them. Different third-party keyboards may have various
    degrees of keystroke logging to help with things such as auto-completion or sending
    data to a remote web service for processing. It’s also possible that an actively
    malicious keyboard could be distributed, working as a pure keylogger. If your
    application accepts security-sensitive data via the keyboard, you may want to
    prevent the use of third-party keyboards with your application. You can do this
    with the `shouldAllowExtensionPointIdentifier` delegate method, as shown in [Listing
    8-10](ch08.html#ch8ex10).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘扩展具有独特的特点，它们会读取用户输入的每个按键。不同的第三方键盘可能会有不同程度的按键记录功能，以帮助自动完成或将数据发送到远程 Web 服务进行处理。也有可能会分发恶意键盘，作为纯粹的按键记录器。如果您的应用程序通过键盘接受安全敏感数据，您可能希望阻止在您的应用程序中使用第三方键盘。您可以通过`shouldAllowExtensionPointIdentifier`代理方法来实现这一点，如[示例
    8-10](ch08.html#ch8ex10)所示。
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 8-10: The* `shouldAllowExtensionPointIdentifier` *delegate method*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-10：* `shouldAllowExtensionPointIdentifier` *委托方法*'
- en: This code simply examines the value of `extensionPointIdentifier` and returns
    `NO` if it matches the constant `UIApplicationKeyboardExtensionPointIdentifier`.
    Note that currently third-party keyboards are the only extensions that can be
    disabled in this fashion.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地检查`extensionPointIdentifier`的值，如果它与常量`UIApplicationKeyboardExtensionPointIdentifier`匹配，则返回`NO`。请注意，目前只有第三方键盘是可以通过这种方式禁用的扩展。
- en: You’ve seen the best ways to implement IPC, so to close the chapter, I’ll walk
    you through one approach to IPC that you may see in the wild that doesn’t work
    out so well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了实现IPC的最佳方法，为了结束这一章，我将带你了解一种可能在实际应用中出现的IPC方法，但它并不太成功。
- en: '**A Failed IPC Hack: The Pasteboard**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一个失败的IPC黑客：粘贴板**'
- en: There have been occasional reports of people abusing the `UIPasteboard` mechanism
    as a kind of IPC channel. For example, some try using it to transfer a user’s
    data from a free version of an application to a “pro” version, since there’s no
    way the newly installed application can read the old application’s data. Don’t
    do that!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔会有报告提到有人滥用`UIPasteboard`机制作为一种IPC通道。例如，有些人尝试使用它将用户的数据从应用程序的免费版本转移到“专业”版本，因为新安装的应用程序无法读取旧应用程序的数据。不要这样做！
- en: 'An OAuth library designed to work with Twitter^([3](footnote.html#fn76)) uses
    the general paste-board as a mechanism to shuffle authentication information from
    a web view to the main part of the app, as in this example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 设计用于与Twitter一起工作的OAuth库^([3](footnote.html#fn76))使用通用粘贴板作为一种机制，将身份验证信息从网页视图传递到应用程序的主部分，如下例所示：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After reading data from the general pasteboard at ➊, this library validates
    the data and sends it to the `gotPin` method at ➋.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊读取通用粘贴板的数据后，该库会验证数据并将其发送到➋处的`gotPin`方法。
- en: But the general pasteboard is shared among all applications and can be read
    by any process on the device. This makes the pasteboard a particularly bad place
    to store anything even resembling private data. I’ll go into more detail on the
    pasteboard in [Chapter 10](ch10.html#ch10), but for now, ensure that the app you’re
    examining isn’t putting anything on the pasteboard that you wouldn’t want every
    other app to know about.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是通用粘贴板是所有应用程序共享的，并且设备上的任何进程都可以读取它。这使得粘贴板成为存储任何类似私密数据的地方特别不安全。我将在[第10章](ch10.html#ch10)中详细讲解粘贴板，但现在，请确保你正在检查的应用程序不会把任何你不希望其他应用程序知道的东西放到粘贴板上。
- en: '**Closing Thoughts**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结语**'
- en: While IPC in iOS appears limited at first, there are ample opportunities for
    developers to fail to parse externally supplied input, create new data leaks,
    and even potentially send data to the wrong app. Ensure that sharing is appropriately
    limited, received data is validated, sending applications are verified, and unencrypted
    data isn’t passed by simply trusting that the receiving URL handler is the one
    you would expect.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然iOS中的IPC看似有限，但开发者往往会遇到无法解析外部输入、创建新的数据泄露，甚至可能将数据发送到错误的应用程序的情况。确保分享被适当限制，接收到的数据经过验证，发送的应用程序经过验证，并且不要仅仅相信接收URL处理程序就是你预期的那个，从而避免传递未加密的数据。
