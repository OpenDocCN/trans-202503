<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_167"/><strong><span class="big">9</span><br/>CENTRAL PROCESSING UNIT</strong></h2>&#13;
<div class="image1"><img src="../images/pg195_Image_241.jpg" alt="Image" width="190" height="188"/></div>&#13;
<p class="noindentz">Now that you’ve learned about the electronic components that are used to build a central processing unit (CPU), it’s time for you to learn about some of the specifics of the ARM CPU.</p>&#13;
<p class="indent">Arm Ltd is a design company that licenses its designs as <em>intellectual property (IP)</em> to other companies. The Raspberry Pi uses a <em>System on a Chip (SoC)</em> made by Broadcom. An SoC is an assembly of IP blocks in a single integrated circuit that includes a CPU and many of the other components of a computer system. The SoC used on a Raspberry Pi includes an ARM CPU IP block and other device IP blocks to work with the CPU.</p>&#13;
<p class="indent">This book is based on the eighth version of the ARM CPU architecture, Armv8-A. This version is used in several Raspberry Pi models, including the Raspberry Pi 3 A+, B, and B+, the Raspberry Pi 4 B, and the Raspberry Pi 5.</p>&#13;
<p class="indent">An Armv8-A processor can be run in either the AArch64 or the AArch32 execution state. <em>AArch64</em> is a 64-bit execution state that supports 64-bit addresses and the <em>A64</em> instruction set. The A64 instructions can use 64-bit registers for processing. <em>AArch32</em> is a 32-bit execution state that supports 32-bit addresses and the <em>A32</em> and <em>T32</em> instruction sets. (In previous Arm documentation, A32 was called ARM and T32 was called Thumb.) The A32 and T32 instructions can use 32-bit registers for processing.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_168"/>A64 and A32 instructions are all 32 bits long. T32 instructions are either 32 or 16 bits long. The T32 instruction set can be useful in implementations of the ARM architecture for small devices because it can reduce the amount of memory needed for a program. I use the A64 instruction set in the AArch64 execution state in this book.</p>&#13;
<p class="indent">We’ll begin this chapter with an overview of a typical CPU, then look at the registers in the AArch64 execution state and how a programmer accesses them. I’ll conclude the chapter with an example of using the <code>gdb</code> debugger to view the contents of the registers.</p>&#13;
<h3 class="h3" id="ch09lev1sec1"><strong>CPU Overview</strong></h3>&#13;
<p class="noindent">As you probably already know, the CPU is the heart of the computer. It follows the execution path that you specify in your program and performs all the arithmetic and logic operations. It also fetches the instructions and data from memory as they are needed by your program.</p>&#13;
<p class="indent">Let’s start with a look at the major subsystems of a typical CPU. I’ll follow this with a description of how the CPU fetches instructions from memory as it executes a program.</p>&#13;
<h4 class="h4" id="ch09lev2sec1"><em><strong>CPU Subsystems</strong></em></h4>&#13;
<p class="noindent"><a href="ch09.xhtml#ch9fig1">Figure 9-1</a> shows a block diagram of the major subsystems of a typical CPU. This is a highly simplified diagram that shows only one processing core; actual CPUs are much more complicated, but the general concepts discussed here apply to most of them.</p>&#13;
<div class="image"><img id="ch9fig1" src="../images/pg196_Image_242.jpg" alt="Image" width="532" height="473"/></div>&#13;
<p class="figcap"><em>Figure 9-1: The major subsystems of a CPU</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_169"/>The subsystems are connected through internal buses, which are the hardware pathways and the protocols that control communications over these pathways. Let’s briefly look at each of the subsystems in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>. After this general introduction, we’ll look at the subsystems a programmer will be most interested in and how they’re used in the A64 architecture. The major CPU subsystems are:</p>&#13;
<p class="noindentin"><strong>Program counter</strong> In the A64 architecture, the program counter register contains the memory address of the currently executing instruction. In many other architectures, it contains the address of the instruction immediately following the current one in memory. In the ARM A32 and T32 architectures, it contains the address of the instruction following the immediately following instruction. It’s commonly called the <em>instruction pointer</em> in x86 architectures.</p>&#13;
<p class="noindentin"><strong>Cache memory</strong> Although it could be argued that this is not part of the CPU, most modern CPUs include some cache memory on the CPU chip. The way the CPU uses cache memory was explained in <a href="ch08.xhtml">Chapter 8</a>.</p>&#13;
<p class="noindentin"><strong>Instruction register</strong> When an instruction is fetched, it’s loaded into the instruction register to be decoded and executed. The instruction register’s bit pattern determines what the control unit causes the CPU to do. Once that action has been completed, the bit pattern in the instruction register will be changed to that of the next instruction in the program, and the CPU will perform the operation specified by this new bit pattern.</p>&#13;
<p class="noindentin"><strong>Register file</strong> As you saw in <a href="ch08.xhtml">Chapter 8</a>, a register file is a group of registers used in similar ways. Most CPUs have several register files. For example, the A64 architecture includes a register file for integer operations and another register file for floating-point and vector operations. Compilers and assemblers have names for each register. All arithmetic and logic operations and data movement operations involve at least one register in a register file.</p>&#13;
<p class="noindentin"><strong>Control unit</strong> The bits in the instruction register are decoded in the control unit. To carry out the action(s) specified by the instruction, the control unit generates the signals that control the other subsystems in the CPU. It’s typically implemented as a finite state machine and contains decoders, multiplexers, and other logic components.</p>&#13;
<p class="noindentin"><strong>Arithmetic logic unit (ALU)</strong> The ALU is used to perform the arithmetic and logic operations you specify in your program. It’s also used by the CPU when it needs to do its own arithmetic (for example, to add two values to compute a memory address).</p>&#13;
<p class="noindentin"><strong>Condition flags</strong> Each operation performed by the ALU results in various conditions that can be recorded for possible use by the program. For example, as discussed in <a href="ch03.xhtml">Chapter 3</a>, addition can produce a carry. The A64 instruction set includes add and subtract instructions that will set one of the condition flags to either <code>0</code> (no carry) or <code>1</code> (carry) after the ALU has completed the operation.</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_170"/><strong>Bus interface</strong> This is how the CPU communicates with the other computer subsystems—the memory and input/output (I/O) in <a href="ch01.xhtml#ch1fig1">Figure 1-1</a> (see <a href="ch01.xhtml">Chapter 1</a>). It contains the circuitry to place addresses on the address bus, to read and write data via the data bus, and to place control signals on the control bus. The bus interface on many CPUs interfaces with external bus control units that in turn interface with memory and with different types of I/O buses (for example, USB, SATA, or PCI-E).</p>&#13;
<h4 class="h4" id="ch09lev2sec2"><em><strong>Instruction Execution Cycle</strong></em></h4>&#13;
<p class="noindent">Let’s go into a bit more detail about how the CPU executes a program stored in main memory. It does this by fetching the instructions from main memory using the three buses that you learned about in <a href="ch01.xhtml">Chapter 1</a>—address, data, and control—through the bus interface.</p>&#13;
<p class="indent">In the A64 architecture, the address in the <em>program counter</em> register always points to (has the memory address of) the currently executing instruction in a program. After fetching the instruction at this address, the CPU decodes and executes it. The CPU then adds 4 (the number of bytes in an instruction) to the program counter, causing it to contain the address of the next instruction in the program. Thus, the program counter marks the current location in a program.</p>&#13;
<p class="indent">There are instructions that change the address in the program counter, thus causing a <em>branch</em> from one place in the program to another. In this case, the address in the program counter is not incremented after the instruction is executed.</p>&#13;
<p class="indent">When the CPU fetches an instruction from memory, it loads that instruction into the instruction register. The bit pattern in the instruction register causes the CPU to perform the operations specified in the instruction. Once that action has been completed, another instruction is automatically loaded into the instruction register, and the CPU will perform the operation specified by this next bit pattern.</p>&#13;
<p class="indent">Most modern CPUs use an <em>instruction queue</em>, where several instructions wait, ready to be executed. Separate electronic circuitry keeps the instruction queue full while the regular control unit is executing the instructions. This is an implementation detail that allows the control unit to run faster; the essence of how the control unit executes a program can be represented by the single instruction register model, which is what I’ll describe here.</p>&#13;
<p class="indent">The steps to fetch each instruction from memory, and thus to execute a program, are as follows:</p>&#13;
<ol>&#13;
<li class="noindent">A sequence of instructions is stored in memory.</li>&#13;
<li class="noindent">The memory address where the first instruction is located is copied to the program counter.</li>&#13;
<li class="noindent">The CPU sends the address in the program counter to memory on the address bus.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_171"/>The CPU sends a “read” signal on the control bus.</li>&#13;
<li class="noindent">The memory responds by sending a copy of the state of the bits at that memory location on the data bus, which the CPU then copies into its instruction register.</li>&#13;
<li class="noindent">The CPU executes the instruction in the instruction register.</li>&#13;
<li class="noindent">If the instruction did not change the address in the program counter, the CPU automatically increments the program counter to contain the address of the next instruction in memory.</li>&#13;
<li class="noindent">Go back to step 3.</li>&#13;
</ol>&#13;
<p class="noindent">Steps 3, 4, and 5 are called an <em>instruction fetch</em>. Notice that steps 3 through 8 constitute a cycle, known as the <em>instruction execution cycle</em>. <a href="ch09.xhtml#ch9fig2">Figure 9-2</a> shows this graphically for nonbranching A64 instructions.</p>&#13;
<div class="image"><img id="ch9fig2" src="../images/pg199_Image_243.jpg" alt="Image" width="169" height="520"/></div>&#13;
<p class="figcap"><em>Figure 9-2: The instruction execution cycle for non-branching A64 instructions</em></p>&#13;
<p class="indent">The CPU adds 4 to the program counter because each A64 instruction is 32 bits long. Some computer architectures add the instruction length to the program counter before executing the instruction.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_172"/>In the ARM A32 instruction set architecture, the CPU adds 8 (the length of two instructions) to the address of the currently executing instruction. You learned in <a href="ch07.xhtml">Chapter 7</a> that instructions are fetched and executed in stages in a pipeline. In the older 32-bit ARM architecture, two more instructions have been fetched and are moving through the pipeline before the current instruction is executed. This difference was preserved in the A32 mode of the AArch64 architecture to give backward compatibility.</p>&#13;
<p class="indent">Most of the time, these differences will not matter to you, but as you will see when we discuss the coding of instructions in <a href="ch12.xhtml">Chapter 12</a>, knowing the details might help when debugging a program.</p>&#13;
<p class="indent">The <code>wfi</code> instruction in <a href="ch09.xhtml#ch9fig2">Figure 9-2</a> causes the CPU to stop executing instructions and wait for an interrupt. The A64 has another instruction, <code>wfe</code>, that also stops instruction execution and waits for an event. The differences between interrupts and events are beyond the scope of this book; the important point is that there are instructions to tell the CPU to stop executing instructions, thus pausing the instruction execution cycle. You’ll learn more about interrupts in <a href="ch21.xhtml">Chapter 21</a>.</p>&#13;
<p class="indent">Most instructions in a program use at least one register in at least one of the register files. A program typically loads data from memory into a register, operates on the data, and stores the result in memory. Registers are also used to hold addresses of items that are stored in memory, thus serving as pointers to data or other addresses.</p>&#13;
<p class="indent">At this point in the book, I will focus mostly on the A64 instruction set architecture. I recommend you download <em>Learn the Architecture—Introducing the ARM Architecture</em> from <em><a href="https://developer.arm.com/documentation/102404/latest">https://developer.arm.com/documentation/102404/latest</a></em>. That document is more advanced than what I cover in this book, but one of my goals here is to help you learn how to read the more advanced presentations. Going back and forth between the two discussions will help you gain a better understanding of the material.</p>&#13;
<p class="indent">The remainder of this chapter is largely devoted to describing the general-purpose registers in the A64 architecture. You’ll learn how to view their contents in the <code>gdb</code> debugger, and you’ll learn how to start using them in assembly language in the next chapter.</p>&#13;
<h3 class="h3" id="ch09lev1sec2"><strong>A64 Registers</strong></h3>&#13;
<p class="noindent">A portion of the memory in the CPU is organized into registers. Machine instructions access CPU registers by their addresses, just like they access main memory. Of course, the register addressing space is separate from the main memory addressing space; register addresses are placed on the internal CPU bus, not on the address portion of the bus interface, since the registers are in the CPU. The difference from a programmer’s point of view is that the assembler has predefined names for the registers, whereas the programmer creates symbolic names for memory addresses.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_173"/>Thus, in each program you write in assembly language, the following happens:</p>&#13;
<ul>&#13;
<li class="noindent">CPU registers are accessed by using the names that are predefined in the assembler.</li>&#13;
<li class="noindent">Memory is accessed by the programmer providing a name for the memory location and using that name in the user program.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch09.xhtml#ch9tab1">Table 9-1</a> lists the basic programming registers in the A64 architecture.</p>&#13;
<p class="tabcap" id="ch9tab1"><strong>Table 9-1:</strong> The Basic A64 Registers</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Number</strong></th>&#13;
<th class="tab_th"><strong>Size</strong></th>&#13;
<th class="tab_th"><strong>Name</strong></th>&#13;
<th class="tab_th"><strong>Usage</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">31</td>&#13;
<td class="bg1">64-bit</td>&#13;
<td class="bg1"><code>x0</code>–<code>x30</code> or <code>w0</code>–<code>w30</code></td>&#13;
<td class="bg1">General-purpose</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">1</td>&#13;
<td class="bg">64-bit</td>&#13;
<td class="bg"><code>sp</code></td>&#13;
<td class="bg">Stack pointer</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">1</td>&#13;
<td class="bg1">64-bit</td>&#13;
<td class="bg1"><code>xzr</code> or <code>wzr</code></td>&#13;
<td class="bg1">Zero register</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">1</td>&#13;
<td class="bg">64-bit</td>&#13;
<td class="bg"><code>pc</code></td>&#13;
<td class="bg">Program counter</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">1</td>&#13;
<td class="bg1">64-bit</td>&#13;
<td class="bg1"><code>nzcv</code></td>&#13;
<td class="bg1">Condition flags</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">32</td>&#13;
<td class="bg">128-bit</td>&#13;
<td class="bg"><code>d0</code>–<code>x31</code>, <code>s0</code>–<code>s31</code>, or <code>h0</code>–<code>h31</code></td>&#13;
<td class="bg">Floating-point or vector</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">1</td>&#13;
<td class="bg1">64-bit</td>&#13;
<td class="bg1"><code>fpcr</code></td>&#13;
<td class="bg1">Floating-point control</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">1</td>&#13;
<td class="bg">64-bit</td>&#13;
<td class="bg"><code>fpsr</code></td>&#13;
<td class="bg">Floating-point status</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The names <code>x0</code>–<code>x30</code> refer to the full 64 bits of the registers, and <code>w0</code>–<code>w30</code> refer to the 32 low-order bits of the same registers. Similarly, <code>xzr</code> is a 64-bit 0 integer and <code>wzr</code> is a 32-bit 0 integer. For the floating-point registers, <code>d0</code>–<code>d31</code> refer to the full 128 bits, <code>s0</code>–<code>s31</code> to the low-order 64 bits, and <code>h0</code>–<code>h31</code> to the low-order 32 bits of the registers.</p>&#13;
<p class="indent">Let’s look at some of these registers in more detail. I’ll start with the 31 general-purpose registers, then we’ll look at several registers that have a special purpose. I’ll cover the floating-point registers in <a href="ch19.xhtml">Chapter 19</a>.</p>&#13;
<h4 class="h4" id="ch09lev2sec3"><em><strong>General-Purpose Registers</strong></em></h4>&#13;
<p class="noindent">The general-purpose registers are used for <em>integral data types</em>, such as <code>int</code> and <code>char</code> integer values (signed and unsigned), character representations, Boolean values, and memory addresses. Each bit in each register is numbered from right to left, beginning with 0. So, the rightmost bit is number 0, the next one to the left is 1, and so on. Since there are 64 bits in each general-purpose register, the leftmost bit is number 63.</p>&#13;
<p class="indent">Each instruction in a computer treats a group of bits as a single unit. In the early days, that unit was called a <em>word</em>. Each CPU architecture had a <em>word size</em>. In modern CPU architectures, different instructions operate on different numbers of bits, but the terminology has carried over from the original 32-bit ARM architecture to the current 64-bit architecture. Hence, <span epub:type="pagebreak" id="page_174"/>8 bits is called a <em>byte</em>, 16 bits a <em>halfword</em>, 32 bits a <em>word</em>, 64 bits a <em>doubleword</em>, and 128 bits a <em>quadword</em>.</p>&#13;
<p class="indent">Each of the general-purpose registers, <code>r0</code>–<code>r30</code> in the A64 architecture, can be accessed as either a 32-bit word or a 64-bit doubleword. Our assembler uses <code>w0</code>–<code>w30</code> for the word portion and <code>x0</code>–<code>x30</code> for the doubleword, as shown in <a href="ch09.xhtml#ch9fig3">Figure 9-3</a>.</p>&#13;
<div class="image"><img id="ch9fig3" src="../images/pg202_Image_244.jpg" alt="Image" width="683" height="73"/></div>&#13;
<p class="figcap"><em>Figure 9-3: A64 general-purpose register names</em></p>&#13;
<p class="indent">When an instruction writes to the low-order 32 bits of a register, the high-order 32 bits are set to <code>0</code>.</p>&#13;
<h4 class="h4" id="ch09lev2sec4"><em><strong>Special-Purpose Registers</strong></em></h4>&#13;
<p class="noindent">As you just learned, the program counter register, named <code>pc</code>, contains the address of the current instruction. Software cannot write directly to <code>pc</code>; it can only be modified indirectly with a <em>branch</em> instruction.</p>&#13;
<p class="indent">Although it’s considered a general-purpose register, <em>branch with link</em> instructions use the <code>x30</code> register as a <em>link register</em>, named <code>lr</code>, to pass the return address when a function is called. I’ll explain this in detail in <a href="ch11.xhtml">Chapter 11</a>, but for now keep in mind that you need to be careful how you use the <code>x30</code> register when you write assembly language code.</p>&#13;
<p class="indent">You’re probably used to most things in a computer occurring in multiples of 2, so you might be wondering why there are only 31 general-purpose registers. There is no register named <code>w31</code> or <code>x31</code>. Instead, the A64 architecture treats the 32nd register as a <em>stack pointer</em>, named <code>sp</code>, or a <em>zero register</em>, named <code>wzr</code> or <code>xzr</code>.</p>&#13;
<p class="indent">The <em>stack</em> is a data structure located in memory, and the <code>sp</code> register contains its address. I’ll cover all of this in detail in <a href="ch11.xhtml">Chapter 11</a>. The register name <code>wsp</code> refers to the low-order 32 bits of the stack pointer register. This would be used in specialized cases using 32-bit addressing that I won’t cover in this book.</p>&#13;
<p class="indent">If your algorithm needs the value 0, many instructions allow you to use the <code>wzr</code> register for a 32-bit 0 or the <code>xzr</code> register for a 64-bit 0. If you use an instruction to store a value in the zero register, the value is simply discarded; however, this does actually have a use, as you’ll see when we look at instructions that compare values in <a href="ch13.xhtml">Chapter 13</a>. The zero register does not need to be implemented as a physical register.</p>&#13;
<p class="indent">The condition flags, which you saw in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>, are located in the <code>nzcv</code> register. Several arithmetic and logical operations affect the condition flags, which are in bits 31 to 28 of the <code>nzcv</code> register, as shown in <a href="ch09.xhtml#ch9fig4">Figure 9-4</a>. The other 60 bits in this register are reserved for other uses.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_175"/><img id="ch9fig4" src="../images/pg203_Image_245.jpg" alt="Image" width="683" height="50"/></div>&#13;
<p class="figcap"><em>Figure 9-4: The A64</em> <span class="codeitalic">nzcv</span> <em>register</em></p>&#13;
<p class="indent">The names of the flags and the conditions that cause them to be true (have a value of <code>1</code>) are shown in <a href="ch09.xhtml#ch9tab2">Table 9-2</a>.</p>&#13;
<p class="tabcap" id="ch9tab2"><strong>Table 9-2:</strong> The Condition Flags</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Name</strong></th>&#13;
<th class="tab_th"><strong>Function</strong></th>&#13;
<th class="tab_th"><strong>Condition that sets flag to <span class="codestrong">1</span></strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>N</code></td>&#13;
<td class="bg1">Negative flag</td>&#13;
<td class="bg1">Highest-order bit of result is <code>1</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>Z</code></td>&#13;
<td class="bg">Zero flag</td>&#13;
<td class="bg">Result is <code>0</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>C</code></td>&#13;
<td class="bg1">Carry flag</td>&#13;
<td class="bg1">Shows carry or borrow</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>V</code></td>&#13;
<td class="bg">Overflow flag</td>&#13;
<td class="bg">Overflow of signed integer (two’s complement) arithmetic</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">There are machine instructions for testing the state of the condition flags. For example, there’s an instruction that will branch to another place in the program if the <code>Z</code> flag is <code>1</code>.</p>&#13;
<p class="indent">Next, we’ll look at some C/C++ data types as they relate to the sizes of the general-purpose registers.</p>&#13;
<h3 class="h3" id="ch09lev1sec3"><strong>C/C++ Integral Data Types and Register Sizes</strong></h3>&#13;
<p class="noindent">Every piece of data in a computer program has a <em>data type</em>, which specifies the possible values for the data, the bit patterns used to represent those values, the operations that can be performed on the data, and the data’s semantic usage in the program.</p>&#13;
<p class="indent">Some programming languages, including C, C++, and Java, require the programmer to explicitly state the data types of values used in the program. Other languages, such as Python, BASIC, and JavaScript, can determine a data type from the way the value is used.</p>&#13;
<p class="indent">Most programming languages specify the ranges for values that can be stored in a variable of each data type. For example, in C and C++, an <code>int</code> must be able to store a value in the range –32,768 to +32,767; thus, it must be at least 16 bits in size. An <code>unsigned int</code> must be able to store values in the range 0 to 65,535, so it also must be at least 16 bits. Programming environments can exceed the minimums given in the language specifications.</p>&#13;
<p class="indent">CPU manufacturers specify machine-level data types specific to the CPU architecture, often including specialized data types that are unique to the design. <a href="ch09.xhtml#ch9tab3">Table 9-3</a> gives A64 register sizes for C/C++ data types you can expect from our compilers, <code>gcc</code> and <code>g++</code>, but you should be careful not to count on these sizes to always be the same. The <code>*</code><span class="codeitalic">&lt;data type&gt;</span> notation means a pointer to the memory address of the specified data type.</p>&#13;
<p class="tabcap" id="ch9tab3"><span epub:type="pagebreak" id="page_176"/><strong>Table 9-3:</strong> The Sizes of Some C/C++ Data Types in the A64 Architecture</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Data type</strong></th>&#13;
<th class="tab_th"><strong>Size (bits)</strong></th>&#13;
<th class="tab_th"><strong>Description</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>char</code></td>&#13;
<td class="bg1">8</td>&#13;
<td class="bg1">Byte</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>short</code></td>&#13;
<td class="bg">16</td>&#13;
<td class="bg">Integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>int</code></td>&#13;
<td class="bg1">32</td>&#13;
<td class="bg1">Integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>long</code></td>&#13;
<td class="bg">32</td>&#13;
<td class="bg">Integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>long long</code></td>&#13;
<td class="bg1">64</td>&#13;
<td class="bg1">Integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>float</code></td>&#13;
<td class="bg">32</td>&#13;
<td class="bg">Single-precision floating point</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>double</code></td>&#13;
<td class="bg1">64</td>&#13;
<td class="bg1">Double-precision floating point</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>*</code><span class="codeitalic">&lt;data type&gt;</span></td>&#13;
<td class="bg">64</td>&#13;
<td class="bg">Pointer</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">A value can usually be represented by more than one data type. For example, most people would think of 123 as representing the integer one hundred and twenty-three, but this value could be stored in a computer either as an <code>int</code> or as a <code>char[]</code> (a <code>char</code> array where each element of the array holds one code point for a character).</p>&#13;
<p class="indent">As <a href="ch09.xhtml#ch9tab3">Table 9-3</a> indicates, an <code>int</code> in our C/C++ environment is stored in a word, so 123 would be stored with the bit pattern <code>0x0000007b</code>. As a C-style text string, we’d also need 4 bytes of memory, but the bit patterns would be <code>0x31</code>, <code>0x32</code>, <code>0x33</code>, and <code>0x00</code>—that is, the characters <code>1</code>, <code>2</code>, <code>3</code>, and <code>NUL</code>. (Recall that a C-style string is terminated with a <code>NUL</code> character.)</p>&#13;
<p class="indent">If your solution to a problem depends on data sizes, C standard libraries often define specific sizes. For example, the GNU C libraries define <code>int16_t</code> to be a 16-bit signed integer and <code>u_int16_t</code> to be a 16-bit unsigned integer. In rare cases, you may want to use assembly language to ensure correctness.</p>&#13;
<p class="indent">You can learn a lot about how the CPU works by viewing what takes place in the registers. In the next section, you’ll learn how to view the registers by using the <code>gdb</code> debugger.</p>&#13;
<h3 class="h3" id="ch09lev1sec4"><strong>Using gdb to View the CPU Registers</strong></h3>&#13;
<p class="noindent">I’ll use the program in <a href="ch09.xhtml#ch9list1">Listing 9-1</a> to show you how to use <code>gdb</code> to view the contents of the CPU registers.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>inches_to_feet.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Convert inches to feet and inches.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#define INCHES_PER_FOOT 12&#13;
&#13;
int main(void)&#13;
{&#13;
 <span class="ent">➊</span> register int feet;&#13;
    register int inches;&#13;
 <span class="ent">➋</span> int total_inches;&#13;
    int *ptr;<span epub:type="pagebreak" id="page_177"/>&#13;
    ptr = &amp;total_inches;&#13;
&#13;
    printf("Enter inches: ");&#13;
 <span class="ent">➌</span> scanf("%i", ptr);&#13;
&#13;
    feet = total_inches / INCHES_PER_FOOT;&#13;
    inches = total_inches % INCHES_PER_FOOT;&#13;
    printf("%i\" = %i' %i\"\n", total_inches, feet, inches);&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch9list1"><em>Listing 9-1: A simple program to illustrate the use of</em> <span class="codeitalic">gdb</span> <em>to view CPU registers</em></p>&#13;
<p class="indent">I’ve used the <code>register</code> storage class modifier <span class="ent">❶</span> to request that the compiler use a CPU register for the <code>feet</code> and <code>inches</code> variables, instead of storing them in memory. The <code>register</code> modifier is advisory only; the C language standard doesn’t require the compiler to honor the request. But notice that I didn’t request that the compiler use a CPU register for the <code>total_inches</code> variable <span class="ent">❷</span>. This variable must be placed in memory, as <code>scanf</code> needs a pointer to the location of <code>total_inches</code> <span class="ent">❸</span> to store the value read from the keyboard.</p>&#13;
<p class="indent">I introduced some <code>gdb</code> commands in <a href="ch02.xhtml">Chapter 2</a>. When you hit a breakpoint in a program that has been running, here are some additional commands that you may find useful for moving through the program under your control and viewing information about the program:</p>&#13;
<div class="indL">&#13;
<p class="noindentin"><span class="codestrong">n</span> <strong>(next)</strong> Execute the current source code statement. If it’s a call to a function, the entire function is executed.</p>&#13;
<p class="noindentin"><span class="codestrong">s</span> <strong>(step)</strong> Execute the current source code statement. If it’s a call to a function, step into the function, arriving at the first instruction of the called function.</p>&#13;
<p class="noindentin"><span class="codestrong">si</span> <strong>(step instruction)</strong> Execute the current machine instruction. If it’s a call to a function, step into the function.</p>&#13;
<p class="noindentin"><span class="codestrong">sho arc</span> <strong>(show architecture)</strong> Display the architecture that <code>gdb</code> is currently using. You can use this command to make sure <code>gdb</code> is being used in the AArch64 mode.</p>&#13;
</div>&#13;
<p class="indent">Here’s how I used <code>gdb</code> to control the execution of the program shown in <a href="ch09.xhtml#ch9list1">Listing 9-1</a> and observe the register contents—note that you’ll probably see different addresses if you replicate this example on your own:</p>&#13;
<pre class="pre"><span class="ent">➊</span> <span class="codestrong1">$ gcc -g -Wall -o inches_to_feet inches_to_feet.c</span>&#13;
<span class="ent">➋</span> <span class="codestrong1">$ gdb ./inches_to_feet</span>&#13;
   GNU gdb (Debian 10.1-1.7) 10.1.90.20210103-git&#13;
   --<span class="codeitalic1">snip</span>--&#13;
   Reading symbols from ./inches_to_feet...&#13;
<span class="ent">➌</span> (gdb) <span class="codestrong1">l</span>&#13;
   1       // Convert inches to feet and inches.&#13;
   2<span epub:type="pagebreak" id="page_178"/>&#13;
   3       #include &lt;stdio.h&gt;&#13;
   4       #define INCHES_PER_FOOT 12&#13;
   5&#13;
   6       int main(void)&#13;
   7       {&#13;
   8           register int feet;&#13;
   9           register int inches;&#13;
   10          int total_inches;&#13;
<span class="ent">➍</span> (gdb)&#13;
   11          int *ptr;&#13;
   12&#13;
   13          ptr = &amp;total_inches;&#13;
   14&#13;
   15          printf("Enter inches: ");&#13;
   16          scanf("%i", ptr);&#13;
   17&#13;
   18          feet = total_inches / INCHES_PER_FOOT;&#13;
   19          inches = total_inches % INCHES_PER_FOOT;&#13;
   20          printf("%i\" = %i' %i\"\n", total_inches, feet, inches);&#13;
   (gdb)&#13;
   21&#13;
   22          return 0;&#13;
   23      }</pre>&#13;
<p class="indent">I first compile the program <span class="ent">❶</span> and then load it in <code>gdb</code> <span class="ent">❷</span>. The debugger starts by printing information about itself, which I’ve removed here to save space. I then list the source code <span class="ent">❸</span> so I know where to set breakpoints. Using the <small>ENTER</small> key <span class="ent">❹</span> (<small>RETURN</small> on some keyboards) repeats the previous command (without showing it).</p>&#13;
<p class="indent">I want to follow along as the program processes the data, which I can do by setting breakpoints at strategic points in the program:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">b 15</span>&#13;
Breakpoint 1 at 0x7d8: file inches_to_feet.c, line 15.&#13;
(gdb) <span class="codestrong1">b 18</span>&#13;
Breakpoint 2 at 0x7f4: file inches_to_feet.c, line 18.</pre>&#13;
<p class="indent">I set the first breakpoint where the program is about to prompt the user to enter the input data, at line 15, and a second at the statement where the program’s computations begins, at line 18.</p>&#13;
<p class="indent">When I run the program, it breaks at the first breakpoint it encounters:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">r</span>&#13;
Starting program: /home/progs/chapter_09/inches_to_feet/inches_to_feet&#13;
&#13;
Breakpoint 1, main () at inches_to_feet.c:15&#13;
15          printf("Enter inches: ");</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_179"/>The program stops at line 15 of the source code, and control returns to <code>gdb</code>. The <code>i r</code> command shows the contents of the registers (be sure to type a space between <code>i</code> and <code>r</code>):</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">i r</span>&#13;
x0             0x7fffffef54        549755809620&#13;
x1             0x7ffffff0b8        549755809976&#13;
x2             0x7ffffff0c8        549755809992&#13;
x3             0x55555507c4        366503856068&#13;
x4             0x0                 0&#13;
x5             0xbc0984bf4dff9186  -4897237162606489210&#13;
x6             0x7ff7fb6c58        549621296216&#13;
x7             0x1000000040        68719476800&#13;
x8             0xffffffffffffffff  -1&#13;
x9             0xf                 15&#13;
x10            0x0                 0&#13;
x11            0x0                 0&#13;
x12            0x7ff7e48e48        549619797576&#13;
x13            0x0                 0&#13;
x14            0x0                 0&#13;
x15            0x6fffff4a          1879048010&#13;
x16            0x0                 0&#13;
x17            0x0                 0&#13;
x18            0x7fffffdb20        549755804448&#13;
x19            0x5555550880        366503856256&#13;
x20            0x0                 0&#13;
x21            0x55555506b0        366503855792&#13;
x22            0x0                 0&#13;
x23            0x0                 0&#13;
x24            0x0                 0&#13;
x25            0x0                 0&#13;
x26            0x0                 0&#13;
x27            0x0                 0&#13;
x28            0x0                 0&#13;
x29            0x7fffffef30        549755809584&#13;
x30            0x7ff7e65e18        549619916312&#13;
sp             0x7fffffef30        0x7fffffef30&#13;
pc             0x55555507d8        0x55555507d8 &lt;main+20&gt;&#13;
cpsr           0x60000000          [ EL=0 C Z ]&#13;
fpsr           0x0                 0&#13;
fpcr           0x0                 0</pre>&#13;
<p class="indent">This display tells us the contents of the registers before the user enters data (you’ll see different numbers). We might want to know if the compiler honored our request to use registers for the <code>feet</code> and <code>inches</code> variables, and if it did, which registers it used.</p>&#13;
<p class="indent">We’d like to know this information so we can look at the contents of the registers before and after they’re used by the program to determine if the <span epub:type="pagebreak" id="page_180"/>program is storing the correct values in them. We can answer this question by asking <code>gdb</code> to print the addresses of these two variables:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">print &amp;feet</span>&#13;
Address requested for identifier "feet" which is in register $x20&#13;
(gdb) <span class="codestrong1">print &amp;inches</span>&#13;
Address requested for identifier "inches" which is in register $x19</pre>&#13;
<p class="indent">When we ask for the address of a variable, <code>gdb</code> will give the memory address associated with a programmer-supplied identifier. But in this program I asked the compiler to use registers, and <code>gdb</code> tells us which register the compiler chose for each variable.</p>&#13;
<p class="indent">I didn’t ask the compiler to use registers for the <code>total_inches</code> and <code>ptr</code> variables, so <code>gdb</code> should tell us where they are located in memory:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">print &amp;total_inches</span>&#13;
$1 = (int *) 0x7fffffef54&#13;
(gdb) <span class="codestrong1">print &amp;ptr</span>&#13;
$2 = (int **) 0x7fffffef58</pre>&#13;
<p class="indent">Now that we know <code>x19</code> is being used for <code>inches</code> and <code>x20</code> for <code>feet</code>, we can see what’s currently stored in these two registers before using them for our computations:</p>&#13;
<pre class="pre"><span class="ent">➊</span> (gdb) <span class="codestrong1">i r x19 x20</span>&#13;
   x19            0x5555550880        366503856256&#13;
   x20            0x0                 0</pre>&#13;
<p class="indent">Rather than display all the registers, we can specify the two we want to look at <span class="ent">❶</span>. We know from <a href="ch09.xhtml#ch9tab3">Table 9-3</a> that <code>inches</code> and <code>feet</code> are using only the <code>w19</code> and <code>w20</code> portions of the <code>x19</code> and <code>x20</code> registers, but <code>gdb</code> always shows us the entire 64 bits.</p>&#13;
<p class="indent">Continuing the program’s execution, the program asks the user to enter the number of inches. Here, I respond with <code>123</code>. It then breaks back into <code>gdb</code> at the next breakpoint it encounters:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
Enter inches: <span class="codestrong1">123</span>&#13;
&#13;
Breakpoint 2, main () at inches_to_feet.c:18&#13;
18          feet = total_inches / INCHES_PER_FOOT;</pre>&#13;
<p class="indent">The program is about to compute the number of feet, and then it will compute the remainder of inches. Before starting the computations, let’s make sure the user’s input is stored in the right place:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">print total_inches</span>&#13;
$3 = 123</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_181"/>We’ll now let the program do its computations:</p>&#13;
<pre class="pre">   (gdb) <span class="codestrong1">n</span>&#13;
   19          inches = total_inches % INCHES_PER_FOOT;&#13;
<span class="ent">➊</span> (gdb)&#13;
   20          printf("%i\" = %i' %i\"\n", total_inches, feet, inches);</pre>&#13;
<p class="indent">Pressing the <small>ENTER</small> key repeats the <code>n</code> command <span class="ent">❶</span>. The program is now ready to print out the results of the computations. Let’s check to make sure all the computations were performed correctly and the results are stored in the right places:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">i r x19 x20</span>&#13;
x19            0x3                 3&#13;
x20            0xa                 10</pre>&#13;
<p class="indent">There are other ways to see what’s stored in <code>inches</code> and <code>feet</code>:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">print $x19</span>&#13;
$4 = 3&#13;
(gdb) <span class="codestrong1">print $x20</span>&#13;
$5 = 10&#13;
(gdb) <span class="codestrong1">print inches</span>&#13;
$6 = 3&#13;
(gdb) <span class="codestrong1">print feet</span>&#13;
$7 = 10</pre>&#13;
<p class="indent">When using <code>gdb</code>’s <code>print</code> command, you can print only one variable at a time, even if a register is being used to store the variable. The <code>$</code> prefix on the register name isn’t required for the <code>i r</code> command, but it is for the <code>print</code> command.</p>&#13;
<p class="indent">Before completing execution of the program, let’s take a final look at all the registers:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">i r</span>&#13;
x0             0x78                120&#13;
x1             0x7b                123&#13;
x2             0xa                 10&#13;
x3             0x0                 0&#13;
x4             0x3                 3&#13;
x5             0x7fffffe9f3        549755808243&#13;
x6             0x21a               538&#13;
x7             0x7b                123&#13;
x8             0x7ff7f5a338        549620917048&#13;
x9             0x5                 5&#13;
x10            0xa                 10&#13;
x11            0xffffffffffffffff  -1&#13;
x12            0xffffffc8          4294967240&#13;
x13            0x7fffffeef0        549755809520<span epub:type="pagebreak" id="page_182"/>&#13;
x14            0x2                 2&#13;
x15            0x410               1040&#13;
x16            0x0                 0&#13;
x17            0x0                 0&#13;
x18            0x0                 0&#13;
x19            0x3                 3&#13;
x20            0xa                 10&#13;
x21            0x55555506b0        366503855792&#13;
x22            0x0                 0&#13;
x23            0x0                 0&#13;
x24            0x0                 0&#13;
x25            0x0                 0&#13;
x26            0x0                 0&#13;
x27            0x0                 0&#13;
x28            0x0                 0&#13;
x29            0x7fffffef30        549755809584&#13;
x30            0x55555507f4        366503856116&#13;
sp             0x7fffffef30        0x7fffffef30&#13;
pc             0x5555550848        0x5555550848 &lt;main+132&gt;&#13;
cpsr           0x60200000          [ EL=0 SS C Z ]&#13;
fpsr           0x0                 0&#13;
fpcr           0x0                 0</pre>&#13;
<p class="indent">There’s nothing remarkable in this display, but after you gain some experience looking at such displays, you’ll learn to sometimes spot that something is not right. Now that I’m satisfied that the program performed all the computations correctly, I’ll continue to the end of the program by using <code>c</code> and then exit:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
123" = 10' 3"&#13;
[Inferior 1 (process 2265) exited normally]&#13;
(gdb) <span class="codestrong1">q</span>&#13;
$</pre>&#13;
<p class="indent">The program continues to execute, printing the result and returning control to <code>gdb</code>. Of course, the last thing to do is to exit from <code>gdb</code> with <code>q</code>.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch9exe1">9.1     Modify the program in <a href="ch09.xhtml#ch9list1">Listing 9-1</a> to request that registers be used for the variables <code>total_inches</code> and <code>ptr</code>. Did the compiler allow you to do that? If not, why?</p>&#13;
<p class="box-list1" id="ch9exe2">9.2     Write a program in C that allows you to determine the endianness of your computer (described on <a href="ch02.xhtml#page_33">page 33</a> in <a href="ch02.xhtml">Chapter 2</a>).</p>&#13;
<p class="box-list1" id="ch9exe3"><span epub:type="pagebreak" id="page_183"/>9.3     Modify the program from <a href="ch09.xhtml#ch9exe2">exercise 9.2</a> so you can demonstrate, using <code>gdb</code>, that endianness is a property of the CPU. That is, even though a 32-bit <code>int</code> is stored little-endian in memory, it will be read into a register in the “proper” order.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch09lev1sec5"><strong>What You’ve Learned</strong></h3>&#13;
<div class="indL">&#13;
<p class="noindentin"><strong>General-purpose registers</strong> The thirty-one 64-bit registers in the A64 architecture that provide a small amount of memory for computations in the CPU.</p>&#13;
<p class="noindentin"><strong>Condition flags</strong> Bits that show whether some arithmetic or logic operations produce carry, overflow, or negative or zero values.</p>&#13;
<p class="noindentin"><strong>Program counter</strong> A pointer that holds the address of the instruction currently being executed.</p>&#13;
<p class="noindentin"><strong>Instruction register</strong> Holds the instruction currently being executed.</p>&#13;
<p class="noindentin"><strong>Arithmetic logic unit (ALU)</strong> Performs the specified arithmetic and logic operations.</p>&#13;
<p class="noindentin"><strong>Control unit</strong> Controls the activity in the CPU.</p>&#13;
<p class="noindentin"><strong>Bus interface</strong> Responsible for interfacing the CPU with the main memory and I/O devices.</p>&#13;
<p class="noindentin"><strong>Cache memory</strong> Holds portions of the program, both instructions and data, that are currently being worked on by the CPU. Cache memory is faster than main memory.</p>&#13;
<p class="noindentin"><strong>Instruction execution cycle</strong> Details how the CPU works its way through a list of instructions.</p>&#13;
<p class="noindentin"><strong>C/C++ data type sizes</strong> Data type sizes are closely related to register sizes.</p>&#13;
</div>&#13;
<p class="indent">In the next chapter, you’ll start programming your Raspberry Pi in assembly language.<span epub:type="pagebreak" id="page_184"/></p>&#13;
</div>
</div>
</body></html>