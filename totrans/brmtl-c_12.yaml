- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linker
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter explores in extreme detail how the linking process works. The linker’s
    job is to take all the object files that make up a program and put them together.
    The linker must know exactly what the memory layout of your device is so it can
    fit the program into memory. It’s also responsible for connecting external symbols
    in one file with their actual definitions in another. This process is called *linking
    symbols*.
  prefs: []
  type: TYPE_NORMAL
- en: It is the linker that knows exactly where things are. On big systems where we
    have gigabytes of memory, this doesn’t matter that much, but on a microcontroller
    with 16KB of RAM, knowing what every byte is used for is important.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at a typical problem that shows how better understanding the
    linker can be helpful. Say you have a system in the field that’s crashing. When
    it crashes, it prints a stack trace showing the call stack that details the faults
    leading up to the problem (see [Listing 11-1](#listing11-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: A sample stack trace'
  prefs: []
  type: TYPE_NORMAL
- en: This tells you that the fault was in the function whose address is `0x0000000000001136`.
  prefs: []
  type: TYPE_NORMAL
- en: Since you didn’t write your program using absolute addresses, the name of the
    function would be more useful to you. That’s where the linker map comes in.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-2](#listing11-2) shows an excerpt from the map of this program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: An excerpt from the map of the program in [Listing 11-1](#listing11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We aborted at `0x1136` in [Listing 11-1](#listing11-1). In [Listing 11-2](#listing11-2),
    function `three` starts at `0x1129` and goes on until the next function at `0x113e`.
    In fact, we are 13 bytes into function `three`, so we are somewhere near the start
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-1](#listing11-1) shows that function `three` was called by someone
    at address `0x1150`. [Listing 11-2](#listing11-2) shows that function `two` goes
    from `0x113e` to `0x1153`, so it called `three`. Using a similar analysis, we
    can tell that `two` was called by `one`, and `one` was called by `main`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linker’s Job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The linker’s job is to take the object files that make up the program and put
    them together to form a single program file. An object file contains code and
    data organized into named sections. (The actual names of the sections are compiler-dependent.
    Advanced programmers can even make up their own names.)
  prefs: []
  type: TYPE_NORMAL
- en: The sections in the object file have no fixed address. They are said to be *relocatable*,
    which means they can be put almost anywhere, but the linker puts them in a specific
    place in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM chip contains two types of memory: random access memory (RAM) and flash.
    RAM is where the variables go. One problem with this type of memory is that all
    the data is lost when the power goes off. Flash memory, for all practical purposes,
    is a type of read-only memory. (You can write to it if you’re very clever with
    the I/O system.) The data in flash memory is not erased when the system loses
    power.'
  prefs: []
  type: TYPE_NORMAL
- en: The linker takes the data from all the object files and packs it into the RAM.
    It then splits up the remaining RAM into the stack and the heap. The code and
    read-only data get put in the flash memory. This description is somewhat oversimplified,
    but we’ll leave the details for later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The final thing the linker does is write out a map file telling you where it
    put everything. Why do we care where the linker puts things? After all, the principal
    thing is that the program gets put in the memory. When it comes to debugging in
    the field, however, we need to know where things are. Also, there are times when
    we may want to define specialized memory sections or attach additional memory
    chips to our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then there’s the big reason: the firmware upgrade. It has been said that
    the hardware people have to get the hardware right the first time. The only thing
    the software people have to get right is the firmware upgrade. But how do you
    use the running software to replace the running software? And more importantly,
    how do you do it without bricking your system? (*Bricking* refers to a failed
    upgrade process that turns your system into something about as useful as a brick.)
    That involves some tricky programming, which I’ll explain near the end of this
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Compilation and Linking Memory Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *memory model* describes how memory is specified in a system. Basically, memory
    is divided into named sections. The C standard, the object files, and the ARM
    chip all use different names to describe their memory. Worse, it is possible to
    define custom names through C language extensions. The linker must then be told
    what to do with those custom sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Ideal C Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Everything in a C program ideally will go into one of the standard sections:
    `text`, `data`, or `bss`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read-only instructions and read-only data go in the `text` section. Here, both
    the code for `main` and the text string (read-only) go in the `text` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialized data (initialized global variables) goes in the `data` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Uninitialized data (uninitialized global variables) goes in the `bss` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Technically, `bss` is uninitialized according to the standard. However, in every
    implementation I’ve seen of a C programming system, the `bss` section is initialized
    to zero.
  prefs: []
  type: TYPE_NORMAL
- en: The data for these sections is allocated at compile time. The C compiler will
    spit out an object file that says, “I need this much `text`, and here are the
    contents. I need this much `data`, and here are the contents. I need this much
    `bss`, with no contents specified.”
  prefs: []
  type: TYPE_NORMAL
- en: The `size` command shows how much space your program is using in each section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The object file uses 481 bytes of `text`, 4 bytes of `data`, and another 4 bytes
    of `bss`. The total number of bytes for all three is 489, or 1e9 in hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: The ideal C model has two other memory sections. However, they are not allocated
    by the compiler; they are allocated by the linker. These are the *stack* and the
    *heap*. The stack is used for local variables and is dynamically allocated as
    procedures are called. The heap is a pool of memory that can be dynamically allocated
    and freed (more on the heap in Chapter 13).
  prefs: []
  type: TYPE_NORMAL
- en: The compiler takes our variable definitions and assigns them to memory sections.
    Those sections use a different namespace from the ideal C memory section names.
    In some cases the names are similar, and in some cases they are completely different.
    Different compilers and even different versions of the same compiler might use
    different names for the sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-3](#listing11-3) shows a program that contains every type of data
    we’ve discussed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-3: Examples of data types'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what our GNU GCC compiler does with our sample program from [Listing
    11-3](#listing11-3)—specifically, how it really allocates memory for the various
    types of variables and data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here’s `initializedGlobal` from [Listing 11-3](#listing11-3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `.global` directive tells the assembler that this is a global symbol and
    can be referred to by other object files. The `.data` directive tells the assembler
    that what follows goes in the `.data` section. So far, we’re following the ideal
    C memory model naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: The `.align` directive tells the assembler that the following data should be
    aligned on a 4-byte boundary. (The last 2 bits of the address must be zero, thus
    the `.align 2`.) Finally, there is the `initializedGlobal` label and the `.word
    1` data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a variable is initialized to zero (`initializedToZero` in [Listing 11-3](#listing11-3)),
    we see slightly different code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, the compiler uses the `.bss` directive to put the variable in the `bss`
    section. It also uses the `.space` directive instead of `.word`, which tells the
    assembler that this variable takes up 4 bytes of space and to initialize those
    bytes to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s deal with an uninitialized global variable (`uninitializedGlobal`
    from [Listing 11-3](#listing11-3)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `.comm` section tells the assembler to define a symbol that is 4 bytes long
    and aligned on a 4-byte boundary. The symbol goes into a memory section called
    `COMMON`. In this case, the section name does not follow the ideal C memory model
    naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement that defines `aString` in [Listing 11-3](#listing11-3) also defines
    a string constant (`"A string."`). The string constant is read-only, while the
    pointer (`aString`) is read/write. Here’s the generated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, the compiler must generate the constant for `"A string."`. It generates
    an internal name (`.LC0`) for this constant, and the contents of this constant
    are generated with the `.ascii` assembler directive. The `.section .rodata` directive
    puts the constant in a linker section called `.rodata`. (The ideal C memory model
    calls this `text`.)
  prefs: []
  type: TYPE_NORMAL
- en: Now we come to the definition of the variable itself, `aString`. The `.data`
    directive puts it in the `data` section. Since it’s a pointer, it is initialized
    with the address of the string (namely, `.LC0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last major section is the one that contains the code. The ideal C memory
    model calls this `text`. Here’s the assembly listing for the start of `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The name for this section is `text.main`. In this case, the compiler decided
    to take the `text` prefix and add on the name of the module (`main`) to form the
    section name.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered the major memory sections that the compiler knows about, so next
    let’s look at the code generated by some other types of declarations. The `static`
    keyword used outside any procedure indicates a variable that can be used only
    within the current module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code that creates the `initializedModule` variable from [Listing
    11-3](#listing11-3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It looks pretty much the same as `initializedGlobal`, only the `.global` directive
    is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `uninitializedModule` variable from [Listing 11-3](#listing11-3)
    looks much like `uninitializedGlobal`, only again, we are missing the `.global`
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we come to the variables declared `static` inside a procedure. These variables
    are allocated at compile time in main memory, but their scope is local to the
    procedure where they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `uninitializedStatic` variable from [Listing 11-3](#listing11-3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It looks like any uninitialized local, except the compiler changed the name
    of the variable from `uninitializedStatic` to `uninitializedStatic.4108`. Why?
    Each block, or section of code enclosed in curly brackets (`{}`), can have its
    own `uninitializedStatic` variable. The scope of the C variable name is local
    to the block in which it is defined. The scope of the assembly language is the
    entire file, so the compiler makes the name unique by appending a unique random
    number to the end of the variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `initializedStatic` variable looks pretty much like its global
    brother:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `.global` is missing and the name has been transformed by
    the addition of a suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Nonstandard Sections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve discussed the standard memory sections that the GNU toolchain generates.
    The STM32 chips use a custom section named `.isr_vector`, and it must be the first
    data programmed into the flash memory because the ARM hardware uses this section
    of memory to service interrupts and other hardware-related functions. [Table 11-1](#table11-1),
    adapted from the STM32F030x4 manual, describes the interrupt vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-1: Interrupt Vector Documentation (Truncated)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Position** | **Priority** | **Type of priority** | **Acronym** | **Description**
    | **Address** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| — | — | — | — | Reserved | `0x0000 0000` |'
  prefs: []
  type: TYPE_TB
- en: '| — | –3 | Fixed | Reset | Reset | `0x0000 0004` |'
  prefs: []
  type: TYPE_TB
- en: '| — | –2 | Fixed | NMI | Non-maskable interrupt. The RCC Clock Security System
    (CSS) is linked to the NMI vector. | `0x0000 0008` |'
  prefs: []
  type: TYPE_TB
- en: '| — | –1 | Fixed | HardFault | All class of fault | `0x0000 000C` |'
  prefs: []
  type: TYPE_TB
- en: '| — | 3 | Settable | SVCall | System service call via SWI instruction | `0x0000
    002C` |'
  prefs: []
  type: TYPE_TB
- en: '| — | 5 | Settable | PendSV | Pendable request for system service | `0x0000
    0038` |'
  prefs: []
  type: TYPE_TB
- en: '| — | 6 | Settable | SysTick | System tick timer | `0x0000 003C` |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 7 | Settable | WWDG | Window watchdog interrupt | `0x0000 0040` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 |  |  | Reserved |  | `0x0000 0044` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 9 | Settable | RTC | RTC interrupts (combined EXTI lines 17, 19, and
    20) | `0x0000 0048` |'
  prefs: []
  type: TYPE_TB
- en: 'The STM firmware file *startup_stm32f030x8.s* (an assembly language file) contains
    the code that defines this table. Here’s an excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first line tells the linker that the table goes in a section called `.isr_vector`.
    This section is highly hardware-specific, precisely defined, and must go in exactly
    the right place. Otherwise, nothing will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code defines an array called `g_pfnVectors` that contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The address of the initial stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The address reset handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The address of the non-maskable interrupt (NMI) handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other interrupt vectors, as described in [Table 11-1](#table11-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll see how the linker handles this code in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Linking Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The compiler and assembler produced a set of object files that divide up the
    code and data into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text.``<name>` Read-only data and code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rodata` Read-only data'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`data` Initialized data'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bss` Data initialized to zero (slightly different definition from the one
    the ideal C memory model uses)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`COMMON` Uninitialized data'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.isr_vector` Interrupt and reset handlers that must go in a specific place'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The linker is controlled by a script named *LinkerScript.ld*, which is part
    of each STM32 Workbench project. The script tells the linker that the system’s
    memory consists of two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Flash, starting at `0x8000000`, 64KB long
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RAM, starting at `0x20000000`, 8KB long
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The linker’s job is to take the data from the object files and pack it into
    memory via the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the `.isr_vector` section at the beginning of flash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put all the data from the `.text.*` sections into flash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the `.rodata` section into flash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the `.data` section into RAM, however the initializers for the `.data` section
    go into flash (we’ll discuss this more later).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the `.bss` section into RAM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, load the `COMMON` section into RAM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `.data` section is the tricky one. Consider the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The linker allocates space in RAM for `initializedGlobal`. The initializer (`1234`)
    goes into flash. At startup, the initializers are copied as a block into RAM to
    initialize the `.data` section.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols Defined by the Linker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During the linking process, the linker defines some important symbols, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_sidata` Start of the initializers for the `.data` section in flash'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_sdata` Start of the `.data` section in RAM'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_edata` End of the `.data` section in RAM'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_sbss` Start of the `.bss` and `COMMON` sections in RAM'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_ebss` End of the `.bss` and `COMMON` sections in RAM'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_estack` Last address of RAM'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon reset, the code in *startup_stm32f030x8.S* executes and performs the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the stack register with `_estack`. The stack will grow down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill the section of memory from `_sdata` to `_edata` with the initialization
    values stored starting at `_sidata`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Zero the memory between `_sbss` and `_ebss`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the function `SystemInit` to initialize the STM32 chip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the function `__libc_init_array` to initialize the C library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop forever.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relocation and Linking Object Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of object files: *absolute* and *relocatable*. An absolute
    file defines everything in terms of a fixed (absolute) address. In other words,
    the symbol `main` is at `0x7B0`, and it cannot be set to another address by the
    linker or any other tool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A relocatable object file is designed to have the location of its data move
    around (relocate). For example, the *main.c* source file produces the *main.o*
    object file. If we look at the assembly listing, we see the symbol `main` is defined
    at `0000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This symbol is relative to the section where it resides (namely, `text.main`).
    Because the object file is relocatable, `text.main` can be located anywhere in
    memory. In this case, the linker decided to put it in flash memory at `0x00000000080007b0`.
    (We found this value using the linker map, which is discussed in the next section.)
    Because `main` is at the beginning of this segment, it gets the value `0x00000000080007b0`.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the linker process, the linker takes the relocatable object files
    and assigns them a location in the memory. The result is a program file with absolute
    addresses for each object file.
  prefs: []
  type: TYPE_NORMAL
- en: The linker also links the object files together. For example, the *startup_stm32f030x8.S*
    file calls `main`. The problem is that this code doesn’t know where `main` is.
    It’s defined in another module (*main.o*), so at link time, the linker will see
    that *startup_stm32f030x8.S* needs to know where the `main` symbol is defined
    and will perform a link operation between the *startup_stm32f030x8.S* call to
    `main` and the absolute address of main (`0x7B0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A library is a collection of object (*.o*) files in an archive format (similar
    to *.zip*, but not as sophisticated). The linker script tells the linker to include
    the libraries *libc.a*, *libm.a*, and *libgcc.a*. For example, the *libm.a* library
    contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When processing a library, the linker will load an object file only if it defines
    a symbol that your program needs. For example, if your program uses the `sin`
    function, it will link in the object *s_sin.o* file that defines this function.
    If you don’t use the `sin` function, then the linker knows you don’t need the
    code in *s_sin.o* and therefore will not link in the file.
  prefs: []
  type: TYPE_NORMAL
- en: The Linker Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the linker loads data into the program, it produces a map file (*Debug/output.map*)
    that contains information about where our code and data are. This map file is
    very complete and contains a lot of useful information as well as a lot of stuff
    we don’t care about. For example, it tells us what our memory configuration looks
    like, which shows the various types of memory and their locations for our processor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this case, our chip has `FLASH` memory, which has the read (`r`) and execute
    (`x`) attributes set. It starts at `0x8000000` and goes on for `0x10000` bytes.
    The `RAM` section starts at `0x20000000` and goes on for only `0x2000` bytes.
    It is readable (`r`), writable (`w`), and executable (`x`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the `.isr_vector` section is loaded first. The linker
    map tells us where this is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The address `0x8000000` is the start of flash. The hardware expects the interrupt
    vector to be at this address, so that is a good thing. The other bit of information
    is that this section is `0xc0` bytes long.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` symbol is defined in *src/main.o*. It is part of the `.text.main`
    segment and is located at `0x0000000008000138`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It also contains a bit of code (`0x60` bytes, which is large considering [Listing
    11-3](#listing11-3) is a nothing program).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see where our global variables are located. For example, here’s
    the location for `uninitializedGlobal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The linker map provides the absolute address of every variable and function
    in this program. Why is that useful? When we are debugging in the field (no JTAG
    debugger), frequently we have only absolute addresses, so if your program suffers
    a fatal error and you see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: on the debug console, you’ll know the error occurred `0x20` bytes into `main`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been using an *external* debugger with our STM board. This system consists
    of a host computer running the debugger, a JTAG debugging pod, and a target machine.
    The debugger on the host computer has access to the source code and the symbol
    table (from the linker). When it detects an error at `0x8000158`, it can look
    into the symbol table, see that the error occurred `0x20` bytes into the program,
    figure out on which line the error occurred, and display in the source file a
    big red arrow pointing to where the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Some systems have an *internal* debugger, where the debugger and all the files
    it needs are on the target system. Some internal debuggers provide the ability
    to dump memory based on absolute addresses. Such debuggers are small and dumb,
    yet they can be surprisingly useful when it comes to debugging in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have such a debugger and need to know the value of `uninitializedGlobal`.
    A dumb debugger doesn’t know anything about symbol names. It dumps memory based
    on address, and that’s it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, you do know about symbol names. You’ve got the linker map,
    so you can tell the debugger to display a 4-byte value at location `0x20000464`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This sort of debugging is primitive and difficult, but sometimes with embedded
    systems, it’s the only way to perform debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you’re wondering why we don’t tell the debugger where `uninitializedGlobal`
    is, which would make things much easier. The problem is that a symbol table takes
    up a lot of space, and we are space-limited. Also, having the symbol table on
    the system itself is a security risk. (A hacker would just love to know the address
    of `passwordCheckingFunction`!)
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Linker Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve used the linker only with the default settings. However, there
    will be times when you’ll want to perform more advanced functions than what you
    get with the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Flash Memory for “Permanent” Storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the problems with the default C memory model is that all your data is
    reset when the program starts. On the STM32, this means resetting the device causes
    it to lose all data. Suppose you want to keep some configuration data around between
    boots. The default setup won’t let that happen. How do we do it?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the serial “Hello World” program from Chapter 9. We’re going
    to add a counter that tells how many times the system has booted and then write
    a message with the reset count to the serial device.
  prefs: []
  type: TYPE_NORMAL
- en: Our design is simple. We’re going to take the top 4KB of flash and use it for
    configuration data. We’ll give it the imaginative name of `CONFIG`, and we’ll
    define a new memory section called `.config` in which we’ll put our reset variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the C code to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to modify the linker script to handle our new section. We start
    by dividing up the flash memory into two sections. The first will be the traditional
    flash memory we discussed earlier. The second, `CONFIG`, will hold our configuration
    data, which means we need to edit *LinkerScript.ld* and replace this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This reduces the size of `FLASH` by 4KB and then uses that 4KB for the memory
    section called `CONFIG`.
  prefs: []
  type: TYPE_NORMAL
- en: Flash is different from normal memory in that you can write it only once before
    you must erase it. Erasing must be done a page at a time. In the STM32’s case,
    that means our `CONFIG` section must be at least 1KB long and must be a multiple
    of 1KB in size. We’ve chosen 4KB because we will probably want to store a lot
    more configuration data later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to tell the linker to put the `.config` section into the memory
    block called `CONFIG`. This is done by adding the following to the `SECTIONS`
    portion of the *LinkerScript.ld* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing this variable is not as simple as just writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A whole sequence of steps is needed to program the chip. We’ve put all the steps
    in a function called `updateCounter`, shown in [Listing 11-4](#listing11-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-4: The `updateCounter` procedure'
  prefs: []
  type: TYPE_NORMAL
- en: The flash memory on the STM32 chip is protected, so we need to unprotect it
    by calling `HAL_FLASH_Unlock` 1. This function writes two password values to the
    flash protection system that enable the writing of flash. However, we still can’t
    write `resetCount` directly to flash, so instead we assign `resetCount` (a flash
    value) to `newResetCount` (a regular variable) 2, which we can increment.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can write to flash, we must erase it, and the smallest unit we can
    erase is a page. We first need to initialize a structure 3 to specify how many
    pages to erase at what address, and then pass this as a parameter to `HAL_FLASHEx_Erase`
    to erase the memory 4.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the memory holding `resetCount` has been erased, we can write it. Unfortunately,
    we have a 32-bit value, and the flash memory writes only 16 bits at a time, so
    we use another HAL function, `HAL_FLASH_Program` 5, to do the job.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-5](#listing11-5) shows the whole program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-5: The reset counting program'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Configuration Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose we want to keep more than one configuration variable in flash memory.
    The problem is that flash memory is not ordinary memory. After you store a value
    in a flash memory variable, you cannot change it until you erase the entire memory
    page containing the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'That works fine when you store one variable per page (a very wasteful way of
    doing things), but how do you store multiple configuration variables in memory
    and update one? It requires a little work. Here is the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Save all the configuration variables in RAM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the value you need to change in RAM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Erase all the configuration variables in flash. (Erase the flash page.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the RAM version back into flash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 11-6](#listing11-6) shows an outline of the code to declare a configuration
    structure in the `.config` section and update a value in the `struct`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-6: Updating the configuration in flash'
  prefs: []
  type: TYPE_NORMAL
- en: A number of problems are associated with flash memory. As mentioned previously,
    the first problem is that an entire page must be erased in order to write a single
    word. It takes time to write a page into flash, and it’s possible for the system
    to be powered off or reset while you are writing. If that happens, the write will
    be incomplete and your configuration data will be corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: A solution to this is to have two configuration sections, a primary and a backup,
    that each contain a checksum. The program first tries to read the primary configuration.
    If the checksum is bad, it reads the second. Because only one configuration is
    written at a time, you can be pretty sure that either the primary or the secondary
    is going to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with flash is that it suffers from *memory wear*. You can go
    through only so many program/erase cycles before the memory becomes corrupted.
    Depending on the type of flash being used, this can be between 100,000 and 1,000,000
    cycles. So, using the flash memory to store a configuration that is expected to
    change at the rate of once per month will work. Using it for something that will
    change several times a second will quickly wear out the memory.
  prefs: []
  type: TYPE_NORMAL
- en: There are ways of programming around the limits of flash memory. You also can
    add external memory chips to your system that don’t have the design limitations
    of flash.
  prefs: []
  type: TYPE_NORMAL
- en: Field Customization Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we work for a company that makes alarms. These alarms go out to alarm
    service companies who install them at end-user sites. Now, Joe’s Alarm Company
    and Bait Shop is not going to be happy if the alarm panel it installs shows an
    Acme Alarm Maker logo when it boots. Joe is into branding and wants his own logo
    to appear, which means we need to give customers a way of customizing the logos
    inside their boxes. We can reserve a section of memory for the logo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now the question is, how do we get the logo into the system? We could program
    it at the factory, but that would mean every time we shipped a unit, someone would
    have to open the box, plug in the device, program the logo, and put it back in
    the box, which is an expensive operation.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we could let the customers do it themselves. We’d give them a cable
    and some software and let them program the logo. We can sell that ability as a
    feature that allows customers to update units with a new logo if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The programming can be accomplished using the same hardware and software we
    use to load our code into flash, or we can write an onboard program that takes
    data off the serial line and programs it into the `LOGO` memory.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a logo is a simple customization to perform. Also, if the replacement
    is botched, a bad logo won’t stop the system. However, replacing the firmware
    is another matter.
  prefs: []
  type: TYPE_NORMAL
- en: Firmware Upgrade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Upgrading software while you are running that software is a bit tricky, but
    there are several ways to do it. One of the simplest is to divide up the flash
    memory into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The bootloader
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Program section 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Program section 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bootloader is a very small program that will never be upgraded. It has a
    rather simple job to do, so hopefully we’ll get it right the first time. The program
    sections contain a complete version of the program. They also contain a program
    version number and a checksum.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bootloader’s job is to decide which program section should be used. It
    verifies the checksum for the two sections and then decides which one to use based
    on the following calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is the general idea, but we’ve skipped some bookkeeping steps. For example,
    the interrupt table in the `.isr_vector` section needs to be changed so that all
    interrupts go to the proper place.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory is a limited resource, especially when you’re doing embedded programming.
    You need to know exactly where your memory is located and how to get the most
    out of it.
  prefs: []
  type: TYPE_NORMAL
- en: The linker’s job is to take the pieces of your program, link them together,
    and produce a program that you can load into memory. For simple programs, the
    default configuration works well. However, as you get into more advanced systems,
    you’ll need to control more precisely exactly what’s being done with your limited
    memory resources, so understanding the linker is vital to being an effective embedded
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify the config program ([Listing 11-6](#listing11-6)) so that the `CONFIG`
    segment does not start on a page boundary. What happens?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the config program so that instead of printing a single-digit reset number,
    the program prints a complete number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The linker script defines a number of symbols to indicate the start and end
    of a memory area. Examine the linker script or linker map to find the symbols
    that define the start and end of the text area. Using these symbols, print the
    size of the text area. Use the `arm-none-eabi-size` command to verify your result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the same techniques to print the amount of stack space allocated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Advanced: Print the stack space left. This will require reading the current
    value of the stack register into a variable using the `asm` keyword.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figuring out what’s in a binary file can be very useful, and the GNU toolchain
    has a number of programs to do so. Examine the documentation for the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`objdump`, which dumps object file information'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nm`, which lists the symbols in a file'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ar`, which creates libraries or extracts information and files from them'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`readelf`, which displays information on elf (program) files'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
