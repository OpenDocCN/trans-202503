- en: Chapter 51. Introduction to POSIX IPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The POSIX.1b realtime extensions defined a set of IPC mechanisms that are analogous
    to the System V IPC mechanisms described in [Chapter 45](ch45.html "Chapter 45. Introduction
    to System V IPC") to [Chapter 48](ch48.html "Chapter 48. System V Shared Memory").
    (One of the POSIX.1b developers’ aims was to devise a set of IPC mechanisms that
    did not suffer the deficiencies of the System V IPC facilities.) These IPC mechanisms
    are collectively referred to as POSIX IPC. The three POSIX IPC mechanisms are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Message queues* can be used to pass messages between processes. As with System
    V message queues, message boundaries are preserved, so that readers and writers
    communicate in units of messages (as opposed to the undelimited byte stream provided
    by a pipe). POSIX message queues permit each message to be assigned a priority,
    which allows high-priority messages to be queued ahead of low-priority messages.
    This provides some of the same functionality that is available via the type field
    of System V messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Semaphores* permit multiple processes to synchronize their actions. As with
    System V semaphores, a POSIX semaphore is a kernel-maintained integer whose value
    is never permitted to go below 0\. POSIX semaphores are simpler to use than System
    V semaphores: they are allocated individually (as opposed to System V semaphore
    *sets*), and they are operated on individually using two operations that increase
    and decrease a semaphore’s value by one (as opposed to the ability of the *semop()*
    system call to atomically add or subtract arbitrary values from multiple semaphores
    in a System V semaphore set).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shared memory* enables multiple processes to share the same region of memory.
    As with System V shared memory, POSIX shared memory provides fast IPC. Once one
    process has updated the shared memory, the change is immediately visible to other
    processes sharing the same region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter provides an overview of the POSIX IPC facilities, focusing on their
    common features.
  prefs: []
  type: TYPE_NORMAL
- en: API Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three POSIX IPC mechanisms have a number of common features. [Table 51-1](ch51.html#summary_of_programming_interfaces_for_po
    "Table 51-1. Summary of programming interfaces for POSIX IPC objects") summarizes
    their APIs, and we go into the details of their common features in the next few
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Except for a mention in [Table 51-1](ch51.html#summary_of_programming_interfaces_for_po
    "Table 51-1. Summary of programming interfaces for POSIX IPC objects"), in the
    remainder of this chapter, we’ll overlook the fact that POSIX semaphores come
    in two flavors: named semaphores and unnamed semaphores. Named semaphores are
    like the other POSIX IPC mechanisms that we describe in this chapter: they are
    identified by a name, and are accessible by any process that has suitable permissions
    on the object. An unnamed semaphore doesn’t have an associated identifier; instead,
    it is placed in an area of memory that is shared by a group of processes or by
    the threads of a single process. We go into the details of both types of semaphores
    in [Chapter 53](ch53.html "Chapter 53. POSIX Semaphores").'
  prefs: []
  type: TYPE_NORMAL
- en: Table 51-1. Summary of programming interfaces for POSIX IPC objects
  prefs: []
  type: TYPE_NORMAL
- en: '| Interface | Message queues | Semaphores | Shared memory |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Header file | `<mqueue.h>` | `<semaphore.h>` | `<sys/mman.h>` |'
  prefs: []
  type: TYPE_TB
- en: '| Object handle | *mqd_t* | *sem_t ** | *int* (file descriptor) |'
  prefs: []
  type: TYPE_TB
- en: '| Create/open | *mq_open()* | *sem_open()* | *shm_open()* + *mmap()* |'
  prefs: []
  type: TYPE_TB
- en: '| Close | *mq_close()* | *sem_close()* | *munmap()* |'
  prefs: []
  type: TYPE_TB
- en: '| Unlink | *mq_unlink()* | *sem_unlink()* | *shm_unlink()* |'
  prefs: []
  type: TYPE_TB
- en: '| Perform IPC | *mq_send()*,*mq_receive()* | *sem_post(), sem_wait()*,*sem_getvalue()*
    | operate on locations in shared region |'
  prefs: []
  type: TYPE_TB
- en: '| Miscellaneous operations | *mq_setattr()*—set attributes*mq_getattr()*—get
    attributes*mq_notify()*—request notification | *sem_init()*—initializeunnamed
    semaphore*sem_destroy()*—destroyunnamed semaphore | (none) |'
  prefs: []
  type: TYPE_TB
- en: IPC object names
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To access a POSIX IPC object, we must have some means of identifying it. The
    only portable means that SUSv3 specifies to identify a POSIX IPC object is via
    a name consisting of an initial slash, followed by one of more nonslash characters;
    for example, `/myobject`. Linux and some other implementations (e.g., Solaris)
    permit this type of portable naming for IPC objects.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, names for POSIX shared memory and message queue objects are limited
    to `NAME_MAX` (255) characters. For semaphores, the limit is 4 characters less,
    since the implementation prepends the string *sem*. to the semaphore name.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 doesn’t prohibit names of a form other than `/myobject`, but says that
    the semantics of such names are implementation-defined. The rules for creating
    IPC object names on some systems are different. For example, on Tru64 5.1, IPC
    object names are created as names within the standard file system, and the name
    is interpreted as an absolute or relative pathname. If the caller doesn’t have
    permission to create a file in that directory, then the IPC *open* call fails.
    This means that unprivileged programs can’t create names of the form `/myobject`
    on Tru64, since unprivileged users normally can’t create files in the root directory
    (`/`). Some other implementations have similar implementation-specific rules for
    the construction of the names given to IPC *open* calls. Therefore, in portable
    applications, we should isolate the generation of IPC object names into a separate
    function or header file that can be tailored to the target implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating or opening an IPC object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each IPC mechanism has an associated *open* call (*mq_open(), sem_open()*,
    or *shm_open()*), which is analogous to the traditional UNIX *open()* system call
    used for files. Given an IPC object name, the IPC *open* call either:'
  prefs: []
  type: TYPE_NORMAL
- en: creates a new object with the given name, opens that object, and returns a handle
    for it; or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: opens an existing object and returns a handle for that object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handle returned by the IPC *open* call is analogous to the file descriptor
    returned by the traditional *open()* system call—it is used in subsequent calls
    to refer to the object.
  prefs: []
  type: TYPE_NORMAL
- en: The type of handle returned by the IPC *open* call depends on the type of object.
    For message queues, it is a message queue descriptor, a value of type *mqd_t*.
    For semaphores, it is a pointer of type *sem_t **. For shared memory, it is a
    file descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the IPC *open* calls permit at least three arguments—*name*, *oflag*,
    and *mode*—as exemplified by the following *shm_open()* call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These arguments are analogous to the arguments of the traditional UNIX *open()*
    system call. The *name* argument identifies the object to be created or opened.
    The *oflag* argument is a bit mask that can include at least the following flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`O_CREAT`'
  prefs: []
  type: TYPE_NORMAL
- en: Create the object if it doesn’t already exist. If this flag is not specified
    and the object doesn’t exist, an error results (`ENOENT`).
  prefs: []
  type: TYPE_NORMAL
- en: '`O_EXCL`'
  prefs: []
  type: TYPE_NORMAL
- en: If `O_CREAT` is also specified and the object already exists, an error results
    (`EEXIST`). The two steps—check for existence and creation—are performed atomically
    ([Atomicity and Race Conditions](ch05.html#atomicity_and_race_conditions "Atomicity
    and Race Conditions")). This flag has no effect if `O_CREAT` is not specified.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of object, *oflag* may also include one of the values
    `O_RDONLY`, `O_WRONLY`, or `O_RDWR`, with meanings similar to *open()*. Additional
    flags are allowed for some IPC mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining argument, *mode*, is a bit mask specifying the permissions to
    be placed on a new object, if one is created by the call (i.e., `O_CREAT` was
    specified and the object did not already exist). The values that may be specified
    for *mode* are the same as for files ([Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Regular
    Files](ch15.html#permissions_on_regular_files "Permissions on Regular Files")).
    As with the *open()* system call, the permissions mask in *mode* is masked against
    the process umask ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")). The ownership and group ownership
    of a new IPC object are taken from the effective user and group IDs of the process
    making the IPC *open* call. (To be strictly accurate, on Linux, the ownership
    of a new POSIX IPC object is determined by the process’s file-system IDs, which
    normally have the same value as the corresponding effective IDs. Refer to Section
    9.5.)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On systems where IPC objects appear in the standard file system, SUSv3 permits
    an implementation to set the group ID of a new IPC object to the group ID of the
    parent directory.
  prefs: []
  type: TYPE_NORMAL
- en: Closing an IPC object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For POSIX message queues and semaphores, there is an IPC *close* call that indicates
    that the calling process has finished using the object and the system may deallocate
    any resources that were associated with the object for this process. A POSIX shared
    memory object is closed by unmapping it with *munmap()*.
  prefs: []
  type: TYPE_NORMAL
- en: IPC objects are automatically closed if the process terminates or performs an
    *exec()*.
  prefs: []
  type: TYPE_NORMAL
- en: IPC object permissions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: IPC objects have a permissions mask that is the same as for files. Permissions
    for accessing an IPC object are similar to those for accessing files ([Permission-Checking
    Algorithm](ch15.html#permission-checking_algorithm "Permission-Checking Algorithm")),
    except that execute permission has no meaning for POSIX IPC objects.
  prefs: []
  type: TYPE_NORMAL
- en: Since kernel 2.6.19, Linux supports the use of access control lists (ACLs) for
    setting the permissions on POSIX shared memory objects and named semaphores. Currently,
    ACLs are not supported for POSIX message queues.
  prefs: []
  type: TYPE_NORMAL
- en: IPC object deletion and object persistence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with open files, POSIX IPC objects are *reference counted*—the kernel maintains
    a count of the number of open references to the object. By comparison with System
    V IPC objects, this makes it easier for applications to determine when the object
    can be safely deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Each IPC object has a corresponding *unlink* call whose operation is analogous
    to the traditional *unlink()* system call for files. The *unlink* call immediately
    removes the object’s name, and then destroys the object once all processes cease
    using it (i.e., when the reference count falls to zero). For message queues and
    semaphores, this means that the object is destroyed after all processes have closed
    the object; for shared memory, destruction occurs after all processes have unmapped
    the object using *munmap()*.
  prefs: []
  type: TYPE_NORMAL
- en: After an object is unlinked, IPC *open* calls specifying the same object name
    will refer to a new object (or fail, if `O_CREAT` was not specified).
  prefs: []
  type: TYPE_NORMAL
- en: As with System V IPC, POSIX IPC objects have kernel persistence. Once created,
    an object continues to exist until it is unlinked or the system is shut down.
    This allows a process to create an object, modify its state, and then exit, leaving
    the object to be accessed by some process that is started at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and removing POSIX IPC objects via the command line
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: System V IPC provides two commands, *ipcs* and *ipcrm*, for listing and deleting
    IPC objects. No standard commands are provided to perform the analogous tasks
    for POSIX IPC objects. However, on many systems, including Linux, IPC objects
    are implemented within a real or virtual file system, mounted somewhere under
    the root directory (`/`), and the standard *ls* and *rm* commands can be used
    to list and remove IPC objects. (SUSv3 doesn’t specify the use of *ls* and *rm*
    for these tasks.) The main problem with using these commands is the nonstandard
    nature of POSIX IPC object names and their location in the file system.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, POSIX IPC objects are contained in virtual file systems mounted under
    directories that have the sticky bit set. This bit is the restricted deletion
    flag ([Set-User-ID, Set-Group-ID, and Sticky Bits](ch15.html#set-user-id_comma_set-group-id_comma_and
    "Set-User-ID, Set-Group-ID, and Sticky Bits")); setting it means that an unprivileged
    process can unlink only the POSIX IPC objects that it owns.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling programs that use POSIX IPC on Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On Linux, programs employing the POSIX IPC mechanisms must be linked with the
    *realtime* library, *librt*, by specifying the *-lrt* option to the *cc* command.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of System V IPC and POSIX IPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we look at the POSIX IPC mechanisms in the following chapters, we’ll compare
    each mechanism against its System V counterpart. Here, we consider a few general
    comparisons for these two types of IPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'POSIX IPC has the following general advantages when compared to System V IPC:'
  prefs: []
  type: TYPE_NORMAL
- en: The POSIX IPC interface is simpler than the System V IPC interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POSIX IPC model—the use of names instead of keys, and the *open*, *close*,
    and *unlink* functions—is more consistent with the traditional UNIX file model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POSIX IPC objects are reference counted. This simplifies object deletion, because
    we can unlink a POSIX IPC object, knowing that it will be destroyed only when
    all processes have closed it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there is one notable advantage in favor of System V IPC: portability.
    POSIX IPC is less portable than System V IPC in the following respects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'System V IPC is specified in SUSv3 and supported on nearly every UNIX implementation.
    By contrast, each of the POSIX IPC mechanisms is an optional component in SUSv3\.
    Some UNIX implementations don’t support (all of) the POSIX IPC mechanisms. This
    situation is reflected in microcosm on Linux: POSIX shared memory is supported
    only since kernel 2.4; a full implementation of POSIX semaphores is available
    only since kernel 2.6; and POSIX message queues are supported only since kernel
    2.6.6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite the SUSv3 specification for POSIX IPC object names, the various implementations
    follow different conventions for naming IPC objects. These differences require
    us to do (a little) extra work to write portable applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various details of POSIX IPC are not specified in SUSv3\. In particular, no
    commands are specified for displaying and deleting the IPC objects that exist
    on a system. (In many implementations, standard file-system commands are used,
    but the details of the pathnames used to identify IPC objects vary.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: POSIX IPC is the general name given to three IPC mechanisms—message queues,
    semaphores, and shared memory—that were devised by POSIX.1b as alternatives to
    the analogous System V IPC mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: The POSIX IPC interface is more consistent with the traditional UNIX file model.
    IPC objects are identified by names, and managed using *open*, *close*, and *unlink*
    calls that operate in a manner similar to the analogous file-related system calls.
  prefs: []
  type: TYPE_NORMAL
- en: POSIX IPC provides an interface that is superior in many respects to the System
    V IPC interface. However, POSIX IPC is somewhat less portable than System V IPC.
  prefs: []
  type: TYPE_NORMAL
