- en: Chapter 46. System V Message Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter describes System V message queues. Message queues allow processes
    to exchange data in the form of messages. Although message queues are similar
    to pipes and FIFOs in some respects, they also differ in important ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The handle used to refer to a message queue is the identifier returned by a
    call to *msgget()*. These identifiers are not the same as the file descriptors
    used for most other forms of I/O on UNIX systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication via message queues is message-oriented; that is, the reader receives
    whole messages, as written by the writer. It is not possible to read part of a
    message, leaving the remainder in the queue, or to read multiple messages at a
    time. This contrasts with pipes, which provide an undifferentiated stream of bytes
    (i.e., with pipes, the reader can read an arbitrary number of bytes at a time,
    irrespective of the size of data blocks written by the writer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to containing data, each message has an integer *type*. Messages
    can be retrieved from a queue in first-in, first-out order or retrieved by type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter ([Disadvantages of System V Message Queues](ch46.html#disadvantages_of_system_v_message_queues
    "Disadvantages of System V Message Queues")), we summarize a number of limitations
    of System V message queues. These limitations lead us to the conclusion that,
    where possible, new applications should avoid the use of System V message queues
    in favor of other IPC mechanisms such as FIFOs, POSIX message queues, and sockets.
    However, when message queues were initially devised, these alternative mechanisms
    were unavailable or were not widespread across UNIX implementations. Consequently,
    there are various existing applications that employ message queues, and this fact
    forms one of the primary motivations for describing them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating or Opening a Message Queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *msgget()* system call creates a new message queue or obtains the identifier
    of an existing queue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns message queue identifier on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The *key* argument is a key generated using one of the methods described in
    [IPC Keys](ch45.html#ipc_keys "IPC Keys") (i.e., usually the value `IPC_PRIVATE`
    or a key returned by *ftok()*). The *msgflg* argument is a bit mask that specifies
    the permissions ([Table 15-4](ch15.html#constants_for_file_permission_bits "Table 15-4. Constants
    for file permission bits"), in [Permissions on Regular Files](ch15.html#permissions_on_regular_files
    "Permissions on Regular Files")) to be placed on a new message queue or checked
    against an existing queue. In addition, zero or more of the following flags can
    be ORed (|) in *msgflg* to control the operation of *msgget()*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_CREAT`'
  prefs: []
  type: TYPE_NORMAL
- en: If no message queue with the specified *key* exists, create a new queue.
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_EXCL`'
  prefs: []
  type: TYPE_NORMAL
- en: If `IPC_CREAT` was also specified, and a queue with the specified *key* already
    exists, fail with the error `EEXIST`.
  prefs: []
  type: TYPE_NORMAL
- en: These flags are described in more detail in Section 45.1.
  prefs: []
  type: TYPE_NORMAL
- en: The *msgget()* system call begins by searching the set of all existing message
    queues for one with the specified key. If a matching queue is found, the identifier
    of that queue is returned (unless both `IPC_CREAT` and `IPC_EXCL` were specified
    in *msgflg*, in which case an error is returned). If no matching queue was found
    and `IPC_CREAT` was specified in *msgflg*, a new queue is created and its identifier
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "Example 46-1. Using msgget()") provides a command-line interface to the *msgget()*
    system call. The program permits the use of command-line options and arguments
    to specify all possibilities for the *key* and *msgflg* arguments to *msgget()*.
    Details of the command format accepted by this program are shown in the *usageError()*
    function. Upon successful queue creation, the program prints the queue identifier.
    We demonstrate the use of this program in [Receiving Messages](ch46.html#receiving_messages
    "Receiving Messages").
  prefs: []
  type: TYPE_NORMAL
- en: Example 46-1. Using *msgget()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Exchanging Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *msgsnd()* and *msgrcv()* system calls perform I/O on message queues. The
    first argument to both system calls (*msqid*) is a message queue identifier. The
    second argument, *msgp*, is a pointer to a programmer-defined structure used to
    hold the message being sent or received. This structure has the following general
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This definition is really just shorthand for saying that the first part of a
    message contains the message type, specified as a long integer, while the remainder
    of the message is a programmer-defined structure of arbitrary length and content;
    it need not be an array of characters. Thus, the *mgsp* argument is typed as *void
    ** to allow it to be a pointer to any type of structure.
  prefs: []
  type: TYPE_NORMAL
- en: A zero-length *mtext* field is permitted, and is sometimes useful if the information
    to be conveyed can be encoded solely in the message type or if the existence of
    a message is in itself sufficient information for the receiving process.
  prefs: []
  type: TYPE_NORMAL
- en: Sending Messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *msgsnd()* system call writes a message to a message queue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: To send a message with *msgsnd()*, we must set the *mtype* field of the message
    structure to a value greater than 0 (we see how this value is used when we discuss
    *msgrcv()* in the next section) and copy the desired information into the programmer-defined
    *mtext* field. The *msgsz* argument specifies the number of bytes contained in
    the *mtext* field.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When sending messages with *msgsnd()*, there is no concept of a partial write
    as with *write()*. This is why a successful *msgsnd()* needs only to return 0,
    rather than the number of bytes sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final argument, *msgflg*, is a bit mask of flags controlling the operation
    of *msgsnd()*. Only one such flag is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_NOWAIT`'
  prefs: []
  type: TYPE_NORMAL
- en: Perform a nonblocking send. Normally, if a message queue is full, *msgsnd()*
    blocks until enough space has become available to allow the message to be placed
    on the queue. However, if this flag is specified, then *msgsnd()* returns immediately
    with the error `EAGAIN`.
  prefs: []
  type: TYPE_NORMAL
- en: A *msgsnd()* call that is blocked because the queue is full may be interrupted
    by a signal handler. In this case, *msgsnd()* always fails with the error `EINTR`.
    (As noted in [Interruption and Restarting of System Calls](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls"), *msgsnd()* is among those system
    calls that are never automatically restarted, regardless of the setting of the
    `SA_RESTART` flag when the signal handler is established.)
  prefs: []
  type: TYPE_NORMAL
- en: Writing a message to a message queue requires write permission on the queue.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare
    "Example 46-2. Using msgsnd() to send a message") provides a command-line interface
    to the *msgsnd()* system call. The command-line format accepted by this program
    is shown in the *usageError()* function. Note that this program doesn’t use the
    *msgget()* system call. (We noted that a process doesn’t need to use a *get* call
    in order to access an IPC object in Section 45.1.) Instead, we specify the message
    queue by providing its identifier as a command-line argument. We demonstrate the
    use of this program in [Receiving Messages](ch46.html#receiving_messages "Receiving
    Messages").
  prefs: []
  type: TYPE_NORMAL
- en: Example 46-2. Using *msgsnd()* to send a message
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Receiving Messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *msgrcv()* system call reads (and removes) a message from a message queue,
    and copies its contents into the buffer pointed to by *msgp*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns number of bytes copied into *mtext* field, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The maximum space available in the *mtext* field of the *msgp* buffer is specified
    by the argument *maxmsgsz*. If the body of the message to be removed from the
    queue exceeds *maxmsgsz* bytes, then no message is removed from the queue, and
    *msgrcv()* fails with the error `E2BIG`. (This default behavior can be changed
    using the `MSG_NOERROR` flag described shortly.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Messages need not be read in the order in which they were sent. Instead, we
    can select messages according to the value in the *mtype* field. This selection
    is controlled by the *msgtyp* argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If *msgtyp* equals 0, the first message from the queue is removed and returned
    to the calling process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *msgtyp* is greater than 0, the first message in the queue whose *mtype*
    equals *msgtyp* is removed and returned to the calling process. By specifying
    different values for *msgtyp*, multiple processes can read from a message queue
    without racing to read the same messages. One useful technique is to have each
    process select messages matching its process ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *msgtyp* is less than 0, treat the waiting messages as a *priority queue*.
    The first message of the lowest *mtype* less than or equal to the absolute value
    of *msgtyp* is removed and returned to the calling process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example helps clarify the behavior when *msgtyp* is less than 0\. Suppose
    that we have a message queue containing the sequence of messages shown in [Figure 46-1](ch46.html#example_of_a_message_queue_containing_me
    "Figure 46-1. Example of a message queue containing messages of different types")
    and we performed a series of *msgrcv()* calls of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These *msgrcv()* calls would retrieve messages in the order 2 (type 100), 5
    (type 100), 3 (type 200), and 1 (type 300). A further call would block, since
    the type of the remaining message (400) exceeds 300.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *msgflg* argument is a bit mask formed by ORing together zero or more of
    the following flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_NOWAIT`'
  prefs: []
  type: TYPE_NORMAL
- en: Perform a nonblocking receive. Normally, if no message matching *msgtyp* is
    in the queue, *msgrcv()* blocks until such a message becomes available. Specifying
    the `IPC_NOWAIT` flag causes *msgrcv()* to instead return immediately with the
    error `ENOMSG`. (The error `EAGAIN` would be more consistent, as occurs on a nonblocking
    *msgsnd()* or a nonblocking read from a FIFO. However, failing with `ENOMSG` is
    historical behavior, and required by SUSv3.)
  prefs: []
  type: TYPE_NORMAL
- en: '`MSG_EXCEPT`'
  prefs: []
  type: TYPE_NORMAL
- en: This flag has an effect only if *msgtyp* is greater than 0, in which case it
    forces the complement of the usual operation; that is, the first message from
    the queue whose *mtype* is *not* equal to *msgtyp* is removed from the queue and
    returned to the caller. This flag is Linux-specific, and is made available from
    `<sys/msg.h>` only if `_GNU_SOURCE` is defined. Performing a series of calls of
    the form *msgrcv(id, &msg, maxmsgsz, 100, MSG_EXCEPT)* on the message queue shown
    in [Figure 46-1](ch46.html#example_of_a_message_queue_containing_me "Figure 46-1. Example
    of a message queue containing messages of different types") would retrieve messages
    in the order 1, 3, 4, and then block.
  prefs: []
  type: TYPE_NORMAL
- en: '`MSG_NOERROR`'
  prefs: []
  type: TYPE_NORMAL
- en: By default, if the size of the *mtext* field of the message exceeds the space
    available (as defined by the *maxmsgsz* argument), *msgrcv()* fails. If the `MSG_NOERROR`
    flag is specified, then *msgrcv()* instead removes the message from the queue,
    truncates its *mtext* field to *maxmsgsz* bytes, and returns it to the caller.
    The truncated data is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Upon successful completion, *msgrcv()* returns the size of the *mtext* field
    of the received message; on error, -1 is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of a message queue containing messages of different types](figs/web/46-1_SVMSG-queue-example-scale90.png.jpg)Figure 46-1. Example
    of a message queue containing messages of different types'
  prefs: []
  type: TYPE_NORMAL
- en: As with *msgsnd()*, if a blocked *msgrcv()* call is interrupted by a signal
    handler, then the call fails with the error `EINTR`, regardless of the setting
    of the `SA_RESTART` flag when the signal handler was established.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a message from a message queue requires read permission on the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program in [Example 46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare
    "Example 46-3. Using msgrcv() to read a message") provides a command-line interface
    to the *msgrcv()* system call. The command-line format accepted by this program
    is shown in the *usageError()* function. Like the program in [Example 46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare
    "Example 46-2. Using msgsnd() to send a message"), which demonstrated the use
    of *msgsnd()*, this program doesn’t use the *msgget()* system call, but instead
    expects a message queue identifier as its command-line argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell session demonstrates the use of the programs in [Example 46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "Example 46-1. Using msgget()"), [Example 46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare
    "Example 46-2. Using msgsnd() to send a message"), and [Example 46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare
    "Example 46-3. Using msgrcv() to read a message"). We begin by creating a message
    queue using the `IPC_PRIVATE` key, and then write three messages with different
    types to the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the program in [Example 46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare
    "Example 46-3. Using msgrcv() to read a message") to read messages with a type
    less than or equal to 20 from the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last of the above commands blocked, because there was no message in the
    queue whose type was less than or equal to 20\. So, we continue by typing *Control-C*
    to terminate the command, and then execute a command that reads a message of any
    type from the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Example 46-3. Using *msgrcv()* to read a message
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Message Queue Control Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *msgctl()* system call performs control operations on the message queue
    identified by *msqid*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The *cmd* argument specifies the operation to be performed on the queue. It
    can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_RMID`'
  prefs: []
  type: TYPE_NORMAL
- en: Immediately remove the message queue object and its associated *msqid_ds* data
    structure. All messages remaining in the queue are lost, and any blocked reader
    or writer processes are immediately awakened, with *msgsnd()* or *msgrcv()* failing
    with the error `EIDRM`. The third argument to *msgctl()* is ignored for this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_STAT`'
  prefs: []
  type: TYPE_NORMAL
- en: Place a copy of the *msqid_ds* data structure associated with this message queue
    in the buffer pointed to by *buf*. We describe the *msqid_ds* structure in Section
    46.4.
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_SET`'
  prefs: []
  type: TYPE_NORMAL
- en: Update selected fields of the *msqid_ds* data structure associated with this
    message queue using values provided in the buffer pointed to by *buf*.
  prefs: []
  type: TYPE_NORMAL
- en: Further details about these operations, including the privileges and permissions
    required by the calling process, are described in Section 45.3\. We describe some
    other values for *cmd* in Section 46.6.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 46-4](ch46.html#deleting_system_v_message_queues "Example 46-4. Deleting
    System V message queues") demonstrates the use of *msgctl()* to delete a message
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: Example 46-4. Deleting System V message queues
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Message Queue Associated Data Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each message queue has an associated *msqid_ds* data structure of the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of the abbreviated spelling *msq* in the name *msqid_ds* is to confuse
    the programmer. This is the only message queue interface employing this spelling.
  prefs: []
  type: TYPE_NORMAL
- en: The *msgqnum_t* and *msglen_t* data types—used to type the *msg_qnum* and *msg_qbytes*
    fields—are unsigned integer types specified in SUSv3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fields of the *msqid_ds* structure are implicitly updated by the various
    message queue system calls, and certain fields can be explicitly updated using
    the *msgctl()* `IPC_SET` operation. The details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*msg_perm*'
  prefs: []
  type: TYPE_NORMAL
- en: When the message queue is created, the fields of this substructure are initialized
    as described in Section 45.3\. The *uid*, *gid*, and *mode* subfields can be updated
    via `IPC_SET`.
  prefs: []
  type: TYPE_NORMAL
- en: '*msg_stime*'
  prefs: []
  type: TYPE_NORMAL
- en: When the queue is created, this field is set to 0; each later successful *msgsnd()*
    sets this field to the current time. This field and the other timestamp fields
    in the *msqid_ds* structure are typed as *time_t*; they store time in seconds
    since the Epoch.
  prefs: []
  type: TYPE_NORMAL
- en: '*msg_rtime*'
  prefs: []
  type: TYPE_NORMAL
- en: This field is set to 0 when the message queue is created, and then set to the
    current time on each successful *msgrcv()*.
  prefs: []
  type: TYPE_NORMAL
- en: '*msg_ctime*'
  prefs: []
  type: TYPE_NORMAL
- en: This field is set to the current time when the message queue is created and
    whenever an `IPC_SET` operation is successfully performed.
  prefs: []
  type: TYPE_NORMAL
- en: '*__msg_cbytes*'
  prefs: []
  type: TYPE_NORMAL
- en: This field is set to 0 when the message queue is created, and then adjusted
    during each successful *msgsnd()* and *msgrcv()* to reflect the total number of
    bytes contained in the *mtext* fields of all messages in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '*msg_qnum*'
  prefs: []
  type: TYPE_NORMAL
- en: When the message queue is created, this field is set to 0\. It is then incremented
    by each successful *msgsnd()* and decremented by each successful *msgrcv()* to
    reflect the total number of messages in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '*msg_qbytes*'
  prefs: []
  type: TYPE_NORMAL
- en: The value in this field defines an upper limit on the number of bytes in the
    *mtext* fields of all messages in the message queue. This field is initialized
    to the value of the `MSGMNB` limit when the queue is created. A privileged (`CAP_SYS_RESOURCE`)
    process can use the `IPC_SET` operation to adjust *msg_qbytes* to any value in
    the range 0 to `INT_MAX` (2,147,483,647 on 32-bit platforms) bytes. An unprivileged
    process can adjust *msg_qbytes* to any value in the range 0 to `MSGMNB`. A privileged
    user can modify the value contained in the Linux-specific `/proc/sys/kernel/msgmnb`
    file in order to change the initial *msg_qbytes* setting for all subsequently
    created message queues, as well as the upper limit for subsequent changes to *msg_qbytes*
    by unprivileged processes. We say more about message queue limits in Section 46.5.
  prefs: []
  type: TYPE_NORMAL
- en: '*msg_lspid*'
  prefs: []
  type: TYPE_NORMAL
- en: This field is set to 0 when the queue is created, and then set to the process
    ID of the calling process on each successful *msgsnd()*.
  prefs: []
  type: TYPE_NORMAL
- en: '*msg_lrpid*'
  prefs: []
  type: TYPE_NORMAL
- en: This field is set to 0 when the message queue is created, and then set to the
    process ID of the calling process on each successful *msgrcv()*.
  prefs: []
  type: TYPE_NORMAL
- en: All of the above fields are specified by SUSv3, with the exception of __*msg_cbytes*.
    Nevertheless, most UNIX implementations provide an equivalent of the __*msg_cbytes*
    field.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 46-5](ch46.html#changing_the_msg_underscore_qbytes_setti
    "Example 46-5. Changing the msg_qbytes setting of a System V message queue") demonstrates
    the use of the `IPC_STAT` and `IPC_SET` operations to modify the *msg_qbytes*
    setting of a message queue.
  prefs: []
  type: TYPE_NORMAL
- en: Example 46-5. Changing the *msg_qbytes* setting of a System V message queue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Message Queue Limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most UNIX implementations impose various limits on the operation of System V
    message queues. Here, we describe the limits under Linux and note a few differences
    from other UNIX implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The following limits are enforced on Linux. The system call affected by the
    limit and the error that results if the limit is reached are noted in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '`MSGMNI`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a system-wide limit on the number of message queue identifiers (in other
    words, message queues) that can be created. (*msgget()*, `ENOSPC`)
  prefs: []
  type: TYPE_NORMAL
- en: '`MSGMAX`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a system-wide limit specifying the maximum number of (*mtext*) bytes
    that can be written in a single message. (*msgsnd()*, `EINVAL`)
  prefs: []
  type: TYPE_NORMAL
- en: '`MSGMNB`'
  prefs: []
  type: TYPE_NORMAL
- en: This is the maximum number of (*mtext*) bytes that can be held in a message
    queue at one time. This limit is a system-wide parameter that is used to initialize
    the *msg_qbytes* field of the *msqid_ds* data structure associated with this message
    queue. Subsequently, the *msg_qbytes* value can be modified on a per-queue basis,
    as described in Section 46.4\. If a queue’s *msg_qbytes* limit is reached, then
    *msgsnd()* blocks, or fails with the error `EAGAIN` if `IPC_NOWAIT` was set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some UNIX implementations also define the following further limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MSGTQL`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a system-wide limit on the number of messages that can be placed on
    all message queues on the system.
  prefs: []
  type: TYPE_NORMAL
- en: '`MSGPOOL`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a system-wide limit on the size of the buffer pool that is used to hold
    data in all message queues on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Although Linux doesn’t impose either of the above limits, it does limit the
    number of messages on an individual queue to the value specified by the queue’s
    *msg_qbytes* setting. This limitation is relevant only if we are writing zero-length
    messages to a queue. It has the effect that the limit on the number of zero-length
    messages is the same as the limit on the number of 1-byte messages that can be
    written to the queue. This is necessary to prevent an infinite number of zero-length
    messages being written to the queue. Although they contain no data, each zero-length
    message consumes a small amount of memory for system bookkeeping overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'At system startup, the message queue limits are set to default values. These
    defaults have varied somewhat across kernel versions. (Some distributors’ kernels
    set different defaults from those provided by vanilla kernels.) On Linux, the
    limits can be viewed or changed via files in the `/proc` file system. [Table 46-1](ch46.html#system_v_message_queue_limits
    "Table 46-1. System V message queue limits") shows the `/proc` file corresponding
    to each limit. As an example, here are the default limits that we see for Linux
    2.6.31 on one x86-32 system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Table 46-1. System V message queue limits
  prefs: []
  type: TYPE_NORMAL
- en: '| Limit | Ceiling value (x86-32) | Corresponding file in `/proc/sys/kernel`
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MSGMNI` | 32768 (`IPCMNI`) | `msgmni` |'
  prefs: []
  type: TYPE_TB
- en: '| `MSGMAX` | Depends on available memory | `msgmax` |'
  prefs: []
  type: TYPE_TB
- en: '| `MSGMNB` | 2147483647 (`INT_MAX`) | `msgmnb` |'
  prefs: []
  type: TYPE_TB
- en: The ceiling value column of [Table 46-1](ch46.html#system_v_message_queue_limits
    "Table 46-1. System V message queue limits") shows the maximum value to which
    each limit can be raised on the x86-32 architecture. Note that although the `MSGMNB`
    limit can be raised to the value `INT_MAX`, some other limit (e.g., lack of memory)
    will be reached before a message queue can be loaded with so much data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux-specific *msgctl()* `IPC_INFO` operation retrieves a structure of
    type *msginfo*, which contains the values of the various message queue limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Details about `IPC_INFO` and the *msginfo* structure can be found in the *msgctl(2)*
    manual page.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying All Message Queues on the System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Obtaining a List of All IPC Objects](ch45.html#obtaining_a_list_of_all_ipc_objects
    "Obtaining a List of All IPC Objects"), we looked at one way to obtain a list
    of all of the IPC objects on the system: via a set of files in the `/proc` file
    system. We now look at a second method of obtaining the same information: via
    a set of Linux-specific IPC *ctl* (*msgctl()*, *semctl()*, and *shmctl()*) operations.
    (The *ipcs* program employs these operations.) These operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MSG_INFO`, `SEM_INFO`, and `SHM_INFO`: The `MSG_INFO` operation serves two
    purposes. First, it returns a structure detailing resources consumed by all message
    queues on the system. Second, as the function result of the *ctl* call, it returns
    the index of the maximum item in the *entries* array pointing to data structures
    for the message queue objects (see [Figure 45-1](ch45.html#kernel_data_structures_used_to_represent
    "Figure 45-1. Kernel data structures used to represent System V IPC (semaphore)
    objects"), in [Algorithm Employed by System V IPC *get* Calls](ch45.html#algorithm_employed_by_system_v_ipc_get_c
    "Algorithm Employed by System V IPC get Calls")). The `SEM_INFO` and `SHM_INFO`
    operations perform an analogous task for semaphore sets and shared memory segments,
    respectively. We must define the `_GNU_SOURCE` feature test macro to obtain the
    definitions of these three constants from the corresponding System V IPC header
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: An example showing the use of `MSG_INFO` to retrieve a *msginfo* structure containing
    information about resources used by all message queue objects is provided in the
    file `svmsg/svmsg_info.c` in the source code distribution for this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`MSG_STAT`, `SEM_STAT`, and `SHM_STAT`: Like the `IPC_STAT` operation, these
    operations retrieve the associated data structure for an IPC object. However,
    they differ in two respects. First, instead of expecting an IPC identifier as
    the first argument of the *ctl* call, these operations expect an index into the
    *entries* array. Second, if the operation is successful, then, as its function
    result, the *ctl* call returns the identifier of the IPC object corresponding
    to that index. We must define the `_GNU_SOURCE` feature test macro to obtain the
    definitions of these three constants from the corresponding System V IPC header
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To list all message queues on the system, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a `MSG_INFO` operation to find out the maximum index (*maxind*) of the *entries*
    array for message queues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a loop for all values from 0 up to and including *maxind*, employing
    a `MSG_STAT` operation for each value. During this loop, we ignore the errors
    that may occur if an item of the *entries* array is empty (`EINVAL`) or if we
    don’t have permissions on the object to which it refers (`EACCES`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Example 46-6](ch46.html#displaying_all_system_v_message_queues_o "Example 46-6. Displaying
    all System V message queues on the system") provides an implementation of the
    above steps for message queues. The following shell session log demonstrates the
    use of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Example 46-6. Displaying all System V message queues on the system
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Client-Server Programming with Message Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we consider two of various possible designs for client-server
    applications using System V message queues:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of a single message queue for exchanging messages in both directions
    between server and client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of separate message queues for the server and for each client. The server’s
    queue is used to receive incoming client requests, and responses are sent to clients
    via the individual client queues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which approach we choose depends on the requirements of our application. We
    next consider some of the factors that may influence our choice.
  prefs: []
  type: TYPE_NORMAL
- en: Using a single message queue for server and clients
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using a single message queue may be suitable when the messages exchanged between
    servers and clients are small. However, note the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Since multiple processes may attempt to read messages at the same time, we must
    use the message type (*mtype*) field to allow each process to select only those
    messages intended for it. One way to accomplish this is to use the client’s process
    ID as the message type for messages sent from the server to the client. The client
    can send its process ID as part of its message(s) to the server. Furthermore,
    messages to the server must also be distinguished by a unique message type. For
    this purpose, we can use the number 1, which, being the process ID of the permanently
    running *init* process, can never be the process ID of a client process. (An alternative
    would be to use the server’s process ID as the message type; however, it is difficult
    for the clients to obtain this information.) This numbering scheme is shown in
    [Figure 46-2](ch46.html#using_a_single_message_queue_for_client- "Figure 46-2. Using
    a single message queue for client-server IPC").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message queues have a limited capacity. This has the potential to cause a couple
    of problems. One of these is that multiple simultaneous clients could fill the
    message queue, resulting in a deadlock situation, where no new client requests
    can be submitted and the server is blocked from writing any responses. The other
    problem is that a poorly behaved or intentionally malicious client may fail to
    read responses from the server. This can lead to the queue becoming clogged with
    unread messages, preventing any communication between clients and server. (Using
    two queues—one for messages from clients to the server, and the other for messages
    from the server to the clients—would solve the first of these problems, but not
    the second.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Using a single message queue for client-server IPC](figs/web/46-2_SVMSG-cs-single-queue.png.jpg)Figure 46-2. Using
    a single message queue for client-server IPC'
  prefs: []
  type: TYPE_NORMAL
- en: Using one message queue per client
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using one message queue per client (as well as one for the server) is preferable
    where large messages need to be exchanged, or where there is potential for the
    problems listed above when using a single message queue. Note the following points
    regarding this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Each client must create its own message queue (typically using the `IPC_PRIVATE`
    key) and inform the server of the queue’s identifier, usually by transmitting
    the identifier as part of the client’s message(s) to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a system-wide limit (`MSGMNI`) on the number of message queues, and
    the default value for this limit is quite low on some systems. If we expect to
    have a large number of simultaneous clients, we may need to raise this limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server should allow for the possibility that the client’s message queue
    no longer exists (perhaps because the client prematurely deleted it).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We say more about using one message queue per client in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A File-Server Application Using Message Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we describe a client-server application that uses one message
    queue per client. The application is a simple file server. The client sends a
    request message to the server’s message queue asking for the contents of a named
    file. The server responds by returning the file contents as a series of messages
    to the client’s private message queue. [Figure 46-3](ch46.html#client-server_ipc_using_one_message_queu
    "Figure 46-3. Client-server IPC using one message queue per client") provides
    an overview of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Because the server performs no authentication of the client, any user that can
    run the client can obtain any of the files accessible to the server. A more sophisticated
    server would require some type of authentication from the client before serving
    the requested file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-server IPC using one message queue per client](figs/web/46-3_SVMSG-cs-multi-queue-scale90.png.jpg)Figure 46-3. Client-server
    IPC using one message queue per client'
  prefs: []
  type: TYPE_NORMAL
- en: Common header file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 46-7](ch46.html#header_file_for_svmsg_underscore_file_un "Example 46-7. Header
    file for svmsg_file_server.c and svmsg_file_client.c") is the header file included
    by both the server and the client. This header defines the well-known key to be
    used for the server’s message queue (`SERVER_KEY`), and defines the formats of
    the messages to be passed between the client and the server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *requestMsg* structure defines the format of the request sent from the
    client to the server. In this structure, the *mtext* component consists of two
    fields: the identifier of the client’s message queue and the pathname of the file
    requested by the client. The constant `REQ_MSG_SIZE` equates to the combined size
    of these two fields and is used as the *msgsz* argument in calls to *msgsnd()*
    using this structure.'
  prefs: []
  type: TYPE_NORMAL
- en: The *responseMsg* structure defines the format of the response messages sent
    from the server back to the client. The *mtype* field is used in response messages
    to supply information about the message content, as defined by the `RESP_MT_*`
    constants.
  prefs: []
  type: TYPE_NORMAL
- en: Example 46-7. Header file for `svmsg_file_server.c` and `svmsg_file_client.c`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Server program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 46-8](ch46.html#a_file_server_using_system_v_message_que "Example 46-8. A
    file server using System V message queues") is the server program for the application.
    Note the following points about the server:'
  prefs: []
  type: TYPE_NORMAL
- en: The server is designed to handle requests concurrently. A concurrent server
    design is preferable to the iterative design employed in [Example 44-7](ch44.html#an_iterative_server_using_fifos
    "Example 44-7. An iterative server using FIFOs") (page 912), since we want to
    avoid the possibility that a client request for a large file would cause all other
    client requests to wait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each client request is handled by creating a child process that serves the
    requested file ![](figs/web/U008.png). In the meantime, the main server process
    waits upon further client requests. Note the following points about the server
    child:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the child produced via *fork()* inherits a copy of the parent’s stack,
    it thus obtains a copy of the request message read by the main server process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The server child terminates after handling its associated client request ![](figs/web/U009.png).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to avoid the creation of zombie processes ([Orphans and Zombies](ch26.html#orphans_and_zombies
    "Orphans and Zombies")), the server establishes a handler for `SIGCHLD` ![](figs/web/U006.png)
    and calls *waitpid()* within this handler ![](figs/web/U001.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *msgrcv()* call in the parent server process may block, and consequently
    be interrupted by the `SIGCHLD` handler. To handle this possibility, a loop is
    used to restart the call if it fails with the `EINTR` error ![](figs/web/U007.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server child executes the *serveRequest()* function ![](figs/web/U002.png),
    which sends three message types back to the client. A request with an *mtype*
    of `RESP_MT_FAILURE` indicates that the server could not open the requested file
    ![](figs/web/U003.png); `RESP_MT_DATA` is used for a series of messages containing
    file data ![](figs/web/U004.png); and `RESP_MT_END` (with a zero-length data field)
    is used to indicate that transmission of file data is complete ![](figs/web/U005.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We consider a number of ways to improve and extend the server program in Exercise
    46-4.
  prefs: []
  type: TYPE_NORMAL
- en: Example 46-8. A file server using System V message queues
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Client program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 46-9](ch46.html#client_for_file_server_using_system_v_me "Example 46-9. Client
    for file server using System V message queues") is the client program for the
    application. Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The client creates a message queue with the `IPC_PRIVATE` key ![](figs/web/U002.png)
    and uses *atexit()* ![](figs/web/U003.png) to establish an exit handler ![](figs/web/U001.png)
    to ensure that the queue is deleted when the client exits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client passes the identifier for its queue, as well as the pathname of the
    file to be served, in a request to the server ![](figs/web/U004.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client handles the possibility that the first response message sent by the
    server may be a failure notification (*mtype* equals `RESP_MT_FAILURE`) by printing
    the text of the error message returned by the server and exiting ![](figs/web/U005.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the file is successfully opened, then the client loops ![](figs/web/U006.png),
    receiving a series of messages containing the file contents (*mtype* equals `RESP_MT_DATA`).
    The loop is terminated by receipt of an end-of-file message (*mtype* equals `RESP_MT_END`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This simple client doesn’t handle various possibilities resulting from failures
    in the server. We consider some improvements in Exercise 46-5.
  prefs: []
  type: TYPE_NORMAL
- en: Example 46-9. Client for file server using System V message queues
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shell session demonstrates the use of the programs in [Example 46-8](ch46.html#a_file_server_using_system_v_message_que
    "Example 46-8. A file server using System V message queues") and [Example 46-9](ch46.html#client_for_file_server_using_system_v_me
    "Example 46-9. Client for file server using System V message queues"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Disadvantages of System V Message Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UNIX systems provide a number of mechanisms for transmitting data from one process
    to another on the same system, either in the form of an undelimited byte stream
    (pipes, FIFOs, and UNIX domain stream sockets) or as delimited messages (System
    V message queues, POSIX message queues, and UNIX domain datagram sockets).
  prefs: []
  type: TYPE_NORMAL
- en: 'A distinctive feature of System V message queues is the ability to attach a
    numeric type to each message. This provides for two possibilities that may be
    useful to applications: reading processes may select messages by type, or they
    may employ a priority-queue strategy so that higher-priority messages (i.e., those
    with lower message type values) are read first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, System V message queues have a number of disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Message queues are referred to by identifiers, rather than the file descriptors
    used by most other UNIX I/O mechanisms. This means that a variety of file descriptor–based
    I/O techniques described in [Chapter 63](ch63.html "Chapter 63. Alternative I/O
    Models") (e.g., *select()*, *poll()*, and *epoll*) can’t be applied to message
    queues. Furthermore, writing programs that simultaneously handle inputs from both
    message queues and file descriptor-based I/O mechanisms requires code that is
    more complex than code that deals with file descriptors alone. (We look at one
    way of combining the two I/O models in Exercise 63-3.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of keys, rather than filenames, to identify message queues results in
    additional programming complexity and also requires the use of *ipcs* and *ipcrm*
    instead of *ls* and *rm*. The *ftok()* function usually generates a unique key,
    but it is not guaranteed to do so. Employing the `IPC_PRIVATE` key guarantees
    a unique queue identifier, but leaves us with the task of making that identifier
    visible to other processes that require it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message queues are connectionless, and the kernel doesn’t maintain a count
    of the number of processes referring to the queue as is done with pipes, FIFOs,
    and sockets. Consequently, it can be difficult to answer the following questions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is it safe for an application to delete a message queue? (Premature deletion
    of the queue results in immediate loss of data, regardless of whether any process
    might later be interested in reading from the queue.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How can an application ensure that an unused queue is deleted?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are limits on the total number of message queues, the size of messages,
    and the capacity of individual queues. These limits are configurable, but if an
    application operates outside the range of the default limits, this requires extra
    work when installing the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, System V message queues are often best avoided. In situations where
    we require the facility to select messages by type, we should consider alternatives.
    POSIX message queues ([Chapter 52](ch52.html "Chapter 52. POSIX Message Queues"))
    are one such alternative. As a further alternative, solutions involving multiple
    file descriptor–based communication channels may provide functionality similar
    to selecting messages by type, while at the same time allowing the use of the
    alternative I/O models described in [Chapter 63](ch63.html "Chapter 63. Alternative
    I/O Models"). For example, if we need to transmit “normal” and “priority” messages,
    we could use a pair of FIFOs or UNIX domain sockets for the two message types,
    and then employ *select()* or *poll()* to monitor file descriptors for both channels.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System V message queues allow processes to communicate by exchanging messages
    consisting of a numeric type plus a body containing arbitrary data. The distinguishing
    features of message queues are that message boundaries are preserved and that
    the receiver(s) can select messages by type, rather than reading messages in first-in,
    first-out order.
  prefs: []
  type: TYPE_NORMAL
- en: Various factors led us to conclude that other IPC mechanisms are usually preferable
    to System V message queues. One major difficulty is that message queues are not
    referred to using file descriptors. This means that we can’t employ various alternative
    I/O models with message queues; in particular, it is complex to simultaneously
    monitor both message queues and file descriptors to see if I/O is possible. Furthermore,
    the fact that message queues are connectionless (i.e., not reference counted)
    makes it difficult for an application to know when a queue may be deleted safely.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Experiment with the programs in [Example 46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "Example 46-1. Using msgget()") (`svmsg_create.c`), [Example 46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare
    "Example 46-2. Using msgsnd() to send a message") (`svmsg_send.c`), and [Example 46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare
    "Example 46-3. Using msgrcv() to read a message") (`svmsg_receive.c`) to confirm
    your understanding of the *msgget()*, *msgsnd()*, and *msgrcv()* system calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recode the sequence-number client-server application of [A Client-Server Application
    Using FIFOs](ch44.html#a_client-server_application_using_fifos "A Client-Server
    Application Using FIFOs") to use System V message queues. Use a single message
    queue to transmit messages from both client to server and server to client. Employ
    the conventions for message types described in Section 46.8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the client-server application of [A File-Server Application Using Message
    Queues](ch46.html#a_file-server_application_using_message "A File-Server Application
    Using Message Queues"), why does the client pass the identifier of its message
    queue in the body of the message (in the *clientId* field), rather than in the
    message type (*mtype*)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to the client-server application of [A File-Server
    Application Using Message Queues](ch46.html#a_file-server_application_using_message
    "A File-Server Application Using Message Queues"):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the use of a hard-coded message queue key with code in the server that
    uses `IPC_PRIVATE` to generate a unique identifier, and then writes this identifier
    to a well-known file. The client must read the identifier from this file. The
    server should remove this file if it terminates.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the *serveRequest()* function of the server program, system call errors are
    not diagnosed. Add code that logs errors using *syslog()* ([Logging Messages and
    Errors Using *syslog*](ch37.html#logging_messages_and_errors_using_syslog "Logging
    Messages and Errors Using syslog")).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to the server so that it becomes a daemon on startup ([Creating a Daemon](ch37.html#creating_a_daemon
    "Creating a Daemon")).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the server, add a handler for `SIGTERM` and `SIGINT` that performs a tidy
    exit. The handler should remove the message queue and (if the earlier part of
    this exercise was implemented) the file created to hold the server’s message queue
    identifier. Include code in the handler to terminate the server by disestablishing
    the handler, and then once more raising the same signal that invoked the handler
    (see [Process Termination from a Signal Handler](ch26.html#process_termination_from_a_signal_handle
    "Process Termination from a Signal Handler") for the rationale and steps required
    for this task).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The server child doesn’t handle the possibility that the client may terminate
    prematurely, in which case the server child would fill the client’s message queue,
    and then block indefinitely. Modify the server to handle this possibility by establishing
    a timeout when calling *msgsnd()*, as described in Section 23.3. If the server
    child deems that the client has disappeared, it should attempt to delete the client’s
    message queue, and then exit (after perhaps logging a message via *syslog()*).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The client shown in [Example 46-9](ch46.html#client_for_file_server_using_system_v_me
    "Example 46-9. Client for file server using System V message queues") (`svmsg_file_client.c`)
    doesn’t handle various possibilities for failure in the server. In particular,
    if the server message queue fills up (perhaps because the server terminated and
    the queue was filled by other clients), then the *msgsnd()* call will block indefinitely.
    Similarly, if the server fails to send a response to the client, then the *msgrcv()*
    call will block indefinitely. Add code to the client that sets timeouts ([Setting
    Timeouts on Blocking Operations](ch23.html#setting_timeouts_on_blocking_operations
    "Setting Timeouts on Blocking Operations")) on these calls. If either call times
    out, then the program should report an error to the user and terminate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a simple chat application (similar to *talk(1)*, but without the *curses*
    interface) using System V messages queues. Use a single message queue for each
    client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
