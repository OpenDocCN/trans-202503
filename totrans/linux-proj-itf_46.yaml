- en: Chapter 46. System V Message Queues
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第46章 系统V消息队列
- en: 'This chapter describes System V message queues. Message queues allow processes
    to exchange data in the form of messages. Although message queues are similar
    to pipes and FIFOs in some respects, they also differ in important ways:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了System V消息队列。消息队列允许进程以消息的形式交换数据。尽管消息队列在某些方面与管道和FIFO相似，但它们在许多重要方面也有所不同：
- en: The handle used to refer to a message queue is the identifier returned by a
    call to *msgget()*. These identifiers are not the same as the file descriptors
    used for most other forms of I/O on UNIX systems.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于引用消息队列的句柄是通过调用*msgget()*返回的标识符。这些标识符与大多数UNIX系统中用于其他I/O形式的文件描述符不同。
- en: Communication via message queues is message-oriented; that is, the reader receives
    whole messages, as written by the writer. It is not possible to read part of a
    message, leaving the remainder in the queue, or to read multiple messages at a
    time. This contrasts with pipes, which provide an undifferentiated stream of bytes
    (i.e., with pipes, the reader can read an arbitrary number of bytes at a time,
    irrespective of the size of data blocks written by the writer).
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过消息队列进行通信是面向消息的；也就是说，读取者接收到完整的消息，正如写入者所写的那样。不能读取消息的一部分并将其余部分留在队列中，也不能一次读取多条消息。这与管道不同，管道提供的是不区分字节流（即，使用管道时，读取者可以一次读取任意数量的字节，无论写入者写入的数据块的大小）。
- en: In addition to containing data, each message has an integer *type*. Messages
    can be retrieved from a queue in first-in, first-out order or retrieved by type.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条消息除了包含数据外，还有一个整数*type*。消息可以按照先进先出顺序从队列中获取，或者按类型获取。
- en: At the end of this chapter ([Disadvantages of System V Message Queues](ch46.html#disadvantages_of_system_v_message_queues
    "Disadvantages of System V Message Queues")), we summarize a number of limitations
    of System V message queues. These limitations lead us to the conclusion that,
    where possible, new applications should avoid the use of System V message queues
    in favor of other IPC mechanisms such as FIFOs, POSIX message queues, and sockets.
    However, when message queues were initially devised, these alternative mechanisms
    were unavailable or were not widespread across UNIX implementations. Consequently,
    there are various existing applications that employ message queues, and this fact
    forms one of the primary motivations for describing them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分（[System V消息队列的缺点](ch46.html#disadvantages_of_system_v_message_queues
    "System V消息队列的缺点")）总结了System V消息队列的若干局限性。这些局限性使我们得出结论：在可能的情况下，新的应用程序应避免使用System
    V消息队列，转而选择其他IPC机制，如FIFO、POSIX消息队列和套接字。然而，当初设计消息队列时，这些替代机制尚不可用或在UNIX实现中并不广泛。因此，仍有许多现有应用程序使用消息队列，这也是我们描述它们的主要动机之一。
- en: Creating or Opening a Message Queue
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建或打开消息队列
- en: The *msgget()* system call creates a new message queue or obtains the identifier
    of an existing queue.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*msgget()*系统调用用于创建一个新的消息队列或获取现有队列的标识符。'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns message queue identifier on success, or -1 on error
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回消息队列标识符，出错时返回 -1
- en: 'The *key* argument is a key generated using one of the methods described in
    [IPC Keys](ch45.html#ipc_keys "IPC Keys") (i.e., usually the value `IPC_PRIVATE`
    or a key returned by *ftok()*). The *msgflg* argument is a bit mask that specifies
    the permissions ([Table 15-4](ch15.html#constants_for_file_permission_bits "Table 15-4. Constants
    for file permission bits"), in [Permissions on Regular Files](ch15.html#permissions_on_regular_files
    "Permissions on Regular Files")) to be placed on a new message queue or checked
    against an existing queue. In addition, zero or more of the following flags can
    be ORed (|) in *msgflg* to control the operation of *msgget()*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*key*参数是通过[IPC键](ch45.html#ipc_keys "IPC Keys")（即通常是值`IPC_PRIVATE`或*ftok()*返回的键）生成的键。*msgflg*参数是一个位掩码，指定新消息队列的权限（[表15-4](ch15.html#constants_for_file_permission_bits
    "表15-4. 文件权限常量")，在[常规文件权限](ch15.html#permissions_on_regular_files "常规文件权限")中）。此外，可以在*msgflg*中按位或(|)一个或多个以下标志，以控制*msgget()*的操作：'
- en: '`IPC_CREAT`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_CREAT`'
- en: If no message queue with the specified *key* exists, create a new queue.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在使用指定*key*的消息队列，则创建一个新队列。
- en: '`IPC_EXCL`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_EXCL`'
- en: If `IPC_CREAT` was also specified, and a queue with the specified *key* already
    exists, fail with the error `EEXIST`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还指定了`IPC_CREAT`，并且使用指定的*key*的队列已经存在，则返回错误`EEXIST`。
- en: These flags are described in more detail in Section 45.1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志在第45.1节中有更详细的描述。
- en: The *msgget()* system call begins by searching the set of all existing message
    queues for one with the specified key. If a matching queue is found, the identifier
    of that queue is returned (unless both `IPC_CREAT` and `IPC_EXCL` were specified
    in *msgflg*, in which case an error is returned). If no matching queue was found
    and `IPC_CREAT` was specified in *msgflg*, a new queue is created and its identifier
    is returned.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*msgget()* 系统调用首先会在所有现有的消息队列中搜索具有指定键的队列。如果找到匹配的队列，则返回该队列的标识符（除非在 *msgflg* 中同时指定了
    `IPC_CREAT` 和 `IPC_EXCL`，此时将返回错误）。如果未找到匹配的队列并且在 *msgflg* 中指定了 `IPC_CREAT`，则会创建一个新队列并返回其标识符。'
- en: The program in [Example 46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "Example 46-1. Using msgget()") provides a command-line interface to the *msgget()*
    system call. The program permits the use of command-line options and arguments
    to specify all possibilities for the *key* and *msgflg* arguments to *msgget()*.
    Details of the command format accepted by this program are shown in the *usageError()*
    function. Upon successful queue creation, the program prints the queue identifier.
    We demonstrate the use of this program in [Receiving Messages](ch46.html#receiving_messages
    "Receiving Messages").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 46-1](ch46.html#using_msgget_open_parenthesis_close_pare "示例 46-1. 使用 msgget()")
    中的程序提供了一个命令行接口，用于调用 *msgget()* 系统调用。该程序允许使用命令行选项和参数来指定 *key* 和 *msgflg* 参数的所有可能值。该程序接受的命令格式的详细信息显示在
    *usageError()* 函数中。成功创建队列后，程序会打印队列标识符。我们在[接收消息](ch46.html#receiving_messages "接收消息")中演示了该程序的使用。'
- en: Example 46-1. Using *msgget()*
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 46-1. 使用 *msgget()*
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Exchanging Messages
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换消息
- en: 'The *msgsnd()* and *msgrcv()* system calls perform I/O on message queues. The
    first argument to both system calls (*msqid*) is a message queue identifier. The
    second argument, *msgp*, is a pointer to a programmer-defined structure used to
    hold the message being sent or received. This structure has the following general
    form:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*msgsnd()* 和 *msgrcv()* 系统调用执行消息队列上的 I/O 操作。两个系统调用的第一个参数 (*msqid*) 是消息队列的标识符。第二个参数，*msgp*，是指向程序员定义的结构体的指针，该结构体用于保存正在发送或接收的消息。该结构体的通用形式如下：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This definition is really just shorthand for saying that the first part of a
    message contains the message type, specified as a long integer, while the remainder
    of the message is a programmer-defined structure of arbitrary length and content;
    it need not be an array of characters. Thus, the *mgsp* argument is typed as *void
    ** to allow it to be a pointer to any type of structure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义实际上只是简写，表示消息的第一部分包含消息类型，类型为长整型，而消息的其余部分是程序员定义的任意长度和内容的结构体；它不一定是字符数组。因此，*mgsp*
    参数被类型化为 *void **，允许它指向任何类型的结构体。
- en: A zero-length *mtext* field is permitted, and is sometimes useful if the information
    to be conveyed can be encoded solely in the message type or if the existence of
    a message is in itself sufficient information for the receiving process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 允许零长度的 *mtext* 字段，如果要传递的信息仅能通过消息类型编码，或者消息的存在本身就是接收进程所需的信息，零长度的 *mtext* 字段有时会很有用。
- en: Sending Messages
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送消息
- en: The *msgsnd()* system call writes a message to a message queue.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*msgsnd()* 系统调用将消息写入消息队列。'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: To send a message with *msgsnd()*, we must set the *mtype* field of the message
    structure to a value greater than 0 (we see how this value is used when we discuss
    *msgrcv()* in the next section) and copy the desired information into the programmer-defined
    *mtext* field. The *msgsz* argument specifies the number of bytes contained in
    the *mtext* field.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 *msgsnd()* 发送消息，必须将消息结构体的 *mtype* 字段设置为大于 0 的值（我们将在下一节讨论 *msgrcv()* 时看到该值的使用），并将所需的信息复制到程序员定义的
    *mtext* 字段中。*msgsz* 参数指定 *mtext* 字段中包含的字节数。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When sending messages with *msgsnd()*, there is no concept of a partial write
    as with *write()*. This is why a successful *msgsnd()* needs only to return 0,
    rather than the number of bytes sent.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *msgsnd()* 发送消息时，不存在像 *write()* 那样的部分写入概念。这就是为什么成功的 *msgsnd()* 只需要返回 0，而不是发送的字节数。
- en: 'The final argument, *msgflg*, is a bit mask of flags controlling the operation
    of *msgsnd()*. Only one such flag is defined:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的参数 *msgflg* 是一个位掩码，控制 *msgsnd()* 的操作。定义了一个这样的标志：
- en: '`IPC_NOWAIT`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_NOWAIT`'
- en: Perform a nonblocking send. Normally, if a message queue is full, *msgsnd()*
    blocks until enough space has become available to allow the message to be placed
    on the queue. However, if this flag is specified, then *msgsnd()* returns immediately
    with the error `EAGAIN`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行非阻塞发送。通常，如果消息队列已满，*msgsnd()*会阻塞，直到有足够的空间可以将消息放入队列中。然而，如果指定了此标志，则*msgsnd()*会立即返回错误`EAGAIN`。
- en: A *msgsnd()* call that is blocked because the queue is full may be interrupted
    by a signal handler. In this case, *msgsnd()* always fails with the error `EINTR`.
    (As noted in [Interruption and Restarting of System Calls](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls"), *msgsnd()* is among those system
    calls that are never automatically restarted, regardless of the setting of the
    `SA_RESTART` flag when the signal handler is established.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于队列已满而阻塞的*msgsnd()*调用可能会被信号处理程序中断。在这种情况下，*msgsnd()*将始终因错误`EINTR`而失败。（如在[系统调用的中断与重启](ch21.html#interruption_and_restarting_of_system_ca
    "系统调用的中断与重启")中所述，*msgsnd()*是那些无论在设置`SA_RESTART`标志时如何，都不会自动重启的系统调用之一。）
- en: Writing a message to a message queue requires write permission on the queue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 向消息队列写入消息需要具有队列的写权限。
- en: The program in [Example 46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare
    "Example 46-2. Using msgsnd() to send a message") provides a command-line interface
    to the *msgsnd()* system call. The command-line format accepted by this program
    is shown in the *usageError()* function. Note that this program doesn’t use the
    *msgget()* system call. (We noted that a process doesn’t need to use a *get* call
    in order to access an IPC object in Section 45.1.) Instead, we specify the message
    queue by providing its identifier as a command-line argument. We demonstrate the
    use of this program in [Receiving Messages](ch46.html#receiving_messages "Receiving
    Messages").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare "示例 46-2. 使用msgsnd()发送消息")中的程序为*msgsnd()*系统调用提供了一个命令行界面。该程序接受的命令行格式如*usageError()*函数中所示。请注意，这个程序并没有使用*msgget()*系统调用。（我们在第45.1节中提到，进程不需要使用*get*调用就能访问IPC对象。）相反，我们通过提供其标识符作为命令行参数来指定消息队列。我们在[接收消息](ch46.html#receiving_messages
    "接收消息")中演示了此程序的使用。'
- en: Example 46-2. Using *msgsnd()* to send a message
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 46-2. 使用*msgsnd()*发送消息
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Receiving Messages
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收消息
- en: The *msgrcv()* system call reads (and removes) a message from a message queue,
    and copies its contents into the buffer pointed to by *msgp*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*msgrcv()*系统调用从消息队列中读取（并移除）一条消息，并将其内容复制到由*msgp*指向的缓冲区中。'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes copied into *mtext* field, or -1 on error
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 返回复制到*mtext*字段的字节数，若出错则返回-1
- en: The maximum space available in the *mtext* field of the *msgp* buffer is specified
    by the argument *maxmsgsz*. If the body of the message to be removed from the
    queue exceeds *maxmsgsz* bytes, then no message is removed from the queue, and
    *msgrcv()* fails with the error `E2BIG`. (This default behavior can be changed
    using the `MSG_NOERROR` flag described shortly.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*msgp*缓冲区中*mtext*字段可用的最大空间由参数*maxmsgsz*指定。如果要从队列中移除的消息体超过*maxmsgsz*字节，则不会从队列中移除消息，且*msgrcv()*将因错误`E2BIG`而失败。（这个默认行为可以通过稍后描述的`MSG_NOERROR`标志进行更改。）'
- en: 'Messages need not be read in the order in which they were sent. Instead, we
    can select messages according to the value in the *mtype* field. This selection
    is controlled by the *msgtyp* argument, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 消息不必按发送的顺序读取。相反，我们可以根据*mtype*字段中的值选择消息。此选择由*msgtyp*参数控制，如下所示：
- en: If *msgtyp* equals 0, the first message from the queue is removed and returned
    to the calling process.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*msgtyp*等于0，则从队列中移除并返回第一个消息给调用进程。
- en: If *msgtyp* is greater than 0, the first message in the queue whose *mtype*
    equals *msgtyp* is removed and returned to the calling process. By specifying
    different values for *msgtyp*, multiple processes can read from a message queue
    without racing to read the same messages. One useful technique is to have each
    process select messages matching its process ID.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*msgtyp*大于0，则从队列中移除并返回第一个*mtype*等于*msgtyp*的消息给调用进程。通过为*msgtyp*指定不同的值，多个进程可以从消息队列中读取，而不必竞争读取相同的消息。一种有用的技术是让每个进程选择与其进程ID匹配的消息。
- en: If *msgtyp* is less than 0, treat the waiting messages as a *priority queue*.
    The first message of the lowest *mtype* less than or equal to the absolute value
    of *msgtyp* is removed and returned to the calling process.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*msgtyp*小于0，则将待处理消息视为*优先队列*。首先移除并返回绝对值小于或等于*msgtyp*的最低*mtype*的消息。
- en: 'An example helps clarify the behavior when *msgtyp* is less than 0\. Suppose
    that we have a message queue containing the sequence of messages shown in [Figure 46-1](ch46.html#example_of_a_message_queue_containing_me
    "Figure 46-1. Example of a message queue containing messages of different types")
    and we performed a series of *msgrcv()* calls of the following form:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例有助于阐明当*msgtyp*小于0时的行为。假设我们有一个包含图[46-1](ch46.html#example_of_a_message_queue_containing_me
    "图46-1. 包含不同类型消息的消息队列示例")所示消息序列的消息队列，并且我们执行一系列如下形式的*msgrcv()*调用：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These *msgrcv()* calls would retrieve messages in the order 2 (type 100), 5
    (type 100), 3 (type 200), and 1 (type 300). A further call would block, since
    the type of the remaining message (400) exceeds 300.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些*msgrcv()*调用将按顺序检索消息：2（类型100）、5（类型100）、3（类型200）和1（类型300）。进一步的调用将会阻塞，因为剩余消息的类型（400）超过了300。
- en: 'The *msgflg* argument is a bit mask formed by ORing together zero or more of
    the following flags:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*msgflg*参数是一个位掩码，通过按位或组合以下标志中的一个或多个形成：'
- en: '`IPC_NOWAIT`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_NOWAIT`'
- en: Perform a nonblocking receive. Normally, if no message matching *msgtyp* is
    in the queue, *msgrcv()* blocks until such a message becomes available. Specifying
    the `IPC_NOWAIT` flag causes *msgrcv()* to instead return immediately with the
    error `ENOMSG`. (The error `EAGAIN` would be more consistent, as occurs on a nonblocking
    *msgsnd()* or a nonblocking read from a FIFO. However, failing with `ENOMSG` is
    historical behavior, and required by SUSv3.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 执行非阻塞接收。通常，如果队列中没有与*msgtyp*匹配的消息，*msgrcv()*将阻塞，直到有匹配的消息可用。指定`IPC_NOWAIT`标志会使*msgrcv()*立即返回，并显示错误`ENOMSG`。（错误`EAGAIN`会更为一致，就像在非阻塞*msgsnd()*或非阻塞从FIFO读取时发生的那样。然而，返回`ENOMSG`是历史行为，并且SUSv3要求如此。）
- en: '`MSG_EXCEPT`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_EXCEPT`'
- en: This flag has an effect only if *msgtyp* is greater than 0, in which case it
    forces the complement of the usual operation; that is, the first message from
    the queue whose *mtype* is *not* equal to *msgtyp* is removed from the queue and
    returned to the caller. This flag is Linux-specific, and is made available from
    `<sys/msg.h>` only if `_GNU_SOURCE` is defined. Performing a series of calls of
    the form *msgrcv(id, &msg, maxmsgsz, 100, MSG_EXCEPT)* on the message queue shown
    in [Figure 46-1](ch46.html#example_of_a_message_queue_containing_me "Figure 46-1. Example
    of a message queue containing messages of different types") would retrieve messages
    in the order 1, 3, 4, and then block.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该标志仅在*msgtyp*大于0时有效，在这种情况下，它强制执行常规操作的补充操作；也就是说，队列中第一个*mtype*不等于*msgtyp*的消息将从队列中移除并返回给调用者。此标志是Linux特有的，只有在定义了`_GNU_SOURCE`时才会从`<sys/msg.h>`中提供。对图[46-1](ch46.html#example_of_a_message_queue_containing_me
    "图46-1. 包含不同类型消息的消息队列示例")所示的消息队列执行一系列形式为*msgrcv(id, &msg, maxmsgsz, 100, MSG_EXCEPT)*的调用，将按顺序检索消息：1、3、4，然后阻塞。
- en: '`MSG_NOERROR`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_NOERROR`'
- en: By default, if the size of the *mtext* field of the message exceeds the space
    available (as defined by the *maxmsgsz* argument), *msgrcv()* fails. If the `MSG_NOERROR`
    flag is specified, then *msgrcv()* instead removes the message from the queue,
    truncates its *mtext* field to *maxmsgsz* bytes, and returns it to the caller.
    The truncated data is lost.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果消息的*mtext*字段的大小超过了可用空间（由*maxmsgsz*参数定义），*msgrcv()*将失败。如果指定了`MSG_NOERROR`标志，则*msgrcv()*将从队列中移除该消息，将其*mtext*字段截断为*maxmsgsz*字节，并返回给调用者。截断的数据将丢失。
- en: Upon successful completion, *msgrcv()* returns the size of the *mtext* field
    of the received message; on error, -1 is returned.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 成功完成后，*msgrcv()*返回接收到的消息的*mtext*字段的大小；如果发生错误，则返回-1。
- en: '![Example of a message queue containing messages of different types](figs/web/46-1_SVMSG-queue-example-scale90.png.jpg)Figure 46-1. Example
    of a message queue containing messages of different types'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![不同类型消息的消息队列示例](figs/web/46-1_SVMSG-queue-example-scale90.png.jpg)图46-1. 包含不同类型消息的消息队列示例'
- en: As with *msgsnd()*, if a blocked *msgrcv()* call is interrupted by a signal
    handler, then the call fails with the error `EINTR`, regardless of the setting
    of the `SA_RESTART` flag when the signal handler was established.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与*msgsnd()*一样，如果被信号处理程序中断的阻塞*msgrcv()*调用发生，调用将失败并返回错误`EINTR`，无论在设置信号处理程序时`SA_RESTART`标志的设置如何。
- en: Reading a message from a message queue requires read permission on the queue.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从消息队列中读取消息需要对队列具有读取权限。
- en: Example program
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The program in [Example 46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare
    "Example 46-3. Using msgrcv() to read a message") provides a command-line interface
    to the *msgrcv()* system call. The command-line format accepted by this program
    is shown in the *usageError()* function. Like the program in [Example 46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare
    "Example 46-2. Using msgsnd() to send a message"), which demonstrated the use
    of *msgsnd()*, this program doesn’t use the *msgget()* system call, but instead
    expects a message queue identifier as its command-line argument.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare "示例46-3. 使用msgrcv()读取消息")中的程序提供了一个命令行接口，用于调用*msgrcv()*系统调用。该程序接受的命令行格式显示在*usageError()*函数中。与[示例46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare
    "示例46-2. 使用msgsnd()发送消息")中的程序一样，该程序演示了如何使用*msgsnd()*，但没有使用*msgget()*系统调用，而是期望将消息队列标识符作为命令行参数。'
- en: 'The following shell session demonstrates the use of the programs in [Example 46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "Example 46-1. Using msgget()"), [Example 46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare
    "Example 46-2. Using msgsnd() to send a message"), and [Example 46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare
    "Example 46-3. Using msgrcv() to read a message"). We begin by creating a message
    queue using the `IPC_PRIVATE` key, and then write three messages with different
    types to the queue:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话演示了[示例46-1](ch46.html#using_msgget_open_parenthesis_close_pare "示例46-1.
    使用msgget()")、[示例46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare "示例46-2.
    使用msgsnd()发送消息")和[示例46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare "示例46-3.
    使用msgrcv()读取消息")程序的使用。我们首先使用`IPC_PRIVATE`键创建一个消息队列，然后将三条不同类型的消息写入队列：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then use the program in [Example 46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare
    "Example 46-3. Using msgrcv() to read a message") to read messages with a type
    less than or equal to 20 from the queue:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用[示例46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare "示例46-3.
    使用msgrcv()读取消息")中的程序从队列中读取类型小于或等于 20 的消息：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last of the above commands blocked, because there was no message in the
    queue whose type was less than or equal to 20\. So, we continue by typing *Control-C*
    to terminate the command, and then execute a command that reads a message of any
    type from the queue:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令中的最后一个被阻塞，因为队列中没有类型小于或等于 20 的消息。所以，我们继续通过键入*Control-C*来终止命令，然后执行一个从队列中读取任何类型消息的命令：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 46-3. Using *msgrcv()* to read a message
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 46-3. 使用*msgrcv()*读取消息
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Message Queue Control Operations
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息队列控制操作
- en: The *msgctl()* system call performs control operations on the message queue
    identified by *msqid*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*msgctl()* 系统调用对由*msqid*标识的消息队列执行控制操作。'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'The *cmd* argument specifies the operation to be performed on the queue. It
    can be one of the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*cmd*参数指定要对队列执行的操作。它可以是以下之一：'
- en: '`IPC_RMID`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_RMID`'
- en: Immediately remove the message queue object and its associated *msqid_ds* data
    structure. All messages remaining in the queue are lost, and any blocked reader
    or writer processes are immediately awakened, with *msgsnd()* or *msgrcv()* failing
    with the error `EIDRM`. The third argument to *msgctl()* is ignored for this operation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 立即删除消息队列对象及其关联的*msqid_ds*数据结构。队列中剩余的所有消息将丢失，任何被阻塞的读写进程将立即被唤醒，*msgsnd()*或*msgrcv()*调用将因错误`EIDRM`而失败。*msgctl()*的第三个参数对于此操作被忽略。
- en: '`IPC_STAT`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_STAT`'
- en: Place a copy of the *msqid_ds* data structure associated with this message queue
    in the buffer pointed to by *buf*. We describe the *msqid_ds* structure in Section
    46.4.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将与此消息队列相关的*msqid_ds*数据结构的副本放入指向*buf*的缓冲区中。我们在第46.4节中描述了*msqid_ds*结构。
- en: '`IPC_SET`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_SET`'
- en: Update selected fields of the *msqid_ds* data structure associated with this
    message queue using values provided in the buffer pointed to by *buf*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指向*buf*的缓冲区中提供的值，更新与此消息队列相关的*msqid_ds*数据结构的选定字段。
- en: Further details about these operations, including the privileges and permissions
    required by the calling process, are described in Section 45.3\. We describe some
    other values for *cmd* in Section 46.6.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的详细信息，包括调用进程所需的特权和权限，详见第45.3节。我们在第46.6节中描述了*cmd*的其他一些值。
- en: The program in [Example 46-4](ch46.html#deleting_system_v_message_queues "Example 46-4. Deleting
    System V message queues") demonstrates the use of *msgctl()* to delete a message
    queue.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 46-4](ch46.html#deleting_system_v_message_queues "示例 46-4. 删除 System V
    消息队列") 中的程序展示了使用 *msgctl()* 删除消息队列的过程。'
- en: Example 46-4. Deleting System V message queues
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 46-4. 删除 System V 消息队列
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Message Queue Associated Data Structure
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息队列关联数据结构
- en: 'Each message queue has an associated *msqid_ds* data structure of the following
    form:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消息队列都有一个关联的 *msqid_ds* 数据结构，其形式如下：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The purpose of the abbreviated spelling *msq* in the name *msqid_ds* is to confuse
    the programmer. This is the only message queue interface employing this spelling.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*msqid_ds* 中的简写 *msq* 目的是为了让程序员感到困惑。这是唯一使用此拼写的消息队列接口。'
- en: The *msgqnum_t* and *msglen_t* data types—used to type the *msg_qnum* and *msg_qbytes*
    fields—are unsigned integer types specified in SUSv3.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*msgqnum_t* 和 *msglen_t* 数据类型——用于定义 *msg_qnum* 和 *msg_qbytes* 字段——是无符号整数类型，规定于
    SUSv3 中。'
- en: 'The fields of the *msqid_ds* structure are implicitly updated by the various
    message queue system calls, and certain fields can be explicitly updated using
    the *msgctl()* `IPC_SET` operation. The details are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*msqid_ds* 结构的字段会在各类消息队列系统调用中隐式更新，并且某些字段可以通过 *msgctl()* `IPC_SET` 操作显式更新。详细信息如下：'
- en: '*msg_perm*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*msg_perm*'
- en: When the message queue is created, the fields of this substructure are initialized
    as described in Section 45.3\. The *uid*, *gid*, and *mode* subfields can be updated
    via `IPC_SET`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息队列被创建时，此子结构的字段按第 45.3 节所述初始化。*uid*、*gid* 和 *mode* 子字段可以通过 `IPC_SET` 更新。
- en: '*msg_stime*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*msg_stime*'
- en: When the queue is created, this field is set to 0; each later successful *msgsnd()*
    sets this field to the current time. This field and the other timestamp fields
    in the *msqid_ds* structure are typed as *time_t*; they store time in seconds
    since the Epoch.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列创建时，此字段被设置为 0；每次成功的 *msgsnd()* 会将此字段设置为当前时间。此字段和 *msqid_ds* 结构中的其他时间戳字段被定义为
    *time_t* 类型；它们存储的是自纪元以来的秒数。
- en: '*msg_rtime*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*msg_rtime*'
- en: This field is set to 0 when the message queue is created, and then set to the
    current time on each successful *msgrcv()*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段在消息队列创建时被设置为 0，然后在每次成功的 *msgrcv()* 后设置为当前时间。
- en: '*msg_ctime*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*msg_ctime*'
- en: This field is set to the current time when the message queue is created and
    whenever an `IPC_SET` operation is successfully performed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段在消息队列创建时以及每次成功执行 `IPC_SET` 操作时，都会被设置为当前时间。
- en: '*__msg_cbytes*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*__msg_cbytes*'
- en: This field is set to 0 when the message queue is created, and then adjusted
    during each successful *msgsnd()* and *msgrcv()* to reflect the total number of
    bytes contained in the *mtext* fields of all messages in the queue.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段在消息队列创建时被设置为 0，然后在每次成功的 *msgsnd()* 和 *msgrcv()* 后调整，以反映队列中所有消息的 *mtext* 字段所包含的总字节数。
- en: '*msg_qnum*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*msg_qnum*'
- en: When the message queue is created, this field is set to 0\. It is then incremented
    by each successful *msgsnd()* and decremented by each successful *msgrcv()* to
    reflect the total number of messages in the queue.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息队列创建时，此字段被设置为 0。随后，每次成功的 *msgsnd()* 会使其加一，每次成功的 *msgrcv()* 会使其减一，以反映队列中消息的总数。
- en: '*msg_qbytes*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*msg_qbytes*'
- en: The value in this field defines an upper limit on the number of bytes in the
    *mtext* fields of all messages in the message queue. This field is initialized
    to the value of the `MSGMNB` limit when the queue is created. A privileged (`CAP_SYS_RESOURCE`)
    process can use the `IPC_SET` operation to adjust *msg_qbytes* to any value in
    the range 0 to `INT_MAX` (2,147,483,647 on 32-bit platforms) bytes. An unprivileged
    process can adjust *msg_qbytes* to any value in the range 0 to `MSGMNB`. A privileged
    user can modify the value contained in the Linux-specific `/proc/sys/kernel/msgmnb`
    file in order to change the initial *msg_qbytes* setting for all subsequently
    created message queues, as well as the upper limit for subsequent changes to *msg_qbytes*
    by unprivileged processes. We say more about message queue limits in Section 46.5.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段中的值定义了消息队列中所有消息的 *mtext* 字段的字节数上限。此字段在队列创建时会初始化为 `MSGMNB` 限制值。一个具有特权的（`CAP_SYS_RESOURCE`）进程可以使用
    `IPC_SET` 操作将 *msg_qbytes* 调整为 0 到 `INT_MAX`（在 32 位平台上为 2,147,483,647）字节的任意值。一个没有特权的进程可以将
    *msg_qbytes* 调整为 0 到 `MSGMNB` 的任何值。一个特权用户可以修改 Linux 特定的 `/proc/sys/kernel/msgmnb`
    文件中的值，以更改所有后续创建的消息队列的初始 *msg_qbytes* 设置，以及未特权进程对 *msg_qbytes* 的后续更改的上限。我们将在第 46.5
    节进一步讨论消息队列的限制。
- en: '*msg_lspid*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*msg_lspid*'
- en: This field is set to 0 when the queue is created, and then set to the process
    ID of the calling process on each successful *msgsnd()*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列被创建时，该字段被设置为0，并在每次成功执行*msgsnd()*时被设置为调用进程的进程ID。
- en: '*msg_lrpid*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*msg_lrpid*'
- en: This field is set to 0 when the message queue is created, and then set to the
    process ID of the calling process on each successful *msgrcv()*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息队列被创建时，该字段被设置为0，并在每次成功执行*msgrcv()*时被设置为调用进程的进程ID。
- en: All of the above fields are specified by SUSv3, with the exception of __*msg_cbytes*.
    Nevertheless, most UNIX implementations provide an equivalent of the __*msg_cbytes*
    field.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所有字段由SUSv3指定，__*msg_cbytes*__除外。不过，大多数UNIX实现提供了相当于__*msg_cbytes*__字段的实现。
- en: The program in [Example 46-5](ch46.html#changing_the_msg_underscore_qbytes_setti
    "Example 46-5. Changing the msg_qbytes setting of a System V message queue") demonstrates
    the use of the `IPC_STAT` and `IPC_SET` operations to modify the *msg_qbytes*
    setting of a message queue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例46-5](ch46.html#changing_the_msg_underscore_qbytes_setti "示例46-5. 修改System
    V消息队列的msg_qbytes设置")中的程序演示了如何使用`IPC_STAT`和`IPC_SET`操作来修改消息队列的*msg_qbytes*设置。'
- en: Example 46-5. Changing the *msg_qbytes* setting of a System V message queue
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 示例46-5. 修改System V消息队列的*msg_qbytes*设置
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Message Queue Limits
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息队列限制
- en: Most UNIX implementations impose various limits on the operation of System V
    message queues. Here, we describe the limits under Linux and note a few differences
    from other UNIX implementations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数UNIX实现对System V消息队列的操作施加了各种限制。这里，我们描述了Linux下的限制，并指出与其他UNIX实现的若干差异。
- en: The following limits are enforced on Linux. The system call affected by the
    limit and the error that results if the limit is reached are noted in parentheses.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下限制在Linux上强制执行。受限的系统调用以及如果达到限制时产生的错误会在括号中注明。
- en: '`MSGMNI`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSGMNI`'
- en: This is a system-wide limit on the number of message queue identifiers (in other
    words, message queues) that can be created. (*msgget()*, `ENOSPC`)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个系统级别的限制，规定了可以创建的消息队列标识符数量（换句话说，消息队列的数量）。(*msgget()*, `ENOSPC`)
- en: '`MSGMAX`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSGMAX`'
- en: This is a system-wide limit specifying the maximum number of (*mtext*) bytes
    that can be written in a single message. (*msgsnd()*, `EINVAL`)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个系统级别的限制，指定了可以在单个消息中写入的最大(*mtext*)字节数。(*msgsnd()*, `EINVAL`)
- en: '`MSGMNB`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSGMNB`'
- en: This is the maximum number of (*mtext*) bytes that can be held in a message
    queue at one time. This limit is a system-wide parameter that is used to initialize
    the *msg_qbytes* field of the *msqid_ds* data structure associated with this message
    queue. Subsequently, the *msg_qbytes* value can be modified on a per-queue basis,
    as described in Section 46.4\. If a queue’s *msg_qbytes* limit is reached, then
    *msgsnd()* blocks, or fails with the error `EAGAIN` if `IPC_NOWAIT` was set.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是消息队列中一次可以容纳的最大(*mtext*)字节数。这个限制是一个系统级别的参数，用来初始化与该消息队列关联的*msqid_ds*数据结构中的*msg_qbytes*字段。随后，可以根据每个队列的需要修改*msg_qbytes*值，如第46.4节所述。如果队列的*msg_qbytes*限制被达到，则*msgsnd()*会被阻塞，或者如果设置了`IPC_NOWAIT`，则返回错误`EAGAIN`。
- en: 'Some UNIX implementations also define the following further limits:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些UNIX实现还定义了以下进一步的限制：
- en: '`MSGTQL`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSGTQL`'
- en: This is a system-wide limit on the number of messages that can be placed on
    all message queues on the system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个系统级别的限制，规定了可以放置在系统所有消息队列上的消息数量。
- en: '`MSGPOOL`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSGPOOL`'
- en: This is a system-wide limit on the size of the buffer pool that is used to hold
    data in all message queues on the system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个系统级别的限制，规定了用于保存系统中所有消息队列数据的缓冲池的大小。
- en: Although Linux doesn’t impose either of the above limits, it does limit the
    number of messages on an individual queue to the value specified by the queue’s
    *msg_qbytes* setting. This limitation is relevant only if we are writing zero-length
    messages to a queue. It has the effect that the limit on the number of zero-length
    messages is the same as the limit on the number of 1-byte messages that can be
    written to the queue. This is necessary to prevent an infinite number of zero-length
    messages being written to the queue. Although they contain no data, each zero-length
    message consumes a small amount of memory for system bookkeeping overhead.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Linux不强加上述限制，但它限制了单个队列中消息的数量，限制值由队列的*msg_qbytes*设置指定。这个限制仅在我们向队列写入零长度消息时相关。它的作用是，零长度消息的数量限制与可以写入队列的1字节消息的数量限制相同。这是为了防止写入无限数量的零长度消息。尽管这些消息不包含数据，但每个零长度消息会占用一小部分内存用于系统的账本开销。
- en: 'At system startup, the message queue limits are set to default values. These
    defaults have varied somewhat across kernel versions. (Some distributors’ kernels
    set different defaults from those provided by vanilla kernels.) On Linux, the
    limits can be viewed or changed via files in the `/proc` file system. [Table 46-1](ch46.html#system_v_message_queue_limits
    "Table 46-1. System V message queue limits") shows the `/proc` file corresponding
    to each limit. As an example, here are the default limits that we see for Linux
    2.6.31 on one x86-32 system:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统启动时，消息队列限制会设置为默认值。这些默认值在不同的内核版本之间有所不同。（一些发行版的内核设置的默认值与原生内核提供的有所不同。）在 Linux
    上，可以通过 `/proc` 文件系统中的文件查看或更改这些限制。[表 46-1](ch46.html#system_v_message_queue_limits
    "表 46-1. 系统 V 消息队列限制") 显示了与每个限制对应的 `/proc` 文件。例如，以下是我们在一台 x86-32 系统上看到的 Linux
    2.6.31 的默认限制：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Table 46-1. System V message queue limits
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表 46-1. 系统 V 消息队列限制
- en: '| Limit | Ceiling value (x86-32) | Corresponding file in `/proc/sys/kernel`
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 限制 | 上限值（x86-32） | 对应的 `/proc/sys/kernel` 中的文件 |'
- en: '| --- | --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `MSGMNI` | 32768 (`IPCMNI`) | `msgmni` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `MSGMNI` | 32768 (`IPCMNI`) | `msgmni` |'
- en: '| `MSGMAX` | Depends on available memory | `msgmax` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `MSGMAX` | 取决于可用内存 | `msgmax` |'
- en: '| `MSGMNB` | 2147483647 (`INT_MAX`) | `msgmnb` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `MSGMNB` | 2147483647 (`INT_MAX`) | `msgmnb` |'
- en: The ceiling value column of [Table 46-1](ch46.html#system_v_message_queue_limits
    "Table 46-1. System V message queue limits") shows the maximum value to which
    each limit can be raised on the x86-32 architecture. Note that although the `MSGMNB`
    limit can be raised to the value `INT_MAX`, some other limit (e.g., lack of memory)
    will be reached before a message queue can be loaded with so much data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 46-1](ch46.html#system_v_message_queue_limits "表 46-1. 系统 V 消息队列限制")中的上限值列显示了在
    x86-32 架构上每个限制可以提升的最大值。请注意，尽管 `MSGMNB` 限制可以提高到 `INT_MAX`，但在消息队列加载如此多数据之前，其他一些限制（例如，内存不足）会先达到。'
- en: 'The Linux-specific *msgctl()* `IPC_INFO` operation retrieves a structure of
    type *msginfo*, which contains the values of the various message queue limits:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 特定的 *msgctl()* `IPC_INFO` 操作检索类型为 *msginfo* 的结构，其中包含各种消息队列限制的值：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Details about `IPC_INFO` and the *msginfo* structure can be found in the *msgctl(2)*
    manual page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `IPC_INFO` 和 *msginfo* 结构的详细信息，请参见 *msgctl(2)* 手册页。
- en: Displaying All Message Queues on the System
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示系统上的所有消息队列
- en: 'In [Obtaining a List of All IPC Objects](ch45.html#obtaining_a_list_of_all_ipc_objects
    "Obtaining a List of All IPC Objects"), we looked at one way to obtain a list
    of all of the IPC objects on the system: via a set of files in the `/proc` file
    system. We now look at a second method of obtaining the same information: via
    a set of Linux-specific IPC *ctl* (*msgctl()*, *semctl()*, and *shmctl()*) operations.
    (The *ipcs* program employs these operations.) These operations are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [获取所有 IPC 对象的列表](ch45.html#obtaining_a_list_of_all_ipc_objects "获取所有 IPC 对象的列表")中，我们查看了通过
    `/proc` 文件系统中的一组文件来获取系统上所有 IPC 对象列表的一个方法。现在我们来看获取相同信息的第二种方法：通过一组 Linux 特定的 IPC
    *ctl*（*msgctl()*、*semctl()* 和 *shmctl()*）操作。（*ipcs* 程序使用这些操作。）这些操作如下：
- en: '`MSG_INFO`, `SEM_INFO`, and `SHM_INFO`: The `MSG_INFO` operation serves two
    purposes. First, it returns a structure detailing resources consumed by all message
    queues on the system. Second, as the function result of the *ctl* call, it returns
    the index of the maximum item in the *entries* array pointing to data structures
    for the message queue objects (see [Figure 45-1](ch45.html#kernel_data_structures_used_to_represent
    "Figure 45-1. Kernel data structures used to represent System V IPC (semaphore)
    objects"), in [Algorithm Employed by System V IPC *get* Calls](ch45.html#algorithm_employed_by_system_v_ipc_get_c
    "Algorithm Employed by System V IPC get Calls")). The `SEM_INFO` and `SHM_INFO`
    operations perform an analogous task for semaphore sets and shared memory segments,
    respectively. We must define the `_GNU_SOURCE` feature test macro to obtain the
    definitions of these three constants from the corresponding System V IPC header
    files.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSG_INFO`、`SEM_INFO` 和 `SHM_INFO`：`MSG_INFO` 操作有两个目的。首先，它返回一个结构，详细说明系统上所有消息队列消耗的资源。其次，作为
    *ctl* 调用的函数结果，它返回指向消息队列对象数据结构的 *entries* 数组中最大项的索引（参见 [图 45-1](ch45.html#kernel_data_structures_used_to_represent
    "图 45-1. 用于表示系统 V IPC（信号量）对象的内核数据结构")，以及 [系统 V IPC *get* 调用所采用的算法](ch45.html#algorithm_employed_by_system_v_ipc_get_c
    "系统 V IPC *get* 调用所采用的算法")）。`SEM_INFO` 和 `SHM_INFO` 操作分别为信号量集和共享内存段执行类似的任务。我们必须定义
    `_GNU_SOURCE` 特性测试宏，以便从相应的系统 V IPC 头文件中获取这三个常量的定义。'
- en: Note
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An example showing the use of `MSG_INFO` to retrieve a *msginfo* structure containing
    information about resources used by all message queue objects is provided in the
    file `svmsg/svmsg_info.c` in the source code distribution for this book.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个示例展示了如何使用 `MSG_INFO` 获取一个 *msginfo* 结构体，包含有关所有消息队列对象使用的资源信息，示例代码位于本书源代码分发包中的
    `svmsg/svmsg_info.c` 文件。
- en: '`MSG_STAT`, `SEM_STAT`, and `SHM_STAT`: Like the `IPC_STAT` operation, these
    operations retrieve the associated data structure for an IPC object. However,
    they differ in two respects. First, instead of expecting an IPC identifier as
    the first argument of the *ctl* call, these operations expect an index into the
    *entries* array. Second, if the operation is successful, then, as its function
    result, the *ctl* call returns the identifier of the IPC object corresponding
    to that index. We must define the `_GNU_SOURCE` feature test macro to obtain the
    definitions of these three constants from the corresponding System V IPC header
    files.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSG_STAT`、`SEM_STAT` 和 `SHM_STAT`：与 `IPC_STAT` 操作类似，这些操作用于检索 IPC 对象的相关数据结构。它们的区别在于两个方面。首先，这些操作期望的是
    *entries* 数组中的索引，而不是 IPC 标识符作为 *ctl* 调用的第一个参数。其次，如果操作成功，那么作为函数结果，*ctl* 调用将返回与该索引对应的
    IPC 对象的标识符。我们必须定义 `_GNU_SOURCE` 功能测试宏，以从相应的 System V IPC 头文件中获取这三个常量的定义。'
- en: 'To list all message queues on the system, we can do the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出系统上所有的消息队列，我们可以执行以下操作：
- en: Use a `MSG_INFO` operation to find out the maximum index (*maxind*) of the *entries*
    array for message queues.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `MSG_INFO` 操作来查找消息队列的 *entries* 数组的最大索引（*maxind*）。
- en: Perform a loop for all values from 0 up to and including *maxind*, employing
    a `MSG_STAT` operation for each value. During this loop, we ignore the errors
    that may occur if an item of the *entries* array is empty (`EINVAL`) or if we
    don’t have permissions on the object to which it refers (`EACCES`).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对从 0 到包括 *maxind* 的所有值执行循环，为每个值使用 `MSG_STAT` 操作。在这个循环过程中，我们忽略可能出现的错误，比如如果 *entries*
    数组中的某个项为空（`EINVAL`），或者我们没有权限访问它所指向的对象（`EACCES`）。
- en: '[Example 46-6](ch46.html#displaying_all_system_v_message_queues_o "Example 46-6. Displaying
    all System V message queues on the system") provides an implementation of the
    above steps for message queues. The following shell session log demonstrates the
    use of this program:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 46-6](ch46.html#displaying_all_system_v_message_queues_o "示例 46-6. 显示系统上所有
    System V 消息队列") 提供了上述消息队列操作步骤的实现。以下是该程序使用的 shell 会话日志：'
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 46-6. Displaying all System V message queues on the system
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 46-6. 显示系统上所有 System V 消息队列
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Client-Server Programming with Message Queues
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用消息队列进行客户端-服务器编程
- en: 'In this section, we consider two of various possible designs for client-server
    applications using System V message queues:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们考虑了使用 System V 消息队列实现客户端-服务器应用程序的两种可能设计：
- en: The use of a single message queue for exchanging messages in both directions
    between server and client.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器和客户端之间使用单一的消息队列进行双向消息交换。
- en: The use of separate message queues for the server and for each client. The server’s
    queue is used to receive incoming client requests, and responses are sent to clients
    via the individual client queues.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为服务器和每个客户端使用单独的消息队列。服务器的队列用于接收来自客户端的请求，而响应通过单独的客户端队列发送给客户端。
- en: Which approach we choose depends on the requirements of our application. We
    next consider some of the factors that may influence our choice.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择哪种方法取决于应用程序的需求。接下来，我们将考虑一些可能影响我们选择的因素。
- en: Using a single message queue for server and clients
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为服务器和客户端使用单一的消息队列
- en: 'Using a single message queue may be suitable when the messages exchanged between
    servers and clients are small. However, note the following points:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器和客户端之间交换的消息较小时，使用单一的消息队列可能是合适的。然而，需要注意以下几点：
- en: Since multiple processes may attempt to read messages at the same time, we must
    use the message type (*mtype*) field to allow each process to select only those
    messages intended for it. One way to accomplish this is to use the client’s process
    ID as the message type for messages sent from the server to the client. The client
    can send its process ID as part of its message(s) to the server. Furthermore,
    messages to the server must also be distinguished by a unique message type. For
    this purpose, we can use the number 1, which, being the process ID of the permanently
    running *init* process, can never be the process ID of a client process. (An alternative
    would be to use the server’s process ID as the message type; however, it is difficult
    for the clients to obtain this information.) This numbering scheme is shown in
    [Figure 46-2](ch46.html#using_a_single_message_queue_for_client- "Figure 46-2. Using
    a single message queue for client-server IPC").
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于多个进程可能同时尝试读取消息，我们必须使用消息类型（*mtype*）字段来允许每个进程只选择那些针对它的消息。实现这一点的一种方法是使用客户端的进程ID作为从服务器发送到客户端的消息的消息类型。客户端可以将其进程ID作为其消息的一部分发送给服务器。此外，发送到服务器的消息必须也通过一个唯一的消息类型来区分。为此，我们可以使用数字1，作为始终运行的*init*进程的进程ID，它永远不会是客户端进程的进程ID。（另一种方法是使用服务器的进程ID作为消息类型；然而，客户端很难获得此信息。）这种编号方案如[图46-2](ch46.html#using_a_single_message_queue_for_client-
    "图46-2. 使用单一消息队列进行客户端-服务器IPC")所示。
- en: Message queues have a limited capacity. This has the potential to cause a couple
    of problems. One of these is that multiple simultaneous clients could fill the
    message queue, resulting in a deadlock situation, where no new client requests
    can be submitted and the server is blocked from writing any responses. The other
    problem is that a poorly behaved or intentionally malicious client may fail to
    read responses from the server. This can lead to the queue becoming clogged with
    unread messages, preventing any communication between clients and server. (Using
    two queues—one for messages from clients to the server, and the other for messages
    from the server to the clients—would solve the first of these problems, but not
    the second.)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列具有有限的容量，这可能导致几个问题。其中之一是多个同时客户端可能会填满消息队列，导致死锁情况，在这种情况下，无法提交新的客户端请求，服务器也无法写入任何响应。另一个问题是一个表现不良或故意恶意的客户端可能无法读取来自服务器的响应。这会导致队列被未读消息堵塞，阻止客户端与服务器之间的任何通信。（使用两个队列——一个用于客户端到服务器的消息，另一个用于服务器到客户端的消息——可以解决第一个问题，但无法解决第二个问题。）
- en: '![Using a single message queue for client-server IPC](figs/web/46-2_SVMSG-cs-single-queue.png.jpg)Figure 46-2. Using
    a single message queue for client-server IPC'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用单一消息队列进行客户端-服务器IPC](figs/web/46-2_SVMSG-cs-single-queue.png.jpg)图46-2.
    使用单一消息队列进行客户端-服务器IPC'
- en: Using one message queue per client
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个客户端使用一个消息队列
- en: 'Using one message queue per client (as well as one for the server) is preferable
    where large messages need to be exchanged, or where there is potential for the
    problems listed above when using a single message queue. Note the following points
    regarding this approach:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端使用一个消息队列（以及一个服务器的消息队列）更为可取，尤其是在需要交换大消息或使用单一消息队列时可能出现上述问题的情况下。关于这种方法，请注意以下几点：
- en: Each client must create its own message queue (typically using the `IPC_PRIVATE`
    key) and inform the server of the queue’s identifier, usually by transmitting
    the identifier as part of the client’s message(s) to the server.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个客户端必须创建自己的消息队列（通常使用`IPC_PRIVATE`键），并通过将队列标识符作为客户端消息的一部分传递给服务器来告知服务器该队列的标识符。
- en: There is a system-wide limit (`MSGMNI`) on the number of message queues, and
    the default value for this limit is quite low on some systems. If we expect to
    have a large number of simultaneous clients, we may need to raise this limit.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中有一个关于消息队列数量的系统限制（`MSGMNI`），在一些系统上，该限制的默认值非常低。如果我们预计会有大量的同时客户端连接，可能需要提高这个限制。
- en: The server should allow for the possibility that the client’s message queue
    no longer exists (perhaps because the client prematurely deleted it).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器应该考虑到客户端的消息队列可能不再存在（可能是因为客户端提前删除了它）。
- en: We say more about using one message queue per client in the next section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中进一步讨论每个客户端使用一个消息队列的方式。
- en: A File-Server Application Using Message Queues
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用消息队列的文件服务器应用程序
- en: In this section, we describe a client-server application that uses one message
    queue per client. The application is a simple file server. The client sends a
    request message to the server’s message queue asking for the contents of a named
    file. The server responds by returning the file contents as a series of messages
    to the client’s private message queue. [Figure 46-3](ch46.html#client-server_ipc_using_one_message_queu
    "Figure 46-3. Client-server IPC using one message queue per client") provides
    an overview of the application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了一个使用每个客户端一个消息队列的客户端-服务器应用程序。该应用程序是一个简单的文件服务器。客户端向服务器的消息队列发送请求消息，要求获取指定文件的内容。服务器通过将文件内容作为一系列消息返回到客户端的私有消息队列来进行响应。[图
    46-3](ch46.html#client-server_ipc_using_one_message_queu "图 46-3. 每个客户端使用一个消息队列的客户端-服务器
    IPC") 提供了该应用程序的概述。
- en: Because the server performs no authentication of the client, any user that can
    run the client can obtain any of the files accessible to the server. A more sophisticated
    server would require some type of authentication from the client before serving
    the requested file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器不对客户端进行认证，任何能够运行客户端的用户都可以访问服务器上任何可以访问的文件。更为复杂的服务器会在为客户端提供请求的文件之前，要求进行某种形式的客户端认证。
- en: '![Client-server IPC using one message queue per client](figs/web/46-3_SVMSG-cs-multi-queue-scale90.png.jpg)Figure 46-3. Client-server
    IPC using one message queue per client'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![每个客户端使用一个消息队列的客户端-服务器 IPC](figs/web/46-3_SVMSG-cs-multi-queue-scale90.png.jpg)图
    46-3. 每个客户端使用一个消息队列的客户端-服务器 IPC'
- en: Common header file
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公共头文件
- en: '[Example 46-7](ch46.html#header_file_for_svmsg_underscore_file_un "Example 46-7. Header
    file for svmsg_file_server.c and svmsg_file_client.c") is the header file included
    by both the server and the client. This header defines the well-known key to be
    used for the server’s message queue (`SERVER_KEY`), and defines the formats of
    the messages to be passed between the client and the server.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 46-7](ch46.html#header_file_for_svmsg_underscore_file_un "示例 46-7. `svmsg_file_server.c`
    和 `svmsg_file_client.c` 的头文件") 是服务器和客户端都包含的头文件。此头文件定义了用于服务器消息队列的知名密钥（`SERVER_KEY`），并定义了客户端与服务器之间传递消息的格式。'
- en: 'The *requestMsg* structure defines the format of the request sent from the
    client to the server. In this structure, the *mtext* component consists of two
    fields: the identifier of the client’s message queue and the pathname of the file
    requested by the client. The constant `REQ_MSG_SIZE` equates to the combined size
    of these two fields and is used as the *msgsz* argument in calls to *msgsnd()*
    using this structure.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*requestMsg* 结构体定义了从客户端发送到服务器的请求格式。在这个结构体中，*mtext* 组件包含两个字段：客户端消息队列的标识符和客户端请求的文件的路径名。常量
    `REQ_MSG_SIZE` 等于这两个字段的总大小，并作为 *msgsz* 参数，在使用此结构体的 *msgsnd()* 调用中传递。'
- en: The *responseMsg* structure defines the format of the response messages sent
    from the server back to the client. The *mtype* field is used in response messages
    to supply information about the message content, as defined by the `RESP_MT_*`
    constants.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*responseMsg* 结构体定义了从服务器返回给客户端的响应消息的格式。*mtype* 字段用于响应消息中，提供有关消息内容的信息，如 `RESP_MT_*`
    常量所定义。'
- en: Example 46-7. Header file for `svmsg_file_server.c` and `svmsg_file_client.c`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 46-7. `svmsg_file_server.c` 和 `svmsg_file_client.c` 的头文件
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Server program
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务器程序
- en: '[Example 46-8](ch46.html#a_file_server_using_system_v_message_que "Example 46-8. A
    file server using System V message queues") is the server program for the application.
    Note the following points about the server:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 46-8](ch46.html#a_file_server_using_system_v_message_que "示例 46-8. 使用 System
    V 消息队列的文件服务器") 是该应用程序的服务器程序。请注意以下几点关于服务器的内容：'
- en: The server is designed to handle requests concurrently. A concurrent server
    design is preferable to the iterative design employed in [Example 44-7](ch44.html#an_iterative_server_using_fifos
    "Example 44-7. An iterative server using FIFOs") (page 912), since we want to
    avoid the possibility that a client request for a large file would cause all other
    client requests to wait.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器设计为并发处理请求。与在[示例 44-7](ch44.html#an_iterative_server_using_fifos "示例 44-7.
    使用 FIFO 的迭代服务器")（第 912 页）中使用的迭代设计相比，并发服务器设计更为优越，因为我们希望避免客户端请求大文件时，导致其他所有客户端请求被阻塞的情况。
- en: 'Each client request is handled by creating a child process that serves the
    requested file ![](figs/web/U008.png). In the meantime, the main server process
    waits upon further client requests. Note the following points about the server
    child:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个客户端请求通过创建一个子进程来处理，该进程为请求的文件提供服务 ![](figs/web/U008.png)。与此同时，主服务器进程会等待进一步的客户端请求。请注意以下关于服务器子进程的几点：
- en: Since the child produced via *fork()* inherits a copy of the parent’s stack,
    it thus obtains a copy of the request message read by the main server process.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于通过*fork()*创建的子进程继承了父进程的堆栈副本，因此它获得了主服务器进程读取的请求消息副本。
- en: The server child terminates after handling its associated client request ![](figs/web/U009.png).
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器子进程在处理完其关联的客户端请求后终止！[](figs/web/U009.png)。
- en: In order to avoid the creation of zombie processes ([Orphans and Zombies](ch26.html#orphans_and_zombies
    "Orphans and Zombies")), the server establishes a handler for `SIGCHLD` ![](figs/web/U006.png)
    and calls *waitpid()* within this handler ![](figs/web/U001.png).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免产生僵尸进程（[孤儿进程和僵尸进程](ch26.html#orphans_and_zombies "孤儿进程和僵尸进程")），服务器为`SIGCHLD`建立了一个处理程序！[](figs/web/U006.png)，并在该处理程序内调用*waitpid()*！[](figs/web/U001.png)。
- en: The *msgrcv()* call in the parent server process may block, and consequently
    be interrupted by the `SIGCHLD` handler. To handle this possibility, a loop is
    used to restart the call if it fails with the `EINTR` error ![](figs/web/U007.png).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父服务器进程中的*msgrcv()*调用可能会阻塞，因此可能会被`SIGCHLD`处理程序中断。为了处理这种情况，使用了一个循环，当调用失败并返回`EINTR`错误时，会重新启动该调用！[](figs/web/U007.png)。
- en: The server child executes the *serveRequest()* function ![](figs/web/U002.png),
    which sends three message types back to the client. A request with an *mtype*
    of `RESP_MT_FAILURE` indicates that the server could not open the requested file
    ![](figs/web/U003.png); `RESP_MT_DATA` is used for a series of messages containing
    file data ![](figs/web/U004.png); and `RESP_MT_END` (with a zero-length data field)
    is used to indicate that transmission of file data is complete ![](figs/web/U005.png).
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器子进程执行*serveRequest()*函数！[](figs/web/U002.png)，该函数向客户端发送三种类型的消息。*mtype*为`RESP_MT_FAILURE`的请求表示服务器无法打开请求的文件！[](figs/web/U003.png)；`RESP_MT_DATA`用于一系列包含文件数据的消息！[](figs/web/U004.png)；`RESP_MT_END`（数据字段为空）用于表示文件数据传输已完成！[](figs/web/U005.png)。
- en: We consider a number of ways to improve and extend the server program in Exercise
    46-4.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑了多种方法来改进和扩展练习46-4中的服务器程序。
- en: Example 46-8. A file server using System V message queues
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 46-8. 使用System V消息队列的文件服务器
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Client program
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 客户端程序
- en: '[Example 46-9](ch46.html#client_for_file_server_using_system_v_me "Example 46-9. Client
    for file server using System V message queues") is the client program for the
    application. Note the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 46-9](ch46.html#client_for_file_server_using_system_v_me "示例 46-9. 使用System
    V消息队列的文件服务器客户端")是该应用程序的客户端程序。请注意以下内容：'
- en: The client creates a message queue with the `IPC_PRIVATE` key ![](figs/web/U002.png)
    and uses *atexit()* ![](figs/web/U003.png) to establish an exit handler ![](figs/web/U001.png)
    to ensure that the queue is deleted when the client exits.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端创建一个使用`IPC_PRIVATE`键的消息队列！[](figs/web/U002.png)，并使用*atexit()*！[](figs/web/U003.png)建立一个退出处理程序！[](figs/web/U001.png)，以确保客户端退出时删除该队列。
- en: The client passes the identifier for its queue, as well as the pathname of the
    file to be served, in a request to the server ![](figs/web/U004.png).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端通过请求向服务器传递其队列的标识符以及要提供的文件的路径名！[](figs/web/U004.png)。
- en: The client handles the possibility that the first response message sent by the
    server may be a failure notification (*mtype* equals `RESP_MT_FAILURE`) by printing
    the text of the error message returned by the server and exiting ![](figs/web/U005.png).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端处理服务器发送的第一个响应消息可能是失败通知的情况（*mtype*等于`RESP_MT_FAILURE`），通过打印服务器返回的错误消息文本并退出！[](figs/web/U005.png)。
- en: If the file is successfully opened, then the client loops ![](figs/web/U006.png),
    receiving a series of messages containing the file contents (*mtype* equals `RESP_MT_DATA`).
    The loop is terminated by receipt of an end-of-file message (*mtype* equals `RESP_MT_END`).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件成功打开，客户端将进入循环！[](figs/web/U006.png)，接收一系列包含文件内容的消息（*mtype* 等于 `RESP_MT_DATA`）。当接收到结束文件的消息（*mtype*
    等于 `RESP_MT_END`）时，循环终止。
- en: This simple client doesn’t handle various possibilities resulting from failures
    in the server. We consider some improvements in Exercise 46-5.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的客户端没有处理服务器故障所导致的各种情况。我们将在练习46-5中考虑一些改进。
- en: Example 46-9. Client for file server using System V message queues
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 46-9. 使用System V消息队列的文件服务器客户端
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following shell session demonstrates the use of the programs in [Example 46-8](ch46.html#a_file_server_using_system_v_message_que
    "Example 46-8. A file server using System V message queues") and [Example 46-9](ch46.html#client_for_file_server_using_system_v_me
    "Example 46-9. Client for file server using System V message queues"):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Disadvantages of System V Message Queues
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UNIX systems provide a number of mechanisms for transmitting data from one process
    to another on the same system, either in the form of an undelimited byte stream
    (pipes, FIFOs, and UNIX domain stream sockets) or as delimited messages (System
    V message queues, POSIX message queues, and UNIX domain datagram sockets).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'A distinctive feature of System V message queues is the ability to attach a
    numeric type to each message. This provides for two possibilities that may be
    useful to applications: reading processes may select messages by type, or they
    may employ a priority-queue strategy so that higher-priority messages (i.e., those
    with lower message type values) are read first.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'However, System V message queues have a number of disadvantages:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Message queues are referred to by identifiers, rather than the file descriptors
    used by most other UNIX I/O mechanisms. This means that a variety of file descriptor–based
    I/O techniques described in [Chapter 63](ch63.html "Chapter 63. Alternative I/O
    Models") (e.g., *select()*, *poll()*, and *epoll*) can’t be applied to message
    queues. Furthermore, writing programs that simultaneously handle inputs from both
    message queues and file descriptor-based I/O mechanisms requires code that is
    more complex than code that deals with file descriptors alone. (We look at one
    way of combining the two I/O models in Exercise 63-3.)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of keys, rather than filenames, to identify message queues results in
    additional programming complexity and also requires the use of *ipcs* and *ipcrm*
    instead of *ls* and *rm*. The *ftok()* function usually generates a unique key,
    but it is not guaranteed to do so. Employing the `IPC_PRIVATE` key guarantees
    a unique queue identifier, but leaves us with the task of making that identifier
    visible to other processes that require it.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message queues are connectionless, and the kernel doesn’t maintain a count
    of the number of processes referring to the queue as is done with pipes, FIFOs,
    and sockets. Consequently, it can be difficult to answer the following questions:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is it safe for an application to delete a message queue? (Premature deletion
    of the queue results in immediate loss of data, regardless of whether any process
    might later be interested in reading from the queue.)
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How can an application ensure that an unused queue is deleted?
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are limits on the total number of message queues, the size of messages,
    and the capacity of individual queues. These limits are configurable, but if an
    application operates outside the range of the default limits, this requires extra
    work when installing the application.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, System V message queues are often best avoided. In situations where
    we require the facility to select messages by type, we should consider alternatives.
    POSIX message queues ([Chapter 52](ch52.html "Chapter 52. POSIX Message Queues"))
    are one such alternative. As a further alternative, solutions involving multiple
    file descriptor–based communication channels may provide functionality similar
    to selecting messages by type, while at the same time allowing the use of the
    alternative I/O models described in [Chapter 63](ch63.html "Chapter 63. Alternative
    I/O Models"). For example, if we need to transmit “normal” and “priority” messages,
    we could use a pair of FIFOs or UNIX domain sockets for the two message types,
    and then employ *select()* or *poll()* to monitor file descriptors for both channels.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，System V 消息队列通常最好避免使用。在需要按类型选择消息的情况下，我们应该考虑其他替代方案。POSIX 消息队列（[第52章](ch52.html
    "第52章. POSIX 消息队列")）就是一种替代方案。作为进一步的替代，基于多个文件描述符的通信渠道解决方案可能提供类似于按类型选择消息的功能，同时允许使用[第63章](ch63.html
    "第63章. 替代 I/O 模型")中描述的其他 I/O 模型。例如，如果我们需要传输“正常”消息和“优先”消息，可以使用一对 FIFO 或 UNIX 域套接字来表示这两种消息类型，然后使用*select()*
    或 *poll()* 来监视这两个通道的文件描述符。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: System V message queues allow processes to communicate by exchanging messages
    consisting of a numeric type plus a body containing arbitrary data. The distinguishing
    features of message queues are that message boundaries are preserved and that
    the receiver(s) can select messages by type, rather than reading messages in first-in,
    first-out order.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: System V 消息队列允许进程通过交换包含数字类型和任意数据的消息体进行通信。消息队列的显著特点是保留了消息边界，并且接收方可以按类型选择消息，而不是按先进先出顺序读取消息。
- en: Various factors led us to conclude that other IPC mechanisms are usually preferable
    to System V message queues. One major difficulty is that message queues are not
    referred to using file descriptors. This means that we can’t employ various alternative
    I/O models with message queues; in particular, it is complex to simultaneously
    monitor both message queues and file descriptors to see if I/O is possible. Furthermore,
    the fact that message queues are connectionless (i.e., not reference counted)
    makes it difficult for an application to know when a queue may be deleted safely.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 各种因素使我们得出结论，通常其他 IPC 机制比 System V 消息队列更为优选。一个主要的困难是消息队列不是通过文件描述符引用的。这意味着我们无法使用各种替代
    I/O 模型与消息队列一起使用；特别是，同时监视消息队列和文件描述符以查看是否可以进行 I/O 操作是复杂的。此外，消息队列是无连接的（即，没有引用计数），这使得应用程序很难知道何时可以安全地删除队列。
- en: Exercises
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Experiment with the programs in [Example 46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "Example 46-1. Using msgget()") (`svmsg_create.c`), [Example 46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare
    "Example 46-2. Using msgsnd() to send a message") (`svmsg_send.c`), and [Example 46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare
    "Example 46-3. Using msgrcv() to read a message") (`svmsg_receive.c`) to confirm
    your understanding of the *msgget()*, *msgsnd()*, and *msgrcv()* system calls.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[示例 46-1](ch46.html#using_msgget_open_parenthesis_close_pare "示例 46-1. 使用 msgget()")（`svmsg_create.c`）、[示例
    46-2](ch46.html#using_msgsnd_open_parenthesis_close_pare "示例 46-2. 使用 msgsnd()
    发送消息")（`svmsg_send.c`）和[示例 46-3](ch46.html#using_msgrcv_open_parenthesis_close_pare
    "示例 46-3. 使用 msgrcv() 读取消息")（`svmsg_receive.c`）中进行实验，以确认你对*msgget()*、*msgsnd()*
    和 *msgrcv()* 系统调用的理解。
- en: Recode the sequence-number client-server application of [A Client-Server Application
    Using FIFOs](ch44.html#a_client-server_application_using_fifos "A Client-Server
    Application Using FIFOs") to use System V message queues. Use a single message
    queue to transmit messages from both client to server and server to client. Employ
    the conventions for message types described in Section 46.8.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将[A Client-Server Application Using FIFOs](ch44.html#a_client-server-application_using_fifos
    "使用 FIFO 的客户端-服务器应用程序")中的序列号客户端-服务器应用程序重新编码为使用 System V 消息队列。使用单一消息队列在客户端和服务器之间、以及服务器和客户端之间传输消息。采用第
    46.8 节中描述的消息类型约定。
- en: In the client-server application of [A File-Server Application Using Message
    Queues](ch46.html#a_file-server_application_using_message "A File-Server Application
    Using Message Queues"), why does the client pass the identifier of its message
    queue in the body of the message (in the *clientId* field), rather than in the
    message type (*mtype*)?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[使用消息队列的文件服务器应用程序](ch46.html#a_file-server_application_using_message "使用消息队列的文件服务器应用程序")的客户端-服务器应用程序中，为什么客户端将其消息队列的标识符放在消息体中（*clientId*字段），而不是在消息类型（*mtype*）中？
- en: 'Make the following changes to the client-server application of [A File-Server
    Application Using Message Queues](ch46.html#a_file-server_application_using_message
    "A File-Server Application Using Message Queues"):'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对[使用消息队列的文件服务器应用程序](ch46.html#a_file-server_application_using_message "使用消息队列的文件服务器应用程序")的客户端-服务器应用程序进行以下更改：
- en: Replace the use of a hard-coded message queue key with code in the server that
    uses `IPC_PRIVATE` to generate a unique identifier, and then writes this identifier
    to a well-known file. The client must read the identifier from this file. The
    server should remove this file if it terminates.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换服务器中硬编码的消息队列键，改为使用`IPC_PRIVATE`生成唯一标识符，然后将该标识符写入一个知名文件。客户端必须从该文件中读取标识符。如果服务器终止，应该删除此文件。
- en: In the *serveRequest()* function of the server program, system call errors are
    not diagnosed. Add code that logs errors using *syslog()* ([Logging Messages and
    Errors Using *syslog*](ch37.html#logging_messages_and_errors_using_syslog "Logging
    Messages and Errors Using syslog")).
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器程序的*serveRequest()*函数中，系统调用错误没有被诊断。添加代码，通过*syslog()*记录错误（[使用*syslog*记录消息和错误](ch37.html#logging_messages_and_errors_using_syslog
    "使用syslog记录消息和错误")）。
- en: Add code to the server so that it becomes a daemon on startup ([Creating a Daemon](ch37.html#creating_a_daemon
    "Creating a Daemon")).
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向服务器添加代码，使其在启动时成为一个守护进程（[创建守护进程](ch37.html#creating_a_daemon "创建守护进程")）。
- en: In the server, add a handler for `SIGTERM` and `SIGINT` that performs a tidy
    exit. The handler should remove the message queue and (if the earlier part of
    this exercise was implemented) the file created to hold the server’s message queue
    identifier. Include code in the handler to terminate the server by disestablishing
    the handler, and then once more raising the same signal that invoked the handler
    (see [Process Termination from a Signal Handler](ch26.html#process_termination_from_a_signal_handle
    "Process Termination from a Signal Handler") for the rationale and steps required
    for this task).
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器中，添加一个用于处理`SIGTERM`和`SIGINT`信号的处理程序，执行干净的退出操作。该处理程序应该移除消息队列，并且（如果前面部分的练习已实现）删除用于存放服务器消息队列标识符的文件。处理程序中应包括代码，通过取消设置处理程序来终止服务器，然后再次触发引发处理程序的相同信号（参见[信号处理中的进程终止](ch26.html#process_termination_from_a_signal_handle
    "信号处理中的进程终止")了解此任务的理由和所需步骤）。
- en: The server child doesn’t handle the possibility that the client may terminate
    prematurely, in which case the server child would fill the client’s message queue,
    and then block indefinitely. Modify the server to handle this possibility by establishing
    a timeout when calling *msgsnd()*, as described in Section 23.3. If the server
    child deems that the client has disappeared, it should attempt to delete the client’s
    message queue, and then exit (after perhaps logging a message via *syslog()*).
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器子进程没有处理客户端可能提前终止的情况，在这种情况下，服务器子进程会填满客户端的消息队列，然后无限期地阻塞。修改服务器，以处理这种情况，通过在调用*msgsnd()*时设置超时，如第23.3节所述。如果服务器子进程认为客户端已消失，它应该尝试删除客户端的消息队列，然后退出（可能会通过*syslog()*记录一条消息）。
- en: The client shown in [Example 46-9](ch46.html#client_for_file_server_using_system_v_me
    "Example 46-9. Client for file server using System V message queues") (`svmsg_file_client.c`)
    doesn’t handle various possibilities for failure in the server. In particular,
    if the server message queue fills up (perhaps because the server terminated and
    the queue was filled by other clients), then the *msgsnd()* call will block indefinitely.
    Similarly, if the server fails to send a response to the client, then the *msgrcv()*
    call will block indefinitely. Add code to the client that sets timeouts ([Setting
    Timeouts on Blocking Operations](ch23.html#setting_timeouts_on_blocking_operations
    "Setting Timeouts on Blocking Operations")) on these calls. If either call times
    out, then the program should report an error to the user and terminate.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[示例 46-9](ch46.html#client_for_file_server_using_system_v_me "示例 46-9. 使用System
    V消息队列的文件服务器客户端")中显示的客户端（`svmsg_file_client.c`）没有处理服务器可能出现的各种失败情况。特别是，如果服务器的消息队列已满（可能是因为服务器终止，且队列被其他客户端填满），那么*msgsnd()*调用将会无限期阻塞。同样，如果服务器未能发送响应给客户端，则*msgrcv()*调用将会无限期阻塞。请在客户端代码中添加设置超时的代码（[设置阻塞操作的超时](ch23.html#setting_timeouts_on_blocking_operations
    "设置阻塞操作的超时")）。如果任何一个调用超时，程序应该向用户报告错误并终止。'
- en: Write a simple chat application (similar to *talk(1)*, but without the *curses*
    interface) using System V messages queues. Use a single message queue for each
    client.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个简单的聊天应用程序（类似于*talk(1)*，但没有*curses*界面），使用System V消息队列。为每个客户端使用一个单独的消息队列。
