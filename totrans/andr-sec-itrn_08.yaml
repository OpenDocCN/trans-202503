- en: Chapter 8. Online Account Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 在线账户管理
- en: While enterprise services usually employ PKI for user authentication, most publicly
    available online services rely on passwords to authenticate their users. However,
    typing complex passwords on a touch screen mobile device multiple times a day
    for different sites is not a very pleasant exercise.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管企业服务通常使用PKI进行用户认证，但大多数公开的在线服务依赖密码来验证用户身份。然而，在触摸屏移动设备上为不同网站多次输入复杂密码并不是一项愉快的操作。
- en: In an effort to improve the user experience when accessing online services,
    Android provides a centralized registry of user accounts that can cache and reuse
    credentials. This account registry can be accessed by third-party applications,
    allowing them to access web services on behalf of the device user without the
    need for apps to handle passwords directly. In this chapter, we discuss how Android
    manages a user’s online account credentials and the APIs that applications can
    use to take advantage of cached credentials and to register custom accounts. We
    then show how Google experience devices (devices on which the Google Play Store
    is preinstalled) store Google account information and allow access to Google APIs
    and other online services by using the stored credentials.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善用户在访问在线服务时的体验，Android提供了一个集中的用户账户注册表，可以缓存和重用凭据。第三方应用可以访问这个账户注册表，从而代表设备用户访问网络服务，而不需要应用直接处理密码。在本章中，我们将讨论Android如何管理用户的在线账户凭据，以及应用程序可以使用的API，以便利用缓存凭据并注册自定义账户。接着，我们将展示Google体验设备（即预装Google
    Play商店的设备）如何存储Google账户信息，并通过存储的凭据访问Google API和其他在线服务。
- en: Android Account Management Overview
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android账户管理概述
- en: While early Android devices had built-in support for Google accounts and automatic
    background data synchronization with Google services such as Gmail, no APIs for
    this functionality were originally provided. Android 2.0 (API Level 5) introduced
    the concept of centralized account management with a public API. The central piece
    in the API is the `AccountManager` class, which “provides access to a centralized
    registry of the user’s online accounts. The user enters credentials (username
    and password) once per account, granting applications access to online resources
    with ‘one-click’ approval.”^([[78](#ftn.ch08fn01)]) Another major feature of the
    class is that it lets you get an authentication token for supported accounts,
    allowing third-party applications to authenticate to online services without needing
    to actually handle the user password. On some older Android versions, the `AccountManager`
    would also monitor your SIM card and wipe cached credentials if you swapped cards,
    but this feature was removed in Android 2.3.4 and later versions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管早期的Android设备内置支持Google账户以及与Gmail等Google服务的自动后台数据同步，但最初并未提供此功能的API。Android
    2.0（API级别5）引入了集中式账户管理的概念，并提供了公共API。该API的核心部分是`AccountManager`类，它“提供对用户在线账户的集中式注册表的访问。用户每个账户仅需输入一次凭据（用户名和密码），就能通过‘一键’授权，允许应用程序访问在线资源。”^([[78](#ftn.ch08fn01)])
    该类的另一个主要功能是，它可以为受支持的账户获取认证令牌，从而允许第三方应用在无需处理用户密码的情况下认证在线服务。在某些旧版本的Android中，`AccountManager`还会监控SIM卡，并在更换卡片时清除缓存凭据，但这个功能在Android
    2.3.4及以后版本中已被移除。
- en: Account Management Implementation
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 账户管理实现
- en: As with most Android system APIs, the `AccountManager` is just a facade for
    the `AccountManagerService`, which does the actual work. The service doesn’t provide
    an implementation for any particular form of authentication, though. It merely
    coordinates a number of pluggable authenticator modules for different account
    types (Google, Twitter, Microsoft Exchange, and so on). Any application can register
    an authenticator module by implementing an account authenticator and related classes,
    if needed. We show how to write and register a custom authenticator module in
    “[Adding an Authenticator Module](ch08.html#adding_an_authenticator_module "Adding
    an Authenticator Module")”.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数Android系统API一样，`AccountManager`只是`AccountManagerService`的外壳，实际的工作由它完成。然而，该服务并未提供任何特定形式的认证实现。它仅仅协调多个可插拔的认证模块，以支持不同的账户类型（如Google、Twitter、Microsoft
    Exchange等）。任何应用程序都可以通过实现账户认证器和相关类来注册一个认证模块（如果需要的话）。我们将在“[添加认证模块](ch08.html#adding_an_authenticator_module
    "Adding an Authenticator Module")”中展示如何编写和注册一个自定义的认证模块。
- en: 'Registering a new account type with the system lets you take advantage of a
    number of Android infrastructure services, including the ability to:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将新账户类型注册到系统中可以让你利用多个 Android 基础设施服务，包括以下能力：
- en: Use a centralized credential storage in a system database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统数据库中使用集中式凭证存储
- en: Issue tokens to third-party apps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向第三方应用发放令牌
- en: Take advantage of Android’s automatic background synchronization (via a sync
    adapter)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Android 的自动后台同步（通过同步适配器）
- en: '[Figure 8-1](ch08.html#account_management_components "Figure 8-1. Account management
    components") shows the main components of Android’s account management subsystems
    and their relationships. Each component and its role will be described in the
    following sections.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](ch08.html#account_management_components "图 8-1. 账户管理组件") 显示了 Android
    账户管理子系统的主要组件及其关系。每个组件及其角色将在接下来的章节中描述。'
- en: '![Account management components](figs/web/08fig01.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![账户管理组件](figs/web/08fig01.png.jpg)'
- en: Figure 8-1. Account management components
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1. 账户管理组件
- en: AccountManagerService and AccountManager
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AccountManagerService 和 AccountManager
- en: The central piece here is the `AccountManagerService`, which coordinates all
    other components and persists account data in the accounts database. The `AccountManager`
    class is the facade that exposes a subset of its functionality to third-party
    applications. It starts worker threads for asynchronous methods and posts the
    results (or error details) back to the caller. Additionally, `AccountManager`
    shows an account chooser when the requested token or feature can be provided by
    more than one account. However, it doesn’t enforce any permissions; all caller
    permissions are checked by the `AccountManagerService` and we’ll discuss the concrete
    permissions shortly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的核心是 `AccountManagerService`，它协调所有其他组件并将账户数据持久化到账户数据库中。`AccountManager` 类是一个外观模式，它向第三方应用暴露其部分功能。它为异步方法启动工作线程，并将结果（或错误详情）返回给调用者。此外，当请求的令牌或功能可以由多个账户提供时，`AccountManager`
    会显示账户选择器。然而，它不强制执行任何权限；所有调用者的权限由 `AccountManagerService` 检查，我们稍后会讨论具体的权限。
- en: Authenticator Modules
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证模块
- en: As mentioned above, the functionality of each registered account is provided
    by a pluggable authenticator module, but what exactly is an authenticator module?
    *Authenticator modules* are defined and hosted by applications, and each is simply
    a bound service that implements the `android.accounts.IAccountAuthenticator` AIDL
    interface. This interface has methods for adding an account, prompting the user
    for their credentials, getting an authentication token, and for updating account
    metadata. In practice, applications don’t implement this interface directly, but
    instead extend the `android.accounts.AbstractAccountAuthenticator` class which
    links implementation methods to an internal AIDL stub.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，每个注册账户的功能是由可插拔的身份验证模块提供的，那么什么是身份验证模块呢？*身份验证模块*是由应用程序定义并托管的，每个模块只是一个实现了
    `android.accounts.IAccountAuthenticator` AIDL 接口的绑定服务。该接口具有添加账户、提示用户输入凭证、获取身份验证令牌以及更新账户元数据的方法。实际上，应用程序并不直接实现此接口，而是扩展
    `android.accounts.AbstractAccountAuthenticator` 类，该类将实现方法与内部 AIDL 存根链接。
- en: The `AbstractAccountAuthenticator` also ensures that all callers of the AIDL
    stub hold the `ACCOUNT_MANAGER` permission; a system signature permission that
    only allows system components to call authenticator modules directly. All other
    clients need to go through the `AccountManagerService`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractAccountAuthenticator` 还确保所有调用 AIDL 存根的客户端都持有 `ACCOUNT_MANAGER` 权限；这是一个系统签名权限，仅允许系统组件直接调用身份验证模块。所有其他客户端需要通过
    `AccountManagerService`。'
- en: Each authenticator module implements an account identified uniquely by a string
    called the *account type*. Account types are typically in reverse domain notation
    (like Java packages) and are usually named using the base package name of the
    defining application concatenated with the account type, or the *account* or *auth*
    strings (Android does not enforce this rule, however, and there are no explicit
    guidelines). For example, in [Figure 8-1](ch08.html#account_management_components
    "Figure 8-1. Account management components"), the `com.example.app` application
    defines an account with type `com.example.account`, and the `org.foo.app` application
    defines an account with type `org.foo.account`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个认证模块实现一个由字符串唯一标识的账户，称为*账户类型*。账户类型通常采用反向域名表示法（类似于 Java 包），通常使用定义应用程序的基础包名与账户类型、*账户*
    或 *auth* 字符串连接而成（不过 Android 并不强制执行此规则，且没有明确的指导方针）。例如，在[图 8-1](ch08.html#account_management_components
    "图 8-1. 账户管理组件")中，`com.example.app` 应用定义了一个类型为 `com.example.account` 的账户，而 `org.foo.app`
    应用定义了一个类型为 `org.foo.account` 的账户。
- en: Authenticator modules are implemented by adding a service that can be bound
    to by using the *android.accounts.AccountAuthenticator* intent action to the host
    application. The account type, as well as other metadata, is linked to the service
    by adding a `<meta-data>` tag to the service declaration. The `resource` attribute
    of the tag points to an XML file that contains account metadata (see [Example 8-8](ch08.html#declaring_an_account_authenticator_servi
    "Example 8-8. Declaring an account authenticator service in AndroidManifest.xml")
    for an example).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 认证模块通过添加一个服务来实现，该服务可以通过使用 *android.accounts.AccountAuthenticator* 意图操作与主机应用程序绑定。账户类型以及其他元数据通过向服务声明中添加
    `<meta-data>` 标签与该服务关联。标签的 `resource` 属性指向一个包含账户元数据的 XML 文件（示例请参见 [示例 8-8](ch08.html#declaring_an_account_authenticator_servi
    "示例 8-8. 在 AndroidManifest.xml 中声明账户认证服务")）。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*A* *`<meta-data>`* *tag allows a name-value pair containing arbitrary data
    to be associated with its parent component. The data can be a literal value, such
    as a string or an integer, or a reference to an Android resource file. Multiple*
    *`<meta-data>`* *tags per component are also supported. The values from all* *`<meta-data>`*
    *tags are collected in a single* *`Bundle`* *object and made available as the*
    *`metaData`* *field of the* *`PackageItemInfo`* *class (the base class of concrete
    classes that encapsulate component attribute values, such as* *`ServiceInfo`**).
    The interpretation of the associated metadata is component-specific.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*<meta-data>* 标签允许将包含任意数据的键值对与其父组件关联。数据可以是字面值，如字符串或整数，也可以是对 Android 资源文件的引用。每个组件也支持多个
    *<meta-data>* 标签。所有 *<meta-data>* 标签的值会收集到一个单独的 *Bundle* 对象中，并作为 *PackageItemInfo*
    类（封装组件属性值的具体类的基类，例如 *ServiceInfo*）的 *metaData* 字段提供。关联元数据的解释是特定于组件的。'
- en: The Authenticator Module Cache
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证模块缓存
- en: “Pluggability” is provided by the `AccountAuthenticatorCache` class, which scans
    for packages that define authenticator modules and makes them available to the
    `AccountManagerService`. The `AccountAuthenticatorCache` is one implementation
    of the more general registered service cache facility that Android provides. The
    cache is built on demand (lazily) by interrogating the `PackageManagerService`
    about installed packages that register a particular intent action and metadata
    file. The cache is kept up-to-date by a broadcast receiver that triggers an update
    when packages are added, updated, or removed. The cache is persistent and written
    to disk each time a change is detected, with cache files written to the */data/system/registered_services/*
    directory and named after the intent action they scan for. The authenticator module
    cache is saved to the *android.accounts.AccountAuthenticator.xml* file and might
    look like [Example 8-1](ch08.html#contents_of_the_accountauthenticatordotx "Example 8-1. Contents
    of the AccountAuthenticator.xml registered services cache file").
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “可插拔性”由 `AccountAuthenticatorCache` 类提供，它扫描定义认证模块的包，并将它们提供给 `AccountManagerService`。`AccountAuthenticatorCache`
    是 Android 提供的更通用的注册服务缓存机制的一种实现。该缓存按需（延迟）构建，通过查询 `PackageManagerService` 来获取安装的包，这些包注册了特定的意图动作和元数据文件。广播接收器会在安装包被添加、更新或删除时触发更新，以保持缓存的最新状态。缓存是持久化的，每次检测到变化时都会写入磁盘，缓存文件被写入到
    */data/system/registered_services/* 目录，并以它们扫描的意图动作命名。认证模块缓存被保存到 *android.accounts.AccountAuthenticator.xml*
    文件中，内容可能类似于 [示例 8-1](ch08.html#contents_of_the_accountauthenticatordotx "示例 8-1.
    AccountAuthenticator.xml 注册服务缓存文件的内容")。
- en: Example 8-1. *Contents of the* AccountAuthenticator.xml *registered services
    cache file*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-1. *AccountAuthenticator.xml* 注册服务缓存文件的*内容*
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the *com.android.exchange* and *com.android.email* account types (➊ and
    ➋) are registered by the stock Email application, and *com.example. account* and
    *org.foo.account* (➌ and ➍) are registered by third-party applications. On a multi-user
    device, the cache file will have entries for the accounts available to each user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*com.android.exchange* 和 *com.android.email* 账户类型（➊ 和 ➋）由系统自带的邮件应用注册，而 *com.example.account*
    和 *org.foo.account*（➌ 和 ➍）由第三方应用注册。在多用户设备上，缓存文件会包含每个用户可用账户的条目。
- en: In this example, the first secondary user (user ID 10) can use *com.android.exchange*,
    *com.android.email*, and *com.example.account* (➎, ➏, and ➐), but not the *org.foo.account*
    account (because there is no entry for it in the file). When the `AccountManagerService`
    needs to perform an action with a particular account, it queries the `AccountAuthenticatorCache`
    for the implementing service by passing the account type. If an account implementation
    for that type is registered for the current user, `AccountAuthenticatorCache`
    returns details about the implementing service that contain the name of the implementing
    component and the UID of the host package. The `AccountManagerService` uses this
    information to bind to the service in order to be able to call methods of the
    `IAccountAuthenticator` interface that the service implements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一个次级用户（用户 ID 10）可以使用 *com.android.exchange*、*com.android.email* 和 *com.example.account*（➎、➏
    和 ➐），但不能使用 *org.foo.account* 账户（因为文件中没有它的条目）。当 `AccountManagerService` 需要对特定账户执行操作时，它通过传递账户类型查询
    `AccountAuthenticatorCache` 以获取实现服务。如果当前用户已注册该账户类型的实现，`AccountAuthenticatorCache`
    会返回包含实现服务信息的详细信息，其中包括实现组件的名称和主机包的 UID。`AccountManagerService` 使用这些信息绑定到服务，从而能够调用该服务实现的
    `IAccountAuthenticator` 接口的方法。
- en: AccountManagerService Operations and Permissions
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AccountManagerService 操作与权限
- en: As shown in [Figure 8-1](ch08.html#account_management_components "Figure 8-1. Account
    management components"), `AccountManagerService` implements its functionality
    by either calling into authenticator modules or by using cached data from the
    accounts database. Third-party components can only use the API that `AccountManagerService`
    exposes; they can’t access authenticator modules or the accounts database. This
    centralized interface guarantees operation workflow and enforces access rules
    for each operation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 8-1](ch08.html#account_management_components "图 8-1. 账户管理组件") 所示，`AccountManagerService`
    通过调用认证模块或使用账户数据库中的缓存数据来实现其功能。第三方组件只能使用 `AccountManagerService` 暴露的 API；它们不能访问认证模块或账户数据库。这个集中的接口保证了操作流程，并对每个操作执行访问控制。
- en: '`AccountManagerService` implements access control using a combination of permissions
    and caller UID and signature checks. Let’s look at the operations it provides
    and the respective permission checks.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountManagerService`通过权限、调用者UID和签名检查的组合实现访问控制。让我们来看一下它提供的操作以及相应的权限检查。'
- en: Listing and Authenticating Accounts
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出和验证账户
- en: Clients can get a list of accounts that match certain criteria (including type,
    declaring package, and other features) by calling one of the `getAccounts()` methods,
    and they can check to see if a particular account has the required features by
    calling the `hasFeatures()` method. These operations require the `GET_ACCOUNTS`
    permission, which has the *normal* protection level. A new account of a particular
    type can be added by calling the `addAccount()` method (which starts an implementation-specific
    *authenticator activity* that collects credentials from the user) or silently
    by calling the `addAccountExplicitly()` method, which takes the account, password,
    and any associated user data as parameters. The first method requires callers
    to hold the `MANAGE_ACCOUNTS` permission, and the second requires that they both
    hold the `AUTHENTICATE_ACCOUNTS` permission and have the same UID as the account’s
    authenticator. Both permissions have protection level *dangerous* and therefore
    require user confirmation when the app is installed. Requiring callers of `addAccountExplicitly()`
    to have the same UID as the authenticator ensures that only the same app, or apps
    that belong to the same shared user ID (see [Chapter 2](ch02.html "Chapter 2. Permissions")
    for details), can add accounts without user interaction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以通过调用`getAccounts()`方法之一获取匹配特定条件（包括类型、声明包和其他特性）的账户列表，他们还可以通过调用`hasFeatures()`方法检查特定账户是否具有所需特性。这些操作需要`GET_ACCOUNTS`权限，且具有*普通*保护级别。可以通过调用`addAccount()`方法（启动一个特定实现的*认证器活动*，从用户收集凭据）或通过调用`addAccountExplicitly()`方法静默添加新的账户，该方法以账户、密码和任何相关用户数据作为参数。第一个方法要求调用者拥有`MANAGE_ACCOUNTS`权限，而第二个方法则要求调用者同时拥有`AUTHENTICATE_ACCOUNTS`权限，并且与账户的认证器具有相同的UID。这两个权限的保护级别为*dangerous*，因此在应用程序安装时需要用户确认。要求`addAccountExplicitly()`的调用者与认证器具有相同UID，确保只有相同的应用程序或属于相同共享用户ID（有关详细信息，请参见[第2章](ch02.html
    "第2章 权限")）的应用程序，才能在无需用户交互的情况下添加账户。
- en: Other operations that require the caller to both hold the `AUTHENTICATE_ ACCOUNTS`
    permission and have the same UID as the account’s authenticator are listed below.
    (We’ve omitted `AccountManager` method parameters here and in the following sections
    for clarity. See the reference documentation of the `AccountManager` class^([[79](#ftn.ch08fn02)])
    for full method signatures and additional information.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他需要调用者同时拥有`AUTHENTICATE_ACCOUNTS`权限，并与账户认证器具有相同UID的操作列举如下。（为了清晰起见，我们在此及以下部分省略了`AccountManager`方法的参数。有关完整的方法签名和更多信息，请参见`AccountManager`类的参考文档^([[79](#ftn.ch08fn02)])。）
- en: '****`getPassword()`****. Returns the raw cached password.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`getPassword()`****。返回原始缓存密码。'
- en: '****`getUserData()`****. Returns authenticator-specific account metadata that
    matches a specified key.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`getUserData()`****。返回与指定键匹配的认证器特定账户元数据。'
- en: '****`peekAuthToken()`****. Returns a cached token of the specified type (if
    available).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`peekAuthToken()`****。返回指定类型的缓存令牌（如果可用）。'
- en: '****`setAuthToken()`****. Adds or replaces an authentication token for an account.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`setAuthToken()`****。为账户添加或替换认证令牌。'
- en: '****`setPassword()`****. Sets or clears the cached password for an account.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`setPassword()`****。为账户设置或清除缓存密码。'
- en: '****`setUserData()`****. Sets or clears the metadata entry with the specified
    key.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`setUserData()`****。设置或清除指定键的元数据条目。'
- en: Managing Accounts
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理账户
- en: Just as when adding a new account, removing an existing account requires the
    `MANAGE_ACCOUNTS` permission. However, if the calling device user has the `DISALLOW_MODIFY_ACCOUNTS`
    restriction set (see [Chapter 4](ch04.html "Chapter 4. User Management") for more
    details on user restrictions), they cannot add or remove accounts, even if the
    calling application holds the `MANAGE_ACCOUNTS` permission. Other methods that
    require this permission are those that modify account properties or credentials
    as listed next.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如添加新账户时一样，删除现有账户也需要`MANAGE_ACCOUNTS`权限。然而，如果调用设备用户设置了`DISALLOW_MODIFY_ACCOUNTS`限制（有关用户限制的更多信息，请参见[第4章](ch04.html
    "第4章 用户管理")），则即使调用应用程序拥有`MANAGE_ACCOUNTS`权限，他们也无法添加或删除账户。其他需要此权限的方法包括修改账户属性或凭据的方法，具体如下所示。
- en: '****`clearPassword()`****. Clears a cached password.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`clearPassword()`****. 清除缓存的密码。'
- en: '****`confirmCredentials()`****. Explicitly confirms that the user knows the
    password (even if it is already cached) by showing a password entry UI.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`confirmCredentials()`****. 明确确认用户知道密码（即使密码已经缓存），通过显示密码输入界面来实现。'
- en: '****`editProperties()`****. Shows a UI that allows the user to change global
    authenticator settings.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`editProperties()`****. 显示一个用户界面，允许用户更改全局身份验证器设置。'
- en: '****`invalidateAuthToken()`****. Removes an authentication token from the cache.
    (This can also be called if the caller holds the `USE_CREDENTIALS` permission.)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`invalidateAuthToken()`****. 从缓存中移除身份验证令牌。（如果调用者持有`USE_CREDENTIALS`权限，也可以调用此方法。）'
- en: '****`removeAccount()`****. Removes an existing account.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`removeAccount()`****. 删除现有账户。'
- en: '****`updateCredentials()`****. Asks the user the enter the current password
    and updates the saved credentials accordingly.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`updateCredentials()`****. 请求用户输入当前密码，并相应更新保存的凭据。'
- en: Using Account Credentials
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用账户凭据
- en: The final permission the `AccountManagerService` might require its clients to
    hold is `USE_CREDENTIALS`. This permission protects methods that return or modify
    *authentication tokens*, a service-dependent credential string that clients can
    use to authenticate requests to the server without sending their password with
    each request.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountManagerService`可能要求其客户端持有的最终权限是`USE_CREDENTIALS`。此权限保护返回或修改*身份验证令牌*的方法，身份验证令牌是一个服务相关的凭据字符串，客户端可以使用该令牌在不发送密码的情况下进行服务器请求的身份验证。'
- en: Typically, servers return an authentication token after the client successfully
    authenticates with their username and password (or other permanent credentials).
    The token is identified by a string called the *token type*, which describes what
    type of access the token grants (for example, read-only or read-write). The token
    is reusable and can be used for sending multiple requests, but might have a limited
    validity period. Additionally, if a user account is believed to have been compromised,
    or if a user changes their password, all existing authentication tokens for that
    user are usually invalidated on the server. In this case, requests that use cached
    authentication tokens will fail with an authentication error. Because the `AccountManagerService`
    is protocol- and application-agnostic, it doesn’t automatically invalidate cached
    tokens, even if they have expired or been invalidated on the server. Applications
    are responsible for cleaning up such invalid cached tokens by calling the `invalidateAuthToken()`
    method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在客户端使用用户名和密码（或其他永久凭据）成功进行身份验证后，服务器会返回一个身份验证令牌。该令牌通过一个字符串来标识，称为*令牌类型*，它描述了令牌所授予的访问类型（例如，只读或读写）。该令牌是可重用的，可以用于发送多个请求，但可能有有效期限制。此外，如果某个用户账户被认为已被泄露，或者用户更改了密码，通常会使该用户的所有现有身份验证令牌在服务器上失效。在这种情况下，使用缓存的身份验证令牌的请求将因身份验证错误而失败。由于`AccountManagerService`与协议和应用程序无关，它不会自动使缓存的令牌失效，即使它们已经过期或在服务器上被作废。应用程序需要通过调用`invalidateAuthToken()`方法来负责清除这些无效的缓存令牌。
- en: 'These are the methods that require `USE_CREDENTIALS`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要`USE_CREDENTIALS`权限的方法：
- en: '****`getAuthToken()`****. Gets an authentication token of the specified type
    for a particular account.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`getAuthToken()`****. 获取指定类型的身份验证令牌，适用于特定账户。'
- en: '****`invalidateAuthToken()`****. Removes an authentication token from the cache.
    (This can also be called if the caller holds the `MANAGE_ACCOUNTS` permission.)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`invalidateAuthToken()`****. 从缓存中移除身份验证令牌。（如果调用者持有`MANAGE_ACCOUNTS`权限，也可以调用此方法。）'
- en: '![Account access request dialog](figs/web/08fig02.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![账户访问请求对话框](figs/web/08fig02.png.jpg)'
- en: Figure 8-2. Account access request dialog
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2. 账户访问请求对话框
- en: Requesting Authentication Token Access
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求身份验证令牌访问
- en: Besides holding the `USE_CREDENTIALS` permission, in order to obtain an authentication
    token of a particular type, callers of the `getAuthToken()` (or any of its wrapper
    methods as provided by the `AccountManager` facade class) must explicitly be granted
    access to the requested token type. This is accomplished by showing a confirmation
    dialog like the one shown in [Figure 8-2](ch08.html#account_access_request_dialog
    "Figure 8-2. Account access request dialog"). The dialog shows both the name of
    the requesting application (in the first bullet, “Account Requestor,” in this
    example), the account type and name (in the second bullet, “Example” and “example_user”,
    respectively), and a short description (below the bullets, “Full access to example
    data”) of the type of data access that will be permitted if the access request
    is granted. If the user grants access, this decision is cached and the dialog
    won’t be shown if a token of the same type is requested again. Applications running
    under the same UID as the authenticator module are allowed access to its tokens
    without showing a confirmation dialog. Additionally, privileged system applications
    are implicitly allowed access to all token types without user confirmation, so
    the dialog is not shown if the token request comes from a privileged application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了持有`USE_CREDENTIALS`权限外，为了获得特定类型的身份验证令牌，调用`getAuthToken()`（或由`AccountManager`外观类提供的任何包装方法）的调用者必须明确获得访问请求的令牌类型。这是通过显示确认对话框来完成的，类似于[图
    8-2](ch08.html#account_access_request_dialog "图 8-2. 账户访问请求对话框")中所示的对话框。该对话框显示了请求应用程序的名称（在第一个项目符号中，“账户请求者”，在此示例中），账户类型和名称（在第二个项目符号中，分别为“Example”和“example_user”），以及简短描述（在项目符号下方，“完全访问示例数据”）如果访问请求被批准，将允许的数据访问类型。如果用户授予访问权限，该决定将被缓存，并且如果再次请求相同类型的令牌，系统将不再显示对话框。在与身份验证模块运行在相同UID下的应用程序可以无需显示确认对话框直接访问其令牌。此外，特权系统应用程序隐式地允许访问所有令牌类型，而无需用户确认，因此如果令牌请求来自特权应用程序，则不会显示对话框。
- en: The Accounts Database
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 账户数据库
- en: We’ve introduced authenticator modules, the authenticator cache, and the main
    features of the `AccountManagerService`. Now let’s see how this service uses the
    *accounts database*, an SQLite database stored in each user’s system directory
    with the *accounts.db* filename, to register accounts and cache credentials.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了身份验证模块、身份验证缓存和`AccountManagerService`的主要功能。现在让我们来看一下该服务如何使用*账户数据库*，这是一个存储在每个用户系统目录中的SQLite数据库，文件名为*accounts.db*，用于注册账户和缓存凭证。
- en: 'The accounts database is found at */data/system/users/0/accounts.db* on single-user
    devices. On multi-user devices, this file stores account information for the primary
    user, and secondary users each have their own instance at */data/system/users/<user
    ID>/accounts.db*. The database consists of six tables: `accounts`, `extras`, `authtokens`,
    `grants`, `shared_users`, and `meta`. As of this writing, the `meta` table appears
    to be unused; all other tables and their relationships are shown in [Figure 8-1](ch08.html#account_management_components
    "Figure 8-1. Account management components").'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在单用户设备上，账户数据库位于*/data/system/users/0/accounts.db*。在多用户设备上，该文件存储主用户的账户信息，而每个次要用户都有自己的实例，路径为*/data/system/users/<user
    ID>/accounts.db*。该数据库包含六个表：`accounts`、`extras`、`authtokens`、`grants`、`shared_users`和`meta`。截至本文写作时，`meta`表似乎未被使用；所有其他表及其关系如[图
    8-1](ch08.html#account_management_components "图 8-1. 账户管理组件")中所示。
- en: Table Schema
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表格架构
- en: The `accounts` table stores the name, type, and password of registered accounts,
    and all other tables directly or indirectly link to it. It might contain data
    similar to [Example 8-2](ch08.html#contents_of_the_accounts_table "Example 8-2. Contents
    of the accounts table").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`accounts`表存储注册账户的名称、类型和密码，所有其他表都直接或间接地与之相关联。它可能包含类似于[示例 8-2](ch08.html#contents_of_the_accounts_table
    "示例 8-2. 账户表内容")的数据。'
- en: Example 8-2. Contents of the accounts table
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-2. 账户表内容
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, ➊ is a Google account (type *com.google*) which allows access to Gmail,
    the Google Play Store, and other Google services. Google accounts depend on proprietary
    system components and are only available on Google experience devices. (You’ll
    find more details on Google accounts in “[The Google Login Service](ch08.html#google_login_service
    "The Google Login Service")”.) The account at ➋ is a POP3 mail account (type *com.google.android.pop3*)
    registered by the stock email application, and ➌ is a custom account (type *com.example.account*)
    registered by a third-party application. Each account can be associated with zero
    or more metadata key-value pairs that are stored in the `extras` table and link
    to the account by using its primary key (in the `_id` column). For example, if
    our custom application (➌ in [Example 8-2](ch08.html#contents_of_the_accounts_table
    "Example 8-2. Contents of the accounts table"), `_id=3`) does background data
    synchronization, it might have entries similar to those in [Example 8-3](ch08.html#contents_of_the_extras_table
    "Example 8-3. Contents of the extras table").
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，➊ 是一个 Google 账户（类型 *com.google*），允许访问 Gmail、Google Play 商店和其他 Google 服务。Google
    账户依赖于专有的系统组件，只能在 Google 体验设备上使用。（你可以在 “[Google 登录服务](ch08.html#google_login_service
    "Google 登录服务")” 中找到关于 Google 账户的更多详细信息。）➋ 处的账户是一个 POP3 邮件账户（类型 *com.google.android.pop3*），由默认邮件应用程序注册，而
    ➌ 是由第三方应用程序注册的自定义账户（类型 *com.example.account*）。每个账户可以与零个或多个元数据键值对关联，这些键值对存储在 `extras`
    表中，并通过使用其主键（在 `_id` 列中）与账户关联。例如，如果我们的自定义应用程序（见 [示例 8-2](ch08.html#contents_of_the_accounts_table
    "示例 8-2. 账户表的内容")，`_id=3`）进行后台数据同步，它可能会有类似 [示例 8-3](ch08.html#contents_of_the_extras_table
    "示例 8-3. extras 表的内容") 中的条目。
- en: Example 8-3. Contents of the `extras` table
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-3. `extras` 表的内容
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `authtokens` table stores tokens that have been issued for an account. For
    our custom application, it might look like [Example 8-4](ch08.html#contents_of_the_authtokens_table
    "Example 8-4. Contents of the authtokens table").
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`authtokens` 表格存储已为某个账户颁发的令牌。对于我们的自定义应用，它可能类似于 [示例 8-4](ch08.html#contents_of_the_authtokens_table
    "示例 8-4. authtokens 表的内容")。'
- en: Example 8-4. Contents of the `authtokens` table
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-4. `authtokens` 表的内容
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `grants` table associates application UIDs with the types of tokens they’re
    allowed to use. Grants are added when the user OK’s the access confirmation dialog
    for a particular account type and token (see [Figure 8-2](ch08.html#account_access_request_dialog
    "Figure 8-2. Account access request dialog")). For example, if an application
    with UID 10291 has requested and been granted access to tokens of type *com.example.auth*
    as in our sample application (see [Example 8-4](ch08.html#contents_of_the_authtokens_table
    "Example 8-4. Contents of the authtokens table")), the grant will be represented
    by the following row in the `grants` table (see [Example 8-5](ch08.html#contents_of_the_grants_table
    "Example 8-5. Contents of the grants table")). A new row is added for each combination
    of account ID, token type, and granted application UID.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`grants` 表将应用程序 UID 与它们被允许使用的令牌类型关联起来。当用户确认特定账户类型和令牌的访问对话框时，将添加授权记录（见 [图 8-2](ch08.html#account_access_request_dialog
    "图 8-2. 账户访问请求对话框")）。例如，如果具有 UID 10291 的应用程序已请求并获得访问 *com.example.auth* 类型的令牌，如我们的示例应用程序所示（见
    [示例 8-4](ch08.html#contents_of_the_authtokens_table "示例 8-4. authtokens 表的内容")），则该授权将通过
    `grants` 表中的以下行表示（见 [示例 8-5](ch08.html#contents_of_the_grants_table "示例 8-5. grants
    表的内容")）。每个账户 ID、令牌类型和授予的应用 UID 的组合都会添加一行。'
- en: Example 8-5. Contents of the `grants` table
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-5. `grants` 表的内容
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `shared_accounts` table is used when sharing the device owner’s accounts
    with one of the restricted users on the device. (You’ll find more details on its
    contents and usage in “[Multi-User Support](ch08.html#multi-user_support-id00015
    "Multi-User Support")”.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_accounts` 表用于将设备所有者的账户与设备上的某个受限用户共享。（你可以在 “[多用户支持](ch08.html#multi-user_support-id00015
    "多用户支持")” 中找到关于其内容和使用的更多详细信息。）'
- en: Table Access
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表格访问
- en: 'Now we’ll examine the relationship between tables and data in the accounts
    database and the key methods of the `AccountManagerService`. At a high level the
    relationship is fairly straightforward (if we ignore caching and synchronization):
    methods that retrieve or manipulate account details access the `accounts` table,
    and methods that handle user data associated with an account access the `extras`
    table. APIs that handle authentication tokens access the `authtokens` table, and
    save per-application token access grants in the `grants` table. We describe each
    method and the data it accesses next.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将研究账户数据库中表格与数据之间的关系，以及`AccountManagerService`的关键方法。从高层次来看，这种关系相当简单（如果忽略缓存和同步）：用于检索或操作账户详情的方法访问`accounts`表，而处理与账户关联的用户数据的方法则访问`extras`表。处理身份验证令牌的API访问`authtokens`表，并将每个应用程序的令牌访问授权保存在`grants`表中。接下来，我们将描述每个方法及其访问的数据。
- en: When you add an account of a particular type by calling one of the `addAccount()`
    methods, the `AccountManagerService` inserts a row in the `accounts` table containing
    its type, username, and password. Calling one of the `getPassword()`, `setPassword()`,
    or `clearPassword()` methods results in the `AccountManagerService` accessing
    or updating the `password` column of the `accounts` table. If you get or set user
    data for the account using the `getUserdata()` or `setUserdata()` methods, the
    `AccountManagerService` fetches the matching entry from or saves it to the `extras`
    table.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过调用`addAccount()`方法添加某种类型的账户时，`AccountManagerService`会在`accounts`表中插入一行，包含该账户的类型、用户名和密码。调用`getPassword()`、`setPassword()`或`clearPassword()`方法时，`AccountManagerService`会访问或更新`accounts`表中的`password`列。如果你使用`getUserdata()`或`setUserdata()`方法获取或设置账户的用户数据，`AccountManagerService`会从`extras`表中获取匹配的条目或将数据保存到该表中。
- en: When you request a token for a particular account, things become a bit more
    complex. If a token with the specified type has never been issued before, `AccountManagerService`
    shows a confirmation dialog (see [Figure 8-2](ch08.html#account_access_request_dialog
    "Figure 8-2. Account access request dialog")) asking the user to approve access
    for the requesting application. If they accept, the UID of the requesting app
    and the token type are saved to the `grants` table. (Authenticators can declare
    that they use custom tokens by setting the `customTokens` account metadata attribute
    to `true`. In this case, they’re responsible for managing tokens, and Android
    neither shows the token access dialog nor automatically saves tokens to the `authtokens`
    table). If a grant already exits, `AccountManagerService` checks the `authtokens`
    table for tokens matching the request. If a valid one exists, it’s returned. If
    a matching token is not found, the `AccountManagerService` finds the authenticator
    for the specified account type in the cache and calls its `getAuthToken()` method
    to request a token. This usually involves the authenticator fetching the user-name
    and password from the `accounts` table (via the `getPassword()` method) and calling
    its respective online service to get a fresh token. When a token is returned,
    it gets cached in the `authtokens` table and then is returned to the requesting
    app (usually asynchronously via a callback). Invalidating a token results in deleting
    the row that stores it from the `authtokens` table. Finally, when an account is
    removed by calling the `removeAccount()` method, its row is deleted from the `accounts`
    table and a database trigger cleans up all linked rows from the `authtokens`,
    `extras`, and `grants` tables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你请求某个账户的令牌时，情况会变得稍微复杂一些。如果之前从未发放过指定类型的令牌，`AccountManagerService`会显示一个确认对话框（参见[图
    8-2](ch08.html#account_access_request_dialog "图 8-2. 账户访问请求对话框")），要求用户批准请求应用程序的访问。如果用户接受，请求应用程序的UID和令牌类型将被保存到`grants`表中。（身份验证器可以通过将`customTokens`账户元数据属性设置为`true`来声明它们使用自定义令牌。在这种情况下，它们负责管理令牌，Android既不会显示令牌访问对话框，也不会自动将令牌保存到`authtokens`表中。）如果已经存在授权，`AccountManagerService`会检查`authtokens`表中是否有与请求匹配的令牌。如果找到有效令牌，则返回该令牌。如果没有找到匹配的令牌，`AccountManagerService`会在缓存中找到指定账户类型的身份验证器，并调用其`getAuthToken()`方法请求令牌。这通常涉及身份验证器从`accounts`表中获取用户名和密码（通过`getPassword()`方法），并调用相应的在线服务获取新的令牌。当令牌返回时，它会被缓存到`authtokens`表中，并返回给请求的应用程序（通常通过回调异步返回）。使令牌失效会导致删除存储令牌的行，从`authtokens`表中删除。最后，当通过调用`removeAccount()`方法删除账户时，其行将从`accounts`表中删除，数据库触发器将清理所有与之关联的行，包括`authtokens`、`extras`和`grants`表中的行。
- en: Password Security
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码安全
- en: One thing to note is that while credentials (usually usernames and passwords)
    are stored in a central database under */data/system/* that is only accessible
    to system applications, credentials are not encrypted; encrypting or otherwise
    protecting credentials is left to the authenticator module to implement as necessary.
    In fact, if you have a rooted device, you’ll likely find that a listing of the
    contents of the accounts table will show certain passwords in cleartext, especially
    for the stock email application (the `com.android.email` or `com.google.android.email`
    package). For example, in [Example 8-2](ch08.html#contents_of_the_accounts_table
    "Example 8-2. Contents of the accounts table"), the strings *password* ➋ and *pass1234*
    ➌ are the cleartext passwords for a POP account used by the stock application
    and a custom *com.example.account* account, respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，虽然凭证（通常是用户名和密码）存储在*/data/system/*下的一个中央数据库中，且只有系统应用可以访问，但凭证并未加密；加密或以其他方式保护凭证的工作留给认证器模块根据需要来实现。事实上，如果你的设备已经获取root权限，你可能会发现查看账户表的内容时会显示某些明文密码，尤其是针对系统自带的电子邮件应用（`com.android.email`或`com.google.android.email`包）。例如，在[示例
    8-2](ch08.html#contents_of_the_accounts_table "示例 8-2. 账户表内容")中，*password* ➋和*pass1234*
    ➌分别是系统自带应用使用的POP账户和自定义*com.example.account*账户的明文密码。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Email applications may need to store the password instead of a password hash
    or an authentication token in order to support several challenge-response authentication
    methods that take the password as input, such as DIGEST-MD5 and CRAM-MD5.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*电子邮件应用程序可能需要存储密码，而不是密码哈希或认证令牌，以支持多种以密码为输入的挑战-响应认证方法，例如DIGEST-MD5和CRAM-MD5。*'
- en: 'Because the `AccountManger.getPassword()` method can be called only by apps
    with the same UID as the account’s authenticator, cleartext passwords are not
    accessible to other applications at runtime, but they may be included in backups
    or device dumps. In order to avoid this potential security risk, applications
    can encrypt passwords with a device-specific key or choose to replace a password
    with a revokable master token after initial authentication succeeds. For example,
    the official Twitter client does not store the user password in the `accounts`
    table, but only saves obtained authentication tokens (in the `authtokens` table).
    Google accounts are another example (account type *com.google*): as shown in “[The
    Google Login Service](ch08.html#google_login_service "The Google Login Service")”,
    instead of the user password, Google accounts store a master token that is exchanged
    for service-specific authentication tokens.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`AccountManger.getPassword()`方法只能由与账户认证器具有相同UID的应用程序调用，所以在运行时，其他应用程序无法访问明文密码，但它们可能会包含在备份或设备转储中。为了避免这一潜在的安全风险，应用程序可以使用设备特定的密钥对密码进行加密，或者在初始认证成功后选择用可撤销的主令牌替代密码。例如，官方Twitter客户端不会将用户密码存储在`accounts`表中，而只是保存获得的认证令牌（存储在`authtokens`表中）。Google账户是另一个例子（账户类型*com.google*）：如“[Google
    登录服务](ch08.html#google_login_service "Google 登录服务")”所示，Google账户并不存储用户密码，而是存储一个主令牌，用于交换服务特定的认证令牌。
- en: Multi-User Support
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多用户支持
- en: Recall from [Chapter 4](ch04.html "Chapter 4. User Management") that on multi-user
    devices, Android allows each user to have their own set of applications, application
    data, and system settings. This user isolation extends to online accounts as well
    and users can have their own accounts registered with the system’s account manager
    service. Android 4.3 added support for restricted profiles, which are not fully
    independent users but share installed applications with the primary user. Additionally,
    restricted profiles can have a number of restrictions applied. Apps that use the
    `AccountManager` APIs can add explicit support for restricted profiles, thus allowing
    restricted profiles to see and use a subset of the primary user’s accounts within
    supported apps. We explain this feature in detail in “Shared Accounts” below.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第4章](ch04.html "第4章. 用户管理")中提到的，在多用户设备上，Android允许每个用户拥有自己的一组应用、应用数据和系统设置。这种用户隔离也扩展到了在线账户，用户可以在系统的账户管理服务中注册自己的账户。Android
    4.3增加了对受限配置文件的支持，这些配置文件不是完全独立的用户，而是与主用户共享已安装的应用程序。此外，受限配置文件还可以应用一系列限制。使用`AccountManager`
    API的应用程序可以明确支持受限配置文件，从而使受限配置文件能够在支持的应用程序中查看和使用主用户账户的子集。我们将在下面的“共享账户”部分详细解释这一功能。
- en: The following sections discuss how Android implements account isolation and
    sharing on multi-user devices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将讨论Android如何在多用户设备上实现账户隔离和共享。
- en: Per-User Account Databases
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每用户账户数据库
- en: As mentioned in “[The Accounts Database](ch08.html#accounts_database "The Accounts
    Database")”, the accounts databases that `AccountManagerServices` uses to store
    account information and cache authentication tokens are stored in each user’s
    system directory in */data/system/users/<user ID>/accounts.db*. This allows each
    user to have dedicated account storage, and different users might even have separate
    instances of the same type of online account. Aside from the database location,
    everything else works in exactly the same way as it does for the owner user, including
    permissions, access grants, and so on. When a user is removed, the system deletes
    all of its data, including the accounts database.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“[账户数据库](ch08.html#accounts_database "账户数据库")”中提到的，`AccountManagerServices`用于存储账户信息和缓存认证令牌的账户数据库存储在每个用户的系统目录中，即*/data/system/users/<user
    ID>/accounts.db*。这允许每个用户拥有专用的账户存储，不同的用户甚至可能拥有相同类型的在线账户的不同实例。除了数据库位置，其他一切与所有者用户的工作方式完全相同，包括权限、访问授权等。当用户被移除时，系统会删除其所有数据，包括账户数据库。
- en: Shared Accounts
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享账户
- en: Primary user accounts are shared with a restricted profile by simply cloning
    the account data into the restricted profile’s accounts database. Thus, restricted
    profiles do not access the primary user’s account data directly, but have their
    own copy. When a new restricted profile is added, the name and type of all current
    accounts of the primary user are copied into the `shared_accounts` table of the
    restricted profile’s accounts database. However, because the new user is not started
    yet, the `accounts` table is empty at this point and the shared accounts are not
    yet usable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 主用户账户通过简单地将账户数据克隆到受限配置文件的账户数据库中来与受限配置文件共享。因此，受限配置文件不会直接访问主用户的账户数据，而是拥有自己的副本。当添加新的受限配置文件时，主用户所有当前账户的名称和类型会被复制到受限配置文件的账户数据库中的`shared_accounts`表中。然而，由于新用户尚未启动，此时`accounts`表为空，且共享账户尚不可用。
- en: The `shared_accounts` table has the same structure as the `accounts` table,
    without the `password` column. It might look like [Example 8-6](ch08.html#contents_of_the_sharedunderscoreaccounts
    "Example 8-6. Contents of the shared_accounts table") for a restricted profile.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_accounts`表的结构与`accounts`表相同，但没有`password`列。对于受限配置文件，它可能类似于[示例 8-6](ch08.html#contents_of_the_sharedunderscoreaccounts
    "示例 8-6. `shared_accounts`表的内容")。'
- en: Example 8-6. Contents of the `shared_accounts` table
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-6. `shared_accounts`表的内容
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Shared accounts are not cloned directly by copying data from the owner’s `accounts`
    table; instead, cloning is performed via the authenticator that declared the account.
    By default, the `AbstractAccountAuthenticator`, which all authenticator classes
    derive from, does not support account cloning.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 共享账户并不是通过直接从所有者的`accounts`表中复制数据来克隆的；而是通过声明账户的认证器进行克隆。默认情况下，所有认证器类都继承自`AbstractAccountAuthenticator`，而该认证器并不支持账户克隆。
- en: 'Implementations that want to support shared accounts for restricted profiles
    need to do so explicitly, by overriding a couple of methods that were introduced
    in Android 4.3, along with restricted profile support: `getAccountCredentialsForCloning()`,
    which returns a `Bundle` containing all data needed to clone the account, and
    `addAccountFromCredentials()`, which receives this `Bundle` as a parameter and
    is responsible for creating the account based on credentials in the `Bundle`.
    The `AccountManagerService` delays the cloning of a shared account until a restricted
    user is actually started. If the owner user adds any new accounts, they are added
    to the `shared_accounts` table and similarly cloned.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持受限配置文件的共享账户，实施方案需要显式地进行支持，通过重写Android 4.3引入的几个方法来实现这些支持，此外还有受限配置文件支持：`getAccountCredentialsForCloning()`，该方法返回一个`Bundle`，包含克隆账户所需的所有数据；`addAccountFromCredentials()`，该方法接收这个`Bundle`作为参数，并负责根据`Bundle`中的凭证创建账户。`AccountManagerService`会延迟共享账户的克隆，直到受限用户实际启动。如果所有者用户添加了任何新账户，这些账户会被添加到`shared_accounts`表中，并同样进行克隆。
- en: Even when accounts are successfully cloned, they may not be available to an
    application started by a restricted profile. Recall from [Chapter 4](ch04.html
    "Chapter 4. User Management") that if an application wants to support shared accounts,
    it must explicitly declare the account type it requires with the `restrictedAccountType`
    attribute of the `<application>` manifest tag. The `AccountManagerServices` uses
    the value of the `restrictedAccountType` attribute to filter accounts before passing
    them to applications running within a restricted profile. As of this writing,
    an application can declare only one type of account with this attribute.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 即使账户成功克隆，它们也可能对由受限配置文件启动的应用程序不可用。回想一下[第4章](ch04.html "第4章. 用户管理")，如果一个应用程序想要支持共享账户，必须在`<application>`清单标签的`restrictedAccountType`属性中显式声明所需的账户类型。`AccountManagerServices`使用`restrictedAccountType`属性的值来过滤账户，然后将它们传递给运行在受限配置文件中的应用程序。截至目前，一个应用程序只能通过该属性声明一种账户类型。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Secondary users do not share accounts with the owner, and therefore their*
    *`shared_accounts`* *tables are always empty and owner accounts are never cloned.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*次要用户与所有者不会共享账户，因此他们的* *`shared_accounts`* *表始终为空，且所有者账户永远不会被克隆。*'
- en: Adding an Authenticator Module
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加认证器模块
- en: In “[Authenticator Modules](ch08.html#authenticator_modules "Authenticator Modules")”,
    we showed that an authentcator module is a bound service that implements the `android.accounts.IAccountAuthenticator`
    AIDL interface and which can be bound to by using the *android.accounts.AccountAuthenticator*
    intent action. In this section, we’ll show how an application can implement and
    declare an authenticator module.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在“[认证器模块](ch08.html#authenticator_modules "认证器模块")”中，我们展示了一个认证器模块是一个绑定服务，实现在`android.accounts.IAccountAuthenticator`
    AIDL接口，可以通过使用*android.accounts.AccountAuthenticator*意图动作进行绑定。在本节中，我们将展示一个应用程序如何实现和声明一个认证器模块。
- en: Most of the authenticator logic, including adding accounts, checking user-supplied
    credentials, and fetching authentication tokens, is implemented in an authenticator
    class derived from the base class that Android provides—namely, `AbstractAccountAuthenticator`.^([[80](#ftn.ch08fn03)])
    The authenticator class needs to provide implementation of all abstract methods,
    but if not all functionality is needed, implemented methods can return `null`
    or throw `UnsupportedOperationException`. In order to store the account password,
    an implementation should implement at least the `addAccount()` method and display
    a UI that collects the password from the user. The password can then be added
    to the accounts database by calling the `addAccountExplicitly()` method of `AccountManager`.
    Activities that implement credential collection and login can extend from the
    `AccountAuthenticatorActivity`,^([[81](#ftn.ch08fn04)]) which provides a convenience
    method to pass back collected credentials to the `AccountManager`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数认证器逻辑，包括添加账户、检查用户提供的凭证和获取认证令牌，都在从Android提供的基类——即`AbstractAccountAuthenticator`派生的认证器类中实现。^([[80](#ftn.ch08fn03)])
    认证器类需要实现所有抽象方法，但如果不需要所有功能，已实现的方法可以返回`null`或抛出`UnsupportedOperationException`。为了存储账户密码，至少需要实现`addAccount()`方法，并显示一个UI来收集用户密码。然后，可以通过调用`AccountManager`的`addAccountExplicitly()`方法将密码添加到账户数据库中。实现凭证收集和登录的活动可以继承自`AccountAuthenticatorActivity`，^([[81](#ftn.ch08fn04)])
    它提供了一个便利的方法，将收集的凭证传递回`AccountManager`。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Remember that the* *`addAccountExplicitly()`* *method does not encrypt or
    otherwise protect the password that is stored in cleartext by default. If required,
    encryption should be implemented separately, and the encrypted password or token
    should be passed to* *`addAccountExplicitly()`* *instead of the cleartext version.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，* *`addAccountExplicitly()`* *方法默认不会加密或以其他方式保护存储的密码（明文存储）。如果需要加密，应该单独实现加密，并将加密后的密码或令牌传递给*
    *`addAccountExplicitly()`* *，而不是明文版本。*'
- en: Once you have an account authenticator implementation, you simply create a service
    that returns its Binder interface when invoked with the *android.accounts.AccountAuthenticator*
    intent action, as shown in [Example 8-7](ch08.html#account_authenticator_service_implementa
    "Example 8-7. Account authenticator service implementation") (`AbstractAccountAuthenticator`
    method implementations have been omitted).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了账户认证器的实现，你只需要创建一个服务，当通过*android.accounts.AccountAuthenticator*意图动作调用时，返回其Binder接口，如[示例8-7](ch08.html#account_authenticator_service_implementa
    "示例8-7. 账户认证器服务实现")所示（`AbstractAccountAuthenticator`方法实现已省略）。
- en: Example 8-7. Account authenticator service implementation
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-7. 账户验证服务实现
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order to be picked up by the `AccountAuthenticatorCache` and made available
    via the `AccountManagerService`, the service needs to declare the *android.accounts.AccountAuthenticator*
    intent action and matching metadata as shown in [Example 8-8](ch08.html#declaring_an_account_authenticator_servi
    "Example 8-8. Declaring an account authenticator service in AndroidManifest.xml").
    Permissions needed to access accounts and tokens need to be added to the manifest
    as well. In this example, we only add the `AUTHENTICATE_ACCOUNTS` permission,
    which is the minimum required in order to be able to add an account with `addAccountExplicitly()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够被`AccountAuthenticatorCache`接收并通过`AccountManagerService`提供服务，该服务需要声明*android.accounts.AccountAuthenticator*意图动作和匹配的元数据，如[示例
    8-8](ch08.html#declaring_an_account_authenticator_servi "示例 8-8. 在AndroidManifest.xml中声明账户验证服务")所示。访问账户和令牌所需的权限也需要添加到清单中。在本示例中，我们仅添加`AUTHENTICATE_ACCOUNTS`权限，这是能够通过`addAccountExplicitly()`方法添加账户所需的最低权限。
- en: Example 8-8. Declaring an account authenticator service in AndroidManifest.xml
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-8. 在AndroidManifest.xml中声明账户验证服务
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, the account type, label, and icons must be declared in the referenced
    XML resource file as shown in [Example 8-9](ch08.html#declaring_account_metadata_in_an_xml_res
    "Example 8-9. Declaring account metadata in an XML resource file"). Here, the
    account type is *com.example.account* and we’re simply using the app icon as the
    account icon.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，账户类型、标签和图标必须在引用的XML资源文件中声明，如[示例 8-9](ch08.html#declaring_account_metadata_in_an_xml_res
    "示例 8-9. 在XML资源文件中声明账户元数据")所示。这里，账户类型是*com.example.account*，我们仅使用应用图标作为账户图标。
- en: Example 8-9. Declaring account metadata in an XML resource file
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-9. 在XML资源文件中声明账户元数据
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After the application that declares our new account is installed, *com.example.account*
    accounts can be added via the `AccountManager` API or the system Settings UI by
    selecting **Add an account**. The new account should show up in the list of supported
    accounts, as shown in [Figure 8-3](ch08.html#adding_a_custom_account_via_the_system_s
    "Figure 8-3. Adding a custom account via the system Settings UI").
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明我们新账户的应用程序安装后，可以通过`AccountManager` API或系统设置界面通过选择**添加账户**来添加*com.example.account*账户。新账户应出现在支持的账户列表中，如[图
    8-3](ch08.html#adding_a_custom_account_via_the_system_s "图 8-3. 通过系统设置界面添加自定义账户")所示。
- en: Custom accounts can be used for convenience only by the declaring application,
    or when creating a sync adapter, which requires a dedicated account. In order
    to allow third-party applications to authenticate using your custom account, you
    must implement authentication tokens, because as we saw in “[Listing and Authenticating
    Accounts](ch08.html#listing_and_authenticating_accounts "Listing and Authenticating
    Accounts")”, third-party applications cannot access an account password via the
    `AccountManager.getPassword()` API, unless they are signed with the same key and
    certificate as the application hosting the target account’s authenticator module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义账户仅供声明的应用程序使用，或者在创建同步适配器时使用，后者需要一个专用账户。为了允许第三方应用程序使用您的自定义账户进行身份验证，您必须实现身份验证令牌，因为正如我们在“[列出和验证账户](ch08.html#listing_and_authenticating_accounts
    "列出和验证账户")”中看到的那样，第三方应用程序无法通过`AccountManager.getPassword()` API访问账户密码，除非它们与托管目标账户验证模块的应用程序使用相同的密钥和证书签名。
- en: '![Adding a custom account via the system Settings UI](figs/web/08fig03.png.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![通过系统设置界面添加自定义账户](figs/web/08fig03.png.jpg)'
- en: Figure 8-3. Adding a custom account via the system Settings UI
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3. 通过系统设置界面添加自定义账户
- en: Google Accounts Support
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谷歌账户支持
- en: 'The main goal of Android’s account management facility is to make it easier
    to integrate online services into the OS, and to allow for seamless access to
    user data via background synchronization. The first versions of the system account
    management service were built to support Android integration with Google online
    services, and the service was later decoupled and made part of the OS. In Android
    versions 2.0 and later, Google account and online service support is bundled as
    a set of components that provide account authenticators (for the *com.google*
    account type) and sync adapters (for Gmail, Calendar, contacts, and so on), using
    standard OS APIs. However, there are a few notable differences from other third-party
    authenticator modules and sync adapters:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Android 账户管理功能的主要目标是简化将在线服务集成到操作系统中，并通过后台同步实现对用户数据的无缝访问。系统账户管理服务的早期版本旨在支持 Android
    与 Google 在线服务的集成，后来该服务被解耦并成为操作系统的一部分。在 Android 2.0 及以后版本中，Google 账户和在线服务支持作为一组组件捆绑提供，这些组件为
    *com.google* 账户类型提供账户验证器，并为 Gmail、日历、联系人等提供同步适配器，使用标准的操作系统 API。然而，与其他第三方验证器模块和同步适配器相比，存在一些显著的不同之处：
- en: The Google accounts components are bundled with the system and thus are granted
    extra permissions.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 账户组件与系统捆绑在一起，因此被授予了额外的权限。
- en: A lot of the actual functionality is implemented on the server side.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多实际功能是在服务器端实现的。
- en: The account authenticator does not store passwords in plain text on the device.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户验证器不会以明文形式在设备上存储密码。
- en: The Google Login Service
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google 登录服务
- en: The two main components that implement Google account and service support are
    the Google Services Framework (GSF) and the Google Login Service (GLS, displayed
    as *Google Account Manager* in recent versions). The former provides common services
    to all Google apps, such as centralized settings and feature toggle management,
    while the latter implements the authentication provider for Google accounts and
    will be the main topic of this section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 Google 账户和服务支持的两个主要组件是 Google 服务框架（GSF）和 Google 登录服务（GLS，最近版本中显示为 *Google
    账户管理器*）。前者为所有 Google 应用提供公共服务，例如集中设置和功能开关管理，而后者实现了 Google 账户的身份验证提供者，将是本节的主要话题。
- en: Google provides numerous online services, and supports a handful of different
    methods to authenticate to those services, both via a user-facing web UI and several
    dedicated authentication APIs. Android’s Google Login Service, however, doesn’t
    call those public authentication APIs directly, but rather via a dedicated online
    service, which lives at *[https://android.clients.google.com](https://android.clients.google.com)*.
    It has endpoints both for authentication, authorization token issuing, and different
    data feeds (mail, calendar, and so on) that are used for data synchronization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Google 提供了众多在线服务，并支持多种不同的方式进行身份验证，包括通过面向用户的网页 UI 和几个专用的身份验证 API。然而，Android 的
    Google 登录服务并不直接调用这些公共身份验证 API，而是通过一个专用的在线服务来实现，地址是 *[https://android.clients.google.com](https://android.clients.google.com)*。该服务具有多个端点，用于身份验证、授权令牌发放以及不同的数据源（如邮件、日历等），这些数据源用于数据同步。
- en: While a lot of the authentication and authorization logic is implemented on
    the server side, some sort of locally stored credentials are also required, especially
    for background syncing. On-device credential management is one of the services
    GLS provides, and while as of this writing there is no source code or reference
    documentation publicly available, we can observe what data GLS stores on the device
    and infer how authentication is implemented.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多身份验证和授权逻辑是在服务器端实现的，但仍然需要某种本地存储的凭据，尤其是在后台同步时。设备上的凭据管理是 GLS 提供的服务之一，尽管截至本文撰写时，尚未公开源代码或参考文档，但我们可以观察
    GLS 在设备上存储的数据，并推测身份验证的实现方式。
- en: As mentioned earlier, GLS plugs into the system account framework, so cached
    credentials, tokens, and associated extra data are stored in the system’s accounts
    database of the current user, just as it is for other account types. Unlike most
    other applications, however, GLS doesn’t store Google account passwords directly.
    Instead, in place of a password, GLS stores an opaque master token (probably some
    form of an OAuth refresh token) in the `password` column of the `accounts` table
    and exchanges it for authentication tokens for different Google services by calling
    an associated web service endpoint. The token is obtained when a Google account
    is first added to the device by sending the username and password entered in the
    sign-in activity shown in [Figure 8-4](ch08.html#google_account_sign-in_activity
    "Figure 8-4. Google account sign-in activity").
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GLS插入系统账户框架，因此缓存的凭证、令牌及相关的额外数据会存储在当前用户的系统账户数据库中，就像其他账户类型一样。然而，与大多数其他应用不同，GLS并不直接存储Google账户密码。相反，GLS在`accounts`表的`password`列中存储一个不透明的主令牌（可能是一种OAuth刷新令牌），并通过调用相关的Web服务端点将其交换为不同Google服务的认证令牌。该令牌在首次将Google账户添加到设备时通过输入登录活动中显示的用户名和密码获得，如[图8-4](ch08.html#google_account_sign-in_activity
    "图8-4. Google账户登录活动")所示。
- en: If the target Google account is using the default password-only authentication
    method and the correct password is entered, the GLS online service returns the
    master token and the account is added to the user’s accounts database. All subsequent
    authentication requests use the master token to obtain service- or scope-specific
    tokens that are used for synchronization or automatic web login. If the Google
    account is set to use two-factor authentication (2FA), the user is prompted to
    enter their one-time password (OTP, called *verification code* in the web UI)
    in an embedded web view like the one shown in [Figure 8-5](ch08.html#one-time_password_entry_as_part_of_addin
    "Figure 8-5. One-time password entry as part of adding a Google account").
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标Google账户使用默认的仅密码验证方法，并且输入了正确的密码，GLS在线服务将返回主令牌，账户会被添加到用户的账户数据库中。所有后续的认证请求将使用主令牌获取服务或特定作用域的令牌，用于同步或自动网页登录。如果Google账户设置为启用两步验证（2FA），用户会被提示在嵌入式网页视图中输入一次性密码（OTP，在网页界面中称为*验证码*），就像[图8-5](ch08.html#one-time_password_entry_as_part_of_addin
    "图8-5. 添加Google账户时输入一次性密码")中显示的那样。
- en: '![Google account sign-in activity](figs/web/08fig04.png.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Google账户登录活动](figs/web/08fig04.png.jpg)'
- en: Figure 8-4. Google account sign-in activity
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4. Google账户登录活动
- en: '![One-time password entry as part of adding a Google account](figs/web/08fig05.png.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![添加Google账户时输入一次性密码](figs/web/08fig05.png.jpg)'
- en: Figure 8-5. One-time password entry as part of adding a Google account
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5. 添加Google账户时输入一次性密码
- en: If the OTP is successfully verified, the master token is added to the accounts
    database and a list of services that support background synchronization is shown
    (see [Figure 8-6](ch08.html#list_of_google_services_that_support_bac "Figure 8-6. List
    of Google services that support background synchronization")).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果OTP验证成功，主令牌会被添加到账户数据库，并显示支持后台同步的服务列表（见[图8-6](ch08.html#list_of_google_services_that_support_bac
    "图8-6. 支持后台同步的Google服务列表")）。
- en: '![List of Google services that support background synchronization](figs/web/08fig06.png.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![支持后台同步的Google服务列表](figs/web/08fig06.png.jpg)'
- en: Figure 8-6. List of Google services that support background synchronization
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6. 支持后台同步的Google服务列表
- en: 'Note that only the initial login process differs for Google accounts that have
    2FA enabled: all subsequent authentication requests use the cached master token
    and do not require entering an OTP. Thus, once cached, the master token grants
    full access to a Google account and can be used not only for data synchronization,
    but for other types of account access as well, including web login.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于启用了2FA的Google账户，唯一不同的是初次登录过程：所有后续的认证请求都使用缓存的主令牌，并不需要输入OTP。因此，一旦缓存，主令牌便可完全访问Google账户，不仅可以用于数据同步，还可以用于其他类型的账户访问，包括网页登录。
- en: While it’s very handy to have an all-powerful authentication token cached, this
    trade-off in favor of convenience has enabled several attacks on Google accounts,
    and as a result many Google services now require additional authentication when
    sensitive data is displayed or account settings are changed. The master token
    can be invalidated by changing the Google account password, by enabling two-factor
    authentication, or by removing the Android device from the *Account Permissions*
    page of the associated Google account (see [Figure 8-7](ch08.html#android_device_entry_in_the_account_perm
    "Figure 8-7. Android device entry in the Account Permissions page of a Google
    account")). Any of these actions will require the user to reauthenticate with
    their new credentials on the device the next time it tries to get a Google authentication
    token via the `AccountManager` API.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然缓存一个全能的认证令牌非常方便，但这种以便捷为优先的权衡使得多个针对谷歌账户的攻击成为可能，因此许多谷歌服务现在在显示敏感数据或更改账户设置时要求额外的认证。通过更改谷歌账户密码、启用双因素认证，或从关联谷歌账户的*账户权限*页面中移除安卓设备，都可以使主令牌失效（参见[图8-7](ch08.html#android_device_entry_in_the_account_perm
    "图8-7. 谷歌账户账户权限页面中的安卓设备条目")）。这些操作中的任何一种都会要求用户在下次尝试通过`AccountManager` API获取谷歌认证令牌时，使用新的凭据在设备上重新认证。
- en: '![Android device entry in the Account Permissions page of a Google account](figs/web/08fig07.png.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![谷歌账户账户权限页面中的安卓设备条目](figs/web/08fig07.png.jpg)'
- en: Figure 8-7. Android device entry in the Account Permissions page of a Google
    account
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-7. 谷歌账户账户权限页面中的安卓设备条目
- en: Google Services Authentication and Authorization
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谷歌服务认证与授权
- en: Besides user-facing online services with a web UI such as Gmail, Google Calendar
    and, of course, search, Google provides programmatic access to many of its services
    via different web APIs. Most of these require authentication, either in order
    to be able to access a subset of a particular user’s data, or for quota and billing
    purposes. Several standard or Google-proprietary authentication and authorization
    methods have been used over the years, with the current trend being to migrate
    everything to OAuth 2.0^([[82](#ftn.ch08fn05)]) and OpenID Connect.^([[83](#ftn.ch08fn06)])
    However, many services still use older, proprietary protocols, so we’ll briefly
    look into those as well.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了面向用户的在线服务（如Gmail、Google Calendar和当然还有搜索）之外，谷歌还通过不同的Web API提供程序化访问许多服务。这些大多数都需要认证，或者是为了能够访问特定用户数据的子集，或者是为了配额和计费目的。多年来，谷歌使用了几种标准或专有的认证和授权方法，目前的趋势是将一切迁移到OAuth
    2.0^([[82](#ftn.ch08fn05)])和OpenID Connect^([[83](#ftn.ch08fn06)])。然而，许多服务仍然使用较旧的专有协议，因此我们也会简要介绍这些协议。
- en: 'Most authentication protocols have two variations: one for web applications
    and one for the so-called installed applications. Web applications run in a browser
    and are expected to be able to take advantage of all standard browser features
    including rich UI, free-form user interaction, cookie store, and the ability to
    follow redirects. Installed applications, on the other hand, don’t have a native
    way to preserve session information, and may not have the full web capabilities
    of a browser. Android native applications (mostly) fall into the “installed applications”
    category, so let’s see what protocols are available for them.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数认证协议有两种变体：一种适用于Web应用程序，另一种适用于所谓的安装应用程序。Web应用程序在浏览器中运行，预期能够利用所有标准浏览器功能，包括丰富的用户界面、自由格式的用户交互、cookie存储以及跟随重定向的能力。另一方面，安装应用程序没有原生方式来保存会话信息，可能也没有浏览器的完整Web功能。安卓原生应用程序（大多数）属于“安装应用程序”类别，因此我们来看看有哪些协议可供它们使用。
- en: ClientLogin
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ClientLogin
- en: 'The oldest and, as of this writing, still widely used authorization protocol
    for installed applications is *ClientLogin*.^([[84](#ftn.ch08fn07)]) This protocol
    assumes that the application has access to the user’s account name and password
    and lets you get an authorization token for a particular service that can be saved
    and used for accessing that service on behalf of the user. Services are identified
    by proprietary service names, such as *cl* for Google Calendar and *ah* for Google
    App engine. You’ll find a list of many supported service names in the Google Data
    API reference,^([[85](#ftn.ch08fn08)]) but here are a few Android-specific ones
    not listed in the reference: *ac2dm*, *android*, *androidsecure*, *androiddeveloper*,
    and *androidmarket*.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，最古老的并且仍被广泛使用的安装应用程序授权协议是*ClientLogin*。^([[84](#ftn.ch08fn07)]) 该协议假设应用程序可以访问用户的账户名和密码，并允许你获取特定服务的授权令牌，该令牌可以保存并用于代表用户访问该服务。服务通过专有的服务名称进行标识，例如*cl*代表
    Google 日历，*ah*代表 Google App Engine。你可以在 Google 数据 API 参考中找到许多支持的服务名称，^([[85](#ftn.ch08fn08)])
    但这里有一些 Android 特定的服务名称没有列出：*ac2dm*，*android*，*androidsecure*，*androiddeveloper*
    和 *androidmarket*。
- en: 'The authorization tokens for these services can be fairly long-lived (up to
    two weeks), but cannot be refreshed and the application must obtain a new token
    when the current token expires. Unfortunately, there is no way to validate a token
    short of accessing the associated service: if you get an *OK* HTTP status (200)
    the token is valid, but if 403 is returned you need to consult the additional
    error code and retry or get a new token.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务的授权令牌可以存活相当长的时间（最多两周），但不能刷新，应用程序必须在当前令牌过期时获取新的令牌。不幸的是，除了访问关联服务外，无法验证令牌：如果返回*OK*
    HTTP 状态（200），则令牌有效；但如果返回 403，则需要查阅额外的错误代码并重试或获取新令牌。
- en: 'Another limitation of ClientLogin authorization tokens is that they don’t offer
    fine-grained access to a service’s resources: access is all or nothing, and you
    cannot specify read-only access or access to a particular resource only.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ClientLogin 授权令牌的另一个限制是，它们不能提供对服务资源的细粒度访问：要么全部访问，要么完全无法访问，无法指定只读访问或仅访问特定资源。
- en: The biggest drawback for mobile apps though is that ClientLogin requires access
    to the actual user password. Therefore, unless you want to force users to enter
    their password each time a new token is required, the password must be saved on
    the device, which poses various problems and potential security issues. Android
    avoids storing the raw password by storing a master token on the device and uses
    GLS and the associated online service to exchange the master token for ClientLogin
    tokens. Getting a token is as simple as calling the appropriate `AccountManger`
    method, which either returns a cached token or issues an API request to fetch
    a fresh one.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动应用程序来说，最大的缺点是 ClientLogin 需要访问实际的用户密码。因此，除非你希望每次需要新令牌时都强制用户输入密码，否则密码必须保存在设备上，这带来了各种问题和潜在的安全隐患。Android
    通过在设备上存储主令牌来避免存储原始密码，并使用 GLS 和相关的在线服务将主令牌交换为 ClientLogin 令牌。获取令牌就像调用适当的 `AccountManager`
    方法一样简单，它要么返回缓存的令牌，要么发出 API 请求以获取一个新的令牌。
- en: Despite its many limitations, the ClientLogin protocol is easy to understand
    and straightforward to implement, so it has been widely used. It was officially
    deprecated in April 2012 though, and apps using it are encouraged to migrate to
    OAuth 2.0.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多限制，ClientLogin 协议易于理解且实现简单，因此得到了广泛使用。然而，它在 2012 年 4 月被正式弃用，使用该协议的应用程序被鼓励迁移到
    OAuth 2.0。
- en: OAuth 2.0
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: The OAuth 2.0 authorization framework became an official Internet standard in
    late 2012\. It defines different *authorization flows* for different use cases,
    but we won’t try to present all of them here. We’ll only discuss how OAuth 2.0
    relates to native mobile applications. (For more detail on the actual protocol,
    see RFC 6749.)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 授权框架在 2012 年底成为官方互联网标准。它定义了不同的*授权流程*，以适应不同的使用场景，但我们在这里不会尝试介绍所有的流程。我们只讨论
    OAuth 2.0 如何与本地移动应用程序相关。（有关实际协议的更多细节，请参见 RFC 6749。）
- en: 'The OAuth 2.0 specification defines four basic flows for getting an authorization
    token for a resource. It also defines two that don’t require the client (in our
    scenario, an Android app) to directly handle user credentials (such as the Google
    account username and password), namely the *authorization code grant* flow and
    the *implicit grant* flow. Both of these require the authorization server (Google’s)
    to authenticate the resource owner (the Android app user) in order to establish
    whether to grant or deny the access request (say, read-only access to profile
    information). In a typical browser-based web application, this is straightforward:
    the user is redirected to an authentication page, then to an access grant page
    that basically says “Do you allow app X to access data Y and Z?” If the user agrees,
    another redirect, which includes an authorization token, takes the user back to
    the original application. The browser simply needs to pass the token in the next
    request in order to gain access to the target resource.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0规范定义了四种基本流程来获取资源的授权令牌。它还定义了两种不需要客户端（在我们的场景中是Android应用）直接处理用户凭证（如Google账号的用户名和密码）的流程，即*授权码授权*流程和*隐式授权*流程。这两种流程都要求授权服务器（Google的）对资源所有者（Android应用用户）进行身份验证，以确定是否授予或拒绝访问请求（比如，只读访问个人信息）。在典型的基于浏览器的Web应用中，这个过程非常直接：用户会被重定向到身份验证页面，然后到访问授权页面，页面上基本上会显示“您是否允许应用X访问数据Y和Z？”如果用户同意，另一个重定向（包含授权令牌）将把用户带回到原始应用程序。浏览器只需要在下一个请求中传递令牌，即可访问目标资源。
- en: Things are not so simple with a native app. A native app can either use the
    system browser to handle the grant permission step, or embed a `WebView` or a
    similar control in the app’s UI. Using the system browser requires launching a
    third-party application (the browser), detecting success or failure, and finally
    figuring out a way to return the token back to the calling application. Embedding
    a `WebView` is a bit more user-friendly, as it doesn’t involve switching back
    and forth between applications, but still results in showing a non-native web
    UI, and requires complex code to detect success and extract the access token.
    Neither option is ideal, and both are confusing to the user.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生应用时情况并不那么简单。原生应用可以选择使用系统浏览器处理授权许可步骤，或者在应用的UI中嵌入`WebView`或类似的控件。使用系统浏览器需要启动一个第三方应用程序（浏览器），检测成功或失败，并最终找到一种方法将令牌返回到调用应用程序。嵌入`WebView`则稍微更具用户友好性，因为它不需要在应用程序之间来回切换，但仍会展示一个非原生的网页UI，并且需要复杂的代码来检测成功与否并提取访问令牌。两者都不是理想选择，且都会让用户感到困惑。
- en: 'This integration complexity and UI impedance mismatch are the problems that
    OAuth 2.0 support via native Android APIs aims to solve. Android offers two APIs
    that can be used to obtain OAuth 2.0 tokens: the platform `AccountManager` via
    the special *oauth2:scope* token type syntax, and Google Play Services (discussed
    in the next section). When using either of those APIs to obtain a token, user
    authentication is implemented transparently by passing the saved master token
    to the server-side component of GLS, which produces the native `AccountManager`
    access grant dialog (see [Figure 8-8](ch08.html#oauth_token_access_request_dialog
    "Figure 8-8. OAuth token access request dialog")) instead of a `WebView` with
    a permission grant page. If you grant token access to the requesting application,
    a second request is sent to convey this to the server, which returns the requested
    token. The access token is then directly delivered to the app, without passing
    through an intermediary component such as a `WebView`. This is essentially the
    same flow as for web applications, except that it doesn’t require context switching
    from native to browser and back, and it’s much more user-friendly. Of course,
    this native authorization flow only works for Google accounts, and writing a client
    for some other online service that uses OAuth 2.0 still requires integrating its
    web interface into your app. For example, Twitter clients often use `WebView`
    to process the permission grant callback URL returned by the Twitter API.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 支持通过原生 Android API 解决的就是这种集成复杂性和 UI 阻抗不匹配的问题。Android 提供了两种可以用来获取 OAuth
    2.0 令牌的 API：平台 `AccountManager` 通过特殊的 *oauth2:scope* 令牌类型语法，以及 Google Play 服务（在下一节中讨论）。当使用这两种
    API 中的任何一种来获取令牌时，用户身份验证通过将保存的主令牌传递给 GLS 的服务器端组件来透明地实现，从而显示原生的 `AccountManager`
    访问授权对话框（见 [图 8-8](ch08.html#oauth_token_access_request_dialog "图 8-8. OAuth 令牌访问请求对话框")），而不是带有权限授予页面的
    `WebView`。如果你授予请求应用程序令牌访问权限，则会发送第二个请求将此信息传递给服务器，服务器返回请求的令牌。然后，访问令牌直接传递给应用程序，而无需通过中介组件如
    `WebView`。这本质上与 Web 应用程序的流程相同，只不过不需要在原生应用与浏览器之间切换，且更加用户友好。当然，这种原生授权流程仅适用于 Google
    账户，编写支持其他使用 OAuth 2.0 的在线服务的客户端仍然需要将其 Web 界面集成到应用中。例如，Twitter 客户端通常使用 `WebView`
    来处理 Twitter API 返回的权限授予回调 URL。
- en: Google Play Services
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Play 服务
- en: '*Google Play Services (GPS)*^([[86](#ftn.ch08fn09)]) was announced at Google
    I/O 2012 as an easy-to-use platform that offers third-party Android apps a way
    to integrate with Google products. Since then, it has grown into a giant all-in-one
    package (with over 14,000 Java methods!) that provides access to Google APIs and
    proprietary OS extensions.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*Google Play 服务 (GPS)*^([[86](#ftn.ch08fn09)]) 于 2012 年 Google I/O 大会上宣布，作为一个易于使用的平台，提供第三方
    Android 应用与 Google 产品集成的方式。从那时起，它已经发展成一个庞大的全能包（拥有超过 14,000 个 Java 方法！），为开发者提供了访问
    Google API 和专有操作系统扩展的功能。'
- en: '![OAuth token access request dialog](figs/web/08fig08.png.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![OAuth 令牌访问请求对话框](figs/web/08fig08.png.jpg)'
- en: Figure 8-8. OAuth token access request dialog
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8. OAuth 令牌访问请求对话框
- en: As mentioned in the previous section, getting OAuth 2.0 tokens via the standard
    `AccountManager` interface has been supported since Android 2.2 and higher, but
    it didn’t work reliably across different Android builds because their different
    bundled GLS versions resulted in slightly different behavior between devices.
    Additionally, the permission grant dialog shown when requesting a token was not
    particularly user friendly because it showed the raw OAuth 2.0 scope in some cases,
    which meant little to most users (see [Figure 8-8](ch08.html#oauth_token_access_request_dialog
    "Figure 8-8. OAuth token access request dialog")). While human-readable aliases
    for certain scopes were partially supported (for example, the *Manage your tasks*
    string was displayed instead of the raw OAuth scope *oauth2:[https://www.googleapis.com/auth/tasks](https://www.googleapis.com/auth/tasks)*
    in some versions), that solution was neither ideal nor universally available,
    as it too depended on the pre-installed GLS version.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，通过标准的`AccountManager`接口获取OAuth 2.0令牌已从Android 2.2及更高版本开始得到支持，但由于不同的Android版本捆绑了不同的GLS版本，这导致设备之间的行为有所不同，因而无法可靠地跨设备工作。此外，在请求令牌时显示的权限授予对话框并不是特别用户友好，因为在某些情况下它会显示原始的OAuth
    2.0范围，这对大多数用户来说意义不大（见[图 8-8](ch08.html#oauth_token_access_request_dialog "图 8-8.
    OAuth令牌访问请求对话框")）。尽管某些范围的可读别名部分得到了支持（例如，某些版本中显示*管理您的任务*字符串，而不是原始的OAuth范围*oauth2:[https://www.googleapis.com/auth/tasks](https://www.googleapis.com/auth/tasks)*），但这一解决方案既不理想，也不是普遍可用的，因为它依赖于预安装的GLS版本。
- en: Generally, while Android’s account management framework is well-integrated into
    the OS and extensible via third-party authenticator modules, its API is not particularly
    flexible, and adding support for multi-step authentication or authorization flows
    such as those used in OAuth 2.0 is far from straightforward. GPS manages to achieve
    this with the help of an online service, which does its best to hide the complexity
    of OAuth 2.0 and provides web APIs compatible with Android’s account management
    framework. We discuss the details of this integration next.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，尽管Android的账户管理框架与操作系统紧密集成，并且可以通过第三方身份验证模块进行扩展，但其API并不是特别灵活，添加对多步骤身份验证或授权流程（如OAuth
    2.0中使用的流程）的支持并不简单。GPS通过在线服务实现这一目标，该服务尽最大努力隐藏OAuth 2.0的复杂性，并提供与Android账户管理框架兼容的Web
    API。我们接下来将讨论这一集成的详细信息。
- en: 'GPS adds universal supports for displaying a user-friendly OAuth scope description
    by making token issuance a two-step process:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: GPS通过将令牌发放过程分为两个步骤，增加了对显示用户友好OAuth范围描述的通用支持：
- en: 'Much like before, the first request includes the account name, master token,
    and requested service, in the *oauth2:scope* format. GPS adds two new parameters
    to the request: the app’s package name and the SHA-1 hash of its signing certificate.
    The response includes some human-readable details about the requested scope and
    requesting application, which GPS shows in a permission grant dialog like the
    one shown in [Figure 8-9](ch08.html#google_play_services_account_access_perm "Figure 8-9. Google
    Play Services account access permission dialog").'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前类似，第一次请求包括账户名、主令牌和请求的服务，采用*oauth2:scope*格式。GPS在请求中添加了两个新参数：应用包名和签名证书的SHA-1哈希值。响应中包括一些可读的关于请求范围和请求应用的详细信息，GPS会在权限授予对话框中显示这些信息，如[图
    8-9](ch08.html#google_play_services_account_access_perm "图 8-9. Google Play 服务账户访问权限对话框")所示。
- en: If the user grants permission, that decision is recorded in the `extras` table
    in a proprietary format that includes the requesting app’s package name, signing
    certificate hash, and granted OAuth 2.0 scope. (Note that the `grants` table is
    not used.) GPS then resends the authorization request, setting the *has_permission*
    parameter to 1\. On success, this results in an OAuth 2.0 token and its expiration
    date in the response. The expiration date is saved in the `extras` table, and
    the token is cached in the `authtokens` table in a similar format.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户授权，决定将以专有格式记录在`extras`表中，该格式包括请求应用的包名、签名证书哈希值和授予的 OAuth 2.0 范围。（注意，`grants`表未被使用。）GPS随后重新发送授权请求，并将*has_permission*参数设置为1。成功后，响应中将返回OAuth
    2.0令牌及其过期日期。过期日期保存在`extras`表中，令牌以类似格式缓存于`authtokens`表中。
- en: '![Google Play Services account access permission dialog](figs/web/08fig09.png.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Google Play 服务账户访问权限对话框](figs/web/08fig09.png.jpg)'
- en: Figure 8-9. Google Play Services account access permission dialog
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9. Google Play 服务账户访问权限对话框
- en: The GPS app has the same shared user ID as the GSF and GLS packages (*com.google.uid.shared*),
    so it can directly interact with those services. This allows it, among other things,
    to directly get and write Google account credentials and tokens to the accounts
    database. As can be expected, GPS runs in a remote service that’s accessed by
    a client library which is linked into apps that use GPS. The major selling point
    against the legacy `AccountManager` API is that while its underlying authenticator
    modules (GLS and GSF) are part of the system (and as such cannot be updated without
    an OTA), GPS is a user-installable app that can be easily updated via Google Play.
    In fact, it is auto-updating, so app developers presumably won’t have to rely
    on users to update it if they want to use newer features (unless GPS is disabled
    altogether). This update mechanism is designed to provide “agility in rolling
    out new platform capabilities,” but as GPS has come to integrate very diverse
    APIs and functionalities that require extensive testing, updates have been infrequent.
    That said, if your app uses OAuth 2.0 tokens to authenticate to Google APIs (the
    preferred method as of this writing), you should definitely consider using GPS
    over “raw” `AccountManager` access.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: GPS 应用与 GSF 和 GLS 包具有相同的共享用户 ID（*com.google.uid.shared*），因此它可以直接与这些服务进行交互。这使得它能够，除其他外，直接获取和写入
    Google 账户凭据及令牌到账户数据库。正如预期的那样，GPS 运行在一个远程服务中，通过客户端库访问，该库被链接到使用 GPS 的应用中。相较于传统的
    `AccountManager` API，其主要卖点在于，虽然其底层的身份验证模块（GLS 和 GSF）是系统的一部分（因此无法在没有 OTA 的情况下更新），但
    GPS 是一个用户可安装的应用，可以通过 Google Play 轻松更新。事实上，它是自动更新的，因此应用开发者显然不必依赖用户更新它，如果他们希望使用更新的功能（除非
    GPS 被完全禁用）。这种更新机制旨在提供“推出新平台功能的敏捷性”，但由于 GPS 已集成了非常多样的 API 和功能，需要进行广泛测试，更新并不频繁。话虽如此，如果你的应用使用
    OAuth 2.0 令牌来认证 Google API（截至本篇写作时的推荐方法），你绝对应该考虑使用 GPS 而不是“原始”的 `AccountManager`
    访问。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In order to be able to actually use a Google API, you must register your app’s
    package name and signing key in Google’s API console. The registration lets services
    validating the token query Google about what app the token was issued for, thus
    identifying the calling app. This validation process has one subtle but important
    side effect: you don’t have to embed an API key in your app and send it with every
    request. Of course, for a third-party published app, you can easily discover both
    the package name and the signing certificate so it’s not particularly hard to
    get a token issued in the name of some other app (though not via the official
    API, of course).*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了能够实际使用 Google API，你必须在 Google 的 API 控制台中注册你的应用包名和签名密钥。此注册允许服务验证令牌并查询 Google
    了解该令牌是为哪个应用颁发的，从而识别调用的应用。这个验证过程有一个微妙但重要的副作用：你不需要将 API 密钥嵌入到应用中并随每次请求发送。当然，对于第三方发布的应用，你可以轻松发现包名和签名证书，因此获得一个以其他应用名义颁发的令牌并不特别困难（当然不是通过官方
    API）。*'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Android provides a centralized registry of user online accounts via the `AccountManager`
    class, which lets you get tokens for existing accounts without having to handle
    the raw user credentials and register your own custom account types. Registering
    a custom account type gives you access to powerful system features, such as authentication
    token caching and automatic background synchronization. Google experience devices
    include built-in support for Google accounts, which lets third-party apps access
    Google online services without having to directly request authentication information
    from the user. The Google Play Services app and companion client library further
    improve support for Google accounts by making it easy to use OAuth 2.0 tokens
    from third-party applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了一个通过 `AccountManager` 类的集中式用户在线账户注册表，它允许你为现有账户获取令牌，而无需处理原始用户凭据并注册你自己的自定义账户类型。注册自定义账户类型使你能够访问强大的系统功能，如认证令牌缓存和自动后台同步。Google
    体验设备包括对 Google 账户的内置支持，这使得第三方应用可以访问 Google 在线服务，而无需直接向用户请求认证信息。Google Play 服务应用及其客户端库通过便捷地使用来自第三方应用的
    OAuth 2.0 令牌，进一步改善了对 Google 账户的支持。
- en: '* * *'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[78](#ch08fn01)]) Google, *Android API Reference*, “AccountManager,” *[http://developer.android.com/reference/android/accounts/AccountManager.html](http://developer.android.com/reference/android/accounts/AccountManager.html)*
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[78](#ch08fn01)]) Google, *Android API Reference*, “AccountManager,” *[http://developer.android.com/reference/android/accounts/AccountManager.html](http://developer.android.com/reference/android/accounts/AccountManager.html)*
- en: ^([[79](#ch08fn02)]) Google, *Android API Reference*, “AccountManager,” *[http://developer.android.com/reference/android/accounts/AccountManager.html](http://developer.android.com/reference/android/accounts/AccountManager.html)*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[79](#ch08fn02)]) Google，*Android API 参考*，“AccountManager”，*[http://developer.android.com/reference/android/accounts/AccountManager.html](http://developer.android.com/reference/android/accounts/AccountManager.html)*。
- en: ^([[80](#ch08fn03)]) Google, *Android API Reference*, “AbstractAccountAuthenticator,”
    *[http://developer.android.com/reference/android/accounts/AbstractAccountAuthenticator.html](http://developer.android.com/reference/android/accounts/AbstractAccountAuthenticator.html)*
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[80](#ch08fn03)]) Google，*Android API 参考*，“AbstractAccountAuthenticator”，*[http://developer.android.com/reference/android/accounts/AbstractAccountAuthenticator.html](http://developer.android.com/reference/android/accounts/AbstractAccountAuthenticator.html)*
- en: ^([[81](#ch08fn04)]) Google, *Android API Reference*, “AccountAuthenticatorActivity,”
    *[http://developer.android.com/reference/android/accounts/AccountAuthenticatorActivity.html](http://developer.android.com/reference/android/accounts/AccountAuthenticatorActivity.html)*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[81](#ch08fn04)]) Google，*Android API 参考*，“AccountAuthenticatorActivity”，*[http://developer.android.com/reference/android/accounts/AccountAuthenticatorActivity.html](http://developer.android.com/reference/android/accounts/AccountAuthenticatorActivity.html)*
- en: ^([[82](#ch08fn05)]) D. Hardt, *The OAuth 2.0 Authorization Framework*, *[http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749)*
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[82](#ch08fn05)]) D. Hardt，*OAuth 2.0 授权框架*，*[http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749)*
- en: ^([[83](#ch08fn06)]) N. Sakimura et al., *OpenID Connect Core 1.0*, *[http://openid.net/specs/openid-connect-core-1_0.html](http://openid.net/specs/openid-connect-core-1_0.html)*
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[83](#ch08fn06)]) N. Sakimura 等人，*OpenID Connect Core 1.0*，*[http://openid.net/specs/openid-connect-core-1_0.html](http://openid.net/specs/openid-connect-core-1_0.html)*
- en: ^([[84](#ch08fn07)]) Google, *Google Accounts Authentication and Authorization*,
    “ClientLogin for Installed Applications,” *[https://developers.google.com/accounts/docs/AuthForInstalledApps](https://developers.google.com/accounts/docs/AuthForInstalledApps)*
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[84](#ch08fn07)]) Google，*Google 账户身份验证与授权*，“已安装应用程序的 ClientLogin”，*[https://developers.google.com/accounts/docs/AuthForInstalledApps](https://developers.google.com/accounts/docs/AuthForInstalledApps)*
- en: ^([[85](#ch08fn08)]) Google, *Google Data APIs*, “Frequently Asked Questions,”
    *[https://developers.google.com/gdata/faq#clientlogin](https://developers.google.com/gdata/faq#clientlogin)*
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[85](#ch08fn08)]) Google，*Google 数据 API*，“常见问题解答”，*[https://developers.google.com/gdata/faq#clientlogin](https://developers.google.com/gdata/faq#clientlogin)*
- en: ^([[86](#ch08fn09)]) Google, “Google Play Services,” *[http://developer.android.com/google/play-services/index.html](http://developer.android.com/google/play-services/index.html)*
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[86](#ch08fn09)]) Google，“Google Play 服务”，*[http://developer.android.com/google/play-services/index.html](http://developer.android.com/google/play-services/index.html)*
