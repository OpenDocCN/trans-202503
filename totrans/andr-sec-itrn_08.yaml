- en: Chapter 8. Online Account Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While enterprise services usually employ PKI for user authentication, most publicly
    available online services rely on passwords to authenticate their users. However,
    typing complex passwords on a touch screen mobile device multiple times a day
    for different sites is not a very pleasant exercise.
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to improve the user experience when accessing online services,
    Android provides a centralized registry of user accounts that can cache and reuse
    credentials. This account registry can be accessed by third-party applications,
    allowing them to access web services on behalf of the device user without the
    need for apps to handle passwords directly. In this chapter, we discuss how Android
    manages a user’s online account credentials and the APIs that applications can
    use to take advantage of cached credentials and to register custom accounts. We
    then show how Google experience devices (devices on which the Google Play Store
    is preinstalled) store Google account information and allow access to Google APIs
    and other online services by using the stored credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Android Account Management Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While early Android devices had built-in support for Google accounts and automatic
    background data synchronization with Google services such as Gmail, no APIs for
    this functionality were originally provided. Android 2.0 (API Level 5) introduced
    the concept of centralized account management with a public API. The central piece
    in the API is the `AccountManager` class, which “provides access to a centralized
    registry of the user’s online accounts. The user enters credentials (username
    and password) once per account, granting applications access to online resources
    with ‘one-click’ approval.”^([[78](#ftn.ch08fn01)]) Another major feature of the
    class is that it lets you get an authentication token for supported accounts,
    allowing third-party applications to authenticate to online services without needing
    to actually handle the user password. On some older Android versions, the `AccountManager`
    would also monitor your SIM card and wipe cached credentials if you swapped cards,
    but this feature was removed in Android 2.3.4 and later versions.
  prefs: []
  type: TYPE_NORMAL
- en: Account Management Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most Android system APIs, the `AccountManager` is just a facade for
    the `AccountManagerService`, which does the actual work. The service doesn’t provide
    an implementation for any particular form of authentication, though. It merely
    coordinates a number of pluggable authenticator modules for different account
    types (Google, Twitter, Microsoft Exchange, and so on). Any application can register
    an authenticator module by implementing an account authenticator and related classes,
    if needed. We show how to write and register a custom authenticator module in
    “[Adding an Authenticator Module](ch08.html#adding_an_authenticator_module "Adding
    an Authenticator Module")”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Registering a new account type with the system lets you take advantage of a
    number of Android infrastructure services, including the ability to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a centralized credential storage in a system database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issue tokens to third-party apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take advantage of Android’s automatic background synchronization (via a sync
    adapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 8-1](ch08.html#account_management_components "Figure 8-1. Account management
    components") shows the main components of Android’s account management subsystems
    and their relationships. Each component and its role will be described in the
    following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Account management components](figs/web/08fig01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1. Account management components
  prefs: []
  type: TYPE_NORMAL
- en: AccountManagerService and AccountManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The central piece here is the `AccountManagerService`, which coordinates all
    other components and persists account data in the accounts database. The `AccountManager`
    class is the facade that exposes a subset of its functionality to third-party
    applications. It starts worker threads for asynchronous methods and posts the
    results (or error details) back to the caller. Additionally, `AccountManager`
    shows an account chooser when the requested token or feature can be provided by
    more than one account. However, it doesn’t enforce any permissions; all caller
    permissions are checked by the `AccountManagerService` and we’ll discuss the concrete
    permissions shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticator Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned above, the functionality of each registered account is provided
    by a pluggable authenticator module, but what exactly is an authenticator module?
    *Authenticator modules* are defined and hosted by applications, and each is simply
    a bound service that implements the `android.accounts.IAccountAuthenticator` AIDL
    interface. This interface has methods for adding an account, prompting the user
    for their credentials, getting an authentication token, and for updating account
    metadata. In practice, applications don’t implement this interface directly, but
    instead extend the `android.accounts.AbstractAccountAuthenticator` class which
    links implementation methods to an internal AIDL stub.
  prefs: []
  type: TYPE_NORMAL
- en: The `AbstractAccountAuthenticator` also ensures that all callers of the AIDL
    stub hold the `ACCOUNT_MANAGER` permission; a system signature permission that
    only allows system components to call authenticator modules directly. All other
    clients need to go through the `AccountManagerService`.
  prefs: []
  type: TYPE_NORMAL
- en: Each authenticator module implements an account identified uniquely by a string
    called the *account type*. Account types are typically in reverse domain notation
    (like Java packages) and are usually named using the base package name of the
    defining application concatenated with the account type, or the *account* or *auth*
    strings (Android does not enforce this rule, however, and there are no explicit
    guidelines). For example, in [Figure 8-1](ch08.html#account_management_components
    "Figure 8-1. Account management components"), the `com.example.app` application
    defines an account with type `com.example.account`, and the `org.foo.app` application
    defines an account with type `org.foo.account`.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticator modules are implemented by adding a service that can be bound
    to by using the *android.accounts.AccountAuthenticator* intent action to the host
    application. The account type, as well as other metadata, is linked to the service
    by adding a `<meta-data>` tag to the service declaration. The `resource` attribute
    of the tag points to an XML file that contains account metadata (see [Example 8-8](ch08.html#declaring_an_account_authenticator_servi
    "Example 8-8. Declaring an account authenticator service in AndroidManifest.xml")
    for an example).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*A* *`<meta-data>`* *tag allows a name-value pair containing arbitrary data
    to be associated with its parent component. The data can be a literal value, such
    as a string or an integer, or a reference to an Android resource file. Multiple*
    *`<meta-data>`* *tags per component are also supported. The values from all* *`<meta-data>`*
    *tags are collected in a single* *`Bundle`* *object and made available as the*
    *`metaData`* *field of the* *`PackageItemInfo`* *class (the base class of concrete
    classes that encapsulate component attribute values, such as* *`ServiceInfo`**).
    The interpretation of the associated metadata is component-specific.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Authenticator Module Cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “Pluggability” is provided by the `AccountAuthenticatorCache` class, which scans
    for packages that define authenticator modules and makes them available to the
    `AccountManagerService`. The `AccountAuthenticatorCache` is one implementation
    of the more general registered service cache facility that Android provides. The
    cache is built on demand (lazily) by interrogating the `PackageManagerService`
    about installed packages that register a particular intent action and metadata
    file. The cache is kept up-to-date by a broadcast receiver that triggers an update
    when packages are added, updated, or removed. The cache is persistent and written
    to disk each time a change is detected, with cache files written to the */data/system/registered_services/*
    directory and named after the intent action they scan for. The authenticator module
    cache is saved to the *android.accounts.AccountAuthenticator.xml* file and might
    look like [Example 8-1](ch08.html#contents_of_the_accountauthenticatordotx "Example 8-1. Contents
    of the AccountAuthenticator.xml registered services cache file").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1. *Contents of the* AccountAuthenticator.xml *registered services
    cache file*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the *com.android.exchange* and *com.android.email* account types (➊ and
    ➋) are registered by the stock Email application, and *com.example. account* and
    *org.foo.account* (➌ and ➍) are registered by third-party applications. On a multi-user
    device, the cache file will have entries for the accounts available to each user.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the first secondary user (user ID 10) can use *com.android.exchange*,
    *com.android.email*, and *com.example.account* (➎, ➏, and ➐), but not the *org.foo.account*
    account (because there is no entry for it in the file). When the `AccountManagerService`
    needs to perform an action with a particular account, it queries the `AccountAuthenticatorCache`
    for the implementing service by passing the account type. If an account implementation
    for that type is registered for the current user, `AccountAuthenticatorCache`
    returns details about the implementing service that contain the name of the implementing
    component and the UID of the host package. The `AccountManagerService` uses this
    information to bind to the service in order to be able to call methods of the
    `IAccountAuthenticator` interface that the service implements.
  prefs: []
  type: TYPE_NORMAL
- en: AccountManagerService Operations and Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As shown in [Figure 8-1](ch08.html#account_management_components "Figure 8-1. Account
    management components"), `AccountManagerService` implements its functionality
    by either calling into authenticator modules or by using cached data from the
    accounts database. Third-party components can only use the API that `AccountManagerService`
    exposes; they can’t access authenticator modules or the accounts database. This
    centralized interface guarantees operation workflow and enforces access rules
    for each operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`AccountManagerService` implements access control using a combination of permissions
    and caller UID and signature checks. Let’s look at the operations it provides
    and the respective permission checks.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing and Authenticating Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clients can get a list of accounts that match certain criteria (including type,
    declaring package, and other features) by calling one of the `getAccounts()` methods,
    and they can check to see if a particular account has the required features by
    calling the `hasFeatures()` method. These operations require the `GET_ACCOUNTS`
    permission, which has the *normal* protection level. A new account of a particular
    type can be added by calling the `addAccount()` method (which starts an implementation-specific
    *authenticator activity* that collects credentials from the user) or silently
    by calling the `addAccountExplicitly()` method, which takes the account, password,
    and any associated user data as parameters. The first method requires callers
    to hold the `MANAGE_ACCOUNTS` permission, and the second requires that they both
    hold the `AUTHENTICATE_ACCOUNTS` permission and have the same UID as the account’s
    authenticator. Both permissions have protection level *dangerous* and therefore
    require user confirmation when the app is installed. Requiring callers of `addAccountExplicitly()`
    to have the same UID as the authenticator ensures that only the same app, or apps
    that belong to the same shared user ID (see [Chapter 2](ch02.html "Chapter 2. Permissions")
    for details), can add accounts without user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Other operations that require the caller to both hold the `AUTHENTICATE_ ACCOUNTS`
    permission and have the same UID as the account’s authenticator are listed below.
    (We’ve omitted `AccountManager` method parameters here and in the following sections
    for clarity. See the reference documentation of the `AccountManager` class^([[79](#ftn.ch08fn02)])
    for full method signatures and additional information.)
  prefs: []
  type: TYPE_NORMAL
- en: '****`getPassword()`****. Returns the raw cached password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`getUserData()`****. Returns authenticator-specific account metadata that
    matches a specified key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`peekAuthToken()`****. Returns a cached token of the specified type (if
    available).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`setAuthToken()`****. Adds or replaces an authentication token for an account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`setPassword()`****. Sets or clears the cached password for an account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`setUserData()`****. Sets or clears the metadata entry with the specified
    key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as when adding a new account, removing an existing account requires the
    `MANAGE_ACCOUNTS` permission. However, if the calling device user has the `DISALLOW_MODIFY_ACCOUNTS`
    restriction set (see [Chapter 4](ch04.html "Chapter 4. User Management") for more
    details on user restrictions), they cannot add or remove accounts, even if the
    calling application holds the `MANAGE_ACCOUNTS` permission. Other methods that
    require this permission are those that modify account properties or credentials
    as listed next.
  prefs: []
  type: TYPE_NORMAL
- en: '****`clearPassword()`****. Clears a cached password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`confirmCredentials()`****. Explicitly confirms that the user knows the
    password (even if it is already cached) by showing a password entry UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`editProperties()`****. Shows a UI that allows the user to change global
    authenticator settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`invalidateAuthToken()`****. Removes an authentication token from the cache.
    (This can also be called if the caller holds the `USE_CREDENTIALS` permission.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`removeAccount()`****. Removes an existing account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`updateCredentials()`****. Asks the user the enter the current password
    and updates the saved credentials accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Account Credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final permission the `AccountManagerService` might require its clients to
    hold is `USE_CREDENTIALS`. This permission protects methods that return or modify
    *authentication tokens*, a service-dependent credential string that clients can
    use to authenticate requests to the server without sending their password with
    each request.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, servers return an authentication token after the client successfully
    authenticates with their username and password (or other permanent credentials).
    The token is identified by a string called the *token type*, which describes what
    type of access the token grants (for example, read-only or read-write). The token
    is reusable and can be used for sending multiple requests, but might have a limited
    validity period. Additionally, if a user account is believed to have been compromised,
    or if a user changes their password, all existing authentication tokens for that
    user are usually invalidated on the server. In this case, requests that use cached
    authentication tokens will fail with an authentication error. Because the `AccountManagerService`
    is protocol- and application-agnostic, it doesn’t automatically invalidate cached
    tokens, even if they have expired or been invalidated on the server. Applications
    are responsible for cleaning up such invalid cached tokens by calling the `invalidateAuthToken()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the methods that require `USE_CREDENTIALS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`getAuthToken()`****. Gets an authentication token of the specified type
    for a particular account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`invalidateAuthToken()`****. Removes an authentication token from the cache.
    (This can also be called if the caller holds the `MANAGE_ACCOUNTS` permission.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Account access request dialog](figs/web/08fig02.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2. Account access request dialog
  prefs: []
  type: TYPE_NORMAL
- en: Requesting Authentication Token Access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides holding the `USE_CREDENTIALS` permission, in order to obtain an authentication
    token of a particular type, callers of the `getAuthToken()` (or any of its wrapper
    methods as provided by the `AccountManager` facade class) must explicitly be granted
    access to the requested token type. This is accomplished by showing a confirmation
    dialog like the one shown in [Figure 8-2](ch08.html#account_access_request_dialog
    "Figure 8-2. Account access request dialog"). The dialog shows both the name of
    the requesting application (in the first bullet, “Account Requestor,” in this
    example), the account type and name (in the second bullet, “Example” and “example_user”,
    respectively), and a short description (below the bullets, “Full access to example
    data”) of the type of data access that will be permitted if the access request
    is granted. If the user grants access, this decision is cached and the dialog
    won’t be shown if a token of the same type is requested again. Applications running
    under the same UID as the authenticator module are allowed access to its tokens
    without showing a confirmation dialog. Additionally, privileged system applications
    are implicitly allowed access to all token types without user confirmation, so
    the dialog is not shown if the token request comes from a privileged application.
  prefs: []
  type: TYPE_NORMAL
- en: The Accounts Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve introduced authenticator modules, the authenticator cache, and the main
    features of the `AccountManagerService`. Now let’s see how this service uses the
    *accounts database*, an SQLite database stored in each user’s system directory
    with the *accounts.db* filename, to register accounts and cache credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'The accounts database is found at */data/system/users/0/accounts.db* on single-user
    devices. On multi-user devices, this file stores account information for the primary
    user, and secondary users each have their own instance at */data/system/users/<user
    ID>/accounts.db*. The database consists of six tables: `accounts`, `extras`, `authtokens`,
    `grants`, `shared_users`, and `meta`. As of this writing, the `meta` table appears
    to be unused; all other tables and their relationships are shown in [Figure 8-1](ch08.html#account_management_components
    "Figure 8-1. Account management components").'
  prefs: []
  type: TYPE_NORMAL
- en: Table Schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `accounts` table stores the name, type, and password of registered accounts,
    and all other tables directly or indirectly link to it. It might contain data
    similar to [Example 8-2](ch08.html#contents_of_the_accounts_table "Example 8-2. Contents
    of the accounts table").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2. Contents of the accounts table
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, ➊ is a Google account (type *com.google*) which allows access to Gmail,
    the Google Play Store, and other Google services. Google accounts depend on proprietary
    system components and are only available on Google experience devices. (You’ll
    find more details on Google accounts in “[The Google Login Service](ch08.html#google_login_service
    "The Google Login Service")”.) The account at ➋ is a POP3 mail account (type *com.google.android.pop3*)
    registered by the stock email application, and ➌ is a custom account (type *com.example.account*)
    registered by a third-party application. Each account can be associated with zero
    or more metadata key-value pairs that are stored in the `extras` table and link
    to the account by using its primary key (in the `_id` column). For example, if
    our custom application (➌ in [Example 8-2](ch08.html#contents_of_the_accounts_table
    "Example 8-2. Contents of the accounts table"), `_id=3`) does background data
    synchronization, it might have entries similar to those in [Example 8-3](ch08.html#contents_of_the_extras_table
    "Example 8-3. Contents of the extras table").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3. Contents of the `extras` table
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `authtokens` table stores tokens that have been issued for an account. For
    our custom application, it might look like [Example 8-4](ch08.html#contents_of_the_authtokens_table
    "Example 8-4. Contents of the authtokens table").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-4. Contents of the `authtokens` table
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `grants` table associates application UIDs with the types of tokens they’re
    allowed to use. Grants are added when the user OK’s the access confirmation dialog
    for a particular account type and token (see [Figure 8-2](ch08.html#account_access_request_dialog
    "Figure 8-2. Account access request dialog")). For example, if an application
    with UID 10291 has requested and been granted access to tokens of type *com.example.auth*
    as in our sample application (see [Example 8-4](ch08.html#contents_of_the_authtokens_table
    "Example 8-4. Contents of the authtokens table")), the grant will be represented
    by the following row in the `grants` table (see [Example 8-5](ch08.html#contents_of_the_grants_table
    "Example 8-5. Contents of the grants table")). A new row is added for each combination
    of account ID, token type, and granted application UID.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-5. Contents of the `grants` table
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `shared_accounts` table is used when sharing the device owner’s accounts
    with one of the restricted users on the device. (You’ll find more details on its
    contents and usage in “[Multi-User Support](ch08.html#multi-user_support-id00015
    "Multi-User Support")”.)
  prefs: []
  type: TYPE_NORMAL
- en: Table Access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll examine the relationship between tables and data in the accounts
    database and the key methods of the `AccountManagerService`. At a high level the
    relationship is fairly straightforward (if we ignore caching and synchronization):
    methods that retrieve or manipulate account details access the `accounts` table,
    and methods that handle user data associated with an account access the `extras`
    table. APIs that handle authentication tokens access the `authtokens` table, and
    save per-application token access grants in the `grants` table. We describe each
    method and the data it accesses next.'
  prefs: []
  type: TYPE_NORMAL
- en: When you add an account of a particular type by calling one of the `addAccount()`
    methods, the `AccountManagerService` inserts a row in the `accounts` table containing
    its type, username, and password. Calling one of the `getPassword()`, `setPassword()`,
    or `clearPassword()` methods results in the `AccountManagerService` accessing
    or updating the `password` column of the `accounts` table. If you get or set user
    data for the account using the `getUserdata()` or `setUserdata()` methods, the
    `AccountManagerService` fetches the matching entry from or saves it to the `extras`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: When you request a token for a particular account, things become a bit more
    complex. If a token with the specified type has never been issued before, `AccountManagerService`
    shows a confirmation dialog (see [Figure 8-2](ch08.html#account_access_request_dialog
    "Figure 8-2. Account access request dialog")) asking the user to approve access
    for the requesting application. If they accept, the UID of the requesting app
    and the token type are saved to the `grants` table. (Authenticators can declare
    that they use custom tokens by setting the `customTokens` account metadata attribute
    to `true`. In this case, they’re responsible for managing tokens, and Android
    neither shows the token access dialog nor automatically saves tokens to the `authtokens`
    table). If a grant already exits, `AccountManagerService` checks the `authtokens`
    table for tokens matching the request. If a valid one exists, it’s returned. If
    a matching token is not found, the `AccountManagerService` finds the authenticator
    for the specified account type in the cache and calls its `getAuthToken()` method
    to request a token. This usually involves the authenticator fetching the user-name
    and password from the `accounts` table (via the `getPassword()` method) and calling
    its respective online service to get a fresh token. When a token is returned,
    it gets cached in the `authtokens` table and then is returned to the requesting
    app (usually asynchronously via a callback). Invalidating a token results in deleting
    the row that stores it from the `authtokens` table. Finally, when an account is
    removed by calling the `removeAccount()` method, its row is deleted from the `accounts`
    table and a database trigger cleans up all linked rows from the `authtokens`,
    `extras`, and `grants` tables.
  prefs: []
  type: TYPE_NORMAL
- en: Password Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to note is that while credentials (usually usernames and passwords)
    are stored in a central database under */data/system/* that is only accessible
    to system applications, credentials are not encrypted; encrypting or otherwise
    protecting credentials is left to the authenticator module to implement as necessary.
    In fact, if you have a rooted device, you’ll likely find that a listing of the
    contents of the accounts table will show certain passwords in cleartext, especially
    for the stock email application (the `com.android.email` or `com.google.android.email`
    package). For example, in [Example 8-2](ch08.html#contents_of_the_accounts_table
    "Example 8-2. Contents of the accounts table"), the strings *password* ➋ and *pass1234*
    ➌ are the cleartext passwords for a POP account used by the stock application
    and a custom *com.example.account* account, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Email applications may need to store the password instead of a password hash
    or an authentication token in order to support several challenge-response authentication
    methods that take the password as input, such as DIGEST-MD5 and CRAM-MD5.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `AccountManger.getPassword()` method can be called only by apps
    with the same UID as the account’s authenticator, cleartext passwords are not
    accessible to other applications at runtime, but they may be included in backups
    or device dumps. In order to avoid this potential security risk, applications
    can encrypt passwords with a device-specific key or choose to replace a password
    with a revokable master token after initial authentication succeeds. For example,
    the official Twitter client does not store the user password in the `accounts`
    table, but only saves obtained authentication tokens (in the `authtokens` table).
    Google accounts are another example (account type *com.google*): as shown in “[The
    Google Login Service](ch08.html#google_login_service "The Google Login Service")”,
    instead of the user password, Google accounts store a master token that is exchanged
    for service-specific authentication tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-User Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall from [Chapter 4](ch04.html "Chapter 4. User Management") that on multi-user
    devices, Android allows each user to have their own set of applications, application
    data, and system settings. This user isolation extends to online accounts as well
    and users can have their own accounts registered with the system’s account manager
    service. Android 4.3 added support for restricted profiles, which are not fully
    independent users but share installed applications with the primary user. Additionally,
    restricted profiles can have a number of restrictions applied. Apps that use the
    `AccountManager` APIs can add explicit support for restricted profiles, thus allowing
    restricted profiles to see and use a subset of the primary user’s accounts within
    supported apps. We explain this feature in detail in “Shared Accounts” below.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections discuss how Android implements account isolation and
    sharing on multi-user devices.
  prefs: []
  type: TYPE_NORMAL
- en: Per-User Account Databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in “[The Accounts Database](ch08.html#accounts_database "The Accounts
    Database")”, the accounts databases that `AccountManagerServices` uses to store
    account information and cache authentication tokens are stored in each user’s
    system directory in */data/system/users/<user ID>/accounts.db*. This allows each
    user to have dedicated account storage, and different users might even have separate
    instances of the same type of online account. Aside from the database location,
    everything else works in exactly the same way as it does for the owner user, including
    permissions, access grants, and so on. When a user is removed, the system deletes
    all of its data, including the accounts database.
  prefs: []
  type: TYPE_NORMAL
- en: Shared Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Primary user accounts are shared with a restricted profile by simply cloning
    the account data into the restricted profile’s accounts database. Thus, restricted
    profiles do not access the primary user’s account data directly, but have their
    own copy. When a new restricted profile is added, the name and type of all current
    accounts of the primary user are copied into the `shared_accounts` table of the
    restricted profile’s accounts database. However, because the new user is not started
    yet, the `accounts` table is empty at this point and the shared accounts are not
    yet usable.
  prefs: []
  type: TYPE_NORMAL
- en: The `shared_accounts` table has the same structure as the `accounts` table,
    without the `password` column. It might look like [Example 8-6](ch08.html#contents_of_the_sharedunderscoreaccounts
    "Example 8-6. Contents of the shared_accounts table") for a restricted profile.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-6. Contents of the `shared_accounts` table
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Shared accounts are not cloned directly by copying data from the owner’s `accounts`
    table; instead, cloning is performed via the authenticator that declared the account.
    By default, the `AbstractAccountAuthenticator`, which all authenticator classes
    derive from, does not support account cloning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementations that want to support shared accounts for restricted profiles
    need to do so explicitly, by overriding a couple of methods that were introduced
    in Android 4.3, along with restricted profile support: `getAccountCredentialsForCloning()`,
    which returns a `Bundle` containing all data needed to clone the account, and
    `addAccountFromCredentials()`, which receives this `Bundle` as a parameter and
    is responsible for creating the account based on credentials in the `Bundle`.
    The `AccountManagerService` delays the cloning of a shared account until a restricted
    user is actually started. If the owner user adds any new accounts, they are added
    to the `shared_accounts` table and similarly cloned.'
  prefs: []
  type: TYPE_NORMAL
- en: Even when accounts are successfully cloned, they may not be available to an
    application started by a restricted profile. Recall from [Chapter 4](ch04.html
    "Chapter 4. User Management") that if an application wants to support shared accounts,
    it must explicitly declare the account type it requires with the `restrictedAccountType`
    attribute of the `<application>` manifest tag. The `AccountManagerServices` uses
    the value of the `restrictedAccountType` attribute to filter accounts before passing
    them to applications running within a restricted profile. As of this writing,
    an application can declare only one type of account with this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Secondary users do not share accounts with the owner, and therefore their*
    *`shared_accounts`* *tables are always empty and owner accounts are never cloned.*'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an Authenticator Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In “[Authenticator Modules](ch08.html#authenticator_modules "Authenticator Modules")”,
    we showed that an authentcator module is a bound service that implements the `android.accounts.IAccountAuthenticator`
    AIDL interface and which can be bound to by using the *android.accounts.AccountAuthenticator*
    intent action. In this section, we’ll show how an application can implement and
    declare an authenticator module.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the authenticator logic, including adding accounts, checking user-supplied
    credentials, and fetching authentication tokens, is implemented in an authenticator
    class derived from the base class that Android provides—namely, `AbstractAccountAuthenticator`.^([[80](#ftn.ch08fn03)])
    The authenticator class needs to provide implementation of all abstract methods,
    but if not all functionality is needed, implemented methods can return `null`
    or throw `UnsupportedOperationException`. In order to store the account password,
    an implementation should implement at least the `addAccount()` method and display
    a UI that collects the password from the user. The password can then be added
    to the accounts database by calling the `addAccountExplicitly()` method of `AccountManager`.
    Activities that implement credential collection and login can extend from the
    `AccountAuthenticatorActivity`,^([[81](#ftn.ch08fn04)]) which provides a convenience
    method to pass back collected credentials to the `AccountManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Remember that the* *`addAccountExplicitly()`* *method does not encrypt or
    otherwise protect the password that is stored in cleartext by default. If required,
    encryption should be implemented separately, and the encrypted password or token
    should be passed to* *`addAccountExplicitly()`* *instead of the cleartext version.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an account authenticator implementation, you simply create a service
    that returns its Binder interface when invoked with the *android.accounts.AccountAuthenticator*
    intent action, as shown in [Example 8-7](ch08.html#account_authenticator_service_implementa
    "Example 8-7. Account authenticator service implementation") (`AbstractAccountAuthenticator`
    method implementations have been omitted).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-7. Account authenticator service implementation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In order to be picked up by the `AccountAuthenticatorCache` and made available
    via the `AccountManagerService`, the service needs to declare the *android.accounts.AccountAuthenticator*
    intent action and matching metadata as shown in [Example 8-8](ch08.html#declaring_an_account_authenticator_servi
    "Example 8-8. Declaring an account authenticator service in AndroidManifest.xml").
    Permissions needed to access accounts and tokens need to be added to the manifest
    as well. In this example, we only add the `AUTHENTICATE_ACCOUNTS` permission,
    which is the minimum required in order to be able to add an account with `addAccountExplicitly()`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-8. Declaring an account authenticator service in AndroidManifest.xml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the account type, label, and icons must be declared in the referenced
    XML resource file as shown in [Example 8-9](ch08.html#declaring_account_metadata_in_an_xml_res
    "Example 8-9. Declaring account metadata in an XML resource file"). Here, the
    account type is *com.example.account* and we’re simply using the app icon as the
    account icon.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-9. Declaring account metadata in an XML resource file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After the application that declares our new account is installed, *com.example.account*
    accounts can be added via the `AccountManager` API or the system Settings UI by
    selecting **Add an account**. The new account should show up in the list of supported
    accounts, as shown in [Figure 8-3](ch08.html#adding_a_custom_account_via_the_system_s
    "Figure 8-3. Adding a custom account via the system Settings UI").
  prefs: []
  type: TYPE_NORMAL
- en: Custom accounts can be used for convenience only by the declaring application,
    or when creating a sync adapter, which requires a dedicated account. In order
    to allow third-party applications to authenticate using your custom account, you
    must implement authentication tokens, because as we saw in “[Listing and Authenticating
    Accounts](ch08.html#listing_and_authenticating_accounts "Listing and Authenticating
    Accounts")”, third-party applications cannot access an account password via the
    `AccountManager.getPassword()` API, unless they are signed with the same key and
    certificate as the application hosting the target account’s authenticator module.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a custom account via the system Settings UI](figs/web/08fig03.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3. Adding a custom account via the system Settings UI
  prefs: []
  type: TYPE_NORMAL
- en: Google Accounts Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main goal of Android’s account management facility is to make it easier
    to integrate online services into the OS, and to allow for seamless access to
    user data via background synchronization. The first versions of the system account
    management service were built to support Android integration with Google online
    services, and the service was later decoupled and made part of the OS. In Android
    versions 2.0 and later, Google account and online service support is bundled as
    a set of components that provide account authenticators (for the *com.google*
    account type) and sync adapters (for Gmail, Calendar, contacts, and so on), using
    standard OS APIs. However, there are a few notable differences from other third-party
    authenticator modules and sync adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: The Google accounts components are bundled with the system and thus are granted
    extra permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lot of the actual functionality is implemented on the server side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The account authenticator does not store passwords in plain text on the device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Google Login Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two main components that implement Google account and service support are
    the Google Services Framework (GSF) and the Google Login Service (GLS, displayed
    as *Google Account Manager* in recent versions). The former provides common services
    to all Google apps, such as centralized settings and feature toggle management,
    while the latter implements the authentication provider for Google accounts and
    will be the main topic of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Google provides numerous online services, and supports a handful of different
    methods to authenticate to those services, both via a user-facing web UI and several
    dedicated authentication APIs. Android’s Google Login Service, however, doesn’t
    call those public authentication APIs directly, but rather via a dedicated online
    service, which lives at *[https://android.clients.google.com](https://android.clients.google.com)*.
    It has endpoints both for authentication, authorization token issuing, and different
    data feeds (mail, calendar, and so on) that are used for data synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: While a lot of the authentication and authorization logic is implemented on
    the server side, some sort of locally stored credentials are also required, especially
    for background syncing. On-device credential management is one of the services
    GLS provides, and while as of this writing there is no source code or reference
    documentation publicly available, we can observe what data GLS stores on the device
    and infer how authentication is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, GLS plugs into the system account framework, so cached
    credentials, tokens, and associated extra data are stored in the system’s accounts
    database of the current user, just as it is for other account types. Unlike most
    other applications, however, GLS doesn’t store Google account passwords directly.
    Instead, in place of a password, GLS stores an opaque master token (probably some
    form of an OAuth refresh token) in the `password` column of the `accounts` table
    and exchanges it for authentication tokens for different Google services by calling
    an associated web service endpoint. The token is obtained when a Google account
    is first added to the device by sending the username and password entered in the
    sign-in activity shown in [Figure 8-4](ch08.html#google_account_sign-in_activity
    "Figure 8-4. Google account sign-in activity").
  prefs: []
  type: TYPE_NORMAL
- en: If the target Google account is using the default password-only authentication
    method and the correct password is entered, the GLS online service returns the
    master token and the account is added to the user’s accounts database. All subsequent
    authentication requests use the master token to obtain service- or scope-specific
    tokens that are used for synchronization or automatic web login. If the Google
    account is set to use two-factor authentication (2FA), the user is prompted to
    enter their one-time password (OTP, called *verification code* in the web UI)
    in an embedded web view like the one shown in [Figure 8-5](ch08.html#one-time_password_entry_as_part_of_addin
    "Figure 8-5. One-time password entry as part of adding a Google account").
  prefs: []
  type: TYPE_NORMAL
- en: '![Google account sign-in activity](figs/web/08fig04.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4. Google account sign-in activity
  prefs: []
  type: TYPE_NORMAL
- en: '![One-time password entry as part of adding a Google account](figs/web/08fig05.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5. One-time password entry as part of adding a Google account
  prefs: []
  type: TYPE_NORMAL
- en: If the OTP is successfully verified, the master token is added to the accounts
    database and a list of services that support background synchronization is shown
    (see [Figure 8-6](ch08.html#list_of_google_services_that_support_bac "Figure 8-6. List
    of Google services that support background synchronization")).
  prefs: []
  type: TYPE_NORMAL
- en: '![List of Google services that support background synchronization](figs/web/08fig06.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6. List of Google services that support background synchronization
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that only the initial login process differs for Google accounts that have
    2FA enabled: all subsequent authentication requests use the cached master token
    and do not require entering an OTP. Thus, once cached, the master token grants
    full access to a Google account and can be used not only for data synchronization,
    but for other types of account access as well, including web login.'
  prefs: []
  type: TYPE_NORMAL
- en: While it’s very handy to have an all-powerful authentication token cached, this
    trade-off in favor of convenience has enabled several attacks on Google accounts,
    and as a result many Google services now require additional authentication when
    sensitive data is displayed or account settings are changed. The master token
    can be invalidated by changing the Google account password, by enabling two-factor
    authentication, or by removing the Android device from the *Account Permissions*
    page of the associated Google account (see [Figure 8-7](ch08.html#android_device_entry_in_the_account_perm
    "Figure 8-7. Android device entry in the Account Permissions page of a Google
    account")). Any of these actions will require the user to reauthenticate with
    their new credentials on the device the next time it tries to get a Google authentication
    token via the `AccountManager` API.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android device entry in the Account Permissions page of a Google account](figs/web/08fig07.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7. Android device entry in the Account Permissions page of a Google
    account
  prefs: []
  type: TYPE_NORMAL
- en: Google Services Authentication and Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides user-facing online services with a web UI such as Gmail, Google Calendar
    and, of course, search, Google provides programmatic access to many of its services
    via different web APIs. Most of these require authentication, either in order
    to be able to access a subset of a particular user’s data, or for quota and billing
    purposes. Several standard or Google-proprietary authentication and authorization
    methods have been used over the years, with the current trend being to migrate
    everything to OAuth 2.0^([[82](#ftn.ch08fn05)]) and OpenID Connect.^([[83](#ftn.ch08fn06)])
    However, many services still use older, proprietary protocols, so we’ll briefly
    look into those as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most authentication protocols have two variations: one for web applications
    and one for the so-called installed applications. Web applications run in a browser
    and are expected to be able to take advantage of all standard browser features
    including rich UI, free-form user interaction, cookie store, and the ability to
    follow redirects. Installed applications, on the other hand, don’t have a native
    way to preserve session information, and may not have the full web capabilities
    of a browser. Android native applications (mostly) fall into the “installed applications”
    category, so let’s see what protocols are available for them.'
  prefs: []
  type: TYPE_NORMAL
- en: ClientLogin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The oldest and, as of this writing, still widely used authorization protocol
    for installed applications is *ClientLogin*.^([[84](#ftn.ch08fn07)]) This protocol
    assumes that the application has access to the user’s account name and password
    and lets you get an authorization token for a particular service that can be saved
    and used for accessing that service on behalf of the user. Services are identified
    by proprietary service names, such as *cl* for Google Calendar and *ah* for Google
    App engine. You’ll find a list of many supported service names in the Google Data
    API reference,^([[85](#ftn.ch08fn08)]) but here are a few Android-specific ones
    not listed in the reference: *ac2dm*, *android*, *androidsecure*, *androiddeveloper*,
    and *androidmarket*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The authorization tokens for these services can be fairly long-lived (up to
    two weeks), but cannot be refreshed and the application must obtain a new token
    when the current token expires. Unfortunately, there is no way to validate a token
    short of accessing the associated service: if you get an *OK* HTTP status (200)
    the token is valid, but if 403 is returned you need to consult the additional
    error code and retry or get a new token.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another limitation of ClientLogin authorization tokens is that they don’t offer
    fine-grained access to a service’s resources: access is all or nothing, and you
    cannot specify read-only access or access to a particular resource only.'
  prefs: []
  type: TYPE_NORMAL
- en: The biggest drawback for mobile apps though is that ClientLogin requires access
    to the actual user password. Therefore, unless you want to force users to enter
    their password each time a new token is required, the password must be saved on
    the device, which poses various problems and potential security issues. Android
    avoids storing the raw password by storing a master token on the device and uses
    GLS and the associated online service to exchange the master token for ClientLogin
    tokens. Getting a token is as simple as calling the appropriate `AccountManger`
    method, which either returns a cached token or issues an API request to fetch
    a fresh one.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its many limitations, the ClientLogin protocol is easy to understand
    and straightforward to implement, so it has been widely used. It was officially
    deprecated in April 2012 though, and apps using it are encouraged to migrate to
    OAuth 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OAuth 2.0 authorization framework became an official Internet standard in
    late 2012\. It defines different *authorization flows* for different use cases,
    but we won’t try to present all of them here. We’ll only discuss how OAuth 2.0
    relates to native mobile applications. (For more detail on the actual protocol,
    see RFC 6749.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The OAuth 2.0 specification defines four basic flows for getting an authorization
    token for a resource. It also defines two that don’t require the client (in our
    scenario, an Android app) to directly handle user credentials (such as the Google
    account username and password), namely the *authorization code grant* flow and
    the *implicit grant* flow. Both of these require the authorization server (Google’s)
    to authenticate the resource owner (the Android app user) in order to establish
    whether to grant or deny the access request (say, read-only access to profile
    information). In a typical browser-based web application, this is straightforward:
    the user is redirected to an authentication page, then to an access grant page
    that basically says “Do you allow app X to access data Y and Z?” If the user agrees,
    another redirect, which includes an authorization token, takes the user back to
    the original application. The browser simply needs to pass the token in the next
    request in order to gain access to the target resource.'
  prefs: []
  type: TYPE_NORMAL
- en: Things are not so simple with a native app. A native app can either use the
    system browser to handle the grant permission step, or embed a `WebView` or a
    similar control in the app’s UI. Using the system browser requires launching a
    third-party application (the browser), detecting success or failure, and finally
    figuring out a way to return the token back to the calling application. Embedding
    a `WebView` is a bit more user-friendly, as it doesn’t involve switching back
    and forth between applications, but still results in showing a non-native web
    UI, and requires complex code to detect success and extract the access token.
    Neither option is ideal, and both are confusing to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'This integration complexity and UI impedance mismatch are the problems that
    OAuth 2.0 support via native Android APIs aims to solve. Android offers two APIs
    that can be used to obtain OAuth 2.0 tokens: the platform `AccountManager` via
    the special *oauth2:scope* token type syntax, and Google Play Services (discussed
    in the next section). When using either of those APIs to obtain a token, user
    authentication is implemented transparently by passing the saved master token
    to the server-side component of GLS, which produces the native `AccountManager`
    access grant dialog (see [Figure 8-8](ch08.html#oauth_token_access_request_dialog
    "Figure 8-8. OAuth token access request dialog")) instead of a `WebView` with
    a permission grant page. If you grant token access to the requesting application,
    a second request is sent to convey this to the server, which returns the requested
    token. The access token is then directly delivered to the app, without passing
    through an intermediary component such as a `WebView`. This is essentially the
    same flow as for web applications, except that it doesn’t require context switching
    from native to browser and back, and it’s much more user-friendly. Of course,
    this native authorization flow only works for Google accounts, and writing a client
    for some other online service that uses OAuth 2.0 still requires integrating its
    web interface into your app. For example, Twitter clients often use `WebView`
    to process the permission grant callback URL returned by the Twitter API.'
  prefs: []
  type: TYPE_NORMAL
- en: Google Play Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Google Play Services (GPS)*^([[86](#ftn.ch08fn09)]) was announced at Google
    I/O 2012 as an easy-to-use platform that offers third-party Android apps a way
    to integrate with Google products. Since then, it has grown into a giant all-in-one
    package (with over 14,000 Java methods!) that provides access to Google APIs and
    proprietary OS extensions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![OAuth token access request dialog](figs/web/08fig08.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8. OAuth token access request dialog
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous section, getting OAuth 2.0 tokens via the standard
    `AccountManager` interface has been supported since Android 2.2 and higher, but
    it didn’t work reliably across different Android builds because their different
    bundled GLS versions resulted in slightly different behavior between devices.
    Additionally, the permission grant dialog shown when requesting a token was not
    particularly user friendly because it showed the raw OAuth 2.0 scope in some cases,
    which meant little to most users (see [Figure 8-8](ch08.html#oauth_token_access_request_dialog
    "Figure 8-8. OAuth token access request dialog")). While human-readable aliases
    for certain scopes were partially supported (for example, the *Manage your tasks*
    string was displayed instead of the raw OAuth scope *oauth2:[https://www.googleapis.com/auth/tasks](https://www.googleapis.com/auth/tasks)*
    in some versions), that solution was neither ideal nor universally available,
    as it too depended on the pre-installed GLS version.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, while Android’s account management framework is well-integrated into
    the OS and extensible via third-party authenticator modules, its API is not particularly
    flexible, and adding support for multi-step authentication or authorization flows
    such as those used in OAuth 2.0 is far from straightforward. GPS manages to achieve
    this with the help of an online service, which does its best to hide the complexity
    of OAuth 2.0 and provides web APIs compatible with Android’s account management
    framework. We discuss the details of this integration next.
  prefs: []
  type: TYPE_NORMAL
- en: 'GPS adds universal supports for displaying a user-friendly OAuth scope description
    by making token issuance a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like before, the first request includes the account name, master token,
    and requested service, in the *oauth2:scope* format. GPS adds two new parameters
    to the request: the app’s package name and the SHA-1 hash of its signing certificate.
    The response includes some human-readable details about the requested scope and
    requesting application, which GPS shows in a permission grant dialog like the
    one shown in [Figure 8-9](ch08.html#google_play_services_account_access_perm "Figure 8-9. Google
    Play Services account access permission dialog").'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user grants permission, that decision is recorded in the `extras` table
    in a proprietary format that includes the requesting app’s package name, signing
    certificate hash, and granted OAuth 2.0 scope. (Note that the `grants` table is
    not used.) GPS then resends the authorization request, setting the *has_permission*
    parameter to 1\. On success, this results in an OAuth 2.0 token and its expiration
    date in the response. The expiration date is saved in the `extras` table, and
    the token is cached in the `authtokens` table in a similar format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Google Play Services account access permission dialog](figs/web/08fig09.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-9. Google Play Services account access permission dialog
  prefs: []
  type: TYPE_NORMAL
- en: The GPS app has the same shared user ID as the GSF and GLS packages (*com.google.uid.shared*),
    so it can directly interact with those services. This allows it, among other things,
    to directly get and write Google account credentials and tokens to the accounts
    database. As can be expected, GPS runs in a remote service that’s accessed by
    a client library which is linked into apps that use GPS. The major selling point
    against the legacy `AccountManager` API is that while its underlying authenticator
    modules (GLS and GSF) are part of the system (and as such cannot be updated without
    an OTA), GPS is a user-installable app that can be easily updated via Google Play.
    In fact, it is auto-updating, so app developers presumably won’t have to rely
    on users to update it if they want to use newer features (unless GPS is disabled
    altogether). This update mechanism is designed to provide “agility in rolling
    out new platform capabilities,” but as GPS has come to integrate very diverse
    APIs and functionalities that require extensive testing, updates have been infrequent.
    That said, if your app uses OAuth 2.0 tokens to authenticate to Google APIs (the
    preferred method as of this writing), you should definitely consider using GPS
    over “raw” `AccountManager` access.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In order to be able to actually use a Google API, you must register your app’s
    package name and signing key in Google’s API console. The registration lets services
    validating the token query Google about what app the token was issued for, thus
    identifying the calling app. This validation process has one subtle but important
    side effect: you don’t have to embed an API key in your app and send it with every
    request. Of course, for a third-party published app, you can easily discover both
    the package name and the signing certificate so it’s not particularly hard to
    get a token issued in the name of some other app (though not via the official
    API, of course).*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android provides a centralized registry of user online accounts via the `AccountManager`
    class, which lets you get tokens for existing accounts without having to handle
    the raw user credentials and register your own custom account types. Registering
    a custom account type gives you access to powerful system features, such as authentication
    token caching and automatic background synchronization. Google experience devices
    include built-in support for Google accounts, which lets third-party apps access
    Google online services without having to directly request authentication information
    from the user. The Google Play Services app and companion client library further
    improve support for Google accounts by making it easy to use OAuth 2.0 tokens
    from third-party applications.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[78](#ch08fn01)]) Google, *Android API Reference*, “AccountManager,” *[http://developer.android.com/reference/android/accounts/AccountManager.html](http://developer.android.com/reference/android/accounts/AccountManager.html)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[79](#ch08fn02)]) Google, *Android API Reference*, “AccountManager,” *[http://developer.android.com/reference/android/accounts/AccountManager.html](http://developer.android.com/reference/android/accounts/AccountManager.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[80](#ch08fn03)]) Google, *Android API Reference*, “AbstractAccountAuthenticator,”
    *[http://developer.android.com/reference/android/accounts/AbstractAccountAuthenticator.html](http://developer.android.com/reference/android/accounts/AbstractAccountAuthenticator.html)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[81](#ch08fn04)]) Google, *Android API Reference*, “AccountAuthenticatorActivity,”
    *[http://developer.android.com/reference/android/accounts/AccountAuthenticatorActivity.html](http://developer.android.com/reference/android/accounts/AccountAuthenticatorActivity.html)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[82](#ch08fn05)]) D. Hardt, *The OAuth 2.0 Authorization Framework*, *[http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[83](#ch08fn06)]) N. Sakimura et al., *OpenID Connect Core 1.0*, *[http://openid.net/specs/openid-connect-core-1_0.html](http://openid.net/specs/openid-connect-core-1_0.html)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[84](#ch08fn07)]) Google, *Google Accounts Authentication and Authorization*,
    “ClientLogin for Installed Applications,” *[https://developers.google.com/accounts/docs/AuthForInstalledApps](https://developers.google.com/accounts/docs/AuthForInstalledApps)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[85](#ch08fn08)]) Google, *Google Data APIs*, “Frequently Asked Questions,”
    *[https://developers.google.com/gdata/faq#clientlogin](https://developers.google.com/gdata/faq#clientlogin)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[86](#ch08fn09)]) Google, “Google Play Services,” *[http://developer.android.com/google/play-services/index.html](http://developer.android.com/google/play-services/index.html)*
  prefs: []
  type: TYPE_NORMAL
