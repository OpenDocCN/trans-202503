<html><head></head><body><section class="chapter" title="Chapter&#xA0;10.&#xA0;Show Me the Data" epub:type="chapter" id="show_me_the_data"><div class="titlepage"><div><div><h2 class="title">Chapter 10. Show Me the Data</h2></div></div></div><p><a id="iddle1571" class="indexterm"/><a id="iddle1799" class="indexterm"/>Virtually every application written today requires robust mechanisms to both access and manipulate data. While the full gamut of data access technologies across the .NET Framework is available to you in F#, this chapter focuses on two specific areas: query expressions and type providers.</p><div class="sect1" title="Query Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="query_expressions">Query Expressions</h2></div></div></div><p>When LINQ was added to .NET, it revolutionized the way we access data by providing a unified syntax for querying data from disparate data sources. Upon LINQ’s introduction, C# and Visual Basic were extended to include the <span class="emphasis"><em>query syntax</em></span>, a SQL-like syntax with context-sensitive keywords that were really syntactic sugar over several language features, such as extension methods and lambda expressions. In this regard, F# was a little late to the party because, prior to F# 3.0, the only way to use LINQ in F# was to directly call the LINQ extension methods.</p><p>Despite their foundations in functional programming, using the LINQ methods directly has a highly object-oriented feel due to their fluent interface; sequences are passed to methods that return new sequences and the methods are typically chained with dot notation. Consider the following query, which uses the LINQ extension methods directly against an F# list to filter out odd numbers, and then sorts the results in descending order (remember to open the <code class="literal">System.Linq</code> namespace):</p><a id="pro_id00489"/><pre class="programlisting">[ 1..100 ]
  .Where(fun n -&gt; n % 2 = 0)
  .OrderByDescending(fun n -&gt; n)</pre><p>As you can see, chaining the method calls in this manner is much more object-oriented than functional. <span class="emphasis"><em>Query expressions</em></span>, introduced with F# 3.0, changed that by providing a convenient SQL-like syntax that resembles the query syntax from C# and Visual Basic. They really are LINQ for F#.</p><p>Query expressions take the form of <code class="literal">query { ... }</code>. Inside the braces we identify a series of operations we want to apply to a sequence, thereby forming a query. For instance, we could rewrite the previous query as a query expression like this (explicitly opening <code class="literal">System.Linq</code> isn’t required for query expressions):</p><a id="pro_id00490"/><pre class="programlisting">query { for n in [ 1..100 ] do
        where (n % 2 = 0)
        sortByDescending n }</pre><p>Now, filtering and sorting the list looks and feels more functional. Instead of chaining method calls directly, we’re expressing the query in a more idiomatic manner that uses expression composition and function calls. Because query expressions are a wrapper around the LINQ technologies, you can use them with any sequence.</p><p>Given this simple example, one could argue that the <code class="literal">Seq</code> and <code class="literal">List</code> module functions could be used to similar effect, and in many cases, that’s true. For instance, we could easily replace the <code class="literal">where</code> operator with a call to <code class="literal">Seq.filter</code>. Likewise, we can often sort using <code class="literal">Seq.sortBy</code> instead of the <code class="literal">sortBy</code> operator. What’s not immediately apparent is that by being built upon LINQ, query expressions can offer additional optimizations, such as generating a <code class="literal">WHERE</code> clause in a SQL query to prevent retrieving a large data set from a database.</p><p>In the interest of simplicity, unless otherwise noted, each query expression example in this chapter will use the types and collections defined in the following <code class="literal">QuerySource</code> module.</p><a id="pro_id00491"/><pre class="programlisting">module QuerySource =
  open System

  type film = { id : int; name : string; releaseYear : int; gross : Nullable&lt;float&gt; }
              override x.ToString() = sprintf "%s (%i)" x.name x.releaseYear
  type actor = { id : int; firstName : string; lastName : string }
              override x.ToString() = sprintf "%s, %s" x.lastName x.firstName
  type filmActor = { filmId : int; actorId : int }

  let films =
    [ { id = 1; name = "The Terminator"; releaseYear = 1984; gross = Nullable 38400000.0 }
      { id = 2; name = "Predator"; releaseYear = 1987; gross = Nullable 59735548.0 }
      { id = 3; name = "Commando"; releaseYear = 1985; gross = Nullable&lt;float&gt;() }
      { id = 4; name = "The Running Man"; releaseYear = 1987; gross = Nullable 38122105.0 }
      { id = 5; name = "Conan the Destroyer"; releaseYear = 1984; gross = Nullable&lt;float&gt;() } ]

  let actors =
    [ { id = 1; firstName = "Arnold"; lastName = "Schwarzenegger" }
      { id = 2; firstName = "Linda"; lastName = "Hamilton" }
      { id = 3; firstName = "Carl"; lastName = "Weathers" }
      { id = 4; firstName = "Jesse"; lastName = "Ventura" }
      { id = 5; firstName = "Vernon"; lastName = "Wells" } ]
  let filmActors =
    [ { filmId = 1; actorId = 1 }
      { filmId = 1; actorId = 2 }
      { filmId = 2; actorId = 1 }
      { filmId = 2; actorId = 3 }
      { filmId = 2; actorId = 4 }
      { filmId = 3; actorId = 1 }
      { filmId = 3; actorId = 5 }
      { filmId = 4; actorId = 1 }
      { filmId = 4; actorId = 4 }
      (* Intentionally omitted actor for filmId = 5 *) ]</pre><p><a id="iddle1809" class="indexterm"/><a id="iddle1868" class="indexterm"/>There’s nothing particularly interesting about the <code class="literal">QuerySource</code> module, but the types and collections defined here sufficiently represent a basic data model we can query in a variety of ways. The <code class="literal">film</code> and <code class="literal">actor</code> types also include overrides of <code class="literal">ToString</code> to simplify the query output.</p><div class="sect2" title="Basic Querying"><div class="titlepage"><div><div><h3 class="title" id="basic_querying">Basic Querying</h3></div></div></div><p>In their most basic form, query expressions consist of an enumerable <code class="literal">for</code> loop and a projection. The enumerable <code class="literal">for</code> loop defines a name for items in a source sequence. The projection identifies the data that will be returned by the query.</p><p>One of the most common projection operators is <code class="literal">select</code>, which equates to LINQ’s <code class="literal">Select</code> method and defines the structure of each item in the resulting sequence (much like <code class="literal">Seq.map</code>). At their most basic, <code class="literal">select</code> operations simply project each data item directly, like this:</p><a id="pro_id00492"/><pre class="programlisting">query { for f in QuerySource.films do select f }</pre><p><a id="iddle1803" class="indexterm"/><a id="iddle2112" class="indexterm"/>which results in:</p><a id="pro_id00493"/><pre class="programlisting">val it : seq&lt;QuerySource.film&gt; =
  seq
    [{id = 1;
      name = "The Terminator";
      releaseYear = 1984;
      gross = 38400000.0;};
      -- <span class="emphasis"><em>snip</em></span> -- ]</pre><p><code class="literal">select</code> operations aren’t limited to projecting only the source data item; they can also transform the source sequence to project more complex types like tuples, records, or classes. For instance, to project a tuple containing the film’s name and its release year, you could write:</p><a id="pro_id00494"/><pre class="programlisting">query { for f in QuerySource.films do
        select (f.name, f.releaseYear) }</pre><p>which gives:</p><a id="pro_id00495"/><pre class="programlisting">val it : seq&lt;string * int&gt; =
  seq
    [("The Terminator", 1984); ("Predator", 1987); ("Commando", 1985);
     ("The Running Man", 1987); ...]</pre><p>In these simple examples, we’ve explicitly included a <code class="literal">select</code> operation to transform the source sequence. As query complexity grows, projecting the raw, nontransformed data items is often implied, so the <code class="literal">select</code> operation can often be safely omitted. In the interest of space, I’ll generally project results with <code class="literal">ToString</code>, but I encourage you to experiment with different projections to familiarize yourself with the query behavior.</p></div><div class="sect2" title="Filtering Data"><div class="titlepage"><div><div><h3 class="title" id="filtering_data">Filtering Data</h3></div></div></div><p>Queries often involve specifying some criteria to filter out unwanted data. There are two primary approaches to filtering with query expressions: predicate-based filters and distinct item filters.</p><div class="sect3" title="Predicate-Based Filters"><div class="titlepage"><div><div><h4 class="title" id="predicate-based_filters">Predicate-Based Filters</h4></div></div></div><p><span class="emphasis"><em>Predicate-based filters</em></span> allow you to filter data by specifying the criteria that each item in the source sequence must satisfy in order to be included in the projected sequence. To create a predicate-based filter, simply include F#’s equivalent of LINQ’s <code class="literal">Where</code> method, the <code class="literal">where</code> operator, followed by a Boolean expression (often called a <span class="emphasis"><em>predicate</em></span>) in your query. (Note that parentheses are typically required around the expression.) For example, to select only the films released in 1984, you could write this:</p><a id="pro_id00496"/><pre class="programlisting">query { for f in QuerySource.films do
        where (f.releaseYear = 1984)
        select (f.ToString()) }</pre><p><a id="iddle1680" class="indexterm"/>to get:</p><a id="pro_id00497"/><pre class="programlisting">val it : seq&lt;string&gt; =
  seq ["The Terminator (1984)"; "Conan the Destroyer (1984)"]</pre><p>When composing predicate-based filters, you must be aware of the source sequence’s underlying type. For the simple examples you’ve seen so far it hasn’t been an issue, but in many cases, particularly when you are working with <code class="literal">IQueryable&lt;'T&gt;</code> instances, you might have to deal with null values.</p><p>Null values can pose a problem in query expressions because the standard comparison operators don’t handle them. For example, if you were to query for all films that grossed no more than $40 million using the standard equality operator like this:</p><a id="pro_id00498"/><pre class="programlisting">query { for f in QuerySource.films do
        where (f.gross &lt;= 40000000.0)
        select (f.ToString()) }</pre><p>you’d receive the following error because <code class="literal">gross</code> is defined as <code class="literal">Nullable&lt;float&gt;</code>:</p><a id="pro_id00499"/><pre class="programlisting">QueryExpressions.fsx(53,16): error FS0001: The type 'System.Nullable&lt;float&gt;'
does not support the 'comparison' constraint. For example, it does not support
the 'System.IComparable' interface</pre><p>To work around this limitation, you need to use the nullable operators defined in the <code class="literal">Microsoft.FSharp.Linq.NullableOperators</code> module. These operators look like the standard operators except that they begin with a question mark (<code class="literal">?</code>) when the left operand is <code class="literal">Nullable&lt;_&gt;</code>, end with a question mark when the right operand is <code class="literal">Nullable&lt;_&gt;</code>, or are surrounded by question marks when both operands are <code class="literal">Nullable&lt;_&gt;</code>. <a class="xref" href="ch10.html#nullable_operators" title="Table 10-1. Nullable Operators">Table 10-1</a> lists each of the nullable operators.</p><div class="table"><a id="nullable_operators"/><div class="table-title">Table 10-1. Nullable Operators</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/><col class="c3"/><col class="c4"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Operator</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Left Side Nullable</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Right Side Nullable</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Both Sides Nullable</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Equality</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?=</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">=?</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">?=?</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Inequality</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?&lt;&gt;</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&lt;&gt;?</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">?&lt;&gt;?</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Greater than</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?&gt;</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&gt;?</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">?&gt;?</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Greater than or equal</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?&gt;=</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&gt;=?</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">?&gt;=?</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Less than</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?&lt;</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&lt;?</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">?&lt;?</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Less than or equal</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?&lt;=</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&lt;=?</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">?&lt;=?</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Addition</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?+</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">+?</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">?+?</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subtraction</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?-</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-?</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">?-?</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Multiplication</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?*</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">*?</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">?*?</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Division</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">?/</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">/?</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">?/?</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>Modulus</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">?%</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">%?</code></p></td><td style="vertical-align: top; "><p><code class="literal">?%?</code></p></td></tr></tbody></table></div></div><p><a id="iddle1321" class="indexterm"/><a id="iddle1801" class="indexterm"/>Now we can rewrite the previous query using the appropriate nullable operator like this:</p><a id="pro_id00500"/><pre class="programlisting">open Microsoft.FSharp.Linq.NullableOperators

query { for f in QuerySource.films do
        where (f.gross ?&lt;= 40000000.0)
        select (f.ToString()) }</pre><p>to get:</p><a id="pro_id00501"/><pre class="programlisting">val it : seq&lt;string&gt; = seq ["The Terminator (1984)"; "The Running Man (1987)"]</pre><p>As you can see, the query resulted in two matches despite the underlying sequence containing some null values.</p><p>It’s possible to chain multiple predicates together with Boolean operators. For instance, to get only the films released in 1987 that grossed no more than $40 million, you could write:</p><a id="pro_id00502"/><pre class="programlisting">query { for f in QuerySource.films do
        where (f.releaseYear = 1987 &amp;&amp; f.gross ?&lt;= 40000000.0)
        select (f.ToString()) }</pre><p>which gives:</p><a id="pro_id00503"/><pre class="programlisting">val it : seq&lt;string&gt; = seq ["The Running Man (1987)"]</pre></div><div class="sect3" title="Distinct-Item Filters"><div class="titlepage"><div><div><h4 class="title" id="distinct-item_filters">Distinct-Item Filters</h4></div></div></div><p>Query expressions can produce a sequence containing only the distinct values from the underlying sequence by filtering out duplicates. To achieve this, you need only include the <code class="literal">distinct</code> operator in your query.</p><p>The <code class="literal">distinct</code> operator corresponds to LINQ’s <code class="literal">Distinct</code> method, but unlike in C# or VB, query expressions allow you to include it directly within the query rather than as a separate method call. For example, to query for distinct release years, you could write this:</p><a id="pro_id00504"/><pre class="programlisting">query { for f in QuerySource.films do
        select f.releaseYear
        distinct }</pre><p>Here, we’ve projected the distinct release years to a new sequence:</p><a id="pro_id00505"/><pre class="programlisting">val it : seq&lt;int&gt; = seq [1984; 1987; 1985]</pre></div></div><div class="sect2" title="Accessing Individual Items"><div class="titlepage"><div><div><h3 class="title" id="accessing_individual_items">Accessing Individual Items</h3></div></div></div><p><a id="iddle1502" class="indexterm"/><a id="iddle1503" class="indexterm"/><a id="iddle1554" class="indexterm"/><a id="iddle1555" class="indexterm"/><a id="iddle1678" class="indexterm"/><a id="iddle1804" class="indexterm"/><a id="iddle1805" class="indexterm"/>It’s quite common for a sequence to contain multiple items when you really care about only one in particular. Query expressions include several operators for accessing the first item, the last item, or arbitrary items from a sequence.</p><div class="sect3" title="Getting the First or Last Item"><div class="titlepage"><div><div><h4 class="title" id="getting_the_first_or_last_item">Getting the First or Last Item</h4></div></div></div><p>To get the first item from a sequence, you can use the <code class="literal">head</code> or <code class="literal">headOrDefault</code> operators. These operators respectively correspond to the parameterless overloads of the <code class="literal">First</code> and <code class="literal">FirstOrDefault</code> LINQ methods but use the more functional nomenclature of “head” to identify the first item (just like with F# lists). The difference between <code class="literal">head</code> and <code class="literal">headOrDefault</code> is that <code class="literal">head</code> raises an exception when the source sequence is empty, whereas <code class="literal">headOrDefault</code> returns <code class="literal">Unchecked.defaultof&lt;_&gt;</code>.</p><p>To get the first item from a sequence, simply project a sequence to one of the head operators like this:</p><a id="pro_id00506"/><pre class="programlisting">query { for f in QuerySource.films do headOrDefault }</pre><p>In this case, the result is:</p><a id="pro_id00507"/><pre class="programlisting">val it : QuerySource.film = {id = 1;
                             name = "The Terminator";
                             releaseYear = 1984;
                             gross = 38400000.0;}</pre><p>Similarly, you can get the last item in a sequence using either the <code class="literal">last</code> or <code class="literal">lastOrDefault</code> operators. These operators behave the same way as their head counterparts in that <code class="literal">last</code> raises an exception when the sequence is empty, whereas <code class="literal">lastOrDefault</code> does not. Depending on the underlying sequence type, getting the last item may require enumerating the entire sequence, so exercise some care because the operation could be expensive or time consuming.</p></div><div class="sect3" title="Getting an Arbitrary Item"><div class="titlepage"><div><div><h4 class="title" id="getting_an_arbitrary_item">Getting an Arbitrary Item</h4></div></div></div><p>When you want to get a specific item by its index you can use the <code class="literal">nth</code> operator, which is equivalent to LINQ’s <code class="literal">ElementAt</code> method. For instance, to get the third element from the <code class="literal">films</code> sequence, you could structure a query like this:</p><a id="pro_id00508"/><pre class="programlisting">query { for f in QuerySource.films do nth 2 }</pre><p>Here, the result is:</p><a id="pro_id00509"/><pre class="programlisting">val it : QuerySource.film = {id = 3;
                             name = "Commando";
                             releaseYear = 1985;
                             gross = null;}</pre><p><a id="iddle1359" class="indexterm"/><a id="iddle1360" class="indexterm"/><a id="iddle1430" class="indexterm"/>Although the <code class="literal">nth</code> operator is useful when you already know the index, it’s more common to want the first item that matches some criteria. In those cases, you’ll want to use the <code class="literal">find</code> operator instead.</p><p>The <code class="literal">find</code> operator is equivalent to calling LINQ’s <code class="literal">First</code> method with a predicate. It is also similar to the <code class="literal">where</code> operator except that it returns only a single item instead of a new sequence. For example, to get the first film listed for 1987, you could write:</p><a id="pro_id00510"/><pre class="programlisting">query { for f in QuerySource.films do find (f.releaseYear = 1987) }</pre><p>Executing this query will give you:</p><a id="pro_id00511"/><pre class="programlisting">val it : QuerySource.film = {id = 2;
                             name = "Predator";
                             releaseYear = 1987;
                             gross = 59735548.0;}</pre><p>The <code class="literal">find</code> operator is useful for locating the first item that matches some criteria, but it doesn’t guarantee that the first match is the only match. When you want to return a single value but also need to be certain that a query result contains one and only one item (such as when you are finding an item by a key value), you can use the <code class="literal">exactlyOne</code> operator, which corresponds to the parameterless overload of LINQ’s <code class="literal">Single</code> method. For example, to get a film by its <code class="literal">id</code> while enforcing uniqueness, you could write:</p><a id="pro_id00512"/><pre class="programlisting">query { for f in QuerySource.films do
        where (f.id = 4)
        exactlyOne }</pre><p>In this case, the query yields:</p><a id="pro_id00513"/><pre class="programlisting">val it : QuerySource.film = {id = 4;
                             name = "The Running Man";
                             releaseYear = 1987;
                             gross = 38122105.0;}</pre><p>When the source sequence doesn’t contain exactly one item, the <code class="literal">exactlyOne</code> operator raises an exception. Should you want a default value when the source sequence is empty, you can use the <code class="literal">exactlyOneOrDefault</code> operator instead. Be warned, though, that if the source sequence includes more than one item, <code class="literal">exactlyOneOrDefault</code> will still raise an exception.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note01"/>Note</h3><p><span class="emphasis"><em>Query expression syntax does not include operators equivalent to the predicate-based overload of Single or SingleOrDefault.</em></span></p></div></div></div><div class="sect2" title="Sorting Results"><div class="titlepage"><div><div><h3 class="title" id="sorting_results">Sorting Results</h3></div></div></div><p><a id="iddle1810" class="indexterm"/><a id="iddle1933" class="indexterm"/><a id="iddle1934" class="indexterm"/><a id="iddle1935" class="indexterm"/><a id="iddle1936" class="indexterm"/>Query expressions make sorting data easy, and, in some ways, they are more flexible than the sorting functions in the various collection modules. The sorting operators allow you to sort in ascending or descending order on both nullable and non-nullable values. You can even sort by multiple values.</p><div class="sect3" title="Sorting in Ascending Order"><div class="titlepage"><div><div><h4 class="title" id="sorting_in_ascending_order">Sorting in Ascending Order</h4></div></div></div><p>Sorting a sequence in ascending order requires either the <code class="literal">sortBy</code> or <code class="literal">sortByNullable</code> operators. Both of these operators are built upon LINQ’s</p><p><code class="literal">OrderBy</code> method. Internally, these methods differ only by the generic constraints applied to their arguments. As their names imply, the <code class="literal">sortBy</code> operator is used with non-nullable values, whereas <code class="literal">sortByNullable</code> is used with <code class="literal">Nullable&lt;_&gt;</code> values.</p><p>With both of these operators, you need to specify the value on which to sort. For example, to sort the films by name, you could write:</p><a id="pro_id00514"/><pre class="programlisting">query { for f in QuerySource.films do
        sortBy f.name
        select (f.ToString()) }</pre><p>This returns the following sequence:</p><a id="pro_id00515"/><pre class="programlisting">val it : seq&lt;string&gt; =
  seq
    ["Commando (1985)"; "Conan the Destroyer (1984)"; "Predator (1987)";
     "The Running Man (1987)"; ...]</pre></div><div class="sect3" title="Sorting in Descending Order"><div class="titlepage"><div><div><h4 class="title" id="sorting_in_descending_order">Sorting in Descending Order</h4></div></div></div><p>To sort a sequence in descending order, you use either the <code class="literal">sortByDescending</code> or <code class="literal">sortByNullableDescending</code> operators. These operators are based on LINQ’s <code class="literal">OrderByDescending</code> method and, like their ascending counterparts, internally differ only by the generic constraints applied to their parameters.</p><p>To sort the <code class="literal">films</code> sequence in descending order by name, you could write:</p><a id="pro_id00516"/><pre class="programlisting">query { for f in QuerySource.films do
        sortByDescending f.name
        select (f.ToString()) }</pre><p>which returns:</p><a id="pro_id00517"/><pre class="programlisting">val it : seq&lt;string&gt; =
  seq
    ["The Terminator (1984)"; "The Running Man (1987)"; "Predator (1987)";
     "Conan the Destroyer (1984)"; ...]</pre></div><div class="sect3" title="Sorting by Multiple Values"><div class="titlepage"><div><div><h4 class="title" id="sorting_by_multiple_values">Sorting by Multiple Values</h4></div></div></div><p><a id="iddle1496" class="indexterm"/><a id="iddle1806" class="indexterm"/><a id="iddle2013" class="indexterm"/><a id="iddle2014" class="indexterm"/><a id="iddle2015" class="indexterm"/><a id="iddle2016" class="indexterm"/>To sort on multiple values, first sort with one of the <code class="literal">sortBy</code> or <code class="literal">sortByDescending</code> operators and then supply subsequent sort values with one of the <code class="literal">thenBy</code> operators. As with the primary sort operators, there are variations of <code class="literal">thenBy</code> that allow you to sort in ascending or descending order using both nullable and non-nullable values.</p><p>The four <code class="literal">thenBy</code> variations, which can appear only after one of the <code class="literal">sortBy</code> variations, are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">thenBy</code></p></li><li class="listitem"><p><code class="literal">thenByNullable</code></p></li><li class="listitem"><p><code class="literal">thenByDescending</code></p></li><li class="listitem"><p><code class="literal">thenByNullableDescending</code></p></li></ul></div><p>These operators are based upon LINQ’s <code class="literal">ThenBy</code> and <code class="literal">ThenByDescending</code> methods. To see these in action, let’s sort the <code class="literal">films</code> sequence by <code class="literal">releaseYear</code> and then in descending order by <code class="literal">gross</code>:</p><a id="pro_id00518"/><pre class="programlisting">query { for f in QuerySource.films do
        sortBy f.releaseYear
        thenByNullableDescending f.gross
        select (f.releaseYear, f.name, f.gross) }</pre><p>This query results in the following sorted sequence:</p><a id="pro_id00519"/><pre class="programlisting">val it : seq&lt;int * string * System.Nullable&lt;float&gt;&gt; =
  seq
    [(1984, "The Terminator", 38400000.0); (1984, "Conan the Destroyer", null);
     (1985, "Commando", null); (1987, "Predator", 59735548.0); ...]</pre><p>You can chain additional <code class="literal">thenBy</code> operators to create even more complex sorting scenarios.</p></div></div><div class="sect2" title="Grouping"><div class="titlepage"><div><div><h3 class="title" id="grouping">Grouping</h3></div></div></div><p>Another common query operation is grouping. Query expressions provide two operators, both based on LINQ’s <code class="literal">GroupBy</code> method, to do just that. Both operators produce an intermediate sequence of <code class="literal">IGrouping&lt;_,_&gt;</code> instances that you refer to later in your query.</p><p>The first operator, <code class="literal">groupBy</code>, lets you specify the key value by which the items in the source sequence will be grouped. Each <code class="literal">IGrouping&lt;_,_&gt;</code> produced by <code class="literal">groupBy</code> includes the key value and a child sequence containing any items from the source sequence that matches the key. For example, to group the films by release year, you could write:</p><a id="pro_id00520"/><pre class="programlisting">query { for f in QuerySource.films do
        groupBy f.releaseYear into g
        sortBy g.Key
        select (g.Key, g) }</pre><p><a id="iddle1498" class="indexterm"/><a id="iddle1808" class="indexterm"/><a id="iddle1927" class="indexterm"/><a id="iddle1928" class="indexterm"/><a id="iddle1979" class="indexterm"/><a id="iddle1980" class="indexterm"/>This query produces the result (formatted and abbreviated for readability):</p><a id="pro_id00521"/><pre class="programlisting">val it : seq&lt;int * IGrouping&lt;int, QuerySource.film&gt;&gt; =
  seq
    [(1984, seq [{id = 1; -- <span class="emphasis"><em>snip</em></span> --};
                 {id = 5; -- <span class="emphasis"><em>snip</em></span> --}]);
     (1985, seq [{id = 3; -- <span class="emphasis"><em>snip</em></span> --}]);
     (1987, seq [{id = 2; -- <span class="emphasis"><em>snip</em></span> --};
                 {id = 4; -- <span class="emphasis"><em>snip</em></span> --}])]</pre><p>It isn’t always necessary to include the full source item in the resulting <code class="literal">IGrouping&lt;_,_&gt;</code> like the <code class="literal">groupBy</code> operator does. Instead, you can use the <code class="literal">groupValBy</code> operator to specify what to include, be it a single value from the source or some other transformation. Unlike the other operators we’ve seen so far, <code class="literal">groupValBy</code> takes two arguments: the value to include in the result, and the key value.</p><p>To demonstrate the <code class="literal">groupValBy</code> operator, let’s group the films by <code class="literal">releaseYear</code> again, but this time we’ll include a tuple of the film <code class="literal">name</code> and its <code class="literal">gross</code> earnings:</p><a id="pro_id00522"/><pre class="programlisting">query { for f in QuerySource.films do
        groupValBy (f.name, f.gross) f.releaseYear into g
        sortBy g.Key
        select (g.Key, g) }</pre><p>This gives us:</p><a id="pro_id00523"/><pre class="programlisting">val it : seq&lt;int * IGrouping&lt;int,(string * System.Nullable&lt;float&gt;)&gt;&gt; =
  seq
    [(1984,
      seq [("The Terminator", 38400000.0); ("Conan the Destroyer", null)]);
     (1985, seq [("Commando", null)]);
     (1987, seq [("Predator", 59735548.0); ("The Running Man", 38122105.0)])]</pre><p>Now, instead of the full film instance, the resulting groupings include only the data we explicitly requested.</p></div><div class="sect2" title="Paginating"><div class="titlepage"><div><div><h3 class="title" id="paginating">Paginating</h3></div></div></div><p>Query expressions allow you to easily paginate a sequence. Think about your typical search results page, where items are partitioned into some number of items (say, 10) per page. Rather than having to manage placeholders that identify which partition a user should see, you can use query expressions, which provide the <code class="literal">skip</code>, <code class="literal">skipWhile</code>, <code class="literal">take</code>, and <code class="literal">takeWhile</code> operators to help you get to the correct partition in the query itself. Each of these operators shares its name with its underlying LINQ method.</p><p>The <code class="literal">skip</code> and <code class="literal">take</code> operators both accept an integer indicating how many items to bypass or include, respectively. For example, you could compose a function to get a particular page, like this:</p><a id="pro_id00524"/><pre class="programlisting">let getFilmPageBySize pageSize pageNumber =
  query { for f in QuerySource.films do
          skip (pageSize * (pageNumber - 1))
          take pageSize
          select (f.ToString()) }</pre><p>Now, getting a particular page is only a matter of invoking the <code class="literal">getFilmPage</code> function. For instance, to get the first page of three items, you would write:</p><a id="pro_id00525"/><pre class="programlisting">getFilmPageBySize 3 1</pre><p>which yields:</p><a id="pro_id00526"/><pre class="programlisting">val it : seq&lt;string&gt; =
  seq ["The Terminator (1984)"; "Predator (1987)"; "Commando (1985)"]</pre><p>Likewise, you would get the second result page as follows:</p><a id="pro_id00527"/><pre class="programlisting">getFilmPageBySize 3 2</pre><p>which gives us:</p><a id="pro_id00528"/><pre class="programlisting">val it : seq&lt;string&gt; =
  seq ["The Running Man (1987)"; "Conan the Destroyer (1984)"]</pre><p>It’s okay to specify more items than are present in the sequence. If the end of the sequence is reached, the <code class="literal">skip</code> and <code class="literal">take</code> operators return what has been selected so far and no exceptions are thrown.</p><p>The <code class="literal">skipWhile</code> and <code class="literal">takeWhile</code> operators are very similar to <code class="literal">skip</code> and <code class="literal">take</code> except that instead of working against a known number of items, they skip or take items as long as a condition is met. This is useful for paging over a variable number of items according to some criteria. For example, the following function returns the films released in a given year:</p><a id="pro_id00529"/><pre class="programlisting">let getFilmPageByYear year =
  query { for f in QuerySource.films do
          sortBy f.releaseYear
          skipWhile (f.releaseYear &lt; year)
          takeWhile (f.releaseYear = year)
          select (f.ToString()) }</pre><p><a id="iddle1195" class="indexterm"/><a id="iddle1272" class="indexterm"/><a id="iddle1370" class="indexterm"/><a id="iddle1636" class="indexterm"/><a id="iddle1647" class="indexterm"/><a id="iddle1798" class="indexterm"/><a id="iddle1968" class="indexterm"/>Invoking this function with a year will generate a sequence containing zero or more items. For instance, invoking it with 1984 returns:</p><a id="pro_id00530"/><pre class="programlisting">val it : seq&lt;string&gt; =
  seq ["The Terminator (1984)"; "Conan the Destroyer (1984)"]</pre><p>whereas invoking it with 1986 returns no items because the source sequence doesn’t include any films released in 1986.</p><p>If you’re wondering whether this simple example of paging by <code class="literal">releaseYear</code> could be simplified with a single <code class="literal">where</code> operator, it can. This example simply demonstrates <code class="literal">takeWhile</code>’s effect. <code class="literal">where</code> and <code class="literal">takeWhile</code> serve similar purposes, but distinguishing between them is important, particularly for more complex predicates. The difference between the two operators is that <code class="literal">takeWhile</code> stops looking as soon as it finds something that doesn’t match, but <code class="literal">where</code> does not.</p></div><div class="sect2" title="Aggregating Data"><div class="titlepage"><div><div><h3 class="title" id="aggregating_data">Aggregating Data</h3></div></div></div><p>As often as we need to present or otherwise work with tabular data, sometimes what we’re really after is an aggregated view of the data. Aggregations such as counting the number of items in a sequence, totaling some values, or finding an average are all commonly sought-after values that can be exposed through built-in query operators.</p><p>Counting the items in a sequence is easy; simply project the sequence to the <code class="literal">count</code> operator.</p><a id="pro_id00531"/><pre class="programlisting">query { for f in QuerySource.films do count }</pre><p>Evaluating this query tells us that five items are present in the <code class="literal">films</code> sequence. Be warned, though, that counting the items in a sequence can be an expensive operation; it typically requires enumerating the entire sequence, which could have a negative impact on performance. That said, the <code class="literal">Count</code> method on which this operator is based is smart enough to short-circuit some sequences (like arrays). If you’re counting items only to determine whether the sequence contains any data, you should instead consider using the <code class="literal">exists</code> operator, discussed in <a class="xref" href="ch10.html#detecting_items" title="Detecting Items">Detecting Items</a>.</p><p>The remaining aggregation operators allow you to easily perform mathematical aggregations against a sequence according to a selector. The operators—<code class="literal">minBy</code>, <code class="literal">maxBy</code>, <code class="literal">sumBy</code>, and <code class="literal">averageBy</code>—allow you to calculate the minimum value, maximum value, total, or average for the values, respectively. Internally, the <code class="literal">minBy</code> and <code class="literal">maxBy</code> operators use LINQ’s <code class="literal">Min</code> and <code class="literal">Max</code> methods, respectively, but <code class="literal">sumBy</code> and <code class="literal">averageBy</code> provide their own implementations and are completely independent of LINQ.</p><p>Each of these four operators also have nullable counterparts that work against nullable values much like the sorting operators introduced in <a class="xref" href="ch10.html#sorting_results" title="Sorting Results">Sorting Results</a>. To demonstrate, we’ll query the <code class="literal">films</code> sequence using the nullable forms.</p><p><a id="iddle1194" class="indexterm"/><a id="iddle1269" class="indexterm"/><a id="iddle1635" class="indexterm"/><a id="iddle1646" class="indexterm"/><a id="iddle1800" class="indexterm"/><a id="iddle1967" class="indexterm"/>To find the highest grossing film, we could write:</p><a id="pro_id00532"/><pre class="programlisting">query { for f in QuerySource.films do maxByNullable f.gross }</pre><p>As expected, running this query returns <code class="literal">59735548.0</code>. Replacing <code class="literal">maxByNullable</code> with <code class="literal">minByNullable</code> returns <code class="literal">38122105.0</code>, and <code class="literal">sumByNullable</code> returns <code class="literal">136257653.0</code>. The <code class="literal">averageByNullable</code> operator doesn’t behave quite as you might expect, however.</p><p>Averaging the gross earnings using <code class="literal">averageByNullable</code> results in <code class="literal">27251530.6</code>. What happens is that although the operator skips null values during the summation phase, it divides the sum by the count of items in the sequence regardless of how many null items were skipped. This means that the null values are effectively treated as zero, which may or may not be desirable. Later in this chapter, we’ll look at how to define a new query operator that truly ignores null values when calculating an average.</p></div><div class="sect2" title="Detecting Items"><div class="titlepage"><div><div><h3 class="title" id="detecting_items">Detecting Items</h3></div></div></div><p>Thus far, we’ve explored the many ways you can structure query expressions to transform, filter, sort, group, and aggregate sequences. Sometimes, though, you don’t really care to obtain specific items from a sequence but rather want to inspect a sequence to determine whether it contains data that matches some criterion. Instead of returning a new sequence or a specific item, the operators discussed in this section return a Boolean value indicating whether the sequence contains the desired data. Like the <code class="literal">distinct</code> operator, these operators are part of the query expression itself, which is another feature that distinguishes F#’s query expressions from query syntax in C# and Visual Basic.</p><p>When you want to see if a known item is contained within a sequence, you use the <code class="literal">contains</code> operator. Built upon LINQ’s <code class="literal">Contains</code> method, the <code class="literal">contains</code> operator accepts the item you are looking for as its argument. For instance, if we want to detect whether <span class="emphasis"><em>Kindergarten Cop</em></span> is present in the <code class="literal">films</code> collection, we could write:</p><a id="pro_id00533"/><pre class="programlisting">open System
open QuerySource

let kindergartenCop =
  { id = 6; name = "Kindergarten Cop"; releaseYear = 1990; gross = Nullable 91457688.0 }

query { for f in films do
        contains kindergartenCop }</pre><p>Invoking this query will inform you that <span class="emphasis"><em>Kindergarten Cop</em></span> is not present in the collection (much to my relief). As you can see, though, the <code class="literal">contains</code> operator is really suitable only when you already have a reference to an item that may already be part of the collection. If you know only part of the value <a id="iddle1117" class="indexterm"/><a id="iddle1371" class="indexterm"/><a id="iddle1807" class="indexterm"/>you’re looking for, such as the name of the film, you can revise the query to project each name and pass the name you’re looking for to <code class="literal">contains</code>, like this:</p><a id="pro_id00534"/><pre class="programlisting">query { for f in QuerySource.films do
        select f.name
        contains "Kindergarten Cop" }</pre><p>Projecting the values like this, however, isn’t particularly efficient because it involves enumerating the entire sequence prior to locating the specified item. Instead, you can turn to another operator, <code class="literal">exists</code>, which is based on LINQ’s <code class="literal">Any</code> method. The <code class="literal">exists</code> operator is like <code class="literal">where</code> except that it stops enumerating the sequence and returns <code class="literal">true</code> or <code class="literal">false</code> as soon as an item that matches its predicate is found. For example, the previous query could be expressed with <code class="literal">exists</code> like this:</p><a id="pro_id00535"/><pre class="programlisting">query { for f in QuerySource.films do
        exists (f.name = "Kindergarten Cop") }</pre><p>Of course, the predicate supplied to <code class="literal">exists</code> doesn’t have to look for a specific item. We can easily determine if any films grossed at least $50 million with the following query:</p><a id="pro_id00536"/><pre class="programlisting">open Microsoft.FSharp.Linq.NullableOperators

query { for f in QuerySource.films do
        exists (f.gross ?&gt;= 50000000.0) }</pre><p>Because <span class="emphasis"><em>Predator</em></span> grossed nearly $60 million, the previous query returns <code class="literal">true</code>. If you want to check whether every item in a sequence satisfies some condition, you can use the <code class="literal">all</code> operator. Based on LINQ’s <code class="literal">All</code> method, the <code class="literal">all</code> operator enumerates the sequence and returns <code class="literal">true</code> when each item matches the predicate. When an item that doesn’t match the predicate is encountered, enumeration stops and <code class="literal">all</code> returns <code class="literal">false</code>. For example, to see if every film grossed at least $50 million, you could construct a query like this:</p><a id="pro_id00537"/><pre class="programlisting">query { for f in QuerySource.films do
        all (f.gross ?&gt;= 50000000.0) }</pre><p>In our <code class="literal">films</code> collection, only one item satisfies the condition; therefore, the query returns <code class="literal">false</code>.</p></div><div class="sect2" title="Joining Multiple Data Sources"><div class="titlepage"><div><div><h3 class="title" id="joining_multiple_data_sources">Joining Multiple Data Sources</h3></div></div></div><p>Querying data from a single sequence is useful, but data is often spread across multiple sources. Query expressions carry forward LINQ’s join capabilities, which allow you to query data from multiple sources within a single expression. Joins in query expressions resemble enumerable <code class="literal">for</code> loops in that they include an iteration identifier and the source sequence but begin with the appropriate <code class="literal">join</code> operator and also include join criteria.</p><p><a id="iddle1497" class="indexterm"/><a id="iddle1550" class="indexterm"/>The first type of join, the <span class="emphasis"><em>inner join</em></span>, uses the <code class="literal">join</code> operator to correlate values from one sequence with values in a second sequence. Internally, the <code class="literal">join</code> operator uses LINQ’s <code class="literal">Join</code> method to work its magic. Once the sequences are joined, values from both sequences can be referenced by subsequent operators like <code class="literal">where</code> or <code class="literal">select</code>.</p><p>Until now, all of the queries we’ve written have used only the <code class="literal">films</code> collection. Recall that when we created the <code class="literal">QuerySource</code> module at the beginning of the chapter, we also defined two other collections: <code class="literal">actors</code> and <code class="literal">filmActors</code>. Together, the <code class="literal">films</code>, <code class="literal">actors</code>, and <code class="literal">filmActors</code> collections model a many-to-many relationship between <code class="literal">films</code> and <code class="literal">actors</code>, with <code class="literal">filmActors</code> serving as the junction table. We can use the <code class="literal">join</code> operator to bring these three collections together in a single query like this:</p><a id="pro_id00538"/><pre class="programlisting">query { for f in QuerySource.films do
        join fa in QuerySource.filmActors on (f.id = fa.filmId)
        join a in QuerySource.actors on (fa.actorId = a.id)
        select (f.name, f.releaseYear, a.lastName, a.firstName) }</pre><p>Joining multiple sequences together merely requires us to include a join expression for each sequence and identify the relationship between them through their members and an equality operator. Invoking this query results in the following sequence (truncated per FSI):</p><a id="pro_id00539"/><pre class="programlisting">val it : seq&lt;string * int * string * string&gt; =
  seq
    [("The Terminator", 1984, "Schwarzenegger", "Arnold");
     ("The Terminator", 1984, "Hamilton", "Linda");
     ("Predator", 1987, "Schwarzenegger", "Arnold");
     ("Predator", 1987, "Weathers", "Carl"); ...]</pre><p>F# exposes LINQ’s <code class="literal">GroupJoin</code> function through the <code class="literal">groupJoin</code> operator. This lets you join two sequences, but instead of selecting items that satisfy the join criterion individually, you project each item that satisfies the join criterion into another sequence you can subsequently reference within your query. You can use this intermediate sequence to create a hierarchical data structure that resembles the <code class="literal">IGrouping&lt;_,_&gt;</code> instances created by the <code class="literal">groupBy</code> operator.</p><p>Consider the following query, which creates a hierarchy where each actor is grouped by the films in which he or she appears:</p><a id="pro_id00540"/><pre class="programlisting">query { for f in QuerySource.films do
        groupJoin fa in QuerySource.filmActors on (f.id = fa.filmId) into junction
        select (f.name, query { for j in junction do
                                join a in QuerySource.actors on (j.actorId = a.id)
                                select (a.lastName, a.firstName) } ) }</pre><p>Here, we use the <code class="literal">groupJoin</code> operator to create an intermediate sequence named <code class="literal">junction</code>. Inside the projected tuple, we have a nested query where we join <code class="literal">actors</code> to <code class="literal">junction</code> and project individual actor names. This results in the following sequence, which I’ve formatted for readability:</p><a id="pro_id00541"/><pre class="programlisting">val it : seq&lt;string * seq&lt;string * string&gt;&gt; =
  seq
    [("The Terminator", seq [("Schwarzenegger", "Arnold");
                             ("Hamilton", "Linda")]);
     ("Predator", seq [("Schwarzenegger", "Arnold");
                       ("Weathers", "Carl");
                       ("Ventura", "Jesse")]);
     ("Commando", seq [("Schwarzenegger", "Arnold");
                       ("Wells", "Vernon")]);
     ("The Running Man", seq [("Schwarzenegger", "Arnold");
                              ("Ventura", "Jesse")]);
     ...]</pre><p>As you can see, the outer query (the <code class="literal">films</code> part) returns a single sequence of tuples. Nested within each item is another sequence containing the actors associated with that film. What isn’t apparent from these truncated results is that when none of the items in the joined sequence satisfies the join criterion (as is the case for <span class="emphasis"><em>Conan the Destroyer</em></span>), the sequence created by the <code class="literal">groupJoin</code> operation is empty.</p><p>If you prefer to flatten the results of a <code class="literal">groupJoin</code> rather than return them as a hierarchy, you can follow the <code class="literal">groupJoin</code> operation with another enumerable <code class="literal">for</code> loop, using the junction sequence as the loop source. Here, the previous query is restructured to return each actor inline with the film:</p><a id="pro_id00542"/><pre class="programlisting">query { for f in QuerySource.films do
        groupJoin fa in QuerySource.filmActors on (f.id = fa.filmId) into junction
        for j in junction do
        join a in QuerySource.actors on (j.actorId = a.id)
        select (f.name, f.releaseYear, a.lastName, a.firstName) }</pre><p>The result of this query is the same as for an inner join, so I won’t repeat the output here. In most cases, you’d want to use the <code class="literal">join</code> operator to forego the overhead associated with creating the intermediate junction sequence, but there is one place where using a <code class="literal">groupJoin</code> like this makes sense: left outer joins.</p><p>By default, if no items satisfy the join criterion in a group join, the result is an empty sequence. However, if you use the <code class="literal">DefaultIfEmpty</code> method with the resulting sequence, you’ll get a new sequence containing a single item that’s the default value for the underlying type. To perform a left outer join in your query, you can use the <code class="literal">groupJoin</code> operator as we did in the previous query but include a call to <code class="literal">DefaultIfEmpty</code> in your enumerable <code class="literal">for</code> loop—for example, <code class="literal">j.DefaultIfEmpty()</code>. Alternatively, you can use the <code class="literal">leftOuterJoin</code> operator to achieve the same result.</p><p>Unfortunately, left outer joins are one area where the dissonance between F# and the rest of the .NET Framework can cause a lot of misery. But this is really a problem only when you’re working with the core F# types. Consider the following query:</p><a id="pro_id00543"/><pre class="programlisting">query { for f in QuerySource.films do
        leftOuterJoin fa in QuerySource.filmActors on (f.id = fa.filmId) into junction
        for j in junction do
        join a in QuerySource.actors on (j.actorId = a.id)
        select (f.name, f.releaseYear, a.lastName, a.firstName) }
|&gt; Seq.iter (printfn "%O")</pre><p>When this query enumerates (via <code class="literal">Seq.iter</code>), it raises a <code class="literal">NullReferenceException</code> as soon as it tries to join in the actors for <span class="emphasis"><em>Conan the Barbarian</em></span>. Because there are no entries for that film in the <code class="literal">filmActors</code> sequence, the call to <code class="literal">DefaultIfEmpty</code> in the left outer join causes the sole entry in <code class="literal">junction</code> to be <code class="literal">null</code>.</p><p>Wait, what? Null? Isn’t <code class="literal">filmActor</code> a record type? How can it possibly be <code class="literal">null</code> if <code class="literal">null</code> isn’t a valid value for record types? The answer lies in the fact that by calling into .NET Framework methods we’ve left the confines of the F# sandbox. <code class="literal">null</code> may not be valid for record types in F#, but the Common Language Runtime has no notion of a record type; all it knows are value and reference types and, from its perspective, a record type is just a reference type. Therefore, <code class="literal">null</code> is a valid value. Unfortunately, because our code is all in F# and the F# compiler enforces the value constraints around the record type, we can’t handle the null value with pattern matching or <code class="literal">if...then</code> expressions. We can’t even use the <code class="literal">AllowNullLiteral</code> attribute on the type because the compiler doesn’t allow that either.</p><p>Working around this issue is a bit of a pain. We can start by splitting the query into two parts: one that joins <code class="literal">actors</code> to <code class="literal">filmActors</code> and another that joins in <code class="literal">films</code>, like this:</p><a id="pro_id00544"/><pre class="programlisting">let actorsFilmActors =
  query { for a in QuerySource.actors do
          join fa in QuerySource.filmActors on (a.id = fa.actorId)
          select (fa.filmId, a) }

query { for f in QuerySource.films do
        leftOuterJoin (id, a) in actorsFilmActors on (f.id = id) into junction
        for (_, a) in junction do
        select (f.name, a.lastName, a.firstName) }</pre><p>This is a good start, but we’ll still get a <code class="literal">NullReferenceException</code> with the Tuple pattern match in the enumerable <code class="literal">for</code> loop for <code class="literal">junction</code> because F# doesn’t allow <code class="literal">null</code> for tuples either. There is yet another workaround we can use: an upcast to <code class="literal">obj</code>.</p><a id="pro_id00545"/><pre class="programlisting">query { for f in QuerySource.films do
        leftOuterJoin (id, a) in actorsFilmActors on (f.id = id) into junction
        for x in junction do
        select (match (<span class="strong"><strong>x :&gt; obj</strong></span>) with

               | null -&gt; (f.name, "", "")
               | _ -&gt; let _, a = x
                      (f.name, a.lastName, a.firstName))
      }</pre><p><a id="iddle1783" class="indexterm"/><a id="iddle1802" class="indexterm"/><code class="literal">null</code> may not be a valid value for a tuple, but it certainly is for <code class="literal">obj</code>. By explicitly upcasting to <code class="literal">obj</code>, we can use pattern matching to detect the null value and return the appropriate tuple instead of raising the exception.</p></div><div class="sect2" title="Extending Query Expressions"><div class="titlepage"><div><div><h3 class="title" id="extending_query_expressions">Extending Query Expressions</h3></div></div></div><p>As you’ve seen in the previous sections, query expressions provide an easy and expressive way to work with data. Query expressions also offer another benefit that really sets them apart from query syntax in C# and Visual Basic: They’re fully extensible. In this section, I’ll show a few additional operators. We’ll start by plugging a hole in the built-in operators by defining operators that expose the parameterized overloads of <code class="literal">Single</code> and <code class="literal">SingleOrDefault</code>. We’ll then move on to a more complex example that allows us to calculate an average by disregarding all null values.</p><div class="sect3" title="Example: ExactlyOneWhen"><div class="titlepage"><div><div><h4 class="title" id="example_exactlyonewhen">Example: ExactlyOneWhen</h4></div></div></div><p>Recall from <a class="xref" href="ch10.html#getting_an_arbitrary_item" title="Getting an Arbitrary Item">Getting an Arbitrary Item</a> that the <code class="literal">exactlyOne</code> and <code class="literal">exactlyOneOrDefault</code> operators expose the parameterless versions of LINQ’s <code class="literal">Single</code> and <code class="literal">SingleByDefault</code> operators, but no such operators exist for the overloads that accept a predicate. We can easily define our own operators to expose these methods by leveraging the power of F# type extensions.</p><p>To create the custom operators, we need to extend the <code class="literal">QueryBuilder</code> class found within the <code class="literal">Microsoft.FSharp.Linq</code> namespace. This class defines the methods that ultimately serve as the query operators. Fundamentally, the type extension we’ll define is no different than any other type extension; we need only to include a few attributes so the compiler knows how the functions should behave within a query expression.</p><p>Here is the code listing in full:</p><a id="pro_id00546"/><pre class="programlisting">open System
open Microsoft.FSharp.Linq

type QueryBuilder with

① [&lt;CustomOperation("exactlyOneWhen")&gt;]
  member ② __.ExactlyOneWhen (③ source : QuerySource&lt;'T,'Q&gt;,
                              ④ [&lt;ProjectionParameter&gt;] selector) =

    System.Linq.Enumerable.Single (source.Source, Func&lt;_,_&gt;(selector))

  [&lt;CustomOperation("exactlyOneOrDefaultWhen")&gt;]
  member __.ExactlyOneOrDefaultWhen (source : QuerySource&lt;'T,'Q&gt;,
                                     [&lt;ProjectionParameter&gt;] selector) =
    System.Linq.Enumerable.SingleOrDefault (source.Source, Func&lt;_,_&gt;(selector))</pre><p>This snippet defines two extension methods on the <code class="literal">QueryBuilder</code> class: <code class="literal">exactlyOneWhen</code> and <code class="literal">exactlyOneOrDefaultWhen</code>. Because these are so similar, we’ll just focus on the <code class="literal">exactlyOneWhen</code> operator. The first item of interest is the <code class="literal">CustomOperation</code> attribute ① applied to the method itself. This attribute indicates that the method should be available within a query expression and the operator name.</p><p>Next, the method’s <code class="literal">this</code> identifier is two underscore characters ② to be consistent with the other operator definitions. The <code class="literal">source</code> parameter at ③, annotated as <code class="literal">QuerySource&lt;'T, 'Q&gt;</code>, identifies the sequence the operator will work against.</p><p>Immediately following <code class="literal">source</code> is the <code class="literal">selector</code> parameter ④. This parameter is a function that will be applied against every item in <code class="literal">source</code> to determine whether it should be selected. The <code class="literal">ProjectionParameter</code> attribute applied to <code class="literal">selector</code> instructs the compiler that the function is implied to accept <code class="literal">'T</code> (as inferred from <code class="literal">source</code>) so that you can write the selector function as if you were working directly with an instance; that is, if you’re querying the <code class="literal">films</code> collection and have used <code class="literal">f</code> as your iteration identifier, you could write <code class="literal">f.id = 4</code>. Without <code class="literal">ProjectionParameter</code>, you’d have to use the full lambda syntax (or a formal function) instead of just the expression.</p><p>With the new operators defined, we can now write queries that use them. For instance, to use the <code class="literal">exactlyOneWhen</code> operator to find a film by <code class="literal">id</code>, you would write:</p><a id="pro_id00547"/><pre class="programlisting">query { for f in QuerySource.films do
        exactlyOneWhen (f.id = 4) }</pre><p>As you can see, with these operators you no longer need to include the <code class="literal">where</code> operator to filter the results before checking that the sequence contains only a single item.</p></div><div class="sect3" title="Example: AverageByNotNull"><div class="titlepage"><div><div><h4 class="title" id="example_averagebynotnull">Example: AverageByNotNull</h4></div></div></div><p>For a more complex example of a custom operator, let’s provide an alternative to the <code class="literal">averageByNullable</code> operator we used in <a class="xref" href="ch10.html#aggregating_data" title="Aggregating Data">Aggregating Data</a> to compute the average gross earnings for our films. The calculation resulted in the average being reported as <code class="literal">27251530.6</code> because the two null values were excluded from the sum but the divisor was still five. If you wanted to truly ignore the null values and divide the total by three, the <code class="literal">averageByNullable</code> operator wouldn’t help you, but you could define a custom operator like this:</p><a id="pro_id00548"/><pre class="programlisting">open System
open Microsoft.FSharp.Linq

type QueryBuilder with

  -- <span class="emphasis"><em>snip</em></span> --
  [&lt;CustomOperation("averageByNotNull")&gt;]
  member inline __.AverageByNotNull&lt; 'T, 'Q, 'Value
                      when 'Value :&gt; ValueType
                      and 'Value : struct
                      and 'Value : (new : unit -&gt; 'Value)
                      and 'Value : (static member op_Explicit : 'Value -&gt; float)&gt;
 (source : QuerySource&lt;'T, 'Q&gt;,
  [&lt;ProjectionParameter&gt;] selector : 'T -&gt; Nullable&lt;'Value&gt;) =
   source.Source
   |&gt; Seq.fold
       (fun (s, c) v -&gt; let i = v |&gt; selector
                        if i.HasValue then
                         (s + float i.Value, c + 1)
                        else (s, c))
       (0.0, 0)
   |&gt; (function
      | (_, 0) -&gt; Nullable&lt;float&gt;()
      | (sum, count) -&gt; Nullable(sum / float count))</pre><p><a id="iddle2055" class="indexterm"/><a id="iddle2057" class="indexterm"/>Notice that the <code class="literal">AverageByNotNull</code> method incorporates many of the same principles as <code class="literal">exactlyOneWhen</code> and <code class="literal">exactlyOneOrDefaultWhen</code>; that is, they each involve the <code class="literal">CustomOperation</code> and <code class="literal">ProjectionParameter</code> attributes. Where <code class="literal">AverageByNotNull</code> differs is that it’s defined as inline to ensure that the generic parameters can be resolved. Because they’re so similar, I’ve based the signature and generic constraints for <code class="literal">AverageByNotNull</code> largely upon that of the <code class="literal">averageByNullable</code> operator, although I’ve simplified it a bit for demonstration purposes.</p><p>Now that we’ve defined the <code class="literal">averageByNotNull</code> operator, we can include it in a query like this:</p><a id="pro_id00549"/><pre class="programlisting">query { for f in QuerySource.films do
        averageByNotNull f.gross }</pre><p>Invoking this query returns <code class="literal">45419217.67</code>, a stark contrast from <code class="literal">27251530.6</code> as returned by <code class="literal">averageByNullable</code>.</p></div></div></div><div class="sect1" title="Type Providers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="type_providers">Type Providers</h2></div></div></div><p>Along with query expressions, the other “killer feature” of F# 3.0 is type providers. <span class="emphasis"><em>Type providers</em></span> were developed to abstract away creation of the types, properties, and methods necessary to work with external data because this process is often tedious, error prone, and difficult to maintain.</p><p>Many type providers can be likened to traditional object-relational mapping (ORM) tools like NHibernate or Entity Framework, although their scope is potentially much greater. ORM tools typically require a great deal of configuration to be used effectively. Although there are tools that simplify this process for many of the more popular ORM technologies, they still require plenty of maintenance. ORM-like type providers aim to remove this overhead by automating type generation as part of the compilation process.</p><p>The other primary use for type providers is to simplify otherwise complex interfaces. Consider how cumbersome and error-prone something like matching strings with regular expressions can be. Regular expression syntax is confusing enough on its own, but getting named captures from the match collection requires using string keys to identify the values you’re <a id="iddle2056" class="indexterm"/>trying to access. A regular expression type provider can simplify the interface by generating types that correspond to the named captures in the regular expression.</p><p>Regardless of which need type providers satisfy, they all offer three primary benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Making data-centric exploratory programming more accessible by eliminating the need to manually create mappings and type definitions</p></li><li class="listitem"><p>Eliminating the administrative burden of manually maintaining mappings or other type definitions</p></li><li class="listitem"><p>Reducing the likelihood of errors caused by undetected changes to the underlying data structure</p></li></ul></div><p>A full discussion of type providers goes well beyond the scope of this book. Instead, this section is intended to introduce many of the type providers that are available to you either as part of the core F# distribution or through some popular third-party libraries. After you’ve seen what’s available, we’ll discuss how to initialize and use a few type providers to easily get the data you care about.</p><div class="sect2" title="Available Type Providers"><div class="titlepage"><div><div><h3 class="title" id="available_type_providers">Available Type Providers</h3></div></div></div><p>F# 3.0 includes several type providers out of the box. <a class="xref" href="ch10.html#built-in_type_providers" title="Table 10-2. Built-in Type Providers">Table 10-2</a> lists the built-in providers and a brief description of each.</p><div class="table"><a id="built-in_type_providers"/><div class="table-title">Table 10-2. Built-in Type Providers</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Provider</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Description</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">DbmlFile</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Provides the types that correspond to a SQL Server database as described in a Database Markup Language file (<span class="emphasis"><em>.dbml</em></span>)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">EdmxFile</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Provides the types that correspond to a database as described by a LINQ-to-Entities mapping file (<span class="emphasis"><em>.edmx</em></span>)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ODataService</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Provides the types that correspond to those returned by an OData service</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SqlDataProvider</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Provides the types that correspond to a SQL Server database</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SqlEntityProvider</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Provides the types that correspond to a database according to a LINQ-to-Entities mapping</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">WsdlService</code></p></td><td style="vertical-align: top; "><p>Provides the types that correspond to those returned by a WSDL-based web service</p></td></tr></tbody></table></div></div><p>The list of built-in type providers is pretty sparse and is focused on database or database-like sources. Even so, what’s provided covers a fairly large number of use cases. Should your data fall outside of the cases covered by the built-in types, you can define custom type providers, but doing so is outside the scope of this book.</p><p>Before you start down the path of building your own type providers, you should see if there are any third-party providers that will meet your needs. At the time of this writing, several popular libraries include a number of useful type providers, most notably: <code class="literal">FSharpx</code> and <code class="literal">FSharp.Data</code>. <a class="xref" href="ch10.html#some_available_third-party_type_provider" title="Table 10-3. Some Available Third-Party Type Providers">Table 10-3</a> lists several of the type providers in each library to give you an idea of what’s readily available and the diversity of uses for type providers. This list is not meant to be exhaustive; there are definitely other libraries available.</p><div class="table"><a id="some_available_third-party_type_provider"/><div class="table-title">Table 10-3. Some Available Third-Party Type Providers</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/><col class="c3"/><col class="c4"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Provider</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>FSharpx</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>FSharp.Data</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">AppSettingsProvider</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Provides types that correspond to the nodes in the AppSettings section of a configuration file</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><span class="inlinemediaobject"><a id="inline_id00001"/><img src="httpatomoreillycomsourcenostarchimages1981222.png.jpg" alt=""/></span></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">CsvProvider</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Provides types that allow for easy parsing of comma-separated value (CSV) files</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><span class="inlinemediaobject"><a id="inline_id00002"/><img src="httpatomoreillycomsourcenostarchimages1981222.png.jpg" alt=""/></span></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ExcelProvider</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Provides the types necessary for working with an Excel workbook</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><span class="inlinemediaobject"><a id="inline_id00003"/><img src="httpatomoreillycomsourcenostarchimages1981222.png.jpg" alt=""/></span></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">FileSystemProvider</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Provides the types necessary for working with the filesystem</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><span class="inlinemediaobject"><a id="inline_id00004"/><img src="httpatomoreillycomsourcenostarchimages1981222.png.jpg" alt=""/></span></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">JsonProvider</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Provides types that represent a JavaScript Object Notation (JSON) document</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><span class="inlinemediaobject"><a id="inline_id00005"/><img src="httpatomoreillycomsourcenostarchimages1981222.png.jpg" alt=""/></span></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RegexProvider</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Provides types that allow for inspecting regular expression matches</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><span class="inlinemediaobject"><a id="inline_id00006"/><img src="httpatomoreillycomsourcenostarchimages1981222.png.jpg" alt=""/></span></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">XamlProvider</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Provides types that allow for easy XAML parsing</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><span class="inlinemediaobject"><a id="inline_id00007"/><img src="httpatomoreillycomsourcenostarchimages1981222.png.jpg" alt=""/></span></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">XmlProvider</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>Provides types that represent an XML document</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="vertical-align: top; "><span class="inlinemediaobject"><a id="inline_id00008"/><img src="httpatomoreillycomsourcenostarchimages1981222.png.jpg" alt=""/></span></td></tr></tbody></table></div></div></div><div class="sect2" title="Using Type Providers"><div class="titlepage"><div><div><h3 class="title" id="using_type_providers">Using Type Providers</h3></div></div></div><p>Regardless of which type provider you need, initializing one always follows the same basic pattern:</p><a id="pro_id00550"/><pre class="programlisting">type <span class="emphasis"><em>name</em></span> = <span class="emphasis"><em>providerName</em></span>&lt;<span class="emphasis"><em>parameters</em></span>&gt;</pre><p>In the preceding syntax, <span class="emphasis"><em>name</em></span> is the name by which you’ll access the provider’s capabilities, <span class="emphasis"><em>providerName</em></span> identifies the provider type itself, and <span class="emphasis"><em>parameters</em></span> are the provider-specific arguments that control the provider’s behavior. Parameters will typically include things like a connection string or the path to the data source, but ultimately each type provider is responsible for defining the parameters it accepts.</p><p><a id="iddle2058" class="indexterm"/>The first time a provider is used within Visual Studio, you’ll be presented with a security dialog like the one pictured in <a class="xref" href="ch10.html#type_provider_security_dialog" title="Figure 10-1. Type Provider Security dialog">Figure 10-1</a>.</p><div class="figure"><a id="type_provider_security_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00015"/><img src="httpatomoreillycomsourcenostarchimages1981224.png.jpg" alt="Type Provider Security dialog"/></div></div><div class="figure-title">Figure 10-1. Type Provider Security dialog</div></div><p>As the dialog indicates, type providers can connect to remote data sources and execute custom code for build and IntelliSense features. Once you’ve enabled or disabled a type provider, you won’t be prompted again. If you want to change your selection at a later time, you can find a listing of type providers under F# Tools in the Visual Studio Options dialog.</p></div><div class="sect2" title="Example: Accessing an OData Service"><div class="titlepage"><div><div><h3 class="title" id="example_accessing_an_odata_service">Example: Accessing an OData Service</h3></div></div></div><p>This first example uses the <code class="literal">ODataService</code> type provider to query the publicly available Northwind sample OData service from <span class="emphasis"><em><a class="ulink" href="http://www.odata.org/" target="_top">http://www.odata.org/</a></em></span>. To start, we need to reference two assemblies:</p><a id="pro_id00551"/><pre class="programlisting">#r "System.Data.Services.Client"
#r "FSharp.Data.TypeProviders"</pre><p>The first assembly includes several Windows Communication Foundation (WCF) classes required by the <code class="literal">ODataService</code> provider. Though we don’t use the WCF types directly within this example, failure to add the reference will result in compilation errors. The second assembly contains the provider itself. With these assemblies referenced, we can now open the namespace that contains the <code class="literal">ODataService</code> provider:</p><a id="pro_id00552"/><pre class="programlisting">open Microsoft.FSharp.Data.TypeProviders</pre><p>Next, we include a type definition that references the appropriate type provider along with the address to the Northwind service:</p><a id="pro_id00553"/><pre class="programlisting">type northwind =
  ODataService&lt;"http://services.odata.org/V3/Northwind/Northwind.svc/"&gt;</pre><p>The <code class="literal">ODataService</code> provider takes the supplied address, appends <code class="literal">$metadata</code>, and then proceeds to construct and import the types described by the service. In order to do anything with the service, we need to obtain a data context via the provider type like this:</p><a id="pro_id00554"/><pre class="programlisting">let svc = northwind.GetDataContext()</pre><p>With the data context established, we now have everything we need to query the data. Here we’ll use a query expression to get some invoice information from the Northwind service.</p><a id="pro_id00555"/><pre class="programlisting">let invoices =
  query { for i in svc.Invoices do
          sortByNullableDescending i.ShippedDate
          select (i.OrderDate, i.CustomerName, i.ProductName)
          take 5 }</pre><p>There’s nothing out of the ordinary with the preceding query; it uses standard query operators to select <code class="literal">OrderDate</code>, <code class="literal">CustomerName</code>, and <code class="literal">ProductName</code> from the five most recently shipped invoices. What <span class="emphasis"><em>is</em></span> exceptional is that with no more effort than pointing the type provider at the OData service, we have a full type hierarchy that models the types exposed by the service.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note02"/>Note</h3><p><span class="emphasis"><em>Not all of the standard query operators are supported by every data source. For example, join is not supported by OData, so including it in a query with two OData sources will result in an error.</em></span></p></div><p>Although we’ve defined the <code class="literal">invoices</code> binding, the query execution is deferred until we actually enumerate the sequence. For simplicity, we can do so by piping the sequence to <code class="literal">Seq.iter</code>, which we’ll use to print each item like this:</p><a id="pro_id00556"/><pre class="programlisting">invoices |&gt; Seq.iter (printfn "%A")</pre><p>Invoking the preceding code printed the following items when I ran it, but your results may differ if the source data changes:</p><a id="pro_id00557"/><pre class="programlisting">(5/4/1998 12:00:00 AM, "Drachenblut Delikatessen", "Jack's New England Clam Chowder")
(4/30/1998 12:00:00 AM, "Hungry Owl All-Night Grocers", "Sasquatch Ale")
(4/30/1998 12:00:00 AM, "Hungry Owl All-Night Grocers", "Boston Crab Meat")
(4/30/1998 12:00:00 AM, "Hungry Owl All-Night Grocers", "Jack's New England Clam Chowder")
(5/4/1998 12:00:00 AM, "Tortuga Restaurante", "Chartreuse verte")</pre><p>So far, the <code class="literal">ODataService</code> provider has been a black box; as long as you give it a valid address, it usually just works and you don’t have to think about how. This is particularly great when you’re doing exploratory coding, but it can be frustrating when the provider isn’t returning what you expect. Fortunately, there are a couple of events you can subscribe to in order to gain some insight into what the provider is doing: <code class="literal">SendingRequest</code> and <code class="literal">ReadingEntity</code>.</p><p>The <code class="literal">SendingRequest</code> event occurs whenever the provider creates a new <code class="literal">HttpWebRequest</code>, whereas <code class="literal">ReadingEntity</code> occurs after data has been read into an entity. For the purposes of this discussion, we’ll focus on <code class="literal">SendingRequest</code> because it can show exactly what is being requested and help you refine your queries.</p><p>Probably the most helpful thing to do with <code class="literal">SendingRequest</code> is interrogate the <code class="literal">RequestUri</code> property of the <code class="literal">WebRequest</code> object that’s associated with the <code class="literal">SendingRequestEventArgs</code>. <code class="literal">RequestUri</code> includes the full address of the OData request, so once you have it, you can paste it into a browser (or other diagnostic utility such as Fiddler) and refine it. One easy way to get the URI is to simply print it to the console like this:</p><a id="pro_id00558"/><pre class="programlisting">svc.DataContext.SendingRequest.Add (fun args -&gt; printfn "%O" args.Request.RequestUri)</pre><p>So long as the preceding snippet is executed before the query is enumerated, the URI will be printed ahead of the results. In the case of the query described in this section, the printed URI is: <code class="literal">http://services.odata.org/V3/ Northwind/Northwind.svc/Invoices()?$orderby=ShippedDate%20desc&amp;$top=5&amp;$select= OrderDate, CustomerName, ProductName</code>.</p><p>For your convenience, the entire example from this section, including the subscription to <code class="literal">SendingRequest</code>, is reproduced in its entirety here:</p><a id="pro_id00559"/><pre class="programlisting">#r "System.Data.Services.Client"
#r "FSharp.Data.TypeProviders"

open Microsoft.FSharp.Data.TypeProviders

type northwind =
  ODataService&lt;"http://services.odata.org/V3/Northwind/Northwind.svc/"&gt;
let svc = northwind.GetDataContext()

let invoices =
  query { for i in svc.Invoices do
          sortByNullableDescending i.ShippedDate
          select (i.OrderDate, i.CustomerName, i.ProductName)
          take 5 }

svc.DataContext.SendingRequest.Add (fun args -&gt; printfn "%O" args.Request.RequestUri)
invoices |&gt; Seq.iter (printfn "%A")</pre></div><div class="sect2" title="Example: Parsing a String with RegexProvider"><div class="titlepage"><div><div><h3 class="title" id="example_parsing_a_string_with_regexprovi">Example: Parsing a String with RegexProvider</h3></div></div></div><p>For this example, we’ll look at how the <code class="literal">RegexProvider</code> from the FSharpx project can generate types that correspond to a regular expression, providing you with a remarkable degree of safety when working with matches. To use this provider, you’ll need to obtain the <code class="literal">FSharpx.TypeProviders.Regex</code> package from NuGet or download the source from GitHub (<span class="emphasis"><em><a class="ulink" href="https://github.com/fsharp/fsharpx/" target="_top">https://github.com/fsharp/fsharpx/</a></em></span>).</p><p>As with the <code class="literal">ODataProvider</code> example, we’ll start by referencing some assemblies and opening some namespaces:</p><a id="pro_id00560"/><pre class="programlisting">#r "System.Drawing"
#r @"..\packages\FSharpx.TypeProviders.Regex.1.8.41\lib\40\FSharpx.TypeProviders.Regex.dll"

open System
open System.Drawing</pre><p>Because I created this script as part of a project that included the <code class="literal">FSharp.TypeProviders.Regex</code> package from NuGet, I simply referenced the package directly via a relative path; the path to the assembly may be different on your machine depending on how you obtained the assembly and its version.</p><p>With the assemblies referenced and the common namespaces opened, we can now create the type provider. Creating a <code class="literal">RegexProvider</code> is similar to creating the <code class="literal">ODataService</code> except that, instead of a URI, <code class="literal">RegexProvider</code> takes a regular expression pattern. For this example, we’ll create the <code class="literal">RegexProvider</code> with a simple pattern that matches hexadecimal RGB values. (The space before the verbatim string is significant. Without the space, the compiler would try to interpret the string as a quoted expression, which is definitely not what we want.)</p><a id="pro_id00561"/><pre class="programlisting">type colorRegex =
  FSharpx.Regex&lt; @"^#(?&lt;Red&gt;[\dA-F]{2})(?&lt;Green&gt;[\dA-F]{2})(?&lt;Blue&gt;[\dA-F]{2})$"&gt;</pre><p>The <code class="literal">RegexProvider</code> works a bit differently than the <code class="literal">ODataService</code> in that it’s not really intended for use as a query source. Instead, we’ll write a function that uses the type provider to convert a hexadecimal string into a standard .NET <code class="literal">Color</code> instance if it matches the regular expression pattern.</p><a id="pro_id00562"/><pre class="programlisting">let convertToRgbColor color =
  let inline hexToDec hex = Convert.ToInt32(hex, 16)
  let m = color |&gt; ① colorRegex().Match
  if m.Success then
    Some (Color.FromArgb(② m.Red.Value |&gt; hexToDec,
                         ③ m.Green.Value |&gt; hexToDec,
                         ④ m.Blue.Value |&gt; hexToDec))
  else None</pre><p>In the preceding code, we push the supplied <code class="literal">color</code> string into the <code class="literal">Match</code> method of a new instance of the <code class="literal">colorRegex</code>①. The value returned by <code class="literal">Match</code> is similar to the <code class="literal">Match</code> object returned when we’re using regular expressions directly (through the <code class="literal">Regex</code> class in <code class="literal">System.Text.RegularExpressions</code>), but as you can see at ②, ③, and ④, it also includes named properties that match the named groups defined within the source regular expression! This means that you don’t have to fumble with magic strings to access the individual named captures!</p><p>To test this, we merely need to pass some strings to the <code class="literal">convertToRgbColor</code> function. Here we invoke the function for each string in a list:</p><a id="pro_id00563"/><pre class="programlisting">[ ""; "#FFFFFF"; "#000000"; "#B0C4DE" ]
|&gt; List.iter
  (convertToRgbColor &gt;&gt;
   (function
    | None -&gt; printfn "Not a color"
    | Some(c) -&gt; printfn "%O" c))</pre><p>Evaluating this code should result in the following:</p><a id="pro_id00564"/><pre class="programlisting">Not a color
Color [A=255, R=255, G=255, B=255]
Color [A=255, R=0, G=0, B=0]
Color [A=255, R=176, G=196, B=222]</pre><p>As you can see, the first string didn’t match the color pattern so it was not converted, whereas the remaining three items were converted and written accordingly.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00016">Summary</h2></div></div></div><p>With the addition of query expressions and type providers in F# 3.0, F# took massive strides toward being an even better language for data-intensive development work.</p><p>Query expressions bring the power of LINQ to the language with an idiomatic flair. With them, you can easily compose complex queries for analyzing and presenting data from a variety of data sources. Furthermore, the extensible nature of query expressions makes them well suited for more complex needs.</p><p>Type providers further expand upon F#’s already rich data experience by abstracting away the details of creating types that map to different data sources. They greatly improve a developer’s ability to perform exploratory programming in data-centric scenarios because the developer doesn’t need to be as concerned about how to access the data. Finally, type providers can add an extra degree of safety to the code by detecting changes to the underlying data structures as part of the build process.</p></div></section></body></html>