<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="57" id="Page_57"/>4</span><br/>
<span class="ChapterTitle">Error Handling</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<p class="ChapterIntro">For all but the simplest programs, you will have methods that can fail. In this chapter, we’ll look at different ways to represent, handle, and propagate those failures and the advantages and drawbacks of each. We’ll start by exploring different ways to represent errors, including enumeration and erasure, and then examine some special error cases that require a different representation technique. Next, we’ll look at various ways of handling errors and the future of error handling. </p>
<p>It’s worth noting that best practices for error handling in Rust are still an active topic of conversation, and at the time of writing, the ecosystem has not yet settled on a single, unified approach. This chapter will therefore focus on the underlying principles and techniques rather than recommending specific crates or patterns.</p>
<h2 id="h1-123456c01-0001"><span epub:type="pagebreak" title="58" id="Page_58"/>Representing Errors</h2>
<p class="BodyFirst">When you write code that can fail, the most important question to ask yourself is how your users will interact with any errors returned. Will users need to know exactly which error happened and the minutiae about what went wrong, or will they simply log that an error occurred and move on as best they can? To understand this, we have to look at whether the nature of the error is likely to affect what the caller does upon receiving it. This in turn will dictate how we represent different errors. </p>
<p>You have two main options for representing errors: enumeration and erasure. That is, you can either have your error type <em>enumerate</em> the possible error conditions so that the caller can distinguish them, or you can just provide the caller with a single, <em>opaque</em> error. Let’s discuss these two options in turn.</p>
<h3 id="h2-123456c01-0001">Enumeration</h3>
<p class="BodyFirst">For our example, we’ll use a library function that copies bytes from some input stream into some output stream, much like <code>std::io::copy</code>. The user provides you with two streams, one to read from and one to write to, and you copy the bytes from one to the other. During this process, it’s entirely possible for either stream to fail, at which point the copy has to stop and return an error to the user. Here, the user will likely want to know whether it was the input stream or the output stream that failed. For example, in a web server, if an error occurs on the input stream while streaming a file to a client, it might be because a disk was ejected, whereas if the output stream errors, maybe the client just disconnected. The latter may be an error the server should ignore, since copies to new connections can still complete, whereas the former may require that the whole server be shut down!</p>
<p>This is a case where we want to enumerate the errors. The user needs to be able to distinguish between the different error cases so that they can respond appropriately, so we use an <code>enum</code> named <code>CopyError</code>, with each variant representing a separate underlying cause for the error, like in <a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a>.</p>
<pre><code>pub enum CopyError {
  In(std::io::Error),
  Out(std::io::Error),
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: An enumerated error type</p>
<p>Each variant also includes the error that was encountered to provide the caller with as much information about went wrong as possible.</p>
<p>When making your own error type, you need to take a number of steps to make the error type play nicely with the rest of the Rust ecosystem. First, your error type should implement the <code>std::error::Error</code> trait, which provides callers with common methods for introspecting error types. The main method of interest is <code>Error::source</code>, which provides a mechanism to find the underlying cause of an error. This is most commonly used to print a backtrace that displays a trace all the way back to the error’s root cause. For our <code>CopyError</code> type, <span epub:type="pagebreak" title="59" id="Page_59"/>the implementation of <code>source</code> is straightforward: we match on <code>self</code> and extract and return the inner <code>std::io::Error</code>.</p>
<p>Second, your type should implement both <code>Display</code> and <code>Debug</code> so that callers can meaningfully print your error. This is required if you implement the <code>Error</code> trait. In general, your implementation of <code>Display</code> should give a one-line description of what went wrong that can easily be folded into other error messages. The display format should be lowercase and without trailing punctuation so that it fits nicely into other, larger error reports. <code>Debug</code> should provide a more descriptive error including auxiliary information that may be useful in tracking down the cause of the error, such as port numbers, request identifiers, filepaths, and the like, which <code>#[derive(Debug)]</code> is usually sufficient for.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	In older Rust code, you may see references to the <code>Error::description</code> method, but this has been deprecated in favor of <code>Display</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Third, your type should, if possible, implement both <code>Send</code> and <code>Sync</code> so that users are able to share the error across thread boundaries. If your error type is not thread-safe, you will find that it’s almost impossible to use your crate in a multithreaded context. Error types that implement <code>Send</code> and <code>Sync</code> are also much easier to use with the very common <code>std::io::Error</code> type, which is able to wrap errors that implement <code>Error</code>, <code>Send</code>, and <code>Sync</code>. Of course, not all error types can reasonably be <code>Send</code> and <code>Sync</code>, such as if they’re tied to particular thread-local resources, and that’s okay. You’re probably not sending those errors across thread boundaries either. However, it’s something to be aware of before you go placing <code>Rc&lt;String&gt;</code> and <code>RefCell&lt;bool&gt;</code> types in your errors.</p>
<p>Finally, where possible, your error type should be <code>'static</code>. The most immediate benefit of this is that it allows the caller to more easily propagate your error up the call stack without running into lifetime issues. It also enables your error type to be used more easily with type-erased error types, as we’ll see shortly.</p>
<h3 id="h2-123456c01-0002">Opaque Errors</h3>
<p class="BodyFirst">Now let’s consider a different example: an image decoding library. You give the library a bunch of bytes to decode, and it gives you access to various image manipulation methods. If the decoding fails, the user needs to be able to figure out how to resolve the issue, and so must understand the cause. But is it important whether the cause is the <code>size</code> field in the image header being invalid, or the compression algorithm failing to decompress a block? Probably not—the application can’t meaningfully recover from either situation, even if it knows the exact cause. In cases like this, you as the library author may instead want to provide a single, opaque error type. This also makes your library a little nicer to use, because there is only one error type in use everywhere. This error type should implement <code>Send</code>, <code>Debug</code>, <code>Display</code>, and <code>Error</code> (including the <code>source</code> method where appropriate), but beyond that, the caller doesn’t need to know anything more. You might internally represent more fine-grained error states, but there is no need to expose those to the users of the library. Doing so would only serve to unnecessarily increase the size and complexity of your API.</p>
<p><span epub:type="pagebreak" title="60" id="Page_60"/>Exactly what your opaque error type should be is mostly up to you. It could just be a type with all private fields that exposes only limited methods for displaying and introspecting the error, or it could be a severely type-erased error type like <code>Box&lt;dyn Error + Send + Sync + 'static&gt;</code>, which reveals nothing more than the fact that it is an error and does not generally let your users introspect at all. Deciding how opaque to make your error types is mostly a matter of whether there is anything interesting about the error beyond its description. With <code>Box&lt;dyn Error&gt;</code>, you leave your users with little option but to bubble up your error. That might be fine if it truly has no information of value to present to the user—for example, if it’s just a dynamic error message or is one of a large number of unrelated errors from deeper inside your program. But if the error has some interesting facets to it, such as a line number or a status code, you may want to expose that through a concrete but opaque type instead.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	In general, the community consensus is that errors should be rare and therefore should not add much cost to the “happy path.” For that reason, errors are often placed behind a pointer type, such as a <code>Box</code> or <code>Arc</code>. This way, they’re unlikely to add much to the size of the overall <code>Result</code> type they’re contained within.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>One benefit of using type-erased errors is that it allows you to easily combine errors from different sources without having to introduce additional error types. That is, type-erased errors often <em>compose</em> nicely, and allow you to express an open-ended set of errors. If you write a function whose return type is <code>Box&lt;dyn Error + ...&gt;</code>, then you can use <code>?</code> across different error types inside that function, on all sorts of different errors, and they will all be turned into that one common error type.</p>
<p>The <code>'static</code> bound on <code>Box&lt;dyn Error + Send + Sync + 'static&gt;</code> is worth spending a bit more time on in the context of erasure. I mentioned in the previous section that it’s useful for letting the caller propagate the error without worrying about the lifetime bounds of the method that failed, but it serves an even bigger purpose: access to downcasting. <em>Downcasting</em> is the process of taking an item of one type and casting it to a more specific type. This is one of the few cases where Rust gives you access to type information at runtime; it’s a limited case of the more general type reflection that dynamic languages often provide. In the context of errors, downcasting allows a user to turn a <code>dyn Error</code> into a concrete underlying error type when that <code>dyn Error</code> was originally of that type. For example, the user may want to take a particular action if the error they received was a <code>std::io::Error</code> of kind <code>std::io::ErrorKind::WouldBlock</code>, but they would not take that same action in any other case. If the user gets a <code>dyn Error</code>, they can use <code>Error::downcast_ref</code> to try to downcast the error into a <code>std::io::Error</code>. The <code>downcast_ref</code> method returns an <code>Option</code>, which tells the user whether or not the downcast succeeded. And here is the key observation: <code>downcast_ref</code> works only if the argument is <code>'static</code>. If we return an opaque <code>Error</code> that’s not <code>'static</code>, we take away the user’s ability to do this kind of error introspection should they wish.</p>
<p>There’s some disagreement in the ecosystem about whether a library’s type-erased errors (or more generally, its type-erased types) are part of <span epub:type="pagebreak" title="61" id="Page_61"/>its public and stable API. That is, if the method <code>foo</code> in your library returns <code>lib::MyError</code> as a <code>Box&lt;dyn Error&gt;</code>, would changing <code>foo</code> to return a different error type be a breaking change? The type signature hasn’t changed, but users may have written code that assumes that they can use <code>downcast</code> to turn that error back into <code>lib::MyError</code>. My opinion on this matter is that you chose to return <code>Box&lt;dyn Error&gt;</code> (and not <code>lib::MyError</code>) for a reason, and unless explicitly documented, that does not guarantee anything in particular about downcasting.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	While <code>Box&lt;dyn Error + ...&gt;</code> is an attractive type-erased error type, it counterintuitively does not itself implement <code>Error</code>. Therefore, consider adding your own <code>BoxError</code> type for type erasure in libraries that <em>does</em> implement <code>Error</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You may wonder how <code>Error::downcast_ref</code> can be safe. That is, how does it know whether a provided <code>dyn Error</code> argument is indeed of the given type <code>T</code>? The standard library even has a trait called <code>Any</code> that is implemented for <em>any</em> type, and which implements <code>downcast_ref</code> for <code>dyn Any</code>—how can that be okay? The answer lies in the compiler-supported type <code>std::any::TypeId</code>, which allows you to get a unique identifier for any type. The <code>Error</code> trait has a hidden provided method called <code>type_id</code>, whose default implementation is to return <code>TypeId::of::&lt;Self&gt;()</code>. Similarly, <code>Any</code> has a blanket implementation of <code>impl Any for T</code>, and in that implementation, its <code>type_id</code> returns the same. In the context of these <code>impl</code> blocks, the concrete type of <code>Self</code> is known, so this <code>type_id</code> is the type identifier of the real type. That provides all the information <code>downcast_ref</code> needs. <code>downcast_ref</code> calls <code>self.type_id</code>, which forwards through the vtable for dynamically sized types (see <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>) to the implementation for the underlying type and compares that to the type identifier of the provided downcast type. If they match, then the type behind the <code>dyn Error</code> or <code>dyn Any</code> really is <code>T</code>, and it is safe to cast from a reference to one to a reference to the other.</p>
<h3 id="h2-123456c01-0003">Special Error Cases</h3>
<p class="BodyFirst">Some functions are fallible but cannot return any meaningful error if they fail. Conceptually, these functions have a return type of <code>Result&lt;T, ()&gt;</code>. In some codebases, you may see this represented as <code>Option&lt;T&gt;</code> instead. While both are legitimate choices for the return type for such a function, they convey different semantic meanings, and you should usually avoid “simplifying” a <code>Result&lt;T, ()&gt;</code> to <code>Option&lt;T&gt;</code>. An <code>Err(())</code> indicates that an operation failed and should be retried, reported, or otherwise handled exceptionally. <code>None</code>, on the other hand, conveys only that the function has nothing to return; it is usually not considered an exceptional case or something that should be handled. You can see this in the <code>#[must_use]</code> annotation on the <code>Result</code> type—when you get a <code>Result</code>, the language expects that it is important to handle both cases, whereas with an <code>Option</code>, neither case actually needs to be handled.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="62" id="Page_62"/><h2><span class="NoteHead">Note</span></h2>
<p>	You should also keep in mind that <code>()</code> does not implement the <code>Error</code> trait. This means that it cannot be type-erased into <code>Box&lt;dyn Error&gt;</code> and can be a bit of a pain to use with <code>?</code>. For this reason, it is often better to define your own unit struct type, implement <code>Error</code> for it, and use that as the error instead of <code>()</code> in these cases.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Some functions, like those that start a continuously running server loop, only ever return errors; unless an error occurs, they run forever. Other functions never error but need to return a <code>Result</code> nonetheless, for example, to match a trait signature. For functions like these, Rust provides the <em>never type</em>, written with the <code>!</code> syntax. The never type represents a value that can never be generated. You cannot construct an instance of this type yourself—the only way to make one is by entering an infinite loop or panicking, or through a handful of other special operations that the compiler knows never return. With <code>Result</code>, when you have an <code>Ok</code> or <code>Err</code> that you know will never be used, you can set it to the <code>!</code> type. If you write a function that returns <code>Result&lt;T, !&gt;</code>, you will be unable to ever return <code>Err</code>, since the only way to do so is to enter code that will never return. Because the compiler knows that any variant with a <code>!</code> will never be produced, it can also optimize your code with that in mind, such as by not generating the panic code for an <code>unwrap</code> on <code>Result&lt;T, !&gt;</code>. And when you pattern match, the compiler knows that any variant that contains a <code>!</code> does not even need to be listed. Pretty neat!</p>
<p>One last curious error case is the error type <code>std::thread::Result</code>. Here’s its definition:</p>
<pre><code>type Result&lt;T&gt; = Result&lt;T, Box&lt;dyn Any + Send + 'static&gt;&gt;;</code></pre>
<p>The error type is type-erased, but it’s not erased into a <code>dyn Error</code> as we’ve seen so far. Instead, it is a <code>dyn Any</code>, which guarantees only that the error is <em>some</em> type, and nothing more . . . which is not much of a guarantee at all. The reason for this curious-looking error type is that the error variant of <code>std::thread::Result</code> is produced only in response to a panic; specifically, if you try to join a thread that has panicked. In that case, it’s not clear that there’s much the joining thread can do other than either ignore the error or panic itself using <code>unwrap</code>. In essence, the error type is “a panic” and the value is “whatever argument was passed to <code>panic!</code>,” which can truly be any type (even though it’s usually a formatted string).</p>
<h2 id="h1-123456c01-0002">Propagating Errors</h2>
<p class="BodyFirst">Rust’s <code>?</code> operator acts as a shorthand for <em>unwrap or return early</em>, for working easily with errors. But it also has a few other tricks up its sleeve that are worth knowing about. First, <code>?</code> performs type conversion through the <code>From</code> trait. In a function that returns <code>Result&lt;T, E&gt;</code>, you can use <code>?</code> on any <code>Result&lt;T, X&gt;</code> where <code>E: From&lt;X&gt;</code>. This is the feature that makes error erasure through <code>Box&lt;dyn Error&gt;</code> so appealing; you can just use <code>?</code> everywhere and not worry about the particular error type, and it will usually “just work.”</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="63" id="Page_63"/>From and Into</h2>
<p>The standard library has many conversion traits, but two of the core ones are <code>From</code> and <code>Into</code>. It might strike you as odd to have two: if we have <code>From</code>, why do we need <code>Into</code>, and vice versa? There are a couple of reasons, but let’s start with the historical one: it wouldn’t have been possible to have just one in the early days of Rust due to the coherence rules discussed in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. Or, more specifically, what the coherence rules used to be.</p>
<p>Suppose you want to implement two-way conversion between some local type you have defined in your crate and some type in the standard library. You can write <code>impl&lt;T&gt; From&lt;Vec&lt;T&gt;&gt; for MyType&lt;T&gt;</code> and <code>impl&lt;T&gt; Into&lt;Vec&lt;T&gt;&gt; for MyType&lt;T&gt;</code> easily enough, but if you only had <code>From</code> <em>or</em> <code>Into</code>, you would have to write <code>impl&lt;T&gt; From&lt;MyType&lt;T&gt;&gt; for Vec&lt;T&gt;</code> or <code>impl&lt;T&gt; Into&lt;MyType&lt;T&gt;&gt; for Vec&lt;T&gt;</code>. However, the compiler used to reject those implementations! Only since Rust 1.41.0, when the exception for covered types was added to the coherence rules, are they legal. Before that change, it was necessary to have both traits. And since much Rust code was written before Rust 1.41.0, neither trait can be removed now.</p>
<p>Beyond that historical fact, however, there are also good ergonomic reasons to have both of these traits, even if we could start from scratch today. It is often significantly easier to use one or the other in different situations. For example, if you’re writing a method that takes a type that can be turned into a <code>Foo</code>, would you rather write <code>fn(impl Into&lt;Foo&gt;)</code> or <code>fn&lt;T&gt;(T) where Foo: From&lt;T&gt;</code>? And conversely, to turn a string into a syntax identifier, would you rather write <code>Ident::from("foo")</code> or <code>&lt;_ as Into&lt;Ident&gt;&gt;::into("foo")</code>? Both of these traits have their uses, and we’re better off having them both.</p>
<p>Given that we do have both, you may wonder which you should use in your code today. The answer, it turns out, is pretty simple: implement <code>From</code>, and use <code>Into</code> in bounds. The reason is that <code>Into</code> has a blanket implementation for any <code>T</code> that implements <code>From</code>, so regardless of whether a type explicitly implements <code>From</code> or <code>Into</code>, it implements <code>Into</code>!</p>
<p>Of course, as simple things frequently go, the story doesn’t quite end there. Since the compiler often has to “go through” the blanket implementation when <code>Into</code> is used as a bound, the reasoning for whether a type implements <code>Into</code> is more complicated than whether it implements <code>From</code>. And in some cases, the compiler is not quite smart enough to figure that puzzle out. For this reason, the <code>?</code> operator at the time of writing uses <code>From</code>, not <code>Into</code>. Most of the time that doesn’t make a difference, because most types implement <code>From</code>, but it does mean that error types from old libraries that implement <code>Into</code> instead may not work with <code>?</code>. As the compiler gets smarter, <code>?</code> will likely be “upgraded” to use <code>Into</code>, at which point that problem will go away, but it's what we have for now.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p class="BodyFirst"><span epub:type="pagebreak" title="64" id="Page_64"/>The second aspect of <code>?</code> to be aware of is that this operator is really just syntax sugar for a trait tentatively called <code>Try</code>. At the time of writing, the <code>Try</code> trait has not yet been stabilized, but by the time you read this, it’s likely that it, or something very similar, will have been settled on. Since the details haven’t all been figured out yet, I’ll give you only an outline of how <code>Try</code> works, rather than the full method signatures. At its heart, <code>Try</code> defines a wrapper type whose state is either one where further computation is useful (the happy path), or one where it is not. Some of you will correctly think of monads, though we won’t explore that connection here. For example, in the case of <code>Result&lt;T, E&gt;</code>, if you have an <code>Ok(t)</code>, you can continue on the happy path by unwrapping the <code>t</code>. If you have an <code>Err(e)</code>, on the other hand, you want to stop executing and produce the error value immediately, since further computation is not possible as you don’t have the <code>t</code>. </p>
<p>What’s interesting about <code>Try</code> is that it applies to more types than just <code>Result</code>. An <code>Option&lt;T&gt;</code>, for example, follows the same pattern—if you have a <code>Some(t)</code>, you can continue on the happy path, whereas if you have a <code>None</code>, you want to yield <code>None</code> instead of continuing. This pattern extends to more complex types, like <code>Poll&lt;Result&lt;T, E&gt;&gt;</code>, whose happy path type is <code>Poll&lt;T&gt;</code>, which makes <code>?</code> apply in far more cases than you might expect. When <code>Try</code> stabilizes, we may see <code>?</code> start to work with all sorts of types to make our happy path code nicer.</p>
The <p><code>?</code> operator is already usable in fallible functions, in doctests, and in <code>fn main</code>. To reach its full potential, though, we also need a way to scope this error handling. For example, consider the function in <a href="#listing4-2" id="listinganchor4-2">Listing 4-2</a>.</p>
<pre><code>fn do_the_thing() -&gt; Result&lt;(), Error&gt; {
  let thing = Thing::setup()?;
<span class="LiteralGray">  // .. code that uses thing and ? ..</span>
  thing.cleanup();
  Ok(())
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-2">Listing 4-2</a>: A multi-step fallible function using the <code>?</code> operator</p>
<p>This won’t quite work as expected. Any <code>?</code> between <code>setup</code> and <code>cleanup</code> will cause an early return from the entire function, which would skip the cleanup code! This is the problem <em>try blocks</em> are intended to solve. A try block acts pretty much like a single-iteration loop, where <code>?</code> uses <code>break</code> instead of <code>return</code>, and the final expression of the block has an implicit <code>break</code>. We can now fix the code in <a href="#listing4-2">Listing 4-2</a> to always do cleanup, as shown in <a href="#listing4-3" id="listinganchor4-3">Listing 4-3</a>.</p>
<pre><code>fn do_the_thing() -&gt; Result&lt;(), Error&gt; {
  let thing = Thing::setup()?;
  let r = try {
<span class="LiteralGray">    // .. code that uses thing and ? ..</span>
  };
  thing.cleanup();
  r
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-3">Listing 4-3</a>: A multi-step fallible function that always cleans up after itself</p>
<p><span epub:type="pagebreak" title="65" id="Page_65"/>Try blocks are also not stable at the time of writing, but there is enough of a consensus on their usefulness that they’re likely to land in a form similar to that described here.</p>
<h2 id="h1-123456c01-0003">Summary</h2>
<p class="BodyFirst">This chapter covered the two primary ways to construct error types in Rust: enumeration and erasure. We looked at when you may want to use each one and the advantages and drawbacks of each. We also took a look at some of the behind-the-scenes aspects of the <code>?</code> operator and considered how <code>?</code> may become even more useful going forward. In the next chapter, we’ll take a step back from the code and look at how you <em>structure</em> a Rust project. We’ll look at feature flags, dependency management, and versioning as well as how to manage more complex crates using workspaces and subcrates. See you on the next page!</p>
</section>
</div></body></html>