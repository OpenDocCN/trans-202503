- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IDENTIFYING ATTACK CAMPAIGNS USING MALWARE NETWORKS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Malware network analysis* can turn malware datasets into valuable threat intelligence,
    revealing adversarial attack campaigns, common malware tactics, and sources of
    malware samples. This approach consists of analyzing the ways in which groups
    of malware samples are connected by their shared attributes, whether those are
    embedded IP addresses, hostnames, strings of printable characters, graphics, or
    similar.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Figure 4-1](ch04.xhtml#ch04fig1) shows an example of the power
    of malware network analysis in a chart that took only seconds to generate with
    the techniques you’ll learn in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0036-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Nation-state malware''s social network connections revealed via
    shared attribute analysis*'
  prefs: []
  type: TYPE_NORMAL
- en: The figure displays a group of nation state–grade malware samples (represented
    as oval-shaped nodes) and their “social” interconnections (the lines connecting
    the nodes). The connections are based on the fact that these samples “call back”
    to the same hostnames and IP addresses, indicating they were deployed by the same
    attackers. As you’ll learn in this chapter, you can use these connections to help
    differentiate between a coordinated attack on your organization and a disparate
    array of criminally motivated attackers.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of the chapter you will have learned:'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals of network analysis theory as it relates to extracting threat
    intelligence from malware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways to use visualizations to identify relationships between malware samples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create, visualize, and extract intelligence from malware networks using
    Python and various open source toolkits for data analysis and visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to tie all this knowledge together to reveal and analyze attack campaigns
    within real-world malware datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nodes and Edges**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you can perform shared attribute analysis on malware, you need to understand
    some basics about networks. *Networks* are collections of connected objects (called
    *nodes*). The connections between these nodes are referred to as *edges*. As abstract
    mathematical objects, the nodes in a network can represent pretty much anything,
    as can their edges. What we care about for our purposes is the structure of the
    interconnections between these nodes and edges, as this can reveal telling details
    about malware.
  prefs: []
  type: TYPE_NORMAL
- en: When using networks to analyze malware, we can treat each individual malware
    file as the definition of a node, and we can treat relationships of interest (such
    as shared code or network behavior) as the definition of an edge. Similar malware
    files share edges and thus cluster together when we apply force-directed networks
    (you will see exactly how this works later). Alternatively, we can treat both
    malware samples and attributes as nodes unto themselves. For example, callback
    IP addresses have nodes, and so do malware samples. Whenever malware samples call
    back to a particular IP address, they are connected to that IP address node.
  prefs: []
  type: TYPE_NORMAL
- en: Networks of malware can be more complex than simply a set of nodes and edges.
    Specifically, they can have *attributes* attached to either nodes or edges, such
    as the percentage of code that two connected samples share. One common edge attribute
    is a *weight*, with greater weights indicating stronger connections between samples.
    Nodes may have their own attributes, such as the file size of the malware samples
    they represent, but these are typically referred to only as attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bipartite Networks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *bipartite network* is one whose nodes can be divided into two partitions
    (groups), where neither partition contains internal connections. Networks of this
    type can be used to show shared attributes between malware samples.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-2](ch04.xhtml#ch04fig2) shows an example of a bipartite network in
    which malware sample nodes go in the bottom partition, and domain names the samples
    “call back” to (in order to communicate with the attacker) go in the other partition.
    Note that callbacks never connect directly to other callbacks, and malware samples
    never connect directly to other malware samples, as is characteristic of a bipartite
    network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, even such a simple visualization reveals an important piece
    of intelligence: based on the malware samples’ shared callback servers, we can
    guess that *sample_014* was probably deployed by the same attacker as *sample_37D*.
    We can also guess that *sample_37D* and *sample_F7F* probably share the same attacker,
    and that *sample_014* and *sample_F7F* probably share the same attacker, because
    they’re connected by sample *sample_37D* (and indeed, the samples shown in [Figure
    4-2](ch04.xhtml#ch04fig2) all come from the same “APT1” Chinese attacker group).'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’d like to thank Mandiant and Mila Parkour for curating the APT1 samples
    and making them available to the research community.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0038-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: A bipartite network. The nodes on top (the attributed partition)
    are callback domain names. The nodes on the bottom (malware partition) are malware
    samples.*'
  prefs: []
  type: TYPE_NORMAL
- en: As the number of nodes and connections in our network grow very large, we might
    want to see just how the malware samples are related, without having to closely
    inspect all the attribute connections. We can examine malware sample similarity
    by creating a bipartite network *projection*, which is a simpler version of a
    bipartite network in which we link nodes in one partition of the network if they
    have nodes in the other partition (the *attribute* partition) in common. For example,
    in the case of the malware samples shown in [Figure 4-1](ch04.xhtml#ch04fig1),
    we’d be creating a network in which malware samples are linked if they share callback
    domain names.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-3](ch04.xhtml#ch04fig3) shows the projected network of the shared-callback
    servers of the entire Chinese APT1 dataset referred to previously.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0038-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: A projection of malware samples from the APT1 dataset, showing
    connections between malware samples only if they share at least one server. The
    two big clusters were used in two different attack campaigns.*'
  prefs: []
  type: TYPE_NORMAL
- en: The nodes here are malware samples, and they are linked if they share at least
    one callback server. By showing connections between malware samples only if they
    share callback servers, we can begin to see the overall “social network” of these
    malware samples. As you can see in [Figure 4-3](ch04.xhtml#ch04fig3), two large
    groupings exist (the large square cluster in the left-center area and the circular
    cluster in the top-right area), which upon further inspection turn out to correspond
    to two different campaigns carried out over the APT1 group’s 10-year history.
  prefs: []
  type: TYPE_NORMAL
- en: '**Visualizing Malware Networks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you perform shared attribute analysis of malware using networks, you’ll find
    that you rely heavily on network visualization software to create the networks
    like the ones shown thus far. This section introduces how these network visualizations
    can be created from an algorithmic perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Crucially, the major challenge in doing network visualization is *network layout*,
    which is the process of deciding where to render each node in a network within
    a two- or three-dimensional coordinate space, depending on whether you want your
    visualization to be two- or three-dimensional. When you’re placing nodes on a
    network, the ideal way is to place them in the coordinate space such that their
    visual distance from one another is proportional to the shortest-path distance
    between them in the network. In other words, nodes that are two hops away from
    one another might be about two inches away from one another, and nodes that are
    three hops away might be about three inches apart. Doing this allows us to visualize
    clusters of similar nodes accurately to their actual relationship. As you’ll see
    in the next section, however, this is often difficult to achieve, especially when
    you’re working with more than three nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Distortion Problem***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As it turns out, it’s often impossible to solve this network layout problem
    perfectly. [Figure 4-4](ch04.xhtml#ch04fig4) illustrates this difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in these simple networks, all nodes are connected to all other
    nodes by edges of equal weights of 1\. The ideal layout for these connections
    would place all nodes equidistant from one another on the page. But as you can
    see, as we create networks of four and then five nodes, as in (c) and (d), we
    start to introduce progressively more distortion due to edges of unequal length.
    Unfortunately, we can only minimize, not eliminate this distortion, and that minimization
    becomes one of the major goals of network visualization algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0040-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: Perfect network layout is usually impossible on real-world malware
    networks. Simple cases like (a) and (b) allow us to lay out all nodes equidistantly.
    However, (c) adds distortion (the edges are no longer all equal length), and (d)
    shows even more distortion.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Force-Directed Algorithms***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To best minimize layout distortion, computer scientists often use *force-directed*
    layout algorithms. Force-directed algorithms are based on physical simulations
    of spring-like forces as well as magnetism. Simulating network edges as physical
    springs often leads to good node positioning, because the simulated springs push
    and pull to try to achieve uniform length between nodes and edges. To better visualize
    this concept, consider how a spring works: when you compress or stretch the spring,
    it “tries” to get back to its length at equilibrium. These properties correlate
    well with our desire to have all the edges of our network be equal length. Force-directed
    algorithms are what we focus on in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building Networks with NetworkX**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of malware networks, you’re ready to
    learn how to create networks of malware relationships using the open source NetworkX
    Python network analysis library and the GraphViz open source network visualization
    toolkit. I show you how to programmatically extract malware-related data and then
    use this data to build, visualize, and analyze networks to represent malware datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with NetworkX, which is an open source project maintained by a team
    centered at Los Alamos National Laboratory and Python’s de facto network-processing
    library (recall that you can install the library dependencies in this chapter,
    including NetworkX, by entering this chapter’s code and data directory and the
    command `pip install -r requirements.txt`). If you know Python, you should find
    NetworkX to be surprisingly easy. Use the code in [Listing 4-1](ch04.xhtml#ch04list1)
    to import NetworkX and instantiate a network.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-1: Instantiating a network*'
  prefs: []
  type: TYPE_NORMAL
- en: This code uses just one function call to the NetworkX `Graph` constructor to
    create a network in NetworkX.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The NetworkX library uses the term* graph *in place of* network *sometimes,
    as the two terms are synonymous in computer science—they both indicate a set of
    nodes connected by edges.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Nodes and Edges**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve instantiated a network, let’s add some nodes. A node in a NetworkX
    network can be any Python object. Here I show you how to add nodes of various
    types to our network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, we’ve added five nodes to our network: `"hello"`, `"world"`, `1`,
    `2`, and `3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to add edges, we call `add_edge()`, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re connecting some of these five nodes via edges. For example, the
    first line of code ➊ connects the `"hello"` and `"world"` nodes together by creating
    an edge between them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Attributes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NetworkX allows us to easily attach attributes to both nodes and edges. To
    attach an attribute to a node (and to access that attribute later), you can add
    the attribute as a keyword argument when you add the node to the network, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To add an attribute later, access the network’s `node` dictionary using the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to access the node, access the `node` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As with nodes, you can add attributes to edges using keyword arguments when
    you add the edges initially, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can add attributes to edges once they’ve been added to a network
    by using the `edge` dictionary, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `edge` dictionary is magical in that it allows you to access node attributes
    the other way around, without having to worry about which node you refer to first,
    as shown in [Listing 4-2](ch04.xhtml#ch04list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-2: Using the* edge *dictionary to access node attributes regardless
    of order*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the first line sets `myattribute` on an edge connecting `node1`
    and `node2` ➊, and the second line accesses `myattribute` despite the `node1`
    and `node2` references being flipped ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '***Saving Networks to Disk***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To visualize our networks, we need to save them to disk from NetworkX in .*dot*
    format—a format commonly used in the network analysis world that can be imported
    into many network visualization toolkits. To save a network in .*dot* format,
    simply call the NetworkX `write_dot()` function, as shown in [Listing 4-3](ch04.xhtml#ch04list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-3: Using* write_dot() *to save networks to disk*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, at the end of the code, we use the `write_dot()` function to
    specify the network we want to save ➊ as well as the path or filename we want
    to save it to ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Visualization with GraphViz**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have written a network to disk using the `write_dot()` NetworkX function,
    we can visualize the resulting file using GraphViz. GraphViz is the best available
    command line package for visualizing your networks. It’s supported by researchers
    at AT&T and has become a standard part of the network analysis toolbox used by
    data analysts. It contains a host of command line network layout tools that can
    be used to both lay out and render networks. GraphViz comes pre-installed on the
    virtual machine provided with this book and can also be downloaded at *[https://graphviz.gitlab.io/download/](https://graphviz.gitlab.io/download/)*.
    Each GraphViz command line tool ingests networks expressed in *.dot* format and
    can be invoked using the following syntax to render a network as a *.png* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fdp` force-directed graph renderer is one GraphViz network visualization
    tool. It uses the same basic command line interface as every other GraphViz tool,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specify that we want to use the `fdp` tool and name the network *.dot*
    file we want to lay out, which is *apt1callback.dot*, found in the *~/ch3/* directory
    of the data accompanying this book. We specify `–T png` to indicate the format
    (PNG) we wish to use. Finally, we specify where we want the output file to be
    saved using `-o` `apt1callback.png`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Parameters to Adjust Networks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The GraphViz tools include many parameters you can use to adjust the way your
    networks are drawn. Many of these parameters are set using the `–G` command-line
    flag in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Two particularly useful parameters are `overlap` and `splines`. Set `overlap`
    to `false` to tell GraphViz not to allow any nodes to overlap one another. Use
    the `splines` parameter to tell GraphViz to draw curved rather than straight lines
    to make it easier to follow the edges on your networks. The following are some
    ways to set the `overlap` and `splines` parameters in GraphViz.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following to prevent nodes from overlapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw edges as curved lines (splines) to improve network readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw edges as curved lines (splines) to improve network readability, and don’t
    allow nodes to visually overlap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we simply list one parameter after the other: -Gsplines=true –Goverlap=false
    (the ordering doesn’t matter), followed by -T png -o <outputfile.png>.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I go over some of the most useful GraphViz tools (in addition
    to `fdp`).
  prefs: []
  type: TYPE_NORMAL
- en: '***The GraphViz Command Line Tools***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here are some of the available GraphViz tools I have found most useful, as well
    as some sense of when it is appropriate to use each tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**fdp**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We used the `fdp` layout tool in the previous example, which we used to create
    a force-directed layout, as described in “[Force-Directed Algorithms](ch04.xhtml#lev54)”
    on [page 40](ch04.xhtml#page_40). When you’re creating malware networks with fewer
    than 500 nodes, `fdp` does a good job of revealing network structure in a reasonable
    amount of time. But when you’re working with more than 500 nodes, and especially
    when connectivity between nodes is complex, you’ll find that `fdp` slows down
    fairly rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try out `fdp` on the APT1 shared callback server network shown in [Figure
    4-3](ch04.xhtml#ch04fig3), enter the following from the *ch4* directory of the
    data accompanying this book (you must have GraphViz installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a *.png* file (fdp_servers.png) that shows a network
    like the one displayed in [Figure 4-5](ch04.xhtml#ch04fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0045-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: Layout of the APT1 samples using the* fdp *tool*'
  prefs: []
  type: TYPE_NORMAL
- en: The `fdp` layout makes a number of themes apparent in the figure. First, two
    big clusters of samples are highly interrelated, as clearly seen in the upper-right
    and lower-left areas of the figure. Second, a number of pairs of samples are related,
    which can be seen in the lower right. Finally, many samples show no apparent relationship
    with one another and aren’t connected to any other nodes. It’s important to recall
    that this visualization is based on shared callback server relationships between
    nodes. It’s possible that the unconnected samples are related to other samples
    in the figure by way of other kinds of relationships, such as shared code relationships—relationships
    we’ll explore in [Chapter 5](ch05.xhtml#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: '**sfdp**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `sfdp` tool uses roughly the same approach to layout as `fdp`, but it scales
    better because it creates a hierarchy of simplifications, known as *coarsenings*,
    where nodes are merged into *supernodes* based on their proximity. After it completes
    its coarsenings, the `sfdp` tool lays out the merged versions of the graph that
    have far fewer nodes and edges, which dramatically speeds up the layout process.
    In this way, `sfdp` is able to perform fewer computations to find the best positions
    in the network. As a result, `sfdp` can lay out tens of thousands of nodes on
    a typical laptop, making it by far the best algorithm for laying out very large
    networks of malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'This scalability comes at a cost, however: `sfdp` produces layouts that are
    sometimes less clear than layouts of the same-sized networks in `fdp`. For example,
    compare [Figure 4-6](ch04.xhtml#ch04fig6), which I created using `sfdp`, to the
    network created with `fdp`, shown in [Figure 4-5](ch04.xhtml#ch04fig5).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0046-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Layout of the APT1 samples'' shared callback server network using
    the* sfdp *command*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there’s slightly more noise over each cluster in [Figure 4-6](ch04.xhtml#ch04fig6),
    making it slightly harder to see what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this network, enter the *ch4* directory of the data accompanying
    this book and then enter the following code to produce the *sfdp_servers.png*
    image file shown in [Figure 4-6](ch04.xhtml#ch04fig6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note how the first item in this code specifies that we’re using the tool `sfdp`,
    as opposed to `fdp` from before. Everything else is the same, save the output
    filename.
  prefs: []
  type: TYPE_NORMAL
- en: '**neato**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `neato` tool is the GraphViz implementation of a different force-directed
    network layout algorithm that creates simulated springs between all nodes (including
    unconnected nodes) to help push things to ideal positions, but at the cost of
    additional computation. It’s hard to know when `neato` will produce the best layout
    for a given network: my recommendation is that you try it, in conjunction with
    `fdp`, and see which layout you like more. [Figure 4-7](ch04.xhtml#ch04fig7) shows
    what the `neato` layout looks like on the APT1 shared callback server network.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0047-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: Layout of the APT1 shared callback server network using the* neato
    *layout*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, in this case `neato` produces a similar network layout to those
    produced by `fdp` and `sfdp`. For some datasets, however, you’ll find that `neato`
    produces a better or worse layout—you just have to try it with your dataset and
    see. To try out `neato`, enter the following from the *ch4* directory of the data
    accompanying this book; this should produce the *neato_servers.png* network image
    file shown in [Figure 4-7](ch04.xhtml#ch04fig7):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To create this network, we simply revise the code we used to create [Figure
    4-6](ch04.xhtml#ch04fig6) to specify that we want to use the tool `neato` and
    then save the *.png* to *neato_servers.png*. Now that you know how to create these
    network visualizations, let’s look at ways to improve them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Visual Attributes to Nodes and Edges***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Beyond deciding on your general network layout, it can be useful to be able
    to specify how individual nodes and edges are to be rendered. For example, you
    might want to set edge thickness based on the strength of the connection between
    two nodes, or set node color based on what compromise each malware sample node
    is associated with, which would allow you to better visualize clusters of malware.
    NetworkX and GraphViz make it easy to do this by allowing you to specify visual
    attributes of nodes and edges simply by assigning values to a set of attributes.
    I discuss only a few such attributes in the sections that follow, but this topic
    is deep enough to fill an entire book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Edge Width**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To set the width of the border that GraphViz draws around nodes, or the line
    that it draws for edges, you can set the `penwidth` attribute of nodes and edges
    to a number of your choice, as shown in [Listing 4-4](ch04.xhtml#ch04list4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-4: Setting the* penwidth *attribute*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I create a simple network ➊ with two nodes connected by an edge, and I
    set the `penwidth` attribute of the edge to 10 ➋ (the default value is 1).
  prefs: []
  type: TYPE_NORMAL
- en: Run this code, and you should see an image that looks like [Figure 4-8](ch04.xhtml#ch04fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0048-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: A simple network with an edge that has a* penwidth *of 10*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 4-8](ch04.xhtml#ch04fig8), a `penwidth` of 10 results
    in a very thick edge. The width of the edge (or, the thickness of the node’s border
    if you set the `penwidth` of a node) scales proportionally with the value of the
    `penwidth` attribute, so choose accordingly. For example, if your edge strength
    values vary from 1 to 1000, but you want to be able to see all the edges, you
    might want to consider assigning `penwidth` attributes based on log scaling of
    your edge strength values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Node and Edge Color**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To set the color of a node’s border or an edge, use the `color` attribute. [Listing
    4-5](ch04.xhtml#ch04list5) shows how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-5: Setting node and edge colors*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I create the same simple network I created in [Listing 4-4](ch04.xhtml#ch04list4),
    with two nodes and an edge connecting them. For each node that I create, I set
    its `color` value (➊ and ➋). I also set the `color` value for the edge ➌ when
    I create it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-9](ch04.xhtml#ch04fig9) shows the result of [Listing 4-5](ch04.xhtml#ch04list5).
    As expected, you should see that the first node (the edge) and the second node
    each have a unique color. For a complete list of colors you can use, refer to
    *[http://www.graphviz.org/doc/info/colors.html](http://www.graphviz.org/doc/info/colors.html)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0049-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: A simple network that demonstrates how to set node and edge colors*'
  prefs: []
  type: TYPE_NORMAL
- en: Colors can be used to show different classes of nodes and edges.
  prefs: []
  type: TYPE_NORMAL
- en: '**Node Shape**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To set the shape of a node, use the `shape` attribute with a string specifying
    a shape, as defined at *[http://www.GraphViz.org/doc/info/shapes.html](http://www.GraphViz.org/doc/info/shapes.html)*.
    Commonly used values are `box`, `ellipse`, `circle`, `egg`, `diamond`, `triangle`,
    `pentagon`, and `hexagon`. [Listing 4-6](ch04.xhtml#ch04list6) shows how to set
    the `shape` attribute of a node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-6: Setting node shapes*'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the way we set a node’s color, we simply use the `shape` keyword
    argument in the `add_node()` function to specify the shape we want each node to
    take. Here, we set the first node to a diamond shape ➊ and the second node to
    an egg shape ➋. The result of this code is shown in [Figure 4-10](ch04.xhtml#ch04fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0050-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: A simple network that shows how we can set node shape*'
  prefs: []
  type: TYPE_NORMAL
- en: The results, showing a diamond-shaped node and an egg-shaped node, reflect the
    shapes that we specified in [Listing 4-6](ch04.xhtml#ch04list6).
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Labels**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, GraphViz also allows you to add labels to nodes and edges with the
    `label` attribute. Although nodes are automatically labeled based on their assigned
    ID (for example, the label for a node added as *123* would be `123`), you can
    specify labels using `label=<`my label attribute`>`. Unlike nodes, edges aren’t
    labeled by default, but you can assign them labels using the `label` attribute.
    [Listing 4-7](ch04.xhtml#ch04list7) shows how to create our now familiar two-node
    network but with `label` attributes attached to both nodes and the connecting
    edge.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-7: Labeling nodes and edges*'
  prefs: []
  type: TYPE_NORMAL
- en: We label the nodes `first node` ➊ and `second node` ➋, respectively. We also
    label the edge connecting them as the `link between first and second node` ➌.
    [Figure 4-11](ch04.xhtml#ch04fig11) shows the graphical output we expect.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0051-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: A simple network that shows how we can label nodes and edges*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to manipulate basic attributes of nodes and edges, you’re
    ready to start building networks from the ground up.
  prefs: []
  type: TYPE_NORMAL
- en: '**Building Malware Networks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll begin our discussion of building malware networks by reproducing and expanding
    on the shared callback server example shown in [Figure 4-1](ch04.xhtml#ch04fig1),
    and then examine shared image analysis of malware.
  prefs: []
  type: TYPE_NORMAL
- en: The following program extracts callback domain names from malware files and
    then builds a bipartite network of malware samples. Next, it performs one projection
    of the network to show which malware samples share common callback servers, and
    it performs another projection to show which callback servers are called by common
    malware samples. Finally, the program saves the three networks—the original bipartite
    network, the malware sample projection, and the callback server projection—as
    files so that they can be visualized with GraphViz.
  prefs: []
  type: TYPE_NORMAL
- en: I walk you through the program, piece by piece. The complete code can be found
    in the data accompanying this book at the file path *ch4/callback_server_network.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-8](ch04.xhtml#ch04list8) shows how to get started by importing the
    requisite modules.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-8: Importing modules*'
  prefs: []
  type: TYPE_NORMAL
- en: Of the requisite modules we imported, the most notable are the `pefile` PE parsing
    module ➊, which we use to parse the target PE binaries, and the `networkx` library
    ➋, which we use to create the malware attribute network.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we parse the command line arguments by adding the code in [Listing 4-9](ch04.xhtml#ch04list9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-9: Parsing command line arguments*'
  prefs: []
  type: TYPE_NORMAL
- en: These arguments include `target_path` ➊ (the path to the directory where the
    malware we’re analyzing is), `output_file` ➋ (the path where we write the complete
    network), `malware_projection` ➌ (the path where we write a reduced version of
    the graph and show which malware samples share attributes), and `resource_projection`
    ➍ (the path where we write a reduced version of the graph and show which attributes
    are seen together within the malware samples).
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to get into the core of the program. [Listing 4-10](ch04.xhtml#ch04list10)
    shows the code for creating a network for the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-10: Creating the network*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create a fresh network by calling the `networkx.Graph()` constructor
    ➊. Then we define the function `find_hostnames()`, which extracts hostnames from
    strings ➋. Don’t worry too much about the mechanics of this function: it’s essentially
    a regular expression and some string-filtering code that tries its best to identify
    domains.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate through all the files in the target directory, checking whether
    they are PE files by seeing if the `pefile.PE` class is able to load them (if
    not, we do not analyze the files). Finally, we extract hostname attributes from
    the current file by first extracting all printable strings from the file ➌ and
    then searching the strings for embedded hostname resources ➍. If we find any,
    we add them as nodes in our network and then add edges from the node for the current
    malware sample to the hostname resource nodes ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to wrap up the program, as shown in [Listing 4-11](ch04.xhtml#ch04list11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-11: Writing networks to files*'
  prefs: []
  type: TYPE_NORMAL
- en: We start by writing our network to disk at the location specified in the command
    line arguments ➊. Then we create the two reduced networks (the “projections” introduced
    earlier in this chapter) that show the malware relationships and the hostname
    resource relationships. We do this by first creating a Python set for containing
    the IDs of the malware nodes ➋ and another Python set for the IDs of the resource
    nodes ➌. We then use the NetworkX-specific `projected_graph()` function ➍ to get
    projections for the malware and resource sets, and we write these networks to
    disk at the specified locations ➎.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! You can use this program on any of the malware datasets in this
    book to see malware relationships between the shared hostname resources embedded
    in the files. You can even use it on your own datasets to see what threat intelligence
    you can glean through this mode of analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Shared Image Relationship Network**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to analyzing malware based on their shared callback servers, we
    can also analyze them based on their use of shared icons and other graphical assets.
    For example, [Figure 4-12](ch04.xhtml#ch04fig12) shows a portion of the shared
    image analysis results for the Trojans found in *ch4/data/Trojans*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0055-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: A visualization of the shared image asset network for a number
    of Trojans*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that all these Trojan horses pose as archive files and use the same
    archive file icon (shown in the center of the figure), even though they’re executables.
    The fact that they use exactly the same image as part of their effort to game
    the user indicates that they probably come from the same attacker. I confirmed
    this by running the malware samples through the Kaspersky antivirus engine, which
    assigns them all the same family name (ArchSMS).
  prefs: []
  type: TYPE_NORMAL
- en: Next, I show you how to produce the kind of visualization shown in [Figure 4-12](ch04.xhtml#ch04fig12),
    in order to see shared-image relationships between malware samples. To extract
    the images from the malware, we use the helper library `images`, which in turn
    relies on `wrestool` (discussed in [Chapter 1](ch01.xhtml#ch01)) to create the
    *image_network.py* program. Recall that `wrestool` extracts images from Windows
    executables.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the process of creating a shared image network, starting
    with the first part of the code, shown in [Listing 4-12](ch04.xhtml#ch04list12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-12: Parsing the initial argument and file-loading code in our shared
    image network program*'
  prefs: []
  type: TYPE_NORMAL
- en: The program starts out much like the hostname graph program (starting at [Listing
    4-8](ch04.xhtml#ch04list8)) we just discussed. It first imports a number of modules,
    including `pefile` and `networkx`. Here, however, we also define the `ExtractImages`
    helper class ➊, which we use to extract graphical assets from target malware samples.
    Then the program enters a loop in which we iterate over all the target malware
    binaries ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are in our loop, it’s time to extract graphical assets from the
    target malware binaries using the `ExtractImages` class (which under the hood
    is a wrapper around the `icoutils` programs discussed in [Chapter 1](ch01.xhtml#ch01)).
    [Listing 4-13](ch04.xhtml#ch04list13) shows the part of the code that does this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-13: Extracting graphical assets from target malware*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we pass in a path to a target malware binary to the `ExtractImages` class
    ➊, and then we call the resulting instance’s `work()` method ➋. This results in
    the `ExtractImages` class creating a temporary directory in which it stores the
    malware images, and then storing a dictionary containing data about each image
    in the `images` class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the list of extracted images from `ExtractImages`, we iterate
    over it ➌, creating a new network node for an image if we haven’t seen its hash
    before ➍, and linking the currently processed malware sample to the image in the
    network ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our network of malware samples linked to the images
    that they contain, we are ready to write the graph to disk, as shown in [Listing
    4-14](ch04.xhtml#ch04list14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-14: Writing the graph to disk*'
  prefs: []
  type: TYPE_NORMAL
- en: We do this in exactly the same way that we did in [Listing 4-11](ch04.xhtml#ch04list11).
    First, we write the complete network to disk ➊, and then we write the two projections
    (the projection for the malware and the projection for the images, which we refer
    to as *resources* here) to disk ➋.
  prefs: []
  type: TYPE_NORMAL
- en: You can use *image_network.py* to analyze graphical assets in any of the malware
    datasets in this book, or to extract intelligence from malware datasets of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about the tools and methods necessary to perform
    shared attribute analysis on your own malware datasets. Specifically, you learned
    how networks, bipartite networks, and bipartite network projections can help identify
    the social connections between malware samples, why network layout is central
    to network visualization, and how force-directed networks work. You also learned
    how to create and visualize malware networks using Python and open source tools
    like NetworkX. In [Chapter 5](ch05.xhtml#ch05), you’ll learn how to build malware
    networks based on shared code relationships between samples.
  prefs: []
  type: TYPE_NORMAL
