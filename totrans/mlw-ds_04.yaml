- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**IDENTIFYING ATTACK CAMPAIGNS USING MALWARE NETWORKS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用恶意软件网络识别攻击活动**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: '*Malware network analysis* can turn malware datasets into valuable threat intelligence,
    revealing adversarial attack campaigns, common malware tactics, and sources of
    malware samples. This approach consists of analyzing the ways in which groups
    of malware samples are connected by their shared attributes, whether those are
    embedded IP addresses, hostnames, strings of printable characters, graphics, or
    similar.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*恶意软件网络分析*可以将恶意软件数据集转化为有价值的威胁情报，揭示对抗性攻击活动、常见的恶意软件战术以及恶意软件样本的来源。此方法包括分析一组恶意软件样本如何通过其共享属性相互连接，无论这些属性是嵌入的IP地址、主机名、可打印字符字符串、图像还是类似的内容。'
- en: For example, [Figure 4-1](ch04.xhtml#ch04fig1) shows an example of the power
    of malware network analysis in a chart that took only seconds to generate with
    the techniques you’ll learn in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图4-1](ch04.xhtml#ch04fig1)展示了恶意软件网络分析的威力，这是通过本章将要介绍的技术在几秒钟内生成的图表示例。
- en: '![image](../images/f0036-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0036-01.jpg)'
- en: '*Figure 4-1: Nation-state malware''s social network connections revealed via
    shared attribute analysis*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-1：通过共享属性分析揭示的国家级恶意软件的社交网络连接*'
- en: The figure displays a group of nation state–grade malware samples (represented
    as oval-shaped nodes) and their “social” interconnections (the lines connecting
    the nodes). The connections are based on the fact that these samples “call back”
    to the same hostnames and IP addresses, indicating they were deployed by the same
    attackers. As you’ll learn in this chapter, you can use these connections to help
    differentiate between a coordinated attack on your organization and a disparate
    array of criminally motivated attackers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图中展示了一组国家级恶意软件样本（以椭圆形节点表示）及其“社交”关联（连接节点的线）。这些连接基于恶意软件样本“回连”到相同的主机名和IP地址，表明它们是由同一攻击者部署的。正如本章将要介绍的，你可以利用这些连接来帮助区分是针对你组织的协调攻击，还是来自多个犯罪动机攻击者的分散攻击。
- en: 'By the end of the chapter you will have learned:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学到：
- en: The fundamentals of network analysis theory as it relates to extracting threat
    intelligence from malware
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络分析理论的基础，及其在从恶意软件中提取威胁情报方面的应用
- en: Ways to use visualizations to identify relationships between malware samples
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用可视化技术识别恶意软件样本之间的关系
- en: How to create, visualize, and extract intelligence from malware networks using
    Python and various open source toolkits for data analysis and visualization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python和各种开源数据分析与可视化工具包来创建、可视化和提取恶意软件网络中的情报
- en: How to tie all this knowledge together to reveal and analyze attack campaigns
    within real-world malware datasets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将所有这些知识结合起来，以揭示和分析现实世界恶意软件数据集中的攻击活动
- en: '**Nodes and Edges**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**节点和边**'
- en: Before you can perform shared attribute analysis on malware, you need to understand
    some basics about networks. *Networks* are collections of connected objects (called
    *nodes*). The connections between these nodes are referred to as *edges*. As abstract
    mathematical objects, the nodes in a network can represent pretty much anything,
    as can their edges. What we care about for our purposes is the structure of the
    interconnections between these nodes and edges, as this can reveal telling details
    about malware.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在对恶意软件进行共享属性分析之前，你需要理解一些关于网络的基础知识。*网络*是由相互连接的对象（称为*节点*）组成的集合。这些节点之间的连接被称为*边*。作为抽象的数学对象，网络中的节点可以代表几乎任何东西，它们的边也是如此。对于我们的目的来说，我们关心的是这些节点和边之间连接的结构，因为这可以揭示关于恶意软件的重要细节。
- en: When using networks to analyze malware, we can treat each individual malware
    file as the definition of a node, and we can treat relationships of interest (such
    as shared code or network behavior) as the definition of an edge. Similar malware
    files share edges and thus cluster together when we apply force-directed networks
    (you will see exactly how this works later). Alternatively, we can treat both
    malware samples and attributes as nodes unto themselves. For example, callback
    IP addresses have nodes, and so do malware samples. Whenever malware samples call
    back to a particular IP address, they are connected to that IP address node.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用网络分析恶意软件时，我们可以将每个独立的恶意软件文件视为一个节点的定义，将感兴趣的关系（例如共享代码或网络行为）视为边的定义。类似的恶意软件文件共享边，因此当我们应用力导向网络时，它们会聚集在一起（你将很快看到这一点是如何运作的）。或者，我们可以将恶意软件样本和属性都视为独立的节点。例如，回调IP地址也有节点，恶意软件样本同样有节点。每当恶意软件样本回调到某个特定的IP地址时，它们就会与该IP地址节点连接。
- en: Networks of malware can be more complex than simply a set of nodes and edges.
    Specifically, they can have *attributes* attached to either nodes or edges, such
    as the percentage of code that two connected samples share. One common edge attribute
    is a *weight*, with greater weights indicating stronger connections between samples.
    Nodes may have their own attributes, such as the file size of the malware samples
    they represent, but these are typically referred to only as attributes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件的网络可能比仅仅是节点和边的集合更复杂。具体来说，它们可以在节点或边上附加*属性*，例如两个连接样本共享的代码百分比。一个常见的边属性是*权重*，较大的权重表示样本之间的连接更强。节点可能有自己的属性，比如它们代表的恶意软件样本的文件大小，但这些通常仅被称为属性。
- en: '**Bipartite Networks**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二分网络**'
- en: A *bipartite network* is one whose nodes can be divided into two partitions
    (groups), where neither partition contains internal connections. Networks of this
    type can be used to show shared attributes between malware samples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*二分网络*是指其节点可以分为两个分区（组），且两个分区内没有内部连接的网络。这种类型的网络可用于显示恶意软件样本之间共享的属性。'
- en: '[Figure 4-2](ch04.xhtml#ch04fig2) shows an example of a bipartite network in
    which malware sample nodes go in the bottom partition, and domain names the samples
    “call back” to (in order to communicate with the attacker) go in the other partition.
    Note that callbacks never connect directly to other callbacks, and malware samples
    never connect directly to other malware samples, as is characteristic of a bipartite
    network.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](ch04.xhtml#ch04fig2)展示了一个二分网络的示例，其中恶意软件样本节点位于底部分区，样本“回调”的域名（用于与攻击者通信）位于另一个分区。请注意，回调节点从不直接连接到其他回调节点，恶意软件样本也从不直接连接到其他恶意软件样本，这是二分网络的特征。'
- en: 'As you can see, even such a simple visualization reveals an important piece
    of intelligence: based on the malware samples’ shared callback servers, we can
    guess that *sample_014* was probably deployed by the same attacker as *sample_37D*.
    We can also guess that *sample_37D* and *sample_F7F* probably share the same attacker,
    and that *sample_014* and *sample_F7F* probably share the same attacker, because
    they’re connected by sample *sample_37D* (and indeed, the samples shown in [Figure
    4-2](ch04.xhtml#ch04fig2) all come from the same “APT1” Chinese attacker group).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，即使是如此简单的可视化也揭示了一个重要的信息：基于恶意软件样本共享的回调服务器，我们可以猜测*sample_014*可能是与*sample_37D*由同一攻击者部署的。我们还可以猜测*sample_37D*和*sample_F7F*可能是由同一攻击者部署的，*sample_014*和*sample_F7F*也可能是由同一攻击者部署的，因为它们通过*sample_37D*连接（事实上，[图
    4-2](ch04.xhtml#ch04fig2)中的所有样本都来自同一个“APT1”中国攻击者组）。
- en: '**NOTE**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’d like to thank Mandiant and Mila Parkour for curating the APT1 samples
    and making them available to the research community.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们要感谢Mandiant和Mila Parkour整理了APT1样本，并将其提供给研究社区。*'
- en: '![image](../images/f0038-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0038-01.jpg)'
- en: '*Figure 4-2: A bipartite network. The nodes on top (the attributed partition)
    are callback domain names. The nodes on the bottom (malware partition) are malware
    samples.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：一个二分网络。顶部的节点（属性分区）是回调域名。底部的节点（恶意软件分区）是恶意软件样本。*'
- en: As the number of nodes and connections in our network grow very large, we might
    want to see just how the malware samples are related, without having to closely
    inspect all the attribute connections. We can examine malware sample similarity
    by creating a bipartite network *projection*, which is a simpler version of a
    bipartite network in which we link nodes in one partition of the network if they
    have nodes in the other partition (the *attribute* partition) in common. For example,
    in the case of the malware samples shown in [Figure 4-1](ch04.xhtml#ch04fig1),
    we’d be creating a network in which malware samples are linked if they share callback
    domain names.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网络中节点和连接的数量急剧增大，我们可能希望查看恶意软件样本之间的关系，而不必仔细检查所有属性连接。我们可以通过创建一个二分网络*投影*来检查恶意软件样本的相似性，这是一种简化版本的二分网络，其中如果网络一方的节点与另一方（*属性*）有共同的节点，它们就会相互连接。例如，在[图
    4-1](ch04.xhtml#ch04fig1)所示的恶意软件样本中，我们将创建一个网络，其中恶意软件样本如果共享回调域名就会被连接。
- en: '[Figure 4-3](ch04.xhtml#ch04fig3) shows the projected network of the shared-callback
    servers of the entire Chinese APT1 dataset referred to previously.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-3](ch04.xhtml#ch04fig3)展示了先前提到的整个中国APT1数据集的共享回调服务器投影网络。'
- en: '![image](../images/f0038-02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0038-02.jpg)'
- en: '*Figure 4-3: A projection of malware samples from the APT1 dataset, showing
    connections between malware samples only if they share at least one server. The
    two big clusters were used in two different attack campaigns.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：APT1数据集的恶意软件样本投影，仅在恶意软件样本共享至少一个服务器时显示它们之间的连接。两个大群集用于两次不同的攻击活动。*'
- en: The nodes here are malware samples, and they are linked if they share at least
    one callback server. By showing connections between malware samples only if they
    share callback servers, we can begin to see the overall “social network” of these
    malware samples. As you can see in [Figure 4-3](ch04.xhtml#ch04fig3), two large
    groupings exist (the large square cluster in the left-center area and the circular
    cluster in the top-right area), which upon further inspection turn out to correspond
    to two different campaigns carried out over the APT1 group’s 10-year history.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的节点是恶意软件样本，它们之间存在链接，如果它们共享至少一个回调服务器。通过仅在恶意软件样本共享回调服务器时显示它们之间的连接，我们可以开始看到这些恶意软件样本的整体“社交网络”。正如在[图
    4-3](ch04.xhtml#ch04fig3)中所看到的，存在两个大的群体（位于左中心区域的大方形群集和位于右上角的圆形群集），进一步检查后发现，它们分别对应APT1小组10年历史中的两个不同攻击活动。
- en: '**Visualizing Malware Networks**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**恶意软件网络的可视化**'
- en: As you perform shared attribute analysis of malware using networks, you’ll find
    that you rely heavily on network visualization software to create the networks
    like the ones shown thus far. This section introduces how these network visualizations
    can be created from an algorithmic perspective.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用网络进行恶意软件共享属性分析时，你会发现你很大程度上依赖于网络可视化软件来创建像目前所展示的这些网络。本节介绍了如何从算法的角度创建这些网络可视化。
- en: Crucially, the major challenge in doing network visualization is *network layout*,
    which is the process of deciding where to render each node in a network within
    a two- or three-dimensional coordinate space, depending on whether you want your
    visualization to be two- or three-dimensional. When you’re placing nodes on a
    network, the ideal way is to place them in the coordinate space such that their
    visual distance from one another is proportional to the shortest-path distance
    between them in the network. In other words, nodes that are two hops away from
    one another might be about two inches away from one another, and nodes that are
    three hops away might be about three inches apart. Doing this allows us to visualize
    clusters of similar nodes accurately to their actual relationship. As you’ll see
    in the next section, however, this is often difficult to achieve, especially when
    you’re working with more than three nodes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，进行网络可视化时的主要挑战是*网络布局*，即决定在二维或三维坐标空间中渲染每个节点的位置，具体取决于你希望你的可视化是二维的还是三维的。当你在网络中放置节点时，理想的方式是将它们放置在坐标空间中，使得它们之间的视觉距离与它们在网络中之间的最短路径距离成比例。换句话说，相隔两跳的节点可能相隔约两英寸，而相隔三跳的节点可能相隔约三英寸。这样做使得我们能够准确地根据节点的实际关系来可视化相似节点的群集。然而，正如你将在下一节中看到的那样，这往往是很难实现的，特别是当你处理的节点超过三个时。
- en: '***The Distortion Problem***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***扭曲问题***'
- en: As it turns out, it’s often impossible to solve this network layout problem
    perfectly. [Figure 4-4](ch04.xhtml#ch04fig4) illustrates this difficulty.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，通常不可能完美解决这个网络布局问题。[图 4-4](ch04.xhtml#ch04fig4) 说明了这一困难。
- en: As you can see in these simple networks, all nodes are connected to all other
    nodes by edges of equal weights of 1\. The ideal layout for these connections
    would place all nodes equidistant from one another on the page. But as you can
    see, as we create networks of four and then five nodes, as in (c) and (d), we
    start to introduce progressively more distortion due to edges of unequal length.
    Unfortunately, we can only minimize, not eliminate this distortion, and that minimization
    becomes one of the major goals of network visualization algorithms.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这些简单的网络中，所有节点都通过相等权重为 1 的边连接到其他所有节点。对于这些连接，理想的布局是将所有节点均匀分布在页面上。但是，正如你所看到的，当我们创建四个或五个节点的网络时，如图
    (c) 和 (d) 所示，由于边缘长度不等，我们开始引入更多的失真。不幸的是，我们只能最小化，而不能消除这种失真，而这种最小化成为网络可视化算法的主要目标之一。
- en: '![image](../images/f0040-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0040-01.jpg)'
- en: '*Figure 4-4: Perfect network layout is usually impossible on real-world malware
    networks. Simple cases like (a) and (b) allow us to lay out all nodes equidistantly.
    However, (c) adds distortion (the edges are no longer all equal length), and (d)
    shows even more distortion.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：在现实世界的恶意软件网络中，完美的网络布局通常是不可行的。像 (a) 和 (b) 这样的简单情况允许我们将所有节点均匀分布。然而，(c)
    引入了失真（边缘不再是等长的），而 (d) 则显示了更多的失真。*'
- en: '***Force-Directed Algorithms***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***力导向算法***'
- en: 'To best minimize layout distortion, computer scientists often use *force-directed*
    layout algorithms. Force-directed algorithms are based on physical simulations
    of spring-like forces as well as magnetism. Simulating network edges as physical
    springs often leads to good node positioning, because the simulated springs push
    and pull to try to achieve uniform length between nodes and edges. To better visualize
    this concept, consider how a spring works: when you compress or stretch the spring,
    it “tries” to get back to its length at equilibrium. These properties correlate
    well with our desire to have all the edges of our network be equal length. Force-directed
    algorithms are what we focus on in this chapter.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽量减少布局失真，计算机科学家通常使用 *力导向* 布局算法。力导向算法基于物理模拟的弹簧力和磁力。将网络的边缘模拟为物理弹簧，通常能得到较好的节点位置，因为模拟的弹簧通过推拉作用，试图使节点和边缘之间的长度均匀。为了更好地理解这一概念，考虑弹簧的工作原理：当你压缩或拉伸弹簧时，它会“试图”恢复到其平衡长度。这些特性与我们希望网络中所有边缘长度相等的目标非常吻合。力导向算法是我们在本章重点讨论的内容。
- en: '**Building Networks with NetworkX**'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 NetworkX 构建网络**'
- en: Now that you have a basic understanding of malware networks, you’re ready to
    learn how to create networks of malware relationships using the open source NetworkX
    Python network analysis library and the GraphViz open source network visualization
    toolkit. I show you how to programmatically extract malware-related data and then
    use this data to build, visualize, and analyze networks to represent malware datasets.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对恶意软件网络有了基本了解，准备好学习如何使用开源的 NetworkX Python 网络分析库和 GraphViz 开源网络可视化工具包来创建恶意软件关系网络。我将向你展示如何通过编程提取与恶意软件相关的数据，然后使用这些数据构建、可视化并分析网络，以表示恶意软件数据集。
- en: Let’s begin with NetworkX, which is an open source project maintained by a team
    centered at Los Alamos National Laboratory and Python’s de facto network-processing
    library (recall that you can install the library dependencies in this chapter,
    including NetworkX, by entering this chapter’s code and data directory and the
    command `pip install -r requirements.txt`). If you know Python, you should find
    NetworkX to be surprisingly easy. Use the code in [Listing 4-1](ch04.xhtml#ch04list1)
    to import NetworkX and instantiate a network.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 NetworkX 开始，它是一个开源项目，由位于洛斯阿拉莫斯国家实验室的团队维护，并且是 Python 的事实上的网络处理库（回想一下，你可以通过进入本章的代码和数据目录并运行
    `pip install -r requirements.txt` 来安装本章中的库依赖项，包括 NetworkX）。如果你了解 Python，应该会觉得
    NetworkX 出奇的容易。使用 [清单 4-1](ch04.xhtml#ch04list1) 中的代码来导入 NetworkX 并实例化一个网络。
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: Instantiating a network*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：实例化网络*'
- en: This code uses just one function call to the NetworkX `Graph` constructor to
    create a network in NetworkX.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只需要调用一次 NetworkX 中的 `Graph` 构造函数，就能在 NetworkX 中创建一个网络。
- en: '**NOTE**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The NetworkX library uses the term* graph *in place of* network *sometimes,
    as the two terms are synonymous in computer science—they both indicate a set of
    nodes connected by edges.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*NetworkX库有时使用* graph *这个术语来代替* network *，因为这两个术语在计算机科学中是同义的——它们都表示一组通过边连接的节点。*'
- en: '**Adding Nodes and Edges**'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加节点和边**'
- en: 'Now that we’ve instantiated a network, let’s add some nodes. A node in a NetworkX
    network can be any Python object. Here I show you how to add nodes of various
    types to our network:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实例化了一个网络，接下来让我们添加一些节点。NetworkX中的节点可以是任何Python对象。在这里，我展示了如何向我们的网络添加不同类型的节点：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As shown, we’ve added five nodes to our network: `"hello"`, `"world"`, `1`,
    `2`, and `3`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们已经向网络中添加了五个节点：`"hello"`、`"world"`、`1`、`2`和`3`。
- en: 'Then, to add edges, we call `add_edge()`, as shown next:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要添加边，我们调用`add_edge()`，如下所示：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we’re connecting some of these five nodes via edges. For example, the
    first line of code ➊ connects the `"hello"` and `"world"` nodes together by creating
    an edge between them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过边连接了这五个节点中的一些。例如，第一行代码➊通过在它们之间创建一条边，将`"hello"`节点和`"world"`节点连接在一起。
- en: '***Adding Attributes***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加属性***'
- en: 'NetworkX allows us to easily attach attributes to both nodes and edges. To
    attach an attribute to a node (and to access that attribute later), you can add
    the attribute as a keyword argument when you add the node to the network, like
    this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX允许我们轻松地为节点和边附加属性。要将属性附加到节点（并在以后访问该属性），你可以在将节点添加到网络时，通过关键字参数添加属性，如下所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To add an attribute later, access the network’s `node` dictionary using the
    following syntax:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要稍后添加属性，可以使用以下语法访问网络的`node`字典：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, to access the node, access the `node` dictionary:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要访问节点，可以访问`node`字典：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As with nodes, you can add attributes to edges using keyword arguments when
    you add the edges initially, as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与节点一样，你可以在初始添加边时，通过关键字参数向边添加属性，如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, you can add attributes to edges once they’ve been added to a network
    by using the `edge` dictionary, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以通过使用`edge`字典，向已添加到网络中的边添加属性，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `edge` dictionary is magical in that it allows you to access node attributes
    the other way around, without having to worry about which node you refer to first,
    as shown in [Listing 4-2](ch04.xhtml#ch04list2).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`edge`字典非常神奇，它允许你反向访问节点属性，无需担心首先引用哪个节点，如在[列表 4-2](ch04.xhtml#ch04list2)中所示。'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 4-2: Using the* edge *dictionary to access node attributes regardless
    of order*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-2：使用* edge *字典反向访问节点属性，不管顺序如何*'
- en: As you can see, the first line sets `myattribute` on an edge connecting `node1`
    and `node2` ➊, and the second line accesses `myattribute` despite the `node1`
    and `node2` references being flipped ➋.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一行在连接`node1`和`node2`的边上设置了`myattribute`➊，第二行则访问了`myattribute`，尽管`node1`和`node2`的引用顺序被调换了➋。
- en: '***Saving Networks to Disk***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将网络保存到磁盘***'
- en: To visualize our networks, we need to save them to disk from NetworkX in .*dot*
    format—a format commonly used in the network analysis world that can be imported
    into many network visualization toolkits. To save a network in .*dot* format,
    simply call the NetworkX `write_dot()` function, as shown in [Listing 4-3](ch04.xhtml#ch04list3).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化我们的网络，我们需要将它们以.*dot*格式从NetworkX保存到磁盘——这是网络分析领域常用的一种格式，可以导入到许多网络可视化工具包中。要将网络保存为.*dot*格式，只需调用NetworkX的`write_dot()`函数，如在[列表
    4-3](ch04.xhtml#ch04list3)中所示。
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 4-3: Using* write_dot() *to save networks to disk*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-3：使用* write_dot() *将网络保存到磁盘*'
- en: As you can see, at the end of the code, we use the `write_dot()` function to
    specify the network we want to save ➊ as well as the path or filename we want
    to save it to ➋.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在代码的最后，我们使用`write_dot()`函数指定了我们要保存的网络➊，以及我们希望保存的路径或文件名➋。
- en: '**Network Visualization with GraphViz**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络可视化与GraphViz**'
- en: 'Once we have written a network to disk using the `write_dot()` NetworkX function,
    we can visualize the resulting file using GraphViz. GraphViz is the best available
    command line package for visualizing your networks. It’s supported by researchers
    at AT&T and has become a standard part of the network analysis toolbox used by
    data analysts. It contains a host of command line network layout tools that can
    be used to both lay out and render networks. GraphViz comes pre-installed on the
    virtual machine provided with this book and can also be downloaded at *[https://graphviz.gitlab.io/download/](https://graphviz.gitlab.io/download/)*.
    Each GraphViz command line tool ingests networks expressed in *.dot* format and
    can be invoked using the following syntax to render a network as a *.png* file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 `write_dot()` NetworkX 函数将网络写入磁盘，我们就可以使用 GraphViz 可视化生成的文件。GraphViz 是目前可用的最佳命令行网络可视化工具。它由
    AT&T 的研究人员支持，并且已经成为数据分析师网络分析工具箱中的标准部分。它包含一组命令行网络布局工具，既可以用于布局，也可以用于渲染网络。GraphViz
    已预装在本书提供的虚拟机中，也可以在 *[https://graphviz.gitlab.io/download/](https://graphviz.gitlab.io/download/)*
    上下载。每个 GraphViz 命令行工具都以 *.dot* 格式读取网络，并可以使用以下语法调用来将网络渲染为 *.png* 文件：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `fdp` force-directed graph renderer is one GraphViz network visualization
    tool. It uses the same basic command line interface as every other GraphViz tool,
    as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdp` 是一个 GraphViz 网络可视化工具，采用与其他所有 GraphViz 工具相同的基本命令行界面，如下所示：'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we specify that we want to use the `fdp` tool and name the network *.dot*
    file we want to lay out, which is *apt1callback.dot*, found in the *~/ch3/* directory
    of the data accompanying this book. We specify `–T png` to indicate the format
    (PNG) we wish to use. Finally, we specify where we want the output file to be
    saved using `-o` `apt1callback.png`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定要使用 `fdp` 工具，并命名我们想要布局的网络 *.dot* 文件，该文件是 *apt1callback.dot*，位于本书附带数据的
    *~/ch3/* 目录中。我们指定 `–T png` 来表示我们希望使用的格式（PNG）。最后，我们通过 `-o` `apt1callback.png` 指定输出文件的保存位置。
- en: '***Using Parameters to Adjust Networks***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用参数调整网络绘制***'
- en: 'The GraphViz tools include many parameters you can use to adjust the way your
    networks are drawn. Many of these parameters are set using the `–G` command-line
    flag in the following format:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: GraphViz 工具包括许多参数，可以用来调整网络绘制的方式。许多这些参数是通过 `–G` 命令行标志设置的，格式如下：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Two particularly useful parameters are `overlap` and `splines`. Set `overlap`
    to `false` to tell GraphViz not to allow any nodes to overlap one another. Use
    the `splines` parameter to tell GraphViz to draw curved rather than straight lines
    to make it easier to follow the edges on your networks. The following are some
    ways to set the `overlap` and `splines` parameters in GraphViz.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特别有用的参数是 `overlap` 和 `splines`。将 `overlap` 设置为 `false`，告诉 GraphViz 不允许任何节点相互重叠。使用
    `splines` 参数告诉 GraphViz 绘制曲线而非直线，以便更容易地跟踪网络上的边。以下是一些设置 `overlap` 和 `splines` 参数的
    GraphViz 示例。
- en: 'Use the following to prevent nodes from overlapping:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令来防止节点重叠：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Draw edges as curved lines (splines) to improve network readability:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将边绘制为曲线（样条线），以提高网络的可读性：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Draw edges as curved lines (splines) to improve network readability, and don’t
    allow nodes to visually overlap:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将边绘制为曲线（样条线），以提高网络的可读性，并且不允许节点在视觉上重叠：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that we simply list one parameter after the other: -Gsplines=true –Goverlap=false
    (the ordering doesn’t matter), followed by -T png -o <outputfile.png>.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只是将一个参数接一个参数列出： -Gsplines=true –Goverlap=false（参数顺序无关），然后是 -T png -o <outputfile.png>。
- en: In the next section, I go over some of the most useful GraphViz tools (in addition
    to `fdp`).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我将介绍一些最有用的 GraphViz 工具（除了 `fdp` 之外）。
- en: '***The GraphViz Command Line Tools***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GraphViz 命令行工具***'
- en: Here are some of the available GraphViz tools I have found most useful, as well
    as some sense of when it is appropriate to use each tool.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我发现最有用的 GraphViz 工具的一些介绍，以及在何时使用每个工具的一些建议。
- en: '**fdp**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**fdp**'
- en: We used the `fdp` layout tool in the previous example, which we used to create
    a force-directed layout, as described in “[Force-Directed Algorithms](ch04.xhtml#lev54)”
    on [page 40](ch04.xhtml#page_40). When you’re creating malware networks with fewer
    than 500 nodes, `fdp` does a good job of revealing network structure in a reasonable
    amount of time. But when you’re working with more than 500 nodes, and especially
    when connectivity between nodes is complex, you’ll find that `fdp` slows down
    fairly rapidly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们使用了`fdp`布局工具，它帮助我们创建了力导向布局，正如在[第40页](ch04.xhtml#page_40)的“[力导向算法](ch04.xhtml#lev54)”中所描述的。当你创建节点少于500个的恶意软件网络时，`fdp`能够在合理的时间内很好地揭示网络结构。但当节点数量超过500个，尤其是节点间的连接复杂时，你会发现`fdp`的速度会迅速变慢。
- en: 'To try out `fdp` on the APT1 shared callback server network shown in [Figure
    4-3](ch04.xhtml#ch04fig3), enter the following from the *ch4* directory of the
    data accompanying this book (you must have GraphViz installed):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在[图 4-3](ch04.xhtml#ch04fig3)中显示的APT1共享回调服务器网络上尝试`fdp`，请在本书随附数据的*ch4*目录中输入以下命令（你必须安装GraphViz）：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command will create a *.png* file (fdp_servers.png) that shows a network
    like the one displayed in [Figure 4-5](ch04.xhtml#ch04fig5).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个*.png*文件（fdp_servers.png），显示类似于[图 4-5](ch04.xhtml#ch04fig5)中的网络。
- en: '![image](../images/f0045-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0045-01.jpg)'
- en: '*Figure 4-5: Layout of the APT1 samples using the* fdp *tool*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：使用* fdp *工具绘制的APT1样本布局*'
- en: The `fdp` layout makes a number of themes apparent in the figure. First, two
    big clusters of samples are highly interrelated, as clearly seen in the upper-right
    and lower-left areas of the figure. Second, a number of pairs of samples are related,
    which can be seen in the lower right. Finally, many samples show no apparent relationship
    with one another and aren’t connected to any other nodes. It’s important to recall
    that this visualization is based on shared callback server relationships between
    nodes. It’s possible that the unconnected samples are related to other samples
    in the figure by way of other kinds of relationships, such as shared code relationships—relationships
    we’ll explore in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdp`布局使得图中显现出许多主题。首先，两个大样本集群之间高度关联，这在图的右上角和左下角清晰可见。其次，一些样本对是相关的，这可以在右下角看到。最后，许多样本之间没有明显的关系，也没有与其他节点连接。需要记住的是，这一可视化是基于节点之间共享回调服务器的关系。未连接的样本可能通过其他类型的关系（如共享代码关系）与图中的其他样本相关联——这种关系我们将在[第5章](ch05.xhtml#ch05)中探讨。'
- en: '**sfdp**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**sfdp**'
- en: The `sfdp` tool uses roughly the same approach to layout as `fdp`, but it scales
    better because it creates a hierarchy of simplifications, known as *coarsenings*,
    where nodes are merged into *supernodes* based on their proximity. After it completes
    its coarsenings, the `sfdp` tool lays out the merged versions of the graph that
    have far fewer nodes and edges, which dramatically speeds up the layout process.
    In this way, `sfdp` is able to perform fewer computations to find the best positions
    in the network. As a result, `sfdp` can lay out tens of thousands of nodes on
    a typical laptop, making it by far the best algorithm for laying out very large
    networks of malware.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`sfdp`工具使用与`fdp`类似的布局方法，但它具有更好的扩展性，因为它创建了一个简化层次结构，称为*粗化*，其中节点根据其邻近度合并成*超级节点*。在完成粗化后，`sfdp`工具会对合并后的图形进行布局，这些图形包含的节点和边要少得多，这大大加速了布局过程。通过这种方式，`sfdp`能够进行更少的计算来找到网络中的最佳位置。因此，`sfdp`能够在典型的笔记本电脑上布局成千上万个节点，成为布置非常大规模恶意软件网络的最佳算法。'
- en: 'This scalability comes at a cost, however: `sfdp` produces layouts that are
    sometimes less clear than layouts of the same-sized networks in `fdp`. For example,
    compare [Figure 4-6](ch04.xhtml#ch04fig6), which I created using `sfdp`, to the
    network created with `fdp`, shown in [Figure 4-5](ch04.xhtml#ch04fig5).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种可扩展性是有代价的：`sfdp`生成的布局有时不如在`fdp`中相同大小网络的布局清晰。例如，比较我使用`sfdp`创建的[图 4-6](ch04.xhtml#ch04fig6)与使用`fdp`创建的网络，后者显示在[图
    4-5](ch04.xhtml#ch04fig5)中。
- en: '![image](../images/f0046-01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0046-01.jpg)'
- en: '*Figure 4-6: Layout of the APT1 samples'' shared callback server network using
    the* sfdp *command*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：使用* sfdp *命令绘制的APT1样本共享回调服务器网络布局*'
- en: As you can see, there’s slightly more noise over each cluster in [Figure 4-6](ch04.xhtml#ch04fig6),
    making it slightly harder to see what’s going on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，[图 4-6](ch04.xhtml#ch04fig6)中每个集群上方略微有更多噪声，这使得观察网络情况变得稍微困难。
- en: 'To create this network, enter the *ch4* directory of the data accompanying
    this book and then enter the following code to produce the *sfdp_servers.png*
    image file shown in [Figure 4-6](ch04.xhtml#ch04fig6):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个网络，进入本书附带数据的*ch4*目录，然后输入以下代码生成[图 4-6](ch04.xhtml#ch04fig6)所示的*sfdp_servers.png*图像文件：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note how the first item in this code specifies that we’re using the tool `sfdp`,
    as opposed to `fdp` from before. Everything else is the same, save the output
    filename.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码中的第一个项指定了我们使用的是工具`sfdp`，而不是之前的`fdp`。其他部分相同，唯一不同的是输出文件名。
- en: '**neato**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**neato**'
- en: 'The `neato` tool is the GraphViz implementation of a different force-directed
    network layout algorithm that creates simulated springs between all nodes (including
    unconnected nodes) to help push things to ideal positions, but at the cost of
    additional computation. It’s hard to know when `neato` will produce the best layout
    for a given network: my recommendation is that you try it, in conjunction with
    `fdp`, and see which layout you like more. [Figure 4-7](ch04.xhtml#ch04fig7) shows
    what the `neato` layout looks like on the APT1 shared callback server network.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`neato`工具是GraphViz实现的另一种基于力导向网络布局算法，它在所有节点（包括未连接的节点）之间创建模拟弹簧，帮助将各个元素推到理想的位置，但代价是增加了计算量。很难知道`neato`何时能为给定的网络生成最佳布局：我的建议是，你可以尝试它，并与`fdp`一起使用，看看哪个布局你更喜欢。[图
    4-7](ch04.xhtml#ch04fig7)展示了`neato`布局在APT1共享回调服务器网络中的效果。'
- en: '![image](../images/f0047-01.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0047-01.jpg)'
- en: '*Figure 4-7: Layout of the APT1 shared callback server network using the* neato
    *layout*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7：使用neato布局的APT1共享回调服务器网络布局*'
- en: 'As you can see, in this case `neato` produces a similar network layout to those
    produced by `fdp` and `sfdp`. For some datasets, however, you’ll find that `neato`
    produces a better or worse layout—you just have to try it with your dataset and
    see. To try out `neato`, enter the following from the *ch4* directory of the data
    accompanying this book; this should produce the *neato_servers.png* network image
    file shown in [Figure 4-7](ch04.xhtml#ch04fig7):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这种情况下，`neato`生成的网络布局与`fdp`和`sfdp`生成的类似。然而，对于某些数据集，你会发现`neato`生成的布局可能更好或更差——你只需要在你的数据集上尝试一下，看看效果如何。要尝试`neato`，请从本书附带数据的*ch4*目录中输入以下内容；这将生成[图
    4-7](ch04.xhtml#ch04fig7)所示的*neato_servers.png*网络图像文件：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To create this network, we simply revise the code we used to create [Figure
    4-6](ch04.xhtml#ch04fig6) to specify that we want to use the tool `neato` and
    then save the *.png* to *neato_servers.png*. Now that you know how to create these
    network visualizations, let’s look at ways to improve them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个网络，我们只需要修改之前用来创建[图 4-6](ch04.xhtml#ch04fig6)的代码，指定我们要使用工具`neato`，然后将输出保存为*.png*格式的*neato_servers.png*。现在你已经知道如何创建这些网络可视化，接下来我们来看一下如何改进它们。
- en: '***Adding Visual Attributes to Nodes and Edges***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***为节点和边添加视觉属性***'
- en: Beyond deciding on your general network layout, it can be useful to be able
    to specify how individual nodes and edges are to be rendered. For example, you
    might want to set edge thickness based on the strength of the connection between
    two nodes, or set node color based on what compromise each malware sample node
    is associated with, which would allow you to better visualize clusters of malware.
    NetworkX and GraphViz make it easy to do this by allowing you to specify visual
    attributes of nodes and edges simply by assigning values to a set of attributes.
    I discuss only a few such attributes in the sections that follow, but this topic
    is deep enough to fill an entire book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了决定整体网络布局外，能够指定如何渲染各个节点和边也非常有用。例如，你可能希望根据两个节点之间连接的强度来设置边的粗细，或者根据每个恶意软件样本节点关联的妥协设置节点的颜色，这样可以更好地可视化恶意软件的聚类。NetworkX和GraphViz使得这一切变得简单，只需为节点和边分配属性值即可。我在接下来的章节中仅讨论一些这样的属性，但这个话题足够深奥，可以写成一本完整的书。
- en: '**Edge Width**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**边宽**'
- en: To set the width of the border that GraphViz draws around nodes, or the line
    that it draws for edges, you can set the `penwidth` attribute of nodes and edges
    to a number of your choice, as shown in [Listing 4-4](ch04.xhtml#ch04list4).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 若要设置GraphViz绘制的节点边框宽度，或绘制边时的线条宽度，可以将节点和边的`penwidth`属性设置为你选择的数字，如[清单 4-4](ch04.xhtml#ch04list4)所示。
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 4-4: Setting the* penwidth *attribute*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4：设置penwidth属性*'
- en: Here, I create a simple network ➊ with two nodes connected by an edge, and I
    set the `penwidth` attribute of the edge to 10 ➋ (the default value is 1).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我创建了一个简单的网络 ➊，其中两个节点通过一条边连接，并将边的`penwidth`属性设置为 10 ➋（默认值为 1）。
- en: Run this code, and you should see an image that looks like [Figure 4-8](ch04.xhtml#ch04fig8).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，你应该看到一个与[图 4-8](ch04.xhtml#ch04fig8)相似的图像。
- en: '![image](../images/f0048-01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0048-01.jpg)'
- en: '*Figure 4-8: A simple network with an edge that has a* penwidth *of 10*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：一个简单的网络，边的* penwidth *为 10*'
- en: As you can see in [Figure 4-8](ch04.xhtml#ch04fig8), a `penwidth` of 10 results
    in a very thick edge. The width of the edge (or, the thickness of the node’s border
    if you set the `penwidth` of a node) scales proportionally with the value of the
    `penwidth` attribute, so choose accordingly. For example, if your edge strength
    values vary from 1 to 1000, but you want to be able to see all the edges, you
    might want to consider assigning `penwidth` attributes based on log scaling of
    your edge strength values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图 4-8](ch04.xhtml#ch04fig8)中看到的，`penwidth` 为 10 会导致边变得非常粗。边的宽度（或者如果你设置了节点的`penwidth`，则是节点边框的厚度）与`penwidth`属性的值成比例，因此需要根据情况进行选择。例如，如果你的边强度值从
    1 到 1000 不等，但你希望能够看到所有的边，可以考虑基于边强度值的对数缩放来为每条边分配`penwidth`属性。
- en: '**Node and Edge Color**'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**节点与边的颜色**'
- en: To set the color of a node’s border or an edge, use the `color` attribute. [Listing
    4-5](ch04.xhtml#ch04list5) shows how to do this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置节点边框或边的颜色，使用`color`属性。[清单 4-5](ch04.xhtml#ch04list5)展示了如何操作。
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 4-5: Setting node and edge colors*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5：设置节点和边的颜色*'
- en: Here, I create the same simple network I created in [Listing 4-4](ch04.xhtml#ch04list4),
    with two nodes and an edge connecting them. For each node that I create, I set
    its `color` value (➊ and ➋). I also set the `color` value for the edge ➌ when
    I create it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我创建了与[清单 4-4](ch04.xhtml#ch04list4)中相同的简单网络，其中包含两个节点和一个连接它们的边。对于每个创建的节点，我都设置了其`color`值（➊
    和 ➋）。在创建边时，我还设置了边的`color`值 ➌。
- en: '[Figure 4-9](ch04.xhtml#ch04fig9) shows the result of [Listing 4-5](ch04.xhtml#ch04list5).
    As expected, you should see that the first node (the edge) and the second node
    each have a unique color. For a complete list of colors you can use, refer to
    *[http://www.graphviz.org/doc/info/colors.html](http://www.graphviz.org/doc/info/colors.html)*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-9](ch04.xhtml#ch04fig9)展示了[清单 4-5](ch04.xhtml#ch04list5)的结果。如预期所示，你应该看到第一个节点（边）和第二个节点各自具有唯一的颜色。有关你可以使用的颜色的完整列表，请参见*[http://www.graphviz.org/doc/info/colors.html](http://www.graphviz.org/doc/info/colors.html)*。'
- en: '![image](../images/f0049-01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0049-01.jpg)'
- en: '*Figure 4-9: A simple network that demonstrates how to set node and edge colors*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：一个简单的网络，演示了如何设置节点和边的颜色*'
- en: Colors can be used to show different classes of nodes and edges.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色可以用来表示不同类别的节点和边。
- en: '**Node Shape**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**节点形状**'
- en: To set the shape of a node, use the `shape` attribute with a string specifying
    a shape, as defined at *[http://www.GraphViz.org/doc/info/shapes.html](http://www.GraphViz.org/doc/info/shapes.html)*.
    Commonly used values are `box`, `ellipse`, `circle`, `egg`, `diamond`, `triangle`,
    `pentagon`, and `hexagon`. [Listing 4-6](ch04.xhtml#ch04list6) shows how to set
    the `shape` attribute of a node.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置节点的形状，使用`shape`属性并指定一个形状字符串，如在*[http://www.GraphViz.org/doc/info/shapes.html](http://www.GraphViz.org/doc/info/shapes.html)*中定义的那样。常用的值包括`box`、`ellipse`、`circle`、`egg`、`diamond`、`triangle`、`pentagon`
    和 `hexagon`。[清单 4-6](ch04.xhtml#ch04list6)展示了如何设置节点的`shape`属性。
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 4-6: Setting node shapes*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-6：设置节点形状*'
- en: Similar to the way we set a node’s color, we simply use the `shape` keyword
    argument in the `add_node()` function to specify the shape we want each node to
    take. Here, we set the first node to a diamond shape ➊ and the second node to
    an egg shape ➋. The result of this code is shown in [Figure 4-10](ch04.xhtml#ch04fig10).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于设置节点颜色的方式，我们仅需在`add_node()`函数中使用`shape`关键字参数来指定我们希望每个节点采用的形状。在这里，我们将第一个节点设置为菱形
    ➊，第二个节点设置为蛋形 ➋。此代码的结果如[图 4-10](ch04.xhtml#ch04fig10)所示。
- en: '![image](../images/f0050-01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0050-01.jpg)'
- en: '*Figure 4-10: A simple network that shows how we can set node shape*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-10：一个简单的网络，展示了如何设置节点形状*'
- en: The results, showing a diamond-shaped node and an egg-shaped node, reflect the
    shapes that we specified in [Listing 4-6](ch04.xhtml#ch04list6).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了一个菱形节点和一个蛋形节点，反映了我们在[清单 4-6](ch04.xhtml#ch04list6)中指定的形状。
- en: '**Text Labels**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**文本标签**'
- en: Finally, GraphViz also allows you to add labels to nodes and edges with the
    `label` attribute. Although nodes are automatically labeled based on their assigned
    ID (for example, the label for a node added as *123* would be `123`), you can
    specify labels using `label=<`my label attribute`>`. Unlike nodes, edges aren’t
    labeled by default, but you can assign them labels using the `label` attribute.
    [Listing 4-7](ch04.xhtml#ch04list7) shows how to create our now familiar two-node
    network but with `label` attributes attached to both nodes and the connecting
    edge.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，GraphViz 还允许你使用 `label` 属性为节点和边添加标签。虽然节点会根据其分配的 ID 自动生成标签（例如，作为*123*添加的节点标签为
    `123`），你也可以通过 `label=<`my label attribute`>` 来指定标签。与节点不同，边默认不会有标签，但你可以使用 `label`
    属性为其指定标签。[清单 4-7](ch04.xhtml#ch04list7) 显示了如何创建我们现在熟悉的两个节点网络，并为两个节点和连接边都附加了 `label`
    属性。
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 4-7: Labeling nodes and edges*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-7：为节点和边添加标签*'
- en: We label the nodes `first node` ➊ and `second node` ➋, respectively. We also
    label the edge connecting them as the `link between first and second node` ➌.
    [Figure 4-11](ch04.xhtml#ch04fig11) shows the graphical output we expect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分别将节点标记为 `first node` ➊ 和 `second node` ➋。我们还将连接它们的边标记为 `link between first
    and second node` ➌。[图 4-11](ch04.xhtml#ch04fig11) 显示了我们期望的图形输出。
- en: '![image](../images/f0051-01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0051-01.jpg)'
- en: '*Figure 4-11: A simple network that shows how we can label nodes and edges*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-11：一个简单的网络，展示了我们如何为节点和边添加标签*'
- en: Now that you know how to manipulate basic attributes of nodes and edges, you’re
    ready to start building networks from the ground up.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何操作节点和边的基本属性，接下来你可以开始从零构建网络了。
- en: '**Building Malware Networks**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建恶意软件网络**'
- en: We’ll begin our discussion of building malware networks by reproducing and expanding
    on the shared callback server example shown in [Figure 4-1](ch04.xhtml#ch04fig1),
    and then examine shared image analysis of malware.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过重现并扩展 [图 4-1](ch04.xhtml#ch04fig1) 中展示的共享回调服务器示例，开始讨论构建恶意软件网络，然后研究共享的恶意软件图像分析。
- en: The following program extracts callback domain names from malware files and
    then builds a bipartite network of malware samples. Next, it performs one projection
    of the network to show which malware samples share common callback servers, and
    it performs another projection to show which callback servers are called by common
    malware samples. Finally, the program saves the three networks—the original bipartite
    network, the malware sample projection, and the callback server projection—as
    files so that they can be visualized with GraphViz.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序从恶意软件文件中提取回调域名，然后构建恶意软件样本的二分网络。接下来，它对网络进行一次投影，显示哪些恶意软件样本共享相同的回调服务器，然后再进行一次投影，显示哪些回调服务器被共同的恶意软件样本调用。最后，程序将三个网络—原始的二分网络、恶意软件样本投影和回调服务器投影—保存为文件，以便用
    GraphViz 进行可视化。
- en: I walk you through the program, piece by piece. The complete code can be found
    in the data accompanying this book at the file path *ch4/callback_server_network.py*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我将逐步带你走过这个程序。完整的代码可以在本书附带的文件中找到，路径为 *ch4/callback_server_network.py*。
- en: '[Listing 4-8](ch04.xhtml#ch04list8) shows how to get started by importing the
    requisite modules.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-8](ch04.xhtml#ch04list8) 显示了如何通过导入所需模块开始。'
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 4-8: Importing modules*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-8：导入模块*'
- en: Of the requisite modules we imported, the most notable are the `pefile` PE parsing
    module ➊, which we use to parse the target PE binaries, and the `networkx` library
    ➋, which we use to create the malware attribute network.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入的必需模块中，最引人注目的是 `pefile` PE 解析模块 ➊，我们用它来解析目标 PE 二进制文件，以及 `networkx` 库 ➋，我们用它来创建恶意软件属性网络。
- en: Next, we parse the command line arguments by adding the code in [Listing 4-9](ch04.xhtml#ch04list9).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过添加 [清单 4-9](ch04.xhtml#ch04list9) 中的代码来解析命令行参数。
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 4-9: Parsing command line arguments*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-9：解析命令行参数*'
- en: These arguments include `target_path` ➊ (the path to the directory where the
    malware we’re analyzing is), `output_file` ➋ (the path where we write the complete
    network), `malware_projection` ➌ (the path where we write a reduced version of
    the graph and show which malware samples share attributes), and `resource_projection`
    ➍ (the path where we write a reduced version of the graph and show which attributes
    are seen together within the malware samples).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数包括 `target_path` ➊（我们正在分析的恶意软件所在目录的路径）、`output_file` ➋（我们写入完整网络的路径）、`malware_projection`
    ➌（我们写入简化版本图形的路径，并显示哪些恶意软件样本共享属性），以及 `resource_projection` ➍（我们写入简化版本图形的路径，并显示在恶意软件样本中哪些属性是一起出现的）。
- en: Now we’re ready to get into the core of the program. [Listing 4-10](ch04.xhtml#ch04list10)
    shows the code for creating a network for the program.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备进入程序的核心部分。[清单 4-10](ch04.xhtml#ch04list10)展示了用于创建程序网络的代码。
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 4-10: Creating the network*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-10：创建网络*'
- en: 'We first create a fresh network by calling the `networkx.Graph()` constructor
    ➊. Then we define the function `find_hostnames()`, which extracts hostnames from
    strings ➋. Don’t worry too much about the mechanics of this function: it’s essentially
    a regular expression and some string-filtering code that tries its best to identify
    domains.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过调用`networkx.Graph()`构造函数 ➊ 创建一个新的网络。然后我们定义函数`find_hostnames()`，该函数从字符串中提取主机名
    ➋。不要太担心这个函数的细节：它本质上是一个正则表达式和一些字符串过滤代码，尽力识别域名。
- en: Next, we iterate through all the files in the target directory, checking whether
    they are PE files by seeing if the `pefile.PE` class is able to load them (if
    not, we do not analyze the files). Finally, we extract hostname attributes from
    the current file by first extracting all printable strings from the file ➌ and
    then searching the strings for embedded hostname resources ➍. If we find any,
    we add them as nodes in our network and then add edges from the node for the current
    malware sample to the hostname resource nodes ➎.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历目标目录中的所有文件，检查它们是否为PE文件，方法是查看`pefile.PE`类是否能加载它们（如果不能，我们就不分析这些文件）。最后，我们通过首先从文件中提取所有可打印的字符串
    ➌，然后在这些字符串中搜索嵌入的主机名资源 ➍，来提取当前文件中的主机名属性。如果找到了任何主机名，我们将它们作为节点添加到网络中，然后从当前恶意软件样本的节点添加边到主机名资源节点
    ➎。
- en: Now we’re ready to wrap up the program, as shown in [Listing 4-11](ch04.xhtml#ch04list11).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备结束程序，正如[清单 4-11](ch04.xhtml#ch04list11)所示。
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 4-11: Writing networks to files*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-11：将网络写入文件*'
- en: We start by writing our network to disk at the location specified in the command
    line arguments ➊. Then we create the two reduced networks (the “projections” introduced
    earlier in this chapter) that show the malware relationships and the hostname
    resource relationships. We do this by first creating a Python set for containing
    the IDs of the malware nodes ➋ and another Python set for the IDs of the resource
    nodes ➌. We then use the NetworkX-specific `projected_graph()` function ➍ to get
    projections for the malware and resource sets, and we write these networks to
    disk at the specified locations ➎.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从将网络写入磁盘开始，写入的位置由命令行参数指定 ➊。接着，我们创建两个简化的网络（即本章前面提到的“投影”），分别展示恶意软件关系和主机名资源关系。首先，我们创建一个Python集合来包含恶意软件节点的ID
    ➋，然后创建另一个Python集合来包含资源节点的ID ➌。接下来，我们使用NetworkX特定的`projected_graph()`函数 ➍，获取恶意软件和资源集合的投影，并将这些网络写入指定的位置
    ➎。
- en: And that’s it! You can use this program on any of the malware datasets in this
    book to see malware relationships between the shared hostname resources embedded
    in the files. You can even use it on your own datasets to see what threat intelligence
    you can glean through this mode of analysis.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你可以在本书中的任何恶意软件数据集上运行此程序，查看嵌入文件中的共享主机名资源之间的恶意软件关系。你甚至可以在自己的数据集上使用它，看看通过这种分析方式能够获得哪些威胁情报。
- en: '**Building a Shared Image Relationship Network**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建共享图像关系网络**'
- en: In addition to analyzing malware based on their shared callback servers, we
    can also analyze them based on their use of shared icons and other graphical assets.
    For example, [Figure 4-12](ch04.xhtml#ch04fig12) shows a portion of the shared
    image analysis results for the Trojans found in *ch4/data/Trojans*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了根据共享回调服务器分析恶意软件，我们还可以根据它们使用共享图标和其他图形资产进行分析。例如，[图 4-12](ch04.xhtml#ch04fig12)展示了*ch4/data/Trojans*中发现的特洛伊木马的共享图像分析结果的一部分。
- en: '![image](../images/f0055-01.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0055-01.jpg)'
- en: '*Figure 4-12: A visualization of the shared image asset network for a number
    of Trojans*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-12：多个特洛伊木马共享图像资产网络的可视化*'
- en: You can see that all these Trojan horses pose as archive files and use the same
    archive file icon (shown in the center of the figure), even though they’re executables.
    The fact that they use exactly the same image as part of their effort to game
    the user indicates that they probably come from the same attacker. I confirmed
    this by running the malware samples through the Kaspersky antivirus engine, which
    assigns them all the same family name (ArchSMS).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这些木马程序伪装成归档文件，并使用相同的归档文件图标（如图中间所示），尽管它们实际上是可执行文件。它们使用完全相同的图像作为欺骗用户的手段，这表明它们可能来自同一个攻击者。我通过将这些恶意软件样本传递给卡巴斯基杀毒引擎来确认这一点，结果它们都被分配了相同的家族名称（ArchSMS）。
- en: Next, I show you how to produce the kind of visualization shown in [Figure 4-12](ch04.xhtml#ch04fig12),
    in order to see shared-image relationships between malware samples. To extract
    the images from the malware, we use the helper library `images`, which in turn
    relies on `wrestool` (discussed in [Chapter 1](ch01.xhtml#ch01)) to create the
    *image_network.py* program. Recall that `wrestool` extracts images from Windows
    executables.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向你展示如何生成[图 4-12](ch04.xhtml#ch04fig12)中显示的那种可视化图，以便查看恶意软件样本之间共享图像的关系。为了从恶意软件中提取图像，我们使用辅助库`images`，它依赖于`wrestool`（在[第1章](ch01.xhtml#ch01)中讨论）来创建*image_network.py*程序。请记住，`wrestool`从Windows可执行文件中提取图像。
- en: Let’s walk through the process of creating a shared image network, starting
    with the first part of the code, shown in [Listing 4-12](ch04.xhtml#ch04list12).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地走过创建共享图像网络的过程，从[列表 4-12](ch04.xhtml#ch04list12)中显示的代码的第一部分开始。
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 4-12: Parsing the initial argument and file-loading code in our shared
    image network program*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-12：解析初始参数和文件加载代码，在我们的共享图像网络程序中*'
- en: The program starts out much like the hostname graph program (starting at [Listing
    4-8](ch04.xhtml#ch04list8)) we just discussed. It first imports a number of modules,
    including `pefile` and `networkx`. Here, however, we also define the `ExtractImages`
    helper class ➊, which we use to extract graphical assets from target malware samples.
    Then the program enters a loop in which we iterate over all the target malware
    binaries ➋.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的开始与我们刚才讨论的主机名图形程序（从[列表 4-8](ch04.xhtml#ch04list8)开始）非常相似。它首先导入多个模块，包括`pefile`和`networkx`。然而，在这里我们还定义了`ExtractImages`辅助类
    ➊，我们用它来提取目标恶意软件样本中的图形资产。然后，程序进入一个循环，在该循环中我们迭代所有目标恶意软件二进制文件 ➋。
- en: Now that we are in our loop, it’s time to extract graphical assets from the
    target malware binaries using the `ExtractImages` class (which under the hood
    is a wrapper around the `icoutils` programs discussed in [Chapter 1](ch01.xhtml#ch01)).
    [Listing 4-13](ch04.xhtml#ch04list13) shows the part of the code that does this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入了循环，接下来是从目标恶意软件二进制文件中提取图形资产，使用的是`ExtractImages`类（该类本质上是对[第1章](ch01.xhtml#ch01)中讨论的`icoutils`程序的封装）。[列表
    4-13](ch04.xhtml#ch04list13)展示了执行这一操作的代码部分。
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 4-13: Extracting graphical assets from target malware*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-13：从目标恶意软件中提取图形资产*'
- en: First, we pass in a path to a target malware binary to the `ExtractImages` class
    ➊, and then we call the resulting instance’s `work()` method ➋. This results in
    the `ExtractImages` class creating a temporary directory in which it stores the
    malware images, and then storing a dictionary containing data about each image
    in the `images` class attribute.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将目标恶意软件二进制文件的路径传递给`ExtractImages`类 ➊，然后调用生成实例的`work()`方法 ➋。这会导致`ExtractImages`类创建一个临时目录，用于存储恶意软件图像，然后将包含每个图像数据的字典存储在`images`类属性中。
- en: Now that we have the list of extracted images from `ExtractImages`, we iterate
    over it ➌, creating a new network node for an image if we haven’t seen its hash
    before ➍, and linking the currently processed malware sample to the image in the
    network ➎.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从`ExtractImages`中提取了图像列表，我们开始迭代它 ➌，如果我们之前没有见过该图像的哈希值，就为该图像创建一个新的网络节点 ➍，并将当前处理的恶意软件样本链接到该图像的网络中
    ➎。
- en: Now that we have created our network of malware samples linked to the images
    that they contain, we are ready to write the graph to disk, as shown in [Listing
    4-14](ch04.xhtml#ch04list14).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个将恶意软件样本与其包含的图像关联的网络，接下来我们准备将图形写入磁盘，如[列表 4-14](ch04.xhtml#ch04list14)所示。
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 4-14: Writing the graph to disk*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-14：将图形写入磁盘*'
- en: We do this in exactly the same way that we did in [Listing 4-11](ch04.xhtml#ch04list11).
    First, we write the complete network to disk ➊, and then we write the two projections
    (the projection for the malware and the projection for the images, which we refer
    to as *resources* here) to disk ➋.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与[清单 4-11](ch04.xhtml#ch04list11)中完全相同的方式进行操作。首先，我们将完整的网络写入磁盘 ➊，然后将两个投影（恶意软件投影和图像投影，这里我们称之为*资源*）写入磁盘
    ➋。
- en: You can use *image_network.py* to analyze graphical assets in any of the malware
    datasets in this book, or to extract intelligence from malware datasets of your
    choice.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*image_network.py*分析本书中任何恶意软件数据集中的图形资产，或者从你选择的恶意软件数据集中提取情报。
- en: '**Summary**'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned about the tools and methods necessary to perform
    shared attribute analysis on your own malware datasets. Specifically, you learned
    how networks, bipartite networks, and bipartite network projections can help identify
    the social connections between malware samples, why network layout is central
    to network visualization, and how force-directed networks work. You also learned
    how to create and visualize malware networks using Python and open source tools
    like NetworkX. In [Chapter 5](ch05.xhtml#ch05), you’ll learn how to build malware
    networks based on shared code relationships between samples.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了执行共享属性分析所需的工具和方法，适用于你自己的恶意软件数据集。具体来说，你了解了网络、二分网络和二分网络投影如何帮助识别恶意软件样本之间的社交连接，为什么网络布局在网络可视化中至关重要，以及如何实现基于力导向的网络。你还学会了如何使用Python和开源工具（如NetworkX）创建和可视化恶意软件网络。在[第5章](ch05.xhtml#ch05)中，你将学习如何根据样本之间的共享代码关系构建恶意软件网络。
