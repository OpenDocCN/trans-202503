["```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n...\n<plist version=\"1.0\">\n<dict>\n    <key>**com.apple.developer.networking.networkextension**</key>\n    <array>\n        <string>**dns-proxy-systemextension**</string>\n    </array>\n    ... \n```", "```\n<?xml version=\"1.0\" encoding=”UTF-8\"?>\n...\n<plist version=\"1.0\">\n<dict>\n    ...\n  ❶ <key>CFBundlePackageType</key>\n <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</string>\n    ...\n  ❷ <key>NetworkExtension</key>\n    <dict>\n      ❸ <key>NEMachServiceName</key>\n        <string>$(TeamIdentifierPrefix)com.objective-see.dnsmonitor</string>\n      ❹ <key>NEProviderClasses</key>\n            <dict>\n                <key>com.apple.networkextension.dns-proxy</key>\n                <string>DNSProxyProvider</string>\n            </dict>\n        </dict>\n        ... \n```", "```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n...\n<plist version=\"1.0\">\n<dict>\n    <key>com.apple.developer.networking.networkextension</key>\n    <array>\n        <string>dns-proxy-systemextension</string>\n    </array>\n    <key>com.apple.developer.system-extension.install</key>\n    <true/>\n    <key>com.apple.security.application-groups</key>\n    <array>\n        <string>$(TeamIdentifierPrefix)com.objective-see.dnsmonitor</string>\n    </array>\n</dict>\n</plist> \n```", "```\nERROR: method '-[Extension request:didFailWithError:]' invoked with\n<OSSystemExtensionActivationRequest: 0x600003a8f150>, Error Domain=\nOSSystemExtensionErrorDomain Code=3 \"App containing System Extension\nto be activated must be in /Applications folder\" UserInfo={NSLocalized\nDescription=App containing System Extension to be activated must be in\n/Applications folder} \n```", "```\nif(YES != [NSBundle.mainBundle.bundlePath hasPrefix:@\"/Applications/\"]) {\n    ...\n    NSLog(@\"\\n\\nERROR: As %@ uses a System Extension, Apple requires it must\n    be located in /Applications\\n\\n\", [APP_NAME stringByDeletingPathExtension]);\n    goto bail;\n} \n```", "```\nNSPredicate* predicate =\n[NSPredicate predicateWithFormat:@\"subsystem='com.objective-see.dnsmonitor'\"];\n\nLogMonitor* logMonitor = [[LogMonitor alloc] init];\n[logMonitor start:predicate level:Log_Level_Default eventHandler:^(OSLogEventProxy* event) {\n    ...\n    NSLog(@\"%@\", event.composedMessage);\n}]; \n```", "```\n❶ signal(SIGINT, SIG_IGN);\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL,\n❷ SIGINT, 0, dispatch_get_main_queue());\n❸ dispatch_source_set_event_handler(source, ^{\n    ...\n    stopExtension();\n    exit(0);\n});\ndispatch_resume(source); \n```", "```\n% **ps aux**\n...\nroot 38943 ... /Library/SystemExtensions/8DC3FC3A-825E-49C3-879B-6B0C08388238/\ncom.objective-see.dnsmonitor.extension.systemextension/Contents/MacOS/com\n.objective-see.dnsmonitor.extension \n```", "```\n#define BUNDLE_ID \"com.objective-see.dnsmonitor\"\n\nos_log_t logHandle = os_log_create(BUNDLE_ID, \"extension\"); \n```", "```\n@interface DNSProxyProvider : NEDNSProxyProvider\n    ...\n@end \n```", "```\n-(void)printPacket:(dns_reply_t*)packet flow:(NEAppProxyFlow*)flow {\n    ...\n    char* bytes = NULL;\n    size_t length = 0;\n\n  ❶ NSMutableDictionary* processInfo = [self getProcessInfo:flow];\n\n    os_log(logHandle, \"PROCESS:\\n%{public}@\\n\", processInfo);\n\n  ❷ FILE* fp = open_memstream(&bytes, &length);\n  ❸ dns_print_reply(packet, fp, 0xFFFF);\n  ❹ fflush(fp);\n\n    os_log(logHandle, \"PACKET:\\n%{public}s\\n\", bytes);\n\n    fclose(fp);\n    free(bytes);\n} \n```", "```\n-(void)cache:(dns_reply_t*)packet {\n    NSMutableArray* answers = [NSMutableArray array];\n    NSMutableArray* questions = [NSMutableArray array];\n\n    // Code to extract questions and answers from DNS response packet removed\n\n  ❶ @synchronized(dnsCache) {\n      ❷ if(dnsCache.count >= MAX_ENTRIES) {\n            [dnsCache removeObjectsInRange:NSMakeRange(0, MAX_ENTRIES/2)];\n        }\n\n      ❸ for(NSString* question in questions) {\n            if(0 != answers.count) {\n              ❹ [dnsCache addObject:@{question:answers}];\n            }\n        }\n        ...\n    }\n} \n```", "```\n[\n    {nostarch.com:[\"104.20.120.46\", \"104.20.121.46\"]},\n    {objective-see.org:[\"185.199.110.153\", \"185.199.109.153\",\n    \"185.199.111.153\", \"185.199.108.153\"]}\n] \n```", "```\nsignal(SIGUSR1, dumpDNSCache);\n```", "```\n% **sudo kill -SIGUSR1 `pgrep com.objective-see.dnsmonitor.extension`**\n```", "```\nvoid dumpDNSCache(int signal) {\n    for(NSDictionary* entry in dnsCache) {\n      ❶ NSString* question = entry.allKeys.firstObject;\n      ❷ os_log(logHandle, \"%{public}@:%{public}@\", question, entry[question]);\n    }\n    ...\n} \n```", "```\nDumping DNS Cache:\nDNSMonitor[2027:25144] www.apple.com:(\n    \"23.2.84.211\"\n)\nDNSMonitor[2027:25144] nostarch.com:(\n    \"104.20.120.46\",\n    \"104.20.121.46\"\n)\nDNSMonitor[2027:25144] objective-see.org:(\n    \"185.199.111.153\",\n    \"185.199.110.153\",\n    \"185.199.109.153\",\n    \"185.199.108.153\"\n) \n```", "```\n% **log stream --predicate=\"subsystem='com.objective-see.dnsmonitor'\"**\n```", "```\n-(BOOL)shouldBlock:(dns_reply_t*)packet {\n    BOOL block = NO;\n    dns_header_t* header = packet->header;\n\n    if(DNS_FLAGS_QR_QUERY == (header->flags & DNS_FLAGS_QR_MASK)) { ❶\n        for(uint16_t i = 0; i < header->qdcount; i++) { ❷\n NSString* question = [NSString stringWithUTF8String:packet->question[i]->name]; ❸\n            if(YES == [self.blockList containsObject:question]) { ❹\n                block = YES;\n                goto bail;\n            }\n        }\n    }\n    ...\n\nbail:\n    return block;\n} \n```", "```\ntypedef struct {\n    uint16_t xid;\n    uint16_t flags;\n    uint16_t qdcount;\n    uint16_t ancount;\n    uint16_t nscount;\n    uint16_t arcount;\n} dns_header_t; \n```", "```\nif(ns_t_a == packet->answer[i]->dnstype) {\n    NSString* address =\n    [NSString stringWithUTF8String:inet_ntoa(packet->answer[i]->data.A->addr)];\n\n    // Add code here to process the extracted answer (IP address).\n} \n```", "```\nBOOL block = [self shouldBlock:parsedPacket];\nif(YES == block) {\n    [flow closeWriteWithError:nil];\n    return;\n} \n```", "```\nnw_connection_receive(connection, 1, UINT32_MAX, ^(dispatch_data_t content,\nnw_content_context_t context, bool is_complete, nw_error_t receive_error) {\n    ...\n    BOOL block = [self shouldBlock:parsedPacket];\n    if(YES == block) {\n        [flow closeWriteWithError:nil];\n        nw_connection_cancel(connection);\n        return;\n    }\n}); \n```", "```\ndns_header_t* header = (dns_header_t *)packet.bytes;\n\nheader->flags |= htons(0x8000);\nheader->flags &= ~htons(0xF);\nheader->flags |= htons(0x3); \n```"]