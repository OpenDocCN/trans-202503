- en: Chapter 12. CLASSES AND OBJECTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![CLASSES AND OBJECTS](tagoreillycom20100401nostarchimages577853.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many modern high-level languages support the notion of classes and objects.
    C++ (an object-oriented version of C), Java, and Delphi (an object-oriented version
    of Pascal) are good examples. Of course, these high-level language compilers translate
    their source code into low-level machine code, so it should be pretty obvious
    that some mechanism exists in machine code for implementing classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Although it has always been possible to implement classes and objects in machine
    code, most assemblers provide poor support for writing object-oriented assembly
    language programs. HLA does not suffer from this drawback because it provides
    good support for writing object-oriented assembly language programs. This chapter
    discusses the general principles behind object-oriented programming (OOP) and
    how HLA supports OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 General Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before discussing the mechanisms behind OOP, it is probably a good idea to take
    a step back and explore the benefits of using OOP (especially in assembly language
    programs). Most texts that describe the benefits of OOP will use buzzwords like
    *code reuse*, *abstract data types*, *improved development efficiency*, and so
    on. While all of these features are nice and are good attributes for a programming
    paradigm, a good software engineer would question the use of assembly language
    in an environment where "improved development efficiency" is an important goal.
    After all, you can probably obtain far better efficiency by using a high-level
    language (even in a non-OOP fashion) than you can by using objects in assembly
    language. If the purported features of OOP don't seem to apply to assembly language
    programming, then why bother using OOP in assembly? This section will explore
    some of those reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you should realize is that the use of assembly language does
    not negate the aforementioned OOP benefits. OOP in assembly language does promote
    code reuse. It provides a good method for implementing abstract data types, and
    it can improve development efficiency *in assembly language*. In other words,
    if you're dead set on using assembly language, there are benefits to using OOP.
  prefs: []
  type: TYPE_NORMAL
- en: To understand one of the principle benefits of OOP, consider the concept of
    a global variable. Most programming texts strongly recommend against the use of
    global variables in a program (as does this text). Interprocedural communication
    through global variables is dangerous because it is difficult to keep track of
    all the possible places in a large program that modify a given global object.
    Worse, it is very easy when making enhancements to accidentally reuse a global
    object for something other than its intended purpose; this tends to introduce
    defects into the system.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the well-understood problems with global variables, the semantics of
    global objects (extended lifetimes and accessibility from different procedures)
    are absolutely necessary in various situations. Objects solve this problem by
    letting the programmer determine the lifetime of an object^([[132](#ftn.CHP-12-FN-1)])
    as well as allowing access to data fields from different procedures. Objects have
    several advantages over simple global variables insofar as objects can control
    access to their data fields (making it difficult for procedures to accidentally
    access the data), and you can also create multiple instances of an object, allowing
    separate sections of your program to use their own unique "global" object without
    interference from other sections.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, objects have many other valuable attributes. One could write several
    volumes on the benefits of objects and OOP; this single chapter cannot do the
    subject justice. This chapter presents objects with an eye toward using them in
    HLA/assembly programs. However, if you are new to OOP or wish more information
    about the object-oriented paradigm, you should consult other texts on this subject.
  prefs: []
  type: TYPE_NORMAL
- en: An important use for classes and objects is to create *abstract data types (ADTs)*.
    An abstract data type is a collection of data objects and the functions (which
    we'll call *methods*) that operate on the data. In a pure abstract data type,
    the ADT's methods are the only code that has access to the data fields of the
    ADT; external code may access the data only by using function calls to get or
    set data field values (these are the ADT's *accessor* methods). In real life,
    for efficiency reasons, most languages that support ADTs allow at least limited
    access to the data fields of an ADT by external code.
  prefs: []
  type: TYPE_NORMAL
- en: Assembly language is not a language most people associate with ADTs. Nevertheless,
    HLA provides several features to allow the creation of rudimentary ADTs. While
    some might argue that HLA's facilities are not as complete as those in a language
    such as C++ or Java, keep in mind that these differences exist because HLA is
    an assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: True ADTs should support *information hiding*. This means that the ADT does
    not allow the user of an ADT access to internal data structures and routines that
    manipulate those structures. In essence, information hiding restricts ADT access
    to the ADT's accessor methods. Assembly language, of course, provides very few
    restrictions. If you are dead set on accessing an object directly, there is very
    little HLA can do to prevent you from doing this. However, HLA has some facilities
    that will provide a limited form of information hiding. Combining these with some
    care on your part, you will be able to enjoy many of the benefits of information
    hiding within your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary facilities HLA provides to support information hiding are separate
    compilation, linkable modules, and the `#include/#includeonce` directives. For
    our purposes, an abstract data type definition will consist of two sections: an
    *interface* section and an *implementation* section.'
  prefs: []
  type: TYPE_NORMAL
- en: The interface section contains the definitions that must be visible to the application
    program. In general, it should not contain any specific information that would
    allow the application program to violate the information-hiding principle, but
    this is often impossible given the nature of assembly language. Nevertheless,
    you should attempt to reveal only what is absolutely necessary within the interface
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation section contains the code, data structures, and so on to
    actually implement the ADT. While some of the methods and data types appearing
    in the implementation section may be public (by virtue of appearance within the
    interface section), many of the subroutines, data items, and so on will be private
    to the implementation code. The implementation section is where you hide all the
    details from the application program.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to modify the abstract data type at some point in the future, you
    will only have to change the interface and implementation sections. Unless you
    delete some previously visible object that the applications use, there will be
    no need to modify the applications at all.
  prefs: []
  type: TYPE_NORMAL
- en: Although you could place the interface and implementation sections directly
    in an application program, this would not promote information hiding or maintainability,
    especially if you have to include the code in several different applications.
    The best approach is to place the implementation section in an include file that
    any interested application reads using the HLA `#include` directive and to place
    the implementation section in a separate module that you link with your applications.
  prefs: []
  type: TYPE_NORMAL
- en: The include file would contain `external` directives, any necessary macros,
    and other definitions you want made public. It generally would not contain 80x86
    code except, perhaps, in some macros. When an application wants to make use of
    an ADT, it would include this file.
  prefs: []
  type: TYPE_NORMAL
- en: The separate assembly file containing the implementation section would contain
    all the procedures, functions, data objects, and so on to actually implement the
    ADT. Those names that you want to be public should appear in the interface include
    file and have the `external` attribute. You should also include the interface
    include file in the implementation file so you do not have to maintain two sets
    of `external` directives.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with using procedures for data access methods is the fact that many
    accessor methods are especially trivial (e.g., just a `mov` instruction), and
    the overhead of the call and return instructions is expensive for such trivial
    operations. For example, suppose you have an ADT whose data object is a structure,
    but you do not want to make the field names visible to the application and you
    really do not want to allow the application to access the fields of the data structure
    directly (because the data structure may change in the future). The normal way
    to handle this is to supply a `GetField` method that returns the value of the
    desired field. However, as pointed out above, this can be very slow. An alternative
    for simple access methods is to use a macro to emit the code to access the desired
    field. Although code to directly access the data object appears in the application
    program (via macro expansion), a recompile will automatically update it if you
    ever change the macro in the interface section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it is quite possible to create ADTs using nothing more than separate
    compilation and, perhaps, records, HLA does provide a better solution: the class.
    Read on to find out about HLA''s support for classes and objects as well as how
    to use these to create ADTs.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[132](#CHP-12-FN-1)]) Lifetime means the time during which the system allocates
    memory for an object.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 Classes in HLA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamentally, a *class* is a record declaration that allows the definition
    of non-data fields (e.g., procedures, constants, and macros). The inclusion of
    other objects in the class definition dramatically expands the capabilities of
    a class. For example, with a class it is now possible to easily define an ADT
    because classes may include data and methods (procedures) that operate on that
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle way to create an abstract data type in HLA is to declare a class
    data type. Classes in HLA always appear in the `type` section and use the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The class declaration section is very similar to the local declaration section
    for a procedure insofar as it allows `const`, `val`, `var`, `storage`, `readonly`,
    `static`, and `proc` variable declaration sections. Classes also let you define
    macros and specify procedure, iterator,^([[133](#ftn.CHP-12-FN-2)]) and *method*
    prototypes (method declarations are legal only in classes). Conspicuously absent
    from this list is the type declaration section. You cannot declare new types within
    a class.
  prefs: []
  type: TYPE_NORMAL
- en: A *method* is a special type of procedure that appears only within a class.
    A little later you will see the difference between procedures and methods; for
    now you can treat them as being the same. Other than a few subtle details regarding
    class initialization and the use of pointers to classes, their semantics are identical.^([[134](#ftn.CHP-12-FN-3)])
    Generally, if you don't know whether to use a procedure or method in a class,
    the safest bet is to use a method.
  prefs: []
  type: TYPE_NORMAL
- en: You do not place procedure/iterator/method code within a class. Instead you
    simply supply *prototypes* for these routines. A routine prototype consists of
    the `procedure`, `iterator`, or `method` reserved word, the routine name, any
    parameters, and a couple of optional procedure attributes (`@use`, `@returns`,
    and `external`). The actual routine definition (the body of the routine and any
    local declarations it needs) appears outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a typical class declaration appearing in
    the `type` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, classes are very similar to records in HLA. Indeed, you can
    think of a record as being a class that allows only `var` declarations. HLA implements
    classes in a fashion quite similar to records insofar as it allocates sequential
    data fields in sequential memory locations. In fact, with only one minor exception,
    there is almost no difference between a `record` declaration and a `class` declaration
    that has only a `var` declaration section. Later you'll see exactly how HLA implements
    classes, but for now you can assume that HLA implements them the same as it does
    records, and you won't be too far off the mark.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the `TCvar` and `TCstatic` fields (in the class above) just
    like a record''s fields. You access the `const` and `val` fields in a similar
    manner. If a variable of type `TypicalClass` has the name `obj`, you can access
    the fields of `obj` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If an application program includes the class declaration above, it can create
    variables using the `TypicalClass` type and perform operations using the mentioned
    methods. Unfortunately, the application program can also access the fields of
    the ADT with impunity. For example, if a program created a variable `MyClass`
    of type `TypicalClass`, then it could easily execute instructions like `mov( MyClass.TCvar,
    eax );` even though this field might be private to the implementation section.
    Unfortunately, if you are going to allow an application to declare a variable
    of type `TypicalClass`, the field names will have to be visible. While there are
    some tricks we could play with HLA's class definitions to help hide the private
    fields, the best solution is to thoroughly comment the private fields and then
    exercise some restraint when accessing the fields of that class. Specifically,
    this means that ADTs you create using HLA's classes cannot be "pure" ADTs because
    HLA allows direct access to the data fields. However, with a little discipline,
    you can simulate a pure ADT by simply electing not to access such fields outside
    the class's methods, procedures, and iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes appearing in a class are effectively forward declarations. Like normal
    forward declarations, all procedures, iterators, and methods you define in a class
    must have an actual implementation later in the code. Alternately, you may attach
    the `external` option to the end of a procedure, iterator, or method declaration
    within a class to inform HLA that the actual code appears in a separate module.
    As a general rule, class declarations appear in header files and represent the
    interface section of an ADT. The procedure, iterator, and method bodies appear
    in the implementation section, which is usually a separate source file that you
    compile separately and link with the modules that use the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a sample class procedure implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are several differences between a standard procedure declaration and a
    class procedure declaration. First, and most obvious, the procedure name includes
    the class name (e.g., `TypicalClass.TCproc`). This differentiates this class procedure
    definition from a regular procedure that just happens to have the name `TCproc`.
    Note, however, that you do not have to repeat the class name before the procedure
    name in the `begin` and `end` clauses of the procedure (this is similar to procedures
    you define in HLA namespaces).
  prefs: []
  type: TYPE_NORMAL
- en: A second difference between class procedures and nonclass procedures is not
    obvious. Some procedure attributes (`@use`, `external`, `@returns`, `@cdecl`,
    `@pascal`, and `@stdcall`) are legal only in the prototype declaration appearing
    within the class, while other attributes (`@noframe`, `@nodisplay`, `@noalignstack`,
    and `@align`) are legal only within the procedure definition and not within the
    class. Fortunately, HLA provides helpful error messages if you stick the option
    in the wrong place, so you don't have to memorize this rule.
  prefs: []
  type: TYPE_NORMAL
- en: If a class routine's prototype does not have the `external` option, the compilation
    unit (that is, the program or unit) containing the class declaration must also
    contain the routine's definition or HLA will generate an error at the end of the
    compilation. For small, local classes (that is, when you're embedding the class
    declaration and routine definitions in the same compilation unit) the convention
    is to place the class's procedure, iterator, and method definitions in the source
    file shortly after the class declaration. For larger systems (that is, when separately
    compiling a class's routines), the convention is to place the class declaration
    in a header file by itself and place all the procedure, iterator, and method definitions
    in a separate HLA unit and compile them by themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[133](#CHP-12-FN-2)]) This text does not discuss iterators. See the HLA reference
    manual for details on this type of function.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[134](#CHP-12-FN-3)]) Note, however, that the difference between procedures
    and methods makes all the difference in the world to the object-oriented programming
    paradigm, hence the inclusion of methods in HLA's class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember, a class definition is just a type. Therefore, when you declare a
    class type you haven''t created a variable whose fields you can manipulate. An
    *object* is an *instance* of a class; that is, an object is a variable whose type
    is some class. You declare objects (i.e., class variables) the same way you declare
    other variables: in a `var`, `static`, or `storage` section.^([[135](#ftn.CHP-12-FN-4)])
    Here is a pair of sample object declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For a given class object, HLA allocates storage for each variable appearing
    in the `var` section of the class declaration. If you have two objects, `T1` and
    `T2`, of type `TypicalClass`, then `T1.TCvar` is unique, as is `T2.TCvar`. This
    is the intuitive result (similar to `record` declarations); most data fields you
    define in a class will appear in the `var` declaration section of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Static data objects (for example, those you declare in the `static` or `storage`
    sections of a class declaration) are not unique among the objects of that class;
    that is, HLA allocates only a single static variable that all variables of that
    class share. For example, consider the following (partial) class declaration and
    object declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `s1.i` and `s2.i` are different variables. However, `s1.s`
    and `s2.s` are aliases of one another. Therefore, an instruction like `mov(5,
    s1.s);` also stores 5 into `s2.s`. Generally you use static class variables to
    maintain information about the whole class, while you use class `var` objects
    to maintain information about the specific object. Because keeping track of class
    information is relatively rare, you will probably declare most class data fields
    in a `var` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create dynamic instances of a class and refer to those dynamic
    objects via pointers. In fact, this is probably the most common form of object
    storage and access. The following code shows how to create pointers to objects
    and how you can dynamically allocate storage for an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of type coercion to cast the pointer in EBX as type `sc`.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[135](#CHP-12-FN-4)]) Technically, you could also declare an object in a
    `readonly` section, but HLA does not allow you to define class constants, so there
    is little utility in declaring class objects in the `readonly` section.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inheritance is one of the most fundamental ideas behind object-oriented programming.
    The basic idea is that a class inherits, or copies, all the fields from some class
    and then possibly expands the number of fields in the new data type. For example,
    suppose you created a data type `point` that describes a point in the planar (two-dimensional)
    space. The class for this `point` might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to create a `point` in 3D space rather than 2D space. You
    can easily build such a data type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `inherits` option on the `class` declaration tells HLA to insert the fields
    of `point` at the beginning of the class. In this case, `point3D` inherits the
    fields of `point`. HLA always places the inherited fields at the beginning of
    a class object. The reason for this will become clear a little later. If you have
    an instance of `point3D`, which you call `P3`, then the following 80x86 instructions
    are all legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `p3.distance` method invocation in this example calls the `point.distance`
    method. You do not have to write a separate `distance` method for the `point3D`
    class unless you really want to do so (see the next section for details). Just
    like the `x` and `y` fields, `point3D` objects inherit `point`'s methods.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5 Overriding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Overriding* is the process of replacing an existing method in an inherited
    class with one more suitable for the new class. In the `point` and `point3D` examples
    appearing in the previous section, the `distance` method (presumably) computes
    the distance from the origin to the specified point. For a point on a two-dimensional
    plane, you can compute the distance using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *d = √ x² + y²* |'
  prefs: []
  type: TYPE_TB
- en: 'However, the distance for a point in 3D space is given by this equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *d = √ x² + y² + z²* |'
  prefs: []
  type: TYPE_TB
- en: Clearly, if you call the `distance` function for `point` for a `point3D` object,
    you will get an incorrect answer. In the previous section, however, you saw that
    the `P3` object calls the `distance` function inherited from the `point` class.
    Therefore, this would produce an incorrect result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation the `point3D` data type must override the `distance` method
    with one that computes the correct value. You cannot simply redefine the `point3D`
    class by adding a `distance` method prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the `distance` method declaration above is that `point3D` already
    has a `distance` method—the one that it inherits from the `point` class. HLA will
    complain because it doesn't like two methods with the same name in a single class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we need some mechanism by which we can override the
    declaration of `point.distance` and replace it with a declaration for `point3D.distance`.
    To do this, you use the `override` keyword before the method declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `override` prefix tells HLA to ignore the fact that `point3D` inherits
    a method named `distance` from the `point` class. Now, any call to the `distance`
    method via a `point3D` object will call the `point3D.distance` method rather than
    `point.distance`. Of course, once you override a method using the `override` prefix,
    you must supply the method in the implementation section of your code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 12.6 Virtual Methods vs. Static Procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A little earlier, this chapter suggested that you could treat class methods
    and class procedures the same. There are, in fact, some major differences between
    the two (after all, why have methods if they''re the same as procedures?). As
    it turns out, the differences between methods and procedures are crucial if you
    want to develop object-oriented programs. Methods provide the second feature necessary
    to support true polymorphism: virtual procedure calls.^([[136](#ftn.CHP-12-FN-5)])
    A virtual procedure call is just a fancy name for an indirect procedure call (using
    a pointer associated with the object). The key benefit of virtual procedures is
    that the system automatically calls the right method when using pointers to generic
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following declarations using the `point` class from the previous
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the declarations above, the following assembly statements are all legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that HLA lets you call a method via a pointer to an object rather than
    directly via an object variable. This is a crucial feature of objects in HLA and
    a key to implementing *virtual method calls*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The magic behind polymorphism and inheritance is that object pointers are *generic*.
    In general, when your program references data indirectly through a pointer, the
    value of the pointer should be the address of some value of the underlying data
    type associated with that pointer. For example, if you have a pointer to a 16-bit
    unsigned integer, you wouldn''t normally use that pointer to access a 32-bit signed
    integer value. Similarly, if you have a pointer to some record, you would not
    normally cast that pointer to some other record type and access the fields of
    that other type.^([[137](#ftn.CHP-12-FN-6)]) With pointers to class objects, however,
    we can lift this restriction a little. Pointers to objects may legally contain
    the address of the object''s type *or the address of any object that inherits
    the fields of that type*. Consider the following declarations that use the `point`
    and `point3D` types from the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Because `p` is a pointer to a `point` object, it might seem intuitive for `p.distance`
    to call the `point.distance` method. However, methods are *polymorphic*. If you
    have a pointer to an object and you call a method associated with that object,
    the system will call the actual (overridden) method associated with the object,
    not the method specifically associated with the pointer's class type.
  prefs: []
  type: TYPE_NORMAL
- en: Class procedures behave differently than methods with respect to overridden
    procedures. When you call a class procedure indirectly through an object pointer,
    the system will always call the procedure associated with the underlying class.
    So had `distance` been a procedure rather than a method in the previous examples,
    the `p.distance()`; invocation would always call `point.distance`, even if `p`
    were pointing at a `point3D` object. [12.9 Constructors and Object Initialization](ch12s09.html
    "12.9 Constructors and Object Initialization") explains why methods and procedures
    are different.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[136](#CHP-12-FN-5)]) *Polymorphism* literally means "many-faced." In the
    context of object-oriented programming, polymorphism means that the same method
    name, for example, `distance`, refers to one of several different methods.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[137](#CHP-12-FN-6)]) Of course, assembly language programmers break rules
    like this all the time. For now, let's assume we're playing by the rules and access
    the data using only the data type associated with the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 12.7 Writing Class Methods and Procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each class procedure and method prototype appearing in a class definition,
    there must be a corresponding procedure or method appearing within the program
    (for the sake of brevity, this section will use the term *routine* to mean procedure
    or method from this point forward). If the prototype does not contain the `external`
    option, then the code must appear in the same compilation unit as the class declaration.
    If the `external` option does follow the prototype, then the code may appear in
    the same compilation unit or a different compilation unit (as long as you link
    the resulting object file with the code containing the class declaration). Like
    external (non-class) procedures, if you fail to provide the code, the linker will
    complain when you attempt to create an executable file. To reduce the size of
    the following examples, they will all define their routines in the same source
    file as the class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: HLA class routines must always follow the class declaration in a compilation
    unit. If you are compiling your routines in a separate unit, the class declarations
    must still precede the implementation of the routines from the class (usually
    via an `#include` file). If you haven't defined the class by the time you define
    a routine like `point.distance`, HLA doesn't know that `point` is a class and,
    therefore, doesn't know how to handle the routine's definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following declarations for a `point2D` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `distance` function for this class should compute the distance from the
    object''s point to `(fromX,fromY)`. The following formula describes this computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![12.7 Writing Class Methods and Procedures](tagoreillycom20100401nostarchimages578079.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A first pass at writing the `distance` method might produce the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code probably looks like it should work to someone who is familiar with
    an object-oriented programming language like C++ or Delphi. However, as the comments
    indicate, the instructions that push the `x` and `y` variables onto the FPU stack
    don't work; HLA doesn't automatically define the symbols associated with the data
    fields of a class within that class's routines.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how to access the data fields of a class within that class''s routines,
    we need to back up a moment and discuss some very important implementation details
    concerning HLA''s classes. To do this, consider the following variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Remember, whenever you create two objects like `Origin` and `PtInSpace`, HLA
    reserves storage for the `x` and `y` data fields for both of these objects. However,
    there is only one copy of the `point2D.distance` method in memory. Therefore,
    were you to call `Origin.distance` and `PtInSpace.distance`, the system would
    call the same routine for both method invocations. Once inside that method, one
    has to wonder what an instruction like `fld( x );` would do. How does it associate
    `x` with `Origin.x` or `PtInSpace.x`? Worse still, how would this code differentiate
    between the data field `x` and a global object `x`? In HLA, the answer is, it
    doesn't. You do not specify the data field names within a class routine by simply
    using their names as though they were common variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To differentiate `Origin.x` from `PtInSpace.x` within class routines, HLA automatically
    passes a pointer to an object''s data fields whenever you call a class routine.
    Therefore, you can reference the data fields indirectly off this pointer. HLA
    passes this object pointer in the ESI register. This is one of the few places
    where HLA-generated code will modify one of the 80x86 registers behind your back:
    *Anytime you call a class routine, HLA automatically loads the ESI register with
    the object''s address*. Obviously, you cannot count on ESI''s value being preserved
    across class routine calls, nor can you pass parameters to the class routine in
    the ESI register (though it is perfectly reasonable to specify `@use esi;` to
    allow HLA to use the ESI register when setting up other parameters). For class
    methods (but not procedures), HLA will also load the EDI register with the address
    of the classes'' *virtual method table*. While the virtual method table address
    isn''t as interesting as the object address, keep in mind that *HLA-generated
    code will overwrite any value in the EDI register when you call a class method
    or an iterator*. Again, "EDI" is a good choice for the `@use` operand for methods
    because HLA will wipe out the value in EDI anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon entry into a class routine, ESI contains a pointer to the (nonstatic)
    data fields associated with the class. Therefore, to access fields like `x` and
    `y` (in our `point2D` example), you could use an address expression like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Because you use ESI as the base address of the object's data fields, it's a
    good idea not to disturb ESI's value within the class routines (or, at least,
    preserve ESI's value across the code where you must use ESI for some other purpose).
    Note that within a method you do not have to preserve EDI (unless, for some reason,
    you need access to the virtual method table, which is unlikely).
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing the fields of a data object within a class''s routines is such a
    common operation that HLA provides a shorthand notation for casting ESI as a pointer
    to the class object: `this`. Within a class in HLA, the reserved word `this` automatically
    expands to a string of the form `(type` *`classname`* `[esi])`, substituting,
    of course, the appropriate class name for *`classname`*. Using the this keyword,
    we can (correctly) rewrite the previous distance method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget that calling a class routine wipes out the value in the ESI register.
    This isn''t obvious from the syntax of the routine''s invocation. It is especially
    easy to forget this when calling some class routine from inside some other class
    routine; remember that if you do this, the internal call wipes out the value in
    ESI and on return from that call ESI no longer points at the original object.
    Always push and pop ESI (or otherwise preserve ESI''s value) in this situation.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `this` keyword provides access to the class variables you declare in the
    `var` section of a class. You can also use `this` to call other class routines
    associated with the current object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To access class constants and `static` data fields, you generally do not use
    the `this` pointer. HLA associates constant and static data fields with the whole
    class, not a specific object ( just like `static` fields in a class). To access
    these class members, use the class name in place of the object name. For example,
    to access the `UnitDistance` constant in the `point2d` class you could use a statement
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As another example, if you wanted to update the `LastDistance` field in the
    `point2D` class each time you computed a distance, you could rewrite the `point2D.distance`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The next section will explain why you use the class name when referring to constants
    and static objects but you use `this` to access `var` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class procedures are also static objects, so it is possible to call a class
    procedure by specifying the class name rather than an object name in the procedure
    invocation; for example, both of the following are legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There is, however, a subtle difference between these two class procedure calls.
    The first call above loads ESI with the address of the `origin` object prior to
    actually calling the `InitLastDistance` procedure. The second call, however, is
    a direct call to the class procedure without referencing an object; therefore,
    HLA doesn't know what object address to load into the ESI register. In this case,
    HLA loads NULL (0) into ESI prior to calling the `InitLastDistance` procedure.
    Because you can call class procedures in this manner, it's always a good idea
    to check the value in ESI within your class procedures to verify that HLA contains
    a valid object address. Checking the value in ESI is a good way to determine which
    calling mechanism is in use. [12.9 Constructors and Object Initialization](ch12s09.html
    "12.9 Constructors and Object Initialization") discusses constructors and object
    initialization; then you will see a good use for static procedures and calling
    those procedures directly (rather than through the use of an object).
  prefs: []
  type: TYPE_NORMAL
- en: 12.8 Object Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a high-level object-oriented language like C++ or Delphi, it is quite possible
    to master the use of objects without really understanding how the machine implements
    them. One of the reasons for learning assembly language programming is to fully
    comprehend low-level implementation details so you can make educated decisions
    concerning the use of programming constructs like objects. Further, because assembly
    language allows you to poke around with data structures at a very low level, knowing
    how HLA implements objects can help you create certain algorithms that would not
    be possible without a detailed knowledge of object implementation. Therefore,
    this section and its corresponding subsections explain the low-level implementation
    details you will need to know in order to write object-oriented HLA programs.
  prefs: []
  type: TYPE_NORMAL
- en: HLA implements objects in a manner quite similar to records. In particular,
    HLA allocates storage for all `var` objects in a class in a sequential fashion,
    just like records. Indeed, if a class consists of only `var` data fields, the
    memory representation of that class is nearly identical to that of a corresponding
    `record` declaration. Consider the `student` record declaration taken from [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES") and the corresponding class
    (see [Figure 12-1](ch12s08.html#student_record_implementation_in_memory "Figure 12-1. student
    record implementation in memory") and [Figure 12-2](ch12s08.html#student_class_implementation_in_memory
    "Figure 12-2. student class implementation in memory"), respectively).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![student record implementation in memory](tagoreillycom20100401nostarchimages578081.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1. `student` record implementation in memory
  prefs: []
  type: TYPE_NORMAL
- en: '![student class implementation in memory](tagoreillycom20100401nostarchimages578083.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2. `student` class implementation in memory
  prefs: []
  type: TYPE_NORMAL
- en: If you look carefully at [Figure 12-1](ch12s08.html#student_record_implementation_in_memory
    "Figure 12-1. student record implementation in memory") and [Figure 12-2](ch12s08.html#student_class_implementation_in_memory
    "Figure 12-2. student class implementation in memory"), you'll discover that the
    only difference between the class and the record implementations is the inclusion
    of the `VMT` (virtual method table) pointer field at the beginning of the class
    object. This field, which is always present in a class, contains the address of
    the class's virtual method table that, in turn, contains the addresses of all
    the class's methods and iterators. The `VMT` field, by the way, is present even
    if a class doesn't contain any methods or iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'As pointed out in previous sections, HLA does not allocate storage for `static`
    objects within the object. Instead, HLA allocates a single instance of each `static`
    data field that all objects share. As an example, consider the following class
    and object declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 12-3](ch12s08.html#object_allocation_with_static_data_field "Figure 12-3. Object
    allocation with static data fields") shows the storage allocation for these two
    objects in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Object allocation with static data fields](tagoreillycom20100401nostarchimages578085.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-3. Object allocation with `static` data fields
  prefs: []
  type: TYPE_NORMAL
- en: Of course, `const`, `val`, and `#macro` objects do not have any runtime memory
    requirements associated with them, so HLA does not allocate any storage for these
    fields. Like the `static` data fields, you may access `const`, `val`, and `#macro`
    fields using the class name as well as an object name. Hence, even if `tHasStatic`
    has these types of fields, the memory organization for `tHasStatic` objects would
    still be the same as shown in [Figure 12-3](ch12s08.html#object_allocation_with_static_data_field
    "Figure 12-3. Object allocation with static data fields").
  prefs: []
  type: TYPE_NORMAL
- en: Other than the presence of the virtual method table (`VMT`) pointer, the presence
    of methods and procedures has no impact on the storage allocation of an object.
    Of course, the machine instructions associated with these routines do appear somewhere
    in memory. So in a sense the code for the routines is quite similar to `static`
    data fields insofar as all the objects share a single instance of the routine.
  prefs: []
  type: TYPE_NORMAL
- en: 12.8.1 Virtual Method Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When HLA calls a class procedure, it directly calls that procedure using a `call`
    instruction, just like any normal procedure call. Methods are another story altogether.
    Each object in the system carries a pointer to a virtual method table, which is
    an array of pointers to all the methods and iterators appearing within the object's
    class (see [Figure 12-4](ch12s08.html#virtual_method_table_organization "Figure 12-4. Virtual
    method table organization")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Virtual method table organization](tagoreillycom20100401nostarchimages578087.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-4. Virtual method table organization
  prefs: []
  type: TYPE_NORMAL
- en: 'Each iterator or method you declare in a class has a corresponding entry in
    the virtual method table. That double-word entry contains the address of the first
    instruction of that iterator or method. Calling a class method or iterator is
    a bit more work than calling a class procedure (it requires one additional instruction
    plus the use of the EDI register). Here is a typical calling sequence for a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For a given class there is only one copy of the virtual method table in memory.
    This is a static object, so all objects of a given class type share the same virtual
    method table. This is reasonable because all objects of the same class type have
    exactly the same methods and iterators (see [Figure 12-5](ch12s08.html#all_objects_that_are_the_same_class_type
    "Figure 12-5. All objects that are the same class type share the same VMT.")).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although HLA builds the `VMT` record structure as it encounters methods and
    iterators within a class, HLA does not automatically create the virtual method
    table for you. You must explicitly declare this table in your program. To do this,
    you include a statement like the following in a `static` or `readonly` declaration
    section of your program. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![All objects that are the same class type share the same VMT.](tagoreillycom20100401nostarchimages578089.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-5. All objects that are the same class type share the same VMT.
  prefs: []
  type: TYPE_NORMAL
- en: Because the addresses in a virtual method table should never change during program
    execution, the `readonly` section is probably the best choice for declaring virtual
    method tables. It should go without saying that changing the pointers in a virtual
    method table is, in general, a really bad idea. So putting `VMT`s in a `static`
    section is usually not a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: A declaration like the one above defines the variable *`classname`*`._VMT_`.
    In [12.9 Constructors and Object Initialization](ch12s09.html "12.9 Constructors
    and Object Initialization"), you will see that you need this name when initializing
    object variables. The class declaration automatically defines the *`classname`*`._VMT_`
    symbol as an external static variable. The declaration above just provides the
    actual definition for this external symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of a `VMT` uses a somewhat strange syntax because you aren''t
    actually declaring a new symbol with this declaration; you''re simply supplying
    the data for a symbol that you previously declared implicitly by defining a class.
    That is, the class declaration defines the static table variable *`classname`*`._VMT_`;
    all you''re doing with the `VMT` declaration is telling HLA to emit the actual
    data for the table. If, for some reason, you would like to refer to this table
    using a name other than *`classname`*`._VMT_`, HLA does allow you to prefix the
    declaration above with a variable name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this declaration, `myVMT` is an alias of *`classname`*`._VMT_`. As a general
    rule, you should avoid using aliases in a program because they make the program
    more difficult to read and understand. Therefore, it is unlikely that you would
    ever need to use this type of declaration.
  prefs: []
  type: TYPE_NORMAL
- en: As with any other global static variable, there should be only one instance
    of a virtual method table for a given class in a program. The best place to put
    the `VMT` declaration is in the same source file as the class's method, iterator,
    and procedure code (assuming they all appear in a single file). This way you will
    automatically link in the virtual method table whenever you link in the routines
    for a given class.
  prefs: []
  type: TYPE_NORMAL
- en: 12.8.2 Object Representation with Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, the discussion of the implementation of class objects has
    ignored the possibility of inheritance. Inheritance affects the memory representation
    of an object only by adding fields that are not explicitly stated in the class
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding inherited fields from a *base class* to another class must be done carefully.
    Remember, an important attribute of a class that inherits fields from a base class
    is that you can use a pointer to the base class to access the inherited fields
    from that base class, even if the pointer contains the address of some other class
    (that inherits the fields from the base class). As an example, consider the following
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Because both `tChildClassA` and `tChildClassB` inherit the fields of `tBaseClass`,
    these two child classes include the `i`, `j`, and `r` fields as well as their
    own specific fields. Furthermore, whenever you have a pointer variable whose base
    type is `tBaseClass`, it is legal to load this pointer with the address of any
    child class of `tBaseClass`; therefore, it is perfectly reasonable to load such
    a pointer with the address of a `tChildClassA` or `tChildClassB` variable. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Because `ptr` points at an object of type `tBaseClass`, you may legally (from
    a semantic sense) access the `i`, `j`, and `r` fields of the object where `ptr`
    is pointing. It is not legal to access the `c`, `b`, `w`, or `d` field of the
    `tChildClassA` or `tChildClassB` objects because at any one given moment the program
    may not know exactly what object type `ptr` references.
  prefs: []
  type: TYPE_NORMAL
- en: In order for inheritance to work properly, the `i`, `j`, and `r` fields must
    appear at the same offsets in all child classes as they do in `tBaseClass`. This
    way, an instruction of the form `mov((type tBaseClass [ebx]).i, eax)`; will correctly
    access the `i` field even if EBX points at an object of type `tChildClassA` or
    `tChildClassB`. [Figure 12-6](ch12s08.html#layout_of_base_and_child_class_objects_i
    "Figure 12-6. Layout of base and child class objects in memory") shows the layout
    of the child and base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the new fields in the two child classes bear no relation to one another,
    even if they have the same name (for example, the `c` fields in the two child
    classes do not lie at the same offset). Although the two child classes share the
    fields they inherit from their common base class, any new fields they add are
    unique and separate. Two fields in different classes share the same offset only
    by coincidence if those fields are not inherited from a common base class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout of base and child class objects in memory](tagoreillycom20100401nostarchimages578091.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-6. Layout of base and child class objects in memory
  prefs: []
  type: TYPE_NORMAL
- en: All classes (even those that aren't related to one another) place the pointer
    to the virtual method table at offset 0 within the object. There is a single virtual
    method table associated with each class in a program; even classes that inherit
    fields from some base class have a virtual method table that is (generally) different
    than the base class's table. [Figure 12-7](ch12s08.html#virtual_method_table_references_from_obj
    "Figure 12-7. Virtual method table references from objects") shows how objects
    of type `tBaseClass`, `tChildClassA`, and `tChildClassB` point at their specific
    virtual method tables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Virtual method table references from objects](tagoreillycom20100401nostarchimages578093.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-7. Virtual method table references from objects
  prefs: []
  type: TYPE_NORMAL
- en: 'A virtual method table is nothing more than an array of pointers to the methods
    and iterators associated with a class. The address of the first method or iterator
    that appears in a class is at offset 0, the address of the second appears at offset
    4, and so on. You can determine the offset value for a given iterator or method
    by using the `@offset` function. If you want to call a method directly (using
    80x86 syntax rather than HLA''s high-level syntax), you could use code like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if the method has any parameters, you must push them onto the stack
    before executing the code above. Don't forget when making direct calls to a method,
    you must load ESI with the address of the object. Any field references within
    the method will probably depend on ESI containing this address. The choice of
    EDI to contain the `VMT` address is nearly arbitrary. Unless you're doing something
    tricky (like using EDI to obtain runtime type information), you could use any
    register you please here. As a general rule, you should use EDI when simulating
    class method calls because this is the convention that HLA employs, and most programmers
    will expect this usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a child class inherits fields from some base class, the child class''s
    virtual method table also inherits entries from the base class''s table. For example,
    the virtual method table for class `tBaseClass` contains only a single entry—a
    pointer to method `tBaseClass.mBase`. The virtual method table for class `tChildClassA`
    contains two entries: a pointer to `tBaseClass.mBase` and `tChildClassA.mA`. Because
    `tChildClassB` doesn''t define any new methods or iterators, `tChildClassB`''s
    virtual method table contains only a single entry, a pointer to the `tBaseClass.mBase`
    method. Note that `tChildClassB`''s virtual method table is identical to `tBaseclass`''s
    table. Nevertheless, HLA produces two distinct virtual method tables. This is
    a critical fact that we will make use of a little later. [Figure 12-8](ch12s08.html#virtual_method_tables_for_inherited_clas
    "Figure 12-8. Virtual method tables for inherited classes") shows the relationship
    between these virtual method tables.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Virtual method tables for inherited classes](tagoreillycom20100401nostarchimages578095.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-8. Virtual method tables for inherited classes
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the virtual method table pointer always appears at offset 0 in an
    object (and, therefore, you can access the pointer using the address expression
    `[ESI]` if ESI points at an object), HLA actually inserts a symbol into the symbol
    table so you may refer to the virtual method table pointer symbolically. The symbol
    `_pVMT_` (pointer to virtual method table) provides this capability. So a more
    readable way to access the pointer (as in the previous code example) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you need to access the virtual method table directly, there are a couple
    of ways to do this. Whenever you declare a class object, HLA automatically includes
    a field named `_VMT_` as part of that class. `_VMT_` is a static array of double-word
    objects. Therefore, you may refer to the virtual method table using an identifier
    of the form *`classname`*`._VMT_`. Generally, you shouldn't access the virtual
    method table directly, but as you'll see shortly, there are some good reasons
    why you need to know the address of this object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 12.9 Constructors and Object Initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've tried to get a little ahead of the game and write a program that uses
    objects prior to this point, you've probably discovered that the program inexplicably
    crashes whenever you attempt to run it. We've covered a lot of material in this
    chapter thus far, but you are still missing one crucial piece of information—how
    to properly initialize objects prior to use. This section will put the final piece
    into the puzzle and allow you to begin writing programs that use classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following object declaration and code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that variables you declare in the `var` section are uninitialized
    at runtime. Therefore, when the program containing these statements gets around
    to executing `bc.mBase`, it executes the three-statement sequence you''ve seen
    several times already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this sequence is that it loads EDI with an undefined value
    assuming you haven''t previously initialized the `bc` object. Because EDI contains
    a garbage value, attempting to call a subroutine at address `[EDI+@offset(tBaseClass.mBase)]`
    will likely crash the system. Therefore, before using an object, you must initialize
    the `_pVMT_` field with the address of that object''s virtual method table. One
    easy way to do this is with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Always remember, before using an object, be sure to initialize the virtual method
    table pointer for that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you must initialize the virtual method table pointer for all objects
    you use, this may not be the only field you need to initialize in those objects.
    Each specific class may have its own application-specific initialization. Although
    the initialization may vary by class, you need to perform the same initialization
    on each object of a specific class that you use. If you ever create more than
    a single object from a given class, it is probably a good idea to create a procedure
    to do this initialization for you. This is such a common operation that object-oriented
    programmers have given these initialization procedures a special name: *constructors*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some object-oriented languages (e.g., C++) use a special syntax to declare
    a constructor. Others (e.g., Delphi) simply use existing procedure declarations
    to define a constructor. One advantage to employing a special syntax is that the
    language knows when you define a constructor and can automatically generate code
    to call that constructor for you (whenever you declare an object). Languages like
    Delphi require that you explicitly call the constructor; this can be a minor inconvenience
    and a source of defects in your programs. HLA does not use a special syntax to
    declare constructors: you define constructors using standard class procedures.
    Thus, you will need to explicitly call the constructors in your program; however,
    you''ll see an easy method for automating this in [12.11 HLA''s _initialize_ and
    _finalize_ Strings](ch12s11.html "12.11 HLA''s _initialize_ and _finalize_ Strings").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most important fact you must remember is that *constructors must
    be class procedures*. You must not define constructors as methods. The reason
    is quite simple: one of the tasks of the constructor is to initialize the pointer
    to the virtual method table, and you cannot call a class method or iterator until
    after you''ve initialized the `VMT` pointer. Because class procedures don''t use
    the virtual method table, you can call a class procedure prior to initializing
    the `VMT` pointer for an object.'
  prefs: []
  type: TYPE_NORMAL
- en: By convention, HLA programmers use the name `create` for the class constructor.
    There is no requirement that you use this name, but by doing so you will make
    your programs easier to read and follow by other programmers.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, you can call a class procedure via an object reference or
    a class reference. For example, if `clsProc` is a class procedure of class `tClass`
    and `Obj` is an object of type `tClass`, then the following two class procedure
    invocations are both legal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There is a big difference between these two calls. The first one calls `clsProc`
    with ESI containing 0 (NULL), while the second invocation loads the address of
    `Obj` into ESI before the call. We can use this fact to determine within a method
    the particular calling mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 12.9.1 Dynamic Object Allocation Within the Constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As it turns out, most programs allocate objects dynamically using `mem.alloc`
    and refer to those objects indirectly using pointers. This adds one more step
    to the initialization process—allocating storage for the object. The constructor
    is the perfect place to allocate this storage. Because you probably won''t need
    to allocate all objects dynamically, you''ll need two types of constructors: one
    that allocates storage and then initializes the object, and another that simply
    initializes an object that already has storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another constructor convention is to merge these two constructors into a single
    constructor and differentiate the type of constructor call by the value in ESI.
    On entry into the class''s `create` procedure, the program checks the value in
    ESI to see if it contains NULL (0). If so, the constructor calls `mem.alloc` to
    allocate storage for the object and returns a pointer to the object in ESI. If
    ESI does not contain NULL upon entry into the procedure, then the constructor
    assumes that ESI points at a valid object and skips over the memory allocation
    statements. At the very least, a constructor initializes the pointer to the virtual
    method table; therefore, the minimalist constructor will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After you write a constructor like the preceding, you choose an appropriate
    calling mechanism based on whether your object''s storage is already allocated.
    For preallocated objects (such as those you''ve declared in `var`, `static`, or
    `storage` sections^([[138](#ftn.CHP-12-FN-7)]) or those you''ve previously allocated
    storage for via `mem.alloc`), you simply load the address of the object into ESI
    and call the constructor. For those objects you declare as a variable, this is
    very easy; just call the appropriate `create` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that although `bcp` is a pointer to a `tBaseClass` object, the create
    method does not automatically allocate storage for this object. The program already
    allocated the storage earlier. Therefore, when the program calls `bcp.create`,
    it loads ESI with the address contained within `bcp`; because this is not NULL,
    the `tBaseClass.create` procedure does not allocate storage for a new object.
    By the way, the call to `bcp.create` emits the following sequence of machine instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Until now, the code examples for a class procedure call always began with an
    `lea` instruction. This is because all the examples to this point have used object
    variables rather than pointers to object variables. Remember, a class procedure
    (method) call passes the address of the object in the ESI register. For object
    variables HLA emits an `lea` instruction to obtain this address. For pointers
    to objects, however, the actual object address is the *value* of the pointer variable;
    therefore, to load the address of the object into ESI, HLA emits a `mov` instruction
    that copies the value of the pointer into the ESI register.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the program preallocates the storage for an object
    prior to calling the object constructor. While there are several reasons for preallocating
    object storage (for example, you''re creating a dynamic array of objects), you
    can achieve most simple object allocations like the one above by calling a standard
    `create` procedure (such as one that allocates storage for an object if ESI contains
    `NULL`). The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Remember, a call to a `tBaseClass.create` constructor returns a pointer to the
    new object in the ESI register. It is the caller's responsibility to save the
    pointer this function returns into the appropriate pointer variable; the constructor
    does not automatically do this for you. Likewise, it is the caller's responsibility
    to free the storage associated with this object when the application has finished
    using the object (see the discussion of destructors in [12.10 Destructors](ch12s10.html
    "12.10 Destructors")).
  prefs: []
  type: TYPE_NORMAL
- en: 12.9.2 Constructors and Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructors for derived (child) classes that inherit fields from a base class
    represent a special case. Each class must have its own constructor but needs the
    ability to call the base class constructor. This section explains the reasons
    for this and how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: A derived class inherits the `create` procedure from its base class. However,
    you must override this procedure in a derived class because the derived class
    probably requires more storage than the base class, and therefore you will probably
    need to use a different call to `mem.alloc` to allocate storage for a dynamic
    object. Hence, it is very unusual for a derived class not to override the definition
    of the `create` procedure.
  prefs: []
  type: TYPE_NORMAL
- en: However, overriding a base class's `create` procedure has problems of its own.
    When you override the base class's `create` procedure, you take the full responsibility
    of initializing the (entire) object, including all the initialization required
    by the base class. At the very least, this involves putting duplicate code in
    the overridden procedure to handle the initialization usually done by the base
    class constructor. In addition to making your program larger (by duplicating code
    already present in the base class constructor), this also violates information-hiding
    principles because the derived class must be aware of all the fields in the base
    class (including those that are logically private to the base class). What we
    need here is the ability to call a base class's constructor from within the derived
    class's constructor and let that call do the lower-level initialization of the
    base class's fields. Fortunately, this is an easy thing to do in HLA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following class declarations (which do things the hard way):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a closer look at the `tDerived.create` procedure above. Like a conventional
    constructor, it begins by checking ESI and allocates storage for a new object
    if ESI contains NULL. Note that the size of a `tDerived` object includes the size
    required by the inherited fields, so this properly allocates the necessary storage
    for all fields in a `tDerived` object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `tDerived.create` procedure initializes the `VMT` pointer field of
    the object. Remember, each class has its own `virtual method table` and, specifically,
    derived classes do not use the `virtual method table` of their base class. Therefore,
    this constructor must initialize the `_pVMT_` field with the address of the `tDerived
    virtual method table`.
  prefs: []
  type: TYPE_NORMAL
- en: After initializing the `virtual method table` pointer, the `tDerived` constructor
    initializes the value of the `r` field to 0.0 (remember, `fldz` loads 0 onto the
    FPU stack). This concludes the `tDerived`-specific initialization.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining instructions in `tDerived.create` are the problem. These statements
    duplicate some of the code appearing in the `tBase.create` procedure. The problem
    with code duplication becomes apparent when you decide to modify the initial values
    of these fields; if you've duplicated the initialization code in derived classes,
    you will need to change the initialization code in more than one `create` procedure.
    More often than not, however, this results in defects in the derived class `create`
    procedures, especially if those derived classes appear in different source files
    than the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with burying base class initialization in derived class constructors
    is the violation of the information-hiding principle. Some fields of the base
    class may be *logically private*. Although HLA does not explicitly support the
    concept of public and private fields in a class (as, say, C++ does), well-disciplined
    programmers will still partition the fields as private or public and then use
    the private fields only in class routines belonging to that class. Initializing
    these private fields in derived classes is not acceptable to such programmers.
    Doing so will make it very difficult to change the definition and implementation
    of some base class at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, HLA provides an easy mechanism for calling the inherited constructor
    within a derived class's constructor. All you have to do is call the base constructor
    using the class name syntax; for example, you could call `tBase.create` directly
    from within `tDerived.create`. By calling the base class constructor, your derived
    class constructors can initialize the base class fields without worrying about
    the exact implementation (or initial values) of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there are two types of initialization that every (conventional)
    constructor does that will affect the way you call a base class constructor: All
    conventional constructors allocate memory for the class if ESI contains 0, and
    all conventional constructors initialize the `VMT` pointer. Fortunately, it is
    very easy to deal with these two problems.'
  prefs: []
  type: TYPE_NORMAL
- en: The memory required by an object of some base class is usually less than the
    memory required for an object of a class you derive from that base class (because
    the derived classes usually add more fields). Therefore, you cannot allow the
    base class constructor to allocate the storage when you call it from inside the
    derived class's constructor. You can easily solve this problem by checking ESI
    within the derived class constructor and allocating any necessary storage for
    the object *before* calling the base class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is the initialization of the `VMT` pointer. When you call
    the base class's constructor, it will initialize the `VMT` pointer with the address
    of the base class's virtual method table. A derived class object's `_pVMT_` field,
    however, must point at the virtual method table for the derived class. Calling
    the base class constructor will always initialize the `_pVMT_` field with the
    wrong pointer. To properly initialize the `_pVMT_` field with the appropriate
    value, the derived class constructor must store the address of the derived class's
    virtual method table into the `_pVMT_` field *after* the call to the base class
    constructor (so that it overwrites the value written by the base class constructor).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tDerived.create` constructor, rewritten to call the `tBase.create` constructors,
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This solution solves all the above concerns with derived class constructors.
    Note that the call to the base constructor uses the syntax `(type tBase [esi]).create();`
    rather than `tBase.create();`. The problem with calling `tBase.create` directly
    is that it will load `NULL` into ESI and overwrite the pointer to the storage
    allocated in `tDerived.create`. The scheme above uses the existing value in ESI
    when calling `tBase.create`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.9.3 Constructor Parameters and Procedure Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: None of the constructor examples to this point have had any parameters. However,
    there is nothing special about constructors that prevents the use of parameters.
    Constructors are procedures; therefore, you can specify any number and any type
    of parameters you choose. You can use these parameter values to initialize certain
    fields or control how the constructor initializes the fields. Of course, you may
    use constructor parameters for any purpose you'd use parameters for in any other
    procedure. In fact, about the only issue you need concern yourself with is the
    use of parameters whenever you have a derived class. This section deals with those
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first, and probably most important, problem with parameters in derived
    class constructors actually applies to all overridden procedures and methods:
    The parameter list of an overridden routine must exactly match the parameter list
    of the corresponding routine in the base class. In fact, HLA doesn''t even give
    you the chance to violate this rule because `override` routine prototypes don''t
    allow parameter list declarations: They automatically inherit the parameter list
    of the base routine. Therefore, you cannot use a special parameter list in the
    constructor prototype for one class and a different parameter list for the constructors
    appearing in base or derived classes. Sometimes it would be nice if this weren''t
    the case, but there are some sound and logical reasons why HLA does not support
    this.^([[139](#ftn.CHP-12-FN-8)])'
  prefs: []
  type: TYPE_NORMAL
- en: HLA supports a special `overloads` declaration that lets you call one of several
    different procedures, methods, or iterators using a single identifier (with the
    number of types of parameters specifying which function to call). This would allow
    you, for example, to create multiple constructors for a given class (or derived
    class) and invoke the desired constructor using a matching parameter list for
    that constructor. Interested readers should consult the chapter on procedures
    in the HLA documentation for more details concerning the `overloads` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[138](#CHP-12-FN-7)]) You generally do not declare objects in `readonly`
    sections because you cannot initialize them.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[139](#CHP-12-FN-8)]) Calling virtual methods and iterators would be a real
    problem because you don't really know which routine a pointer references. Therefore,
    you couldn't know the proper parameter list. While the problems with procedures
    aren't quite as drastic, there are some subtle problems that could creep into
    your code if base or derived classes allowed overridden procedures with different
    parameter lists.
  prefs: []
  type: TYPE_NORMAL
- en: 12.10 Destructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *destructor* is a class routine that cleans up an object once a program finishes
    using that object. As for constructors, HLA does not provide a special syntax
    for creating destructors, nor does HLA automatically call a destructor. Unlike
    constructors, a destructor is usually a method rather than a procedure (because
    virtual destructors make a lot of sense, whereas virtual constructors do not).
  prefs: []
  type: TYPE_NORMAL
- en: A typical destructor might close any files opened by the object, free the memory
    allocated during the use of the object, and, finally, free the object itself if
    it was created dynamically. The destructor also handles any other cleanup chores
    the object may require before it ceases to exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'By convention, most HLA programmers name their destructors `destroy`. About
    the only code that most destructors have in common is the code to free the storage
    associated with the object. The following destructor demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The HLA Standard Library routine `mem.isInHeap` returns true if its parameter
    is an address that `mem.alloc` returned. Therefore, this code automatically frees
    the storage associated with the object if the program originally allocated storage
    for the object by calling `mem.alloc`. Obviously, on return from this method call,
    ESI will no longer point at a legal object in memory if you allocated it dynamically.
    Note that this code will not affect the value in ESI nor will it modify the object
    if the object wasn't one you've previously allocated via a call to `mem.alloc`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.11 HLA's _initialize_ and _finalize_ Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although HLA does not automatically call constructors and destructors associated
    with your classes, HLA does provide a mechanism whereby you can force HLA to automatically
    emit these calls: by using the `_initialize_` and `_finalize_` compile-time string
    variables (i.e., `val` constants) that HLA automatically declares in every procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you write a procedure, iterator, or method, HLA automatically declares
    several local symbols in that routine. Two such symbols are `_initialize_` and
    `_finalize_`. HLA declares these symbols as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'HLA emits the `_initialize_` string as text at the very beginning of the routine''s
    body, that is, immediately after the routine''s `begin` clause.^([[140](#ftn.CHP-12-FN-9)])
    Similarly, HLA emits the `_finalize_` string at the very end of the routine''s
    body, just before the `end` clause. This is comparable to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `_initialize_` and `_finalize_` initially contain the empty string,
    these expansions have no effect on the code that HLA generates unless you explicitly
    modify the value of `_initialize_` prior to the `begin` clause or you modify `_finalize_`
    prior to the `end` clause of the procedure. So if you modify either of these string
    objects to contain a machine instruction, HLA will compile that instruction at
    the beginning or end of the procedure. The following example demonstrates how
    to use this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Of course, these examples don't save you much. It would be easier to type the
    actual statements at the beginning and end of the procedure than to assign a string
    containing these statements to the `_initialize_` and `_finalize_` compile-time
    variables. However, if we could automate the assignment of some string to these
    variables, so that we don't have to explicitly assign them in each procedure,
    then this feature might be useful. In a moment, you'll see how we can automate
    the assignment of values to the `_initialize_` and `_finalize_` strings. For the
    time being, consider the case where we load the name of a constructor into the
    `_initialize_` string and we load the name of a destructor in to the `_finalize_`
    string. By doing this, the routine will "automatically" call the constructor and
    destructor for that particular object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example has a minor problem. If we can automate the assignment
    of some value to `_initialize_` or `_finalize_`, what happens if these variables
    already contain some value? For example, suppose we have two objects we use in
    a routine, and the first one loads the name of its constructor into the `_initialize_`
    string; what happens when the second object attempts to do the same thing? The
    solution is simple: Don''t directly assign any string to the `_initialize_` or
    `_finalize_` compile-time variables; instead, always concatenate your strings
    to the end of the existing string in these variables. The following is a modification
    to the above example that demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When you assign values to the `_initialize_` and `_finalize_` strings, HLA guarantees
    that the `_initialize_` sequence will execute upon entry into the routine. Sadly,
    the same is not true for the `_finalize_` string upon exit. HLA simply emits the
    code for the `_finalize_` string at the end of the routine, immediately before
    the code that cleans up the activation record and returns. Unfortunately, "falling
    off the end of the routine" is not the only way that you could return from that
    routine. You could explicitly return from somewhere in the middle of the code
    by executing a `ret` instruction. Because HLA emits the `_finalize_` string only
    at the very end of the routine, returning from that routine in this manner bypasses
    the `_finalize_` code. Unfortunately, other than manually emitting the `_finalize_`
    code, there is nothing you can do about this.^([[141](#ftn.CHP-12-FN-10)]) Fortunately,
    this mechanism for exiting a routine is completely under your control. If you
    never exit a routine except by "falling off the end," then you won't have to worry
    about this problem (note that you can use the `exit` control structure to transfer
    control to the end of a routine if you really want to return from that routine
    from somewhere in the middle of the code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to prematurely exit a routine, over which, unfortunately, you don''t
    have any control, is by raising an exception. Your routine could call some other
    routine (e.g., a Standard Library routine) that raises an exception and then transfers
    control immediately to whomever called your routine. Fortunately, you can easily
    trap and handle exceptions by putting a `try..endtry` block in your procedure.
    Here is an example that demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Although the previous code handles some problems that exist with `_finalize_`,
    by no means does it handle every possible case. Always be on the lookout for ways
    your program could inadvertently exit a routine without executing the code found
    in the `_finalize_` string. You should explicitly expand `_finalize_` if you encounter
    such a situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important place you can get into trouble with respect to exceptions:
    within the code the routine emits for the `_initialize_` string. If you modify
    the `_initialize_` string so that it contains a constructor call and the execution
    of that constructor raises an exception, this will probably force an exit from
    that routine without executing the corresponding `_finalize_` code. You could
    bury the `try..endtry` statement directly into the `_initialize_` and `_finalize_`
    strings, but this approach has several problems, not the least of which is the
    fact that one of the first constructors you call might raise an exception that
    transfers control to the exception handler that calls the destructors for all
    objects in that routine (including those objects whose constructors you have yet
    to call). Although no single solution that handles all problems exists, probably
    the best approach is to put a `try..endtry` block within each constructor call
    if it is possible for that constructor to raise some exception that is possible
    to handle (that is, doesn''t require the immediate termination of the program).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus far this discussion of `_initialize_` and `_finalize_` has failed to address
    one important point: Why use this feature to implement the "automatic" calling
    of constructors and destructors, because it apparently involves more work than
    simply calling the constructors and destructors directly? Clearly there must be
    a way to automate the assignment of the `_initialize_` and `_finalize_` strings
    or this section wouldn''t exist. The way to accomplish this is by using a macro
    to define the class type. So now it''s time to take a look at another HLA feature
    that makes it possible to automate this activity: the `forward` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ve seen how to use the `forward` reserved word to create procedure prototypes
    (see the discussion in [5.9 Forward Procedures](ch05s09.html "5.9 Forward Procedures"));
    it turns out that you can declare forward `const`, `val`, `type`, and variable
    declarations as well. The syntax for such declarations takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration is completely equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Especially note that this expansion does not actually define the symbol *`ForwardSymbolName`*.
    It just converts this symbol to a string and assigns this string to the specified
    `text` object *`undefinedID`*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you''re probably wondering how something like the above is equivalent to
    a forward declaration. The truth is, it isn''t. However, forward declarations
    let you create macros that simulate type names by allowing you to defer the actual
    declaration of an object''s type until some later point in the code. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, and this is very important, that a semicolon does not follow the `varID:
    myClass` declaration at the end of this macro. You''ll find out why this semicolon
    is missing in a little while.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have the above class and macro declarations in your program, you can
    now declare variables of type `_myClass` that automatically invoke the constructor
    and destructor upon entry and exit of the routine containing the variable declarations.
    To see how, take a look at the following procedure shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `_myClass` is a macro, the procedure above expands to the following
    text during compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You might notice that a semicolon appears after the `mco: myClass` declaration
    in the example above. This semicolon is not actually a part of the macro; instead
    it is the semicolon that follows the `mco: _myClass;` declaration in the original
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create an array of objects, you could legally declare that array
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the last statement in the `_myClass` macro doesn''t end with a semicolon,
    the declaration above will expand to something like the following (almost correct)
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The only problem with this expansion is that it calls the constructor only for
    the first object of the array. There are several ways to solve this problem; one
    is to append a macro name to the end of `_initialize_` and `_finalize_` rather
    than the constructor name. That macro would check the object's name (`mcoArray`
    in this example) to determine if it is an array. If so, that macro could expand
    to a loop that calls the constructor for each element of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution to this problem is to use a macro parameter to specify the
    dimensions for arrays of `myClass`. This scheme is easier to implement than the
    one above, but it does have the drawback of requiring a different syntax for declaring
    object arrays (you have to use parentheses rather than square brackets around
    the array dimension).
  prefs: []
  type: TYPE_NORMAL
- en: The `forward` directive is quite powerful and lets you achieve all kinds of
    tricks. However, there are a few problems of which you should be aware. First,
    because HLA emits the `_initialize_` and `_finalize_` code transparently, you
    can be easily confused if there are any errors in the code appearing within these
    strings. If you start getting error messages associated with the `begin` or `end`
    statements in a routine, you might want to take a look at the `_initialize_` and
    `_finalize_` strings within that routine. The best defense here is to always append
    very simple statements to these strings so that you reduce the likelihood of an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fundamentally, HLA doesn''t support automatic constructor and destructor calls.
    This section has presented several tricks to attempt to automate the calls to
    these routines. However, the automation isn''t perfect and, indeed, the aforementioned
    problems with the `_finalize_` strings limit the applicability of this approach.
    The mechanism this section presents is probably fine for simple classes and simple
    programs. One piece of advice is probably worth following: If your code is complex
    or correctness is critical, it''s probably a good idea to explicitly call the
    constructors and destructors manually.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[140](#CHP-12-FN-9)]) If the routine automatically emits code to construct
    the activation record, HLA emits `_initialize_`'s text after the code that builds
    the activation record.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[141](#CHP-12-FN-10)]) Note that you can manually emit the `_finalize_` code
    using the statement `@text( _finalize_ );`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.12 Abstract Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An *abstract base class* is one that exists solely to supply a set of common
    fields to its derived classes. You never declare variables whose type is an abstract
    base class; you always use one of the derived classes. The purpose of an abstract
    base class is to provide a template for creating other classes, nothing more.
    As it turns out, the only difference in syntax between a standard base class and
    an abstract base class is the presence of at least one *abstract method* declaration.
    An abstract method is a special method that does not have an actual implementation
    in the abstract base class. Any attempt to call that method will raise an exception.
    If you're wondering what possible good an abstract method could be, keep on reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to create a set of classes to hold numeric values. One class
    could represent unsigned integers, another class could represent signed integers,
    a third could implement BCD values, and a fourth could support `real64` values.
    While you could create four separate classes that function independently of one
    another, doing so passes up an opportunity to make this set of classes more convenient
    to use. To understand why, consider the following possible class declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of these classes is not unreasonable. They have fields for
    the data and they have a `put` method (which, presumably, writes the data to the
    standard output device). They probably have other methods and procedures to implement
    various operations on the data. There are, however, two problems with these classes,
    one minor and one major, both occurring because these classes do not inherit any
    fields from a common base class.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem, which is relatively minor, is that you have to repeat the
    declaration of several common fields in these classes. For example, the `put`
    method declaration appears in each of these classes.^([[142](#ftn.CHP-12-FN-11)])
    This duplication of effort results in a harder-to-maintain program because it
    doesn't encourage you to use a common name for a common function since it's easy
    to use a different name in each of the classes.
  prefs: []
  type: TYPE_NORMAL
- en: A bigger problem with this approach is that it is not generic. That is, you
    can't create a generic pointer to a "numeric" object and perform operations like
    addition, subtraction, and output on that value (regardless of the underlying
    numeric representation).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily solve these two problems by turning the previous class declarations
    into a set of derived classes. The following code demonstrates an easy way to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This scheme solves both the problems. First, by inheriting the `put` method
    from numeric, this code encourages the derived classes to always use the name
    *`put`*, thereby making the program easier to maintain. Second, because this example
    uses derived classes, it's possible to create a pointer to the `numeric` type
    and load this pointer with the address of a `uint`, `sint`, or `r64` object. That
    pointer can invoke the methods found in the `numeric` class to do functions like
    addition, subtraction, or numeric output. Therefore, the application that uses
    this pointer doesn't need to know the exact data type; it deals with numeric values
    only in a generic fashion.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with this scheme is that it's possible to declare and use variables
    of type `numeric`. Unfortunately, such numeric variables don't have the ability
    to represent any type of number (notice that the data storage for the numeric
    fields actually appears in the derived classes). Worse, because you've declared
    the `put` method in the `numeric` class, you actually have to write some code
    to implement that method even though you should never really call it; the actual
    implementation should occur only in the derived classes. While you could write
    a dummy method that prints an error message (or, better yet, raises an exception),
    there shouldn't be any need to write "dummy" procedures like this. Fortunately,
    there is no reason to do so—if you use *abstract* methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `abstract` keyword, when it follows a method declaration, tells HLA that
    you are not going to provide an implementation of the method for this class. Instead,
    it is the responsibility of all derived classes to provide a concrete implementation
    for the abstract method. HLA will raise an exception if you attempt to call an
    abstract method directly. The following is the modification to the `numeric` class
    to convert `put` to an abstract method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: An abstract base class is a class that has at least one abstract method. Note
    that you don't have to make all methods abstract in an abstract base class; it
    is perfectly legal to declare some standard methods (and, of course, provide their
    implementation) within the abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract method declarations provide a mechanism by which a base class can specify
    some generic methods that the derived classes must implement. In theory, all derived
    classes must provide concrete implementations of all abstract methods, or those
    derived classes are themselves abstract base classes. In practice, it's possible
    to bend the rules a little and use abstract methods for a slightly different purpose.
  prefs: []
  type: TYPE_NORMAL
- en: A little earlier, you read that you should never create variables whose type
    is an abstract base class. If you attempt to execute an abstract method, the program
    would immediately raise an exception to complain about this illegal method call.
    In practice, you actually can declare variables of an abstract base type and get
    away with this as long as you don't call any abstract methods in that class.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[142](#CHP-12-FN-11)]) Note, by the way, that `TheValue` is not a common
    field because this field has a different type in the `r64` class.
  prefs: []
  type: TYPE_NORMAL
- en: 12.13 Runtime Type Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with an object variable (as opposed to a pointer to an object),
    the type of that object is obvious: It''s the variable''s declared type. Therefore,
    at both compile time and runtime the program knows the type of the object. When
    working with pointers to objects you cannot, in the general case, determine the
    type of an object a pointer references. However, at runtime it is possible to
    determine the object''s actual type. This section discusses how to detect the
    underlying object''s type and how to use this information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a pointer to an object and that pointer''s type is some base class,
    at runtime the pointer could point at an object of the base class or any derived
    type. At compile time it is not possible to determine the exact type of an object
    at any instant. To see why, consider the following short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The routine *`ReturnSomeObject`* returns a pointer to an object in ESI. This
    could be the address of some base class object or a derived class object. At compile
    time there is no way for the program to know what type of object this function
    returns. For example, *`ReturnSomeObject`* could ask the user what value to return
    so the exact type could not be determined until the program actually runs and
    the user makes a selection.
  prefs: []
  type: TYPE_NORMAL
- en: In a perfectly designed program, there probably is no need to know a generic
    object's actual type. After all, the whole purpose of object-oriented programming
    and inheritance is to produce general programs that work with lots of different
    objects without having to make substantial changes to the program. In the real
    world, however, programs may not have a perfect design, and sometimes it's nice
    to know the exact object type a pointer references. Runtime type information,
    or RTTI, gives you the capability of determining an object's type at runtime,
    even if you are referencing that object using a pointer to some base class of
    that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most fundamental RTTI operation you need is the ability to ask
    if a pointer contains the address of some specific object type. Many object-oriented
    languages (e.g., Delphi) provide an `is` operator that provides this functionality.
    `is` is a boolean operator that returns true if its left operand (a pointer) points
    at an object whose type matches the right operand (which must be a type identifier).
    The typical syntax is generally the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This operator returns true if the variable is of the specified class; it returns
    false otherwise. Here is a typical use of this operator (in the Delphi language):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s actually quite simple to implement this functionality in HLA. As you
    may recall, each class is given its own virtual method table. Whenever you create
    an object, you must initialize the pointer to the virtual method table with the
    address of that class''s virtual method table. Therefore, the `VMT` pointer field
    of all objects of a given class type contains the same pointer value, and this
    pointer value is different from the `VMT` pointer field of all other classes.
    We can use this fact to see if an object is some specific type. The following
    code demonstrates how to implement the Delphi statement above in HLA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This `if` statement simply compares the object's `_pVMT_` field (the pointer
    to the virtual method table) against the address of the desired classes' virtual
    method table. If they are equal, then the *`ptrToNumeric`* variable points at
    an object of type `uint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the body of a class method or iterator, there is a slightly easier way
    to see if the object is a certain class. Remember, upon entry into a method or
    an iterator, the EDI register contains the address of the virtual method table.
    Therefore, assuming you haven''t modified EDI''s value, you can easily test to
    see if the method or iterator is a specific class type using an `if` statement
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Remember, however, that EDI will contain a pointer to the virtual method table
    only when you call a class method. This is not the case when calling a class procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 12.14 Calling Base Class Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the section on constructors you saw that it is possible to call an ancestor
    class's procedure within the derived class's overridden procedure. To do this,
    all you need to do is to invoke the procedure using the call `(type` *`classname`*
    `[esi]).`*`procedureName`*`(` *`parameters`* `);`. On occasion you may want to
    do this same operation with a class's methods as well as its procedures (that
    is, have an overridden method call the corresponding base class method in order
    to do some computation you'd rather not repeat in the derived class's method).
    Unfortunately, HLA does not let you directly call methods as it does procedures.
    You will need to use an indirect mechanism to achieve this; specifically, you
    will have to call the method using the address in the base class's virtual method
    table. This section describes how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever your program calls a method it does so indirectly, using the address
    found in the virtual method table for the method''s class. The virtual method
    table is nothing more than an array of 32-bit pointers, with each entry containing
    the address of one of that class''s methods. So to call a method, all you need
    is the index into this array (or, more properly, the offset into the array) of
    the address of the method you wish to call. The HLA compile-time function `@offset`
    comes to the rescue: It will return the offset into the virtual method table of
    the method whose name you supply as a parameter. Combined with the `call` instruction,
    you can easily call any method associated with a class. Here''s an example of
    how you would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `call` instruction above calls the method whose address appears at the specified
    entry in the virtual method table for *`myCls`*. The `@offset` function call returns
    the offset (i.e., index times 4) of the address of `myCls.m` within the virtual
    method table. Hence, this code indirectly calls the `m` method by using the virtual
    method table entry for `m`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one major drawback to calling methods using this scheme: You don''t
    get to use the high-level syntax for procedure/method calls. Instead, you must
    use the low-level `call` instruction. In the example above, this isn''t much of
    an issue because the `m` procedure doesn''t have any parameters. If it did have
    parameters, you would have to manually push those parameters onto the stack yourself.
    Fortunately, you''ll rarely need to call ancestor class methods from a derived
    class, so this won''t be much of an issue in real-world programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.15 For More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HLA reference manual at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/) contains additional information
    about HLA's class implementation. Check out this document for additional low-level
    implementation features. This chapter hasn't really attempted to teach the object-oriented
    programming paradigm. See a generic text on object-oriented design for more details
    about this subject.
  prefs: []
  type: TYPE_NORMAL
