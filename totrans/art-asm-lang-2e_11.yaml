- en: Chapter 12. CLASSES AND OBJECTS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 类和对象
- en: '![CLASSES AND OBJECTS](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![类和对象](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: Many modern high-level languages support the notion of classes and objects.
    C++ (an object-oriented version of C), Java, and Delphi (an object-oriented version
    of Pascal) are good examples. Of course, these high-level language compilers translate
    their source code into low-level machine code, so it should be pretty obvious
    that some mechanism exists in machine code for implementing classes and objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代高级语言支持类和对象的概念。C++（C语言的面向对象版本）、Java和Delphi（Pascal的面向对象版本）就是很好的例子。当然，这些高级语言编译器将源代码转换成低级机器代码，所以应该很明显，机器代码中存在某种机制来实现类和对象。
- en: Although it has always been possible to implement classes and objects in machine
    code, most assemblers provide poor support for writing object-oriented assembly
    language programs. HLA does not suffer from this drawback because it provides
    good support for writing object-oriented assembly language programs. This chapter
    discusses the general principles behind object-oriented programming (OOP) and
    how HLA supports OOP.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在机器代码中实现类和对象一直是可能的，但大多数汇编器在编写面向对象的汇编语言程序时提供的支持较差。HLA不会受到这个缺点的影响，因为它为编写面向对象的汇编语言程序提供了良好的支持。本章将讨论面向对象编程（OOP）的基本原则以及HLA如何支持OOP。
- en: 12.1 General Principles
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.1 一般原则
- en: Before discussing the mechanisms behind OOP, it is probably a good idea to take
    a step back and explore the benefits of using OOP (especially in assembly language
    programs). Most texts that describe the benefits of OOP will use buzzwords like
    *code reuse*, *abstract data types*, *improved development efficiency*, and so
    on. While all of these features are nice and are good attributes for a programming
    paradigm, a good software engineer would question the use of assembly language
    in an environment where "improved development efficiency" is an important goal.
    After all, you can probably obtain far better efficiency by using a high-level
    language (even in a non-OOP fashion) than you can by using objects in assembly
    language. If the purported features of OOP don't seem to apply to assembly language
    programming, then why bother using OOP in assembly? This section will explore
    some of those reasons.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论OOP背后的机制之前，最好先退一步，探讨一下使用OOP的好处（尤其是在汇编语言程序中）。大多数描述OOP好处的书籍会使用一些流行词汇，如*代码重用*、*抽象数据类型*、*提高开发效率*等。尽管这些特性都很不错，是编程范式的优点，但一个好的软件工程师会质疑在“提高开发效率”是重要目标的环境中使用汇编语言。毕竟，使用高级语言（即使不是OOP方式）比在汇编语言中使用对象可能更能获得更好的效率。如果OOP的声称特性似乎不适用于汇编语言编程，那么为什么还要在汇编中使用OOP呢？本节将探讨一些这些原因。
- en: The first thing you should realize is that the use of assembly language does
    not negate the aforementioned OOP benefits. OOP in assembly language does promote
    code reuse. It provides a good method for implementing abstract data types, and
    it can improve development efficiency *in assembly language*. In other words,
    if you're dead set on using assembly language, there are benefits to using OOP.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要意识到的是，使用汇编语言并不会否定上述的OOP好处。汇编语言中的OOP确实促进了代码重用。它提供了一种实现抽象数据类型的好方法，而且它能够*提高汇编语言中的开发效率*。换句话说，如果你坚定地想使用汇编语言，那么使用OOP是有好处的。
- en: To understand one of the principle benefits of OOP, consider the concept of
    a global variable. Most programming texts strongly recommend against the use of
    global variables in a program (as does this text). Interprocedural communication
    through global variables is dangerous because it is difficult to keep track of
    all the possible places in a large program that modify a given global object.
    Worse, it is very easy when making enhancements to accidentally reuse a global
    object for something other than its intended purpose; this tends to introduce
    defects into the system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解面向对象编程（OOP）的主要好处之一，可以考虑全局变量的概念。大多数编程书籍强烈建议不要在程序中使用全局变量（本书也是如此）。通过全局变量进行跨过程通信是危险的，因为在大型程序中，很难追踪到所有可能修改给定全局对象的地方。更糟的是，在进行增强时，意外地重新使用全局对象来做原本不打算做的事情是非常容易的；这往往会导致系统出现缺陷。
- en: Despite the well-understood problems with global variables, the semantics of
    global objects (extended lifetimes and accessibility from different procedures)
    are absolutely necessary in various situations. Objects solve this problem by
    letting the programmer determine the lifetime of an object^([[132](#ftn.CHP-12-FN-1)])
    as well as allowing access to data fields from different procedures. Objects have
    several advantages over simple global variables insofar as objects can control
    access to their data fields (making it difficult for procedures to accidentally
    access the data), and you can also create multiple instances of an object, allowing
    separate sections of your program to use their own unique "global" object without
    interference from other sections.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管全局变量存在众所周知的问题，全局对象的语义（延长的生命周期和来自不同过程的可访问性）在各种情况下绝对是必要的。对象通过让程序员确定对象的生命周期^([[132](#ftn.CHP-12-FN-1)])以及允许从不同过程访问数据字段来解决这个问题。在许多方面，对象比简单的全局变量有几个优势，因为对象可以控制对它们的数据字段的访问（使得过程无意中访问数据变得困难），而且你还可以创建对象的多个实例，允许程序的不同部分使用自己独特的“全局”对象而不受其他部分的干扰。
- en: Of course, objects have many other valuable attributes. One could write several
    volumes on the benefits of objects and OOP; this single chapter cannot do the
    subject justice. This chapter presents objects with an eye toward using them in
    HLA/assembly programs. However, if you are new to OOP or wish more information
    about the object-oriented paradigm, you should consult other texts on this subject.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对象还具有许多其他宝贵的特性。关于对象和面向对象编程的好处，可以写下几卷书来讨论；这一章节无法全面展示这个主题。本章以在HLA/汇编程序中使用对象为目标。然而，如果你对面向对象编程是新手或者希望获取更多关于面向对象范式的信息，你应该参考其他关于这一主题的文献。
- en: An important use for classes and objects is to create *abstract data types (ADTs)*.
    An abstract data type is a collection of data objects and the functions (which
    we'll call *methods*) that operate on the data. In a pure abstract data type,
    the ADT's methods are the only code that has access to the data fields of the
    ADT; external code may access the data only by using function calls to get or
    set data field values (these are the ADT's *accessor* methods). In real life,
    for efficiency reasons, most languages that support ADTs allow at least limited
    access to the data fields of an ADT by external code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类和对象的一个重要用途是创建*抽象数据类型（ADT）*。抽象数据类型是数据对象的集合，以及操作这些数据的函数（我们称之为*方法*）。在纯粹的抽象数据类型中，ADT的方法是唯一能够访问ADT数据字段的代码；外部代码只能通过函数调用来获取或设置数据字段的值（这些是ADT的*访问器*方法）。在现实生活中，出于效率的原因，大多数支持ADT的语言允许外部代码至少有限地访问ADT的数据字段。
- en: Assembly language is not a language most people associate with ADTs. Nevertheless,
    HLA provides several features to allow the creation of rudimentary ADTs. While
    some might argue that HLA's facilities are not as complete as those in a language
    such as C++ or Java, keep in mind that these differences exist because HLA is
    an assembly language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言并不是大多数人与ADT关联的语言。尽管如此，HLA提供了几个功能来允许创建基本的ADT。虽然有些人可能会认为HLA的功能不如像C++或Java这样的语言完整，但要记住，这些差异存在是因为HLA是一种汇编语言。
- en: True ADTs should support *information hiding*. This means that the ADT does
    not allow the user of an ADT access to internal data structures and routines that
    manipulate those structures. In essence, information hiding restricts ADT access
    to the ADT's accessor methods. Assembly language, of course, provides very few
    restrictions. If you are dead set on accessing an object directly, there is very
    little HLA can do to prevent you from doing this. However, HLA has some facilities
    that will provide a limited form of information hiding. Combining these with some
    care on your part, you will be able to enjoy many of the benefits of information
    hiding within your programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的ADT应该支持*信息隐藏*。这意味着ADT不允许ADT的用户访问内部数据结构和操作这些结构的例程。实质上，信息隐藏将ADT的访问限制为ADT的访问器方法。当然，汇编语言提供的限制非常少。如果你坚决要直接访问一个对象，HLA几乎无法阻止你这样做。然而，HLA提供了一些设施，可以提供一种有限形式的信息隐藏。结合你的一些注意，你将能够在你的程序中享受信息隐藏的许多好处。
- en: 'The primary facilities HLA provides to support information hiding are separate
    compilation, linkable modules, and the `#include/#includeonce` directives. For
    our purposes, an abstract data type definition will consist of two sections: an
    *interface* section and an *implementation* section.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HLA提供的主要支持信息隐藏的功能包括单独编译、可链接模块和`#include/#includeonce`指令。为了我们的目的，抽象数据类型定义将由两个部分组成：*接口*部分和*实现*部分。
- en: The interface section contains the definitions that must be visible to the application
    program. In general, it should not contain any specific information that would
    allow the application program to violate the information-hiding principle, but
    this is often impossible given the nature of assembly language. Nevertheless,
    you should attempt to reveal only what is absolutely necessary within the interface
    section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接口部分包含必须对应用程序可见的定义。通常，它不应包含任何允许应用程序违反信息隐藏原则的特定信息，但考虑到汇编语言的性质，这通常是不可能的。尽管如此，你应尽量仅在接口部分公开绝对必要的信息。
- en: The implementation section contains the code, data structures, and so on to
    actually implement the ADT. While some of the methods and data types appearing
    in the implementation section may be public (by virtue of appearance within the
    interface section), many of the subroutines, data items, and so on will be private
    to the implementation code. The implementation section is where you hide all the
    details from the application program.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实现部分包含实际实现ADT的代码、数据结构等。虽然实现部分中出现的一些方法和数据类型可能是公共的（由于出现在接口部分），但许多子程序、数据项等将是实现代码私有的。实现部分是你隐藏所有细节的地方，避免暴露给应用程序。
- en: If you wish to modify the abstract data type at some point in the future, you
    will only have to change the interface and implementation sections. Unless you
    delete some previously visible object that the applications use, there will be
    no need to modify the applications at all.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在未来某个时间修改抽象数据类型，你只需要更改接口和实现部分。除非你删除一些应用程序正在使用的以前可见的对象，否则完全不需要修改应用程序。
- en: Although you could place the interface and implementation sections directly
    in an application program, this would not promote information hiding or maintainability,
    especially if you have to include the code in several different applications.
    The best approach is to place the implementation section in an include file that
    any interested application reads using the HLA `#include` directive and to place
    the implementation section in a separate module that you link with your applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以将接口和实现部分直接放入应用程序中，但这不会促进信息隐藏或可维护性，特别是当你需要在多个不同的应用程序中包含这段代码时。最好的方法是将实现部分放入一个包含文件中，任何需要的应用程序可以使用HLA的`#include`指令读取该文件，并将实现部分放入一个单独的模块中，与你的应用程序链接。
- en: The include file would contain `external` directives, any necessary macros,
    and other definitions you want made public. It generally would not contain 80x86
    code except, perhaps, in some macros. When an application wants to make use of
    an ADT, it would include this file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 包含文件将包含`external`指令、任何必要的宏以及你希望公开的其他定义。通常，它不会包含80x86代码，除非在某些宏中。应用程序如果需要使用ADT，它会包含这个文件。
- en: The separate assembly file containing the implementation section would contain
    all the procedures, functions, data objects, and so on to actually implement the
    ADT. Those names that you want to be public should appear in the interface include
    file and have the `external` attribute. You should also include the interface
    include file in the implementation file so you do not have to maintain two sets
    of `external` directives.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 包含实现部分的单独汇编文件将包含所有的过程、函数、数据对象等，用于实际实现抽象数据类型（ADT）。那些你希望公开的名称应该出现在接口包含文件中，并具有`external`属性。你还应该在实现文件中包含接口包含文件，这样就不需要维护两组`external`指令。
- en: One problem with using procedures for data access methods is the fact that many
    accessor methods are especially trivial (e.g., just a `mov` instruction), and
    the overhead of the call and return instructions is expensive for such trivial
    operations. For example, suppose you have an ADT whose data object is a structure,
    but you do not want to make the field names visible to the application and you
    really do not want to allow the application to access the fields of the data structure
    directly (because the data structure may change in the future). The normal way
    to handle this is to supply a `GetField` method that returns the value of the
    desired field. However, as pointed out above, this can be very slow. An alternative
    for simple access methods is to use a macro to emit the code to access the desired
    field. Although code to directly access the data object appears in the application
    program (via macro expansion), a recompile will automatically update it if you
    ever change the macro in the interface section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过程作为数据访问方法的一个问题是，许多访问方法特别简单（例如，仅一个 `mov` 指令），而调用和返回指令的开销对于这种简单的操作来说是昂贵的。例如，假设你有一个抽象数据类型（ADT），其数据对象是一个结构，但你不希望将字段名称暴露给应用程序，并且你真的不希望允许应用程序直接访问数据结构的字段（因为数据结构可能会在未来发生变化）。处理这种情况的常见方法是提供一个
    `GetField` 方法，该方法返回所需字段的值。然而，如上所述，这可能非常慢。对于简单的访问方法，替代方案是使用宏来生成访问所需字段的代码。尽管直接访问数据对象的代码会出现在应用程序中（通过宏展开），但如果你在接口部分更改宏，重新编译将自动更新它。
- en: 'Although it is quite possible to create ADTs using nothing more than separate
    compilation and, perhaps, records, HLA does provide a better solution: the class.
    Read on to find out about HLA''s support for classes and objects as well as how
    to use these to create ADTs.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管完全可以仅通过单独编译和可能的记录来创建抽象数据类型，但 HLA 提供了更好的解决方案：类。继续阅读，了解 HLA 对类和对象的支持以及如何使用它们来创建抽象数据类型。
- en: '* * *'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[132](#CHP-12-FN-1)]) Lifetime means the time during which the system allocates
    memory for an object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[132](#CHP-12-FN-1)]) 生命周期指的是系统为对象分配内存的时间。
- en: 12.2 Classes in HLA
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.2 HLA 中的类
- en: Fundamentally, a *class* is a record declaration that allows the definition
    of non-data fields (e.g., procedures, constants, and macros). The inclusion of
    other objects in the class definition dramatically expands the capabilities of
    a class. For example, with a class it is now possible to easily define an ADT
    because classes may include data and methods (procedures) that operate on that
    data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，*类* 是一种记录声明，它允许定义非数据字段（例如，过程、常量和宏）。将其他对象包含在类定义中极大地扩展了类的功能。例如，通过类现在可以轻松定义抽象数据类型（ADT），因为类可以包含数据和对数据进行操作的方法（过程）。
- en: 'The principle way to create an abstract data type in HLA is to declare a class
    data type. Classes in HLA always appear in the `type` section and use the following
    syntax:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HLA 中创建抽象数据类型的主要方式是声明一个类数据类型。HLA 中的类总是出现在 `type` 部分，并使用以下语法：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The class declaration section is very similar to the local declaration section
    for a procedure insofar as it allows `const`, `val`, `var`, `storage`, `readonly`,
    `static`, and `proc` variable declaration sections. Classes also let you define
    macros and specify procedure, iterator,^([[133](#ftn.CHP-12-FN-2)]) and *method*
    prototypes (method declarations are legal only in classes). Conspicuously absent
    from this list is the type declaration section. You cannot declare new types within
    a class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明部分与过程的局部声明部分非常相似，它允许声明`const`、`val`、`var`、`storage`、`readonly`、`static` 和
    `proc` 变量。类还允许你定义宏，并指定过程、迭代器、^([[133](#ftn.CHP-12-FN-2)]) 以及 *方法* 原型（方法声明仅在类中合法）。这一列表中显著缺少的是类型声明部分。你不能在类中声明新类型。
- en: A *method* is a special type of procedure that appears only within a class.
    A little later you will see the difference between procedures and methods; for
    now you can treat them as being the same. Other than a few subtle details regarding
    class initialization and the use of pointers to classes, their semantics are identical.^([[134](#ftn.CHP-12-FN-3)])
    Generally, if you don't know whether to use a procedure or method in a class,
    the safest bet is to use a method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法* 是一种特殊类型的过程，只出现在类内部。稍后你将看到过程和方法之间的区别；现在你可以将它们视为相同。除了关于类初始化和使用指向类的指针的几个微妙细节外，它们的语义是相同的。^([[134](#ftn.CHP-12-FN-3)])
    通常，如果你不确定在类中是使用过程还是方法，最安全的选择是使用方法。'
- en: You do not place procedure/iterator/method code within a class. Instead you
    simply supply *prototypes* for these routines. A routine prototype consists of
    the `procedure`, `iterator`, or `method` reserved word, the routine name, any
    parameters, and a couple of optional procedure attributes (`@use`, `@returns`,
    and `external`). The actual routine definition (the body of the routine and any
    local declarations it needs) appears outside the class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要将过程/迭代器/方法代码放在类中。相反，你只需提供这些例程的*原型*。一个例程原型由`procedure`、`iterator`或`method`保留字、例程名称、任何参数以及一些可选的过程属性（`@use`、`@returns`和`external`）组成。实际的例程定义（例程的主体及其所需的任何局部声明）出现在类外部。
- en: 'The following example demonstrates a typical class declaration appearing in
    the `type` section:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了一个典型的类声明，出现在`type`部分：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, classes are very similar to records in HLA. Indeed, you can
    think of a record as being a class that allows only `var` declarations. HLA implements
    classes in a fashion quite similar to records insofar as it allocates sequential
    data fields in sequential memory locations. In fact, with only one minor exception,
    there is almost no difference between a `record` declaration and a `class` declaration
    that has only a `var` declaration section. Later you'll see exactly how HLA implements
    classes, but for now you can assume that HLA implements them the same as it does
    records, and you won't be too far off the mark.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，类与HLA中的记录非常相似。事实上，你可以把记录看作是只允许`var`声明的类。HLA实现类的方式与记录非常相似，因为它将顺序数据字段分配到顺序的内存位置。事实上，除了一个小例外之外，`record`声明和只有`var`声明部分的`class`声明之间几乎没有区别。稍后你将看到HLA是如何实现类的，但现在你可以假设HLA的实现方式与记录相同，这样你就不会偏离主题太远。
- en: 'You can access the `TCvar` and `TCstatic` fields (in the class above) just
    like a record''s fields. You access the `const` and `val` fields in a similar
    manner. If a variable of type `TypicalClass` has the name `obj`, you can access
    the fields of `obj` as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像访问记录的字段一样访问`TCvar`和`TCstatic`字段（如上面的类）。你也可以以类似的方式访问`const`和`val`字段。如果一个`TypicalClass`类型的变量名为`obj`，你可以如下访问`obj`的字段：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If an application program includes the class declaration above, it can create
    variables using the `TypicalClass` type and perform operations using the mentioned
    methods. Unfortunately, the application program can also access the fields of
    the ADT with impunity. For example, if a program created a variable `MyClass`
    of type `TypicalClass`, then it could easily execute instructions like `mov( MyClass.TCvar,
    eax );` even though this field might be private to the implementation section.
    Unfortunately, if you are going to allow an application to declare a variable
    of type `TypicalClass`, the field names will have to be visible. While there are
    some tricks we could play with HLA's class definitions to help hide the private
    fields, the best solution is to thoroughly comment the private fields and then
    exercise some restraint when accessing the fields of that class. Specifically,
    this means that ADTs you create using HLA's classes cannot be "pure" ADTs because
    HLA allows direct access to the data fields. However, with a little discipline,
    you can simulate a pure ADT by simply electing not to access such fields outside
    the class's methods, procedures, and iterators.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序包含上述类声明，它可以使用`TypicalClass`类型创建变量，并使用提到的方法执行操作。不幸的是，应用程序也可以肆意访问该ADT的字段。例如，如果程序创建了一个`TypicalClass`类型的变量`MyClass`，则它可以轻松执行像`mov(
    MyClass.TCvar, eax );`这样的指令，即使该字段可能是实现部分的私有字段。不幸的是，如果你打算允许应用程序声明一个`TypicalClass`类型的变量，字段名称就必须是可见的。虽然我们可以通过一些技巧来隐藏HLA类定义中的私有字段，但最好的解决方案是彻底注释私有字段，并在访问该类的字段时保持一定的克制。具体来说，这意味着你使用HLA的类创建的ADT不能是“纯”ADT，因为HLA允许直接访问数据字段。然而，只要有一些自律，你可以通过简单地选择不在类的方法、过程和迭代器之外访问这些字段来模拟一个纯ADT。
- en: Prototypes appearing in a class are effectively forward declarations. Like normal
    forward declarations, all procedures, iterators, and methods you define in a class
    must have an actual implementation later in the code. Alternately, you may attach
    the `external` option to the end of a procedure, iterator, or method declaration
    within a class to inform HLA that the actual code appears in a separate module.
    As a general rule, class declarations appear in header files and represent the
    interface section of an ADT. The procedure, iterator, and method bodies appear
    in the implementation section, which is usually a separate source file that you
    compile separately and link with the modules that use the class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的原型实际上是前向声明。像普通的前向声明一样，你在类中定义的所有过程、迭代器和方法必须在代码的后面有实际实现。或者，你可以在类中的过程、迭代器或方法声明的末尾附加`external`选项，以通知HLA实际的代码出现在一个单独的模块中。通常，类声明出现在头文件中，并表示ADT的接口部分。过程、迭代器和方法的主体出现在实现部分，通常是一个单独的源文件，你将其单独编译并与使用该类的模块进行链接。
- en: 'The following is an example of a sample class procedure implementation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例类过程实现的例子：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are several differences between a standard procedure declaration and a
    class procedure declaration. First, and most obvious, the procedure name includes
    the class name (e.g., `TypicalClass.TCproc`). This differentiates this class procedure
    definition from a regular procedure that just happens to have the name `TCproc`.
    Note, however, that you do not have to repeat the class name before the procedure
    name in the `begin` and `end` clauses of the procedure (this is similar to procedures
    you define in HLA namespaces).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 标准过程声明和类过程声明之间有几个区别。首先，也是最明显的，过程名称包括类名（例如，`TypicalClass.TCproc`）。这将类过程定义与一个仅恰好叫做`TCproc`的常规过程区分开来。然而请注意，你不需要在过程的`begin`和`end`子句中重复类名（这与在HLA命名空间中定义的过程类似）。
- en: A second difference between class procedures and nonclass procedures is not
    obvious. Some procedure attributes (`@use`, `external`, `@returns`, `@cdecl`,
    `@pascal`, and `@stdcall`) are legal only in the prototype declaration appearing
    within the class, while other attributes (`@noframe`, `@nodisplay`, `@noalignstack`,
    and `@align`) are legal only within the procedure definition and not within the
    class. Fortunately, HLA provides helpful error messages if you stick the option
    in the wrong place, so you don't have to memorize this rule.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类过程和非类过程之间的第二个区别不那么明显。某些过程属性（`@use`、`external`、`@returns`、`@cdecl`、`@pascal`和`@stdcall`）仅在类中的原型声明中合法，而其他属性（`@noframe`、`@nodisplay`、`@noalignstack`和`@align`）仅在过程定义中合法，而不能出现在类中。幸运的是，如果你将选项放在错误的位置，HLA会提供有用的错误消息，因此你不需要记住这个规则。
- en: If a class routine's prototype does not have the `external` option, the compilation
    unit (that is, the program or unit) containing the class declaration must also
    contain the routine's definition or HLA will generate an error at the end of the
    compilation. For small, local classes (that is, when you're embedding the class
    declaration and routine definitions in the same compilation unit) the convention
    is to place the class's procedure, iterator, and method definitions in the source
    file shortly after the class declaration. For larger systems (that is, when separately
    compiling a class's routines), the convention is to place the class declaration
    in a header file by itself and place all the procedure, iterator, and method definitions
    in a separate HLA unit and compile them by themselves.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类例程的原型没有`external`选项，则包含类声明的编译单元（即程序或单元）必须同时包含该例程的定义，否则HLA会在编译结束时生成错误。对于小型的本地类（即当你将类声明和例程定义嵌入到同一个编译单元中时），惯例是将类的过程、迭代器和方法定义放在类声明之后不久的源文件中。对于较大的系统（即在单独编译类的例程时），惯例是将类声明单独放在头文件中，将所有过程、迭代器和方法定义放在一个单独的HLA单元中并单独编译。
- en: '* * *'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[133](#CHP-12-FN-2)]) This text does not discuss iterators. See the HLA reference
    manual for details on this type of function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[133](#CHP-12-FN-2)]) 本文不讨论迭代器。有关这种类型的函数，请参阅HLA参考手册。
- en: ^([[134](#CHP-12-FN-3)]) Note, however, that the difference between procedures
    and methods makes all the difference in the world to the object-oriented programming
    paradigm, hence the inclusion of methods in HLA's class definitions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[134](#CHP-12-FN-3)]) 然而，请注意，过程与方法之间的差异对于面向对象编程范式至关重要，因此 HLA 的类定义中包括了方法。
- en: 12.3 Objects
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.3 对象
- en: 'Remember, a class definition is just a type. Therefore, when you declare a
    class type you haven''t created a variable whose fields you can manipulate. An
    *object* is an *instance* of a class; that is, an object is a variable whose type
    is some class. You declare objects (i.e., class variables) the same way you declare
    other variables: in a `var`, `static`, or `storage` section.^([[135](#ftn.CHP-12-FN-4)])
    Here is a pair of sample object declarations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，类定义只是一个类型。因此，当你声明一个类类型时，你并没有创建一个可以操作其字段的变量。一个 *对象* 是一个 *实例*；也就是说，对象是一个类型为某个类的变量。你声明对象（即类变量）与声明其他变量的方式相同：在
    `var`、`static` 或 `storage` 部分。^([[135](#ftn.CHP-12-FN-4)]) 这里是一个示例对象声明对：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For a given class object, HLA allocates storage for each variable appearing
    in the `var` section of the class declaration. If you have two objects, `T1` and
    `T2`, of type `TypicalClass`, then `T1.TCvar` is unique, as is `T2.TCvar`. This
    is the intuitive result (similar to `record` declarations); most data fields you
    define in a class will appear in the `var` declaration section of the class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的类对象，HLA 为类声明的 `var` 部分中出现的每个变量分配存储空间。如果你有两个 `TypicalClass` 类型的对象 `T1` 和
    `T2`，那么 `T1.TCvar` 是唯一的，`T2.TCvar` 也是唯一的。这是直观的结果（类似于 `record` 声明）；你在类中定义的大多数数据字段会出现在类的
    `var` 声明部分。
- en: 'Static data objects (for example, those you declare in the `static` or `storage`
    sections of a class declaration) are not unique among the objects of that class;
    that is, HLA allocates only a single static variable that all variables of that
    class share. For example, consider the following (partial) class declaration and
    object declarations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数据对象（例如，你在类声明的 `static` 或 `storage` 部分声明的对象）在该类的对象中不是唯一的；也就是说，HLA 只分配一个静态变量，所有该类的变量共享该变量。例如，考虑以下（部分）类声明和对象声明：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, `s1.i` and `s2.i` are different variables. However, `s1.s`
    and `s2.s` are aliases of one another. Therefore, an instruction like `mov(5,
    s1.s);` also stores 5 into `s2.s`. Generally you use static class variables to
    maintain information about the whole class, while you use class `var` objects
    to maintain information about the specific object. Because keeping track of class
    information is relatively rare, you will probably declare most class data fields
    in a `var` section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`s1.i` 和 `s2.i` 是不同的变量。然而，`s1.s` 和 `s2.s` 是彼此的别名。因此，像 `mov(5, s1.s);`
    这样的指令也会将 5 存储到 `s2.s` 中。通常，你使用静态类变量来保持关于整个类的信息，而使用类 `var` 对象来保持关于特定对象的信息。由于追踪类信息相对较少见，因此你可能会将大多数类数据字段声明在
    `var` 部分。
- en: 'You can also create dynamic instances of a class and refer to those dynamic
    objects via pointers. In fact, this is probably the most common form of object
    storage and access. The following code shows how to create pointers to objects
    and how you can dynamically allocate storage for an object:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建类的动态实例，并通过指针引用这些动态对象。事实上，这可能是对象存储和访问中最常见的形式。以下代码演示了如何创建指向对象的指针，以及如何动态分配对象的存储：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note the use of type coercion to cast the pointer in EBX as type `sc`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用类型转换将 EBX 中的指针强制转换为 `sc` 类型。
- en: '* * *'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[135](#CHP-12-FN-4)]) Technically, you could also declare an object in a
    `readonly` section, but HLA does not allow you to define class constants, so there
    is little utility in declaring class objects in the `readonly` section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[135](#CHP-12-FN-4)]) 从技术上讲，你也可以在 `readonly` 部分声明一个对象，但 HLA 不允许你定义类常量，因此在
    `readonly` 部分声明类对象的实用性不大。
- en: 12.4 Inheritance
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.4 继承
- en: 'Inheritance is one of the most fundamental ideas behind object-oriented programming.
    The basic idea is that a class inherits, or copies, all the fields from some class
    and then possibly expands the number of fields in the new data type. For example,
    suppose you created a data type `point` that describes a point in the planar (two-dimensional)
    space. The class for this `point` might look like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程中最基本的概念之一。基本思想是一个类继承或复制某个类的所有字段，然后可能会扩展新数据类型的字段数量。例如，假设你创建了一个描述平面（二维）空间中的点的数据类型
    `point`。该 `point` 类可能如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Suppose you want to create a `point` in 3D space rather than 2D space. You
    can easily build such a data type as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在 3D 空间中创建一个 `point`，而不是在 2D 空间中。你可以像下面这样轻松地构建一个数据类型：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `inherits` option on the `class` declaration tells HLA to insert the fields
    of `point` at the beginning of the class. In this case, `point3D` inherits the
    fields of `point`. HLA always places the inherited fields at the beginning of
    a class object. The reason for this will become clear a little later. If you have
    an instance of `point3D`, which you call `P3`, then the following 80x86 instructions
    are all legal:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`class` 声明中的 `inherits` 选项告诉 HLA 将 `point` 的字段插入到类的开头。在这种情况下，`point3D` 继承了
    `point` 的字段。HLA 总是将继承的字段放在类对象的开头。稍后你会明白为什么这样做。如果你有一个 `point3D` 的实例，叫做 `P3`，那么以下
    80x86 指令都是合法的：'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the `p3.distance` method invocation in this example calls the `point.distance`
    method. You do not have to write a separate `distance` method for the `point3D`
    class unless you really want to do so (see the next section for details). Just
    like the `x` and `y` fields, `point3D` objects inherit `point`'s methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此示例中调用的 `p3.distance` 方法调用的是 `point.distance` 方法。除非你真的想这么做（参见下一节的详细信息），否则你不必为
    `point3D` 类编写一个单独的 `distance` 方法。就像 `x` 和 `y` 字段一样，`point3D` 对象继承了 `point` 的方法。
- en: 12.5 Overriding
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.5 重写
- en: '*Overriding* is the process of replacing an existing method in an inherited
    class with one more suitable for the new class. In the `point` and `point3D` examples
    appearing in the previous section, the `distance` method (presumably) computes
    the distance from the origin to the specified point. For a point on a two-dimensional
    plane, you can compute the distance using the following function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*重写* 是将继承类中现有的方法替换为更适合新类的方法的过程。在前一节中出现的 `point` 和 `point3D` 示例中，`distance`
    方法（推测）计算的是从原点到指定点的距离。对于一个位于二维平面上的点，你可以使用以下函数来计算距离：'
- en: '| *d = √ x² + y²* |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| *d = √ x² + y²* |'
- en: 'However, the distance for a point in 3D space is given by this equation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，3D 空间中一个点的距离是通过这个公式给出的：
- en: '| *d = √ x² + y² + z²* |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| *d = √ x² + y² + z²* |'
- en: Clearly, if you call the `distance` function for `point` for a `point3D` object,
    you will get an incorrect answer. In the previous section, however, you saw that
    the `P3` object calls the `distance` function inherited from the `point` class.
    Therefore, this would produce an incorrect result.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，如果你对一个 `point3D` 对象调用 `point` 的 `distance` 函数，你将得到一个错误的结果。然而，在前一节中，你看到 `P3`
    对象调用了从 `point` 类继承来的 `distance` 函数。因此，这将产生一个不正确的结果。
- en: 'In this situation the `point3D` data type must override the `distance` method
    with one that computes the correct value. You cannot simply redefine the `point3D`
    class by adding a `distance` method prototype:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`point3D` 数据类型必须用一个计算正确值的方法重写 `distance` 方法。你不能仅仅通过添加 `distance` 方法原型来重新定义
    `point3D` 类：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The problem with the `distance` method declaration above is that `point3D` already
    has a `distance` method—the one that it inherits from the `point` class. HLA will
    complain because it doesn't like two methods with the same name in a single class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上面 `distance` 方法声明的问题在于，`point3D` 已经有一个 `distance` 方法——它是从 `point` 类继承过来的。HLA
    会抱怨，因为它不喜欢在一个类中有两个同名的方法。
- en: 'To solve this problem, we need some mechanism by which we can override the
    declaration of `point.distance` and replace it with a declaration for `point3D.distance`.
    To do this, you use the `override` keyword before the method declaration:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要某种机制，能够重写 `point.distance` 的声明，并将其替换为 `point3D.distance` 的声明。为此，你在方法声明之前使用
    `override` 关键字：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `override` prefix tells HLA to ignore the fact that `point3D` inherits
    a method named `distance` from the `point` class. Now, any call to the `distance`
    method via a `point3D` object will call the `point3D.distance` method rather than
    `point.distance`. Of course, once you override a method using the `override` prefix,
    you must supply the method in the implementation section of your code. For example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`override` 前缀告诉 HLA 忽略 `point3D` 从 `point` 类继承了一个名为 `distance` 的方法。现在，任何通过
    `point3D` 对象调用 `distance` 方法都会调用 `point3D.distance` 方法，而不是 `point.distance`。当然，一旦你使用
    `override` 前缀重写了一个方法，你必须在代码的实现部分提供该方法。例如：'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 12.6 Virtual Methods vs. Static Procedures
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.6 虚方法与静态过程
- en: 'A little earlier, this chapter suggested that you could treat class methods
    and class procedures the same. There are, in fact, some major differences between
    the two (after all, why have methods if they''re the same as procedures?). As
    it turns out, the differences between methods and procedures are crucial if you
    want to develop object-oriented programs. Methods provide the second feature necessary
    to support true polymorphism: virtual procedure calls.^([[136](#ftn.CHP-12-FN-5)])
    A virtual procedure call is just a fancy name for an indirect procedure call (using
    a pointer associated with the object). The key benefit of virtual procedures is
    that the system automatically calls the right method when using pointers to generic
    objects.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 稍早些时候，本章建议你可以将类方法和类过程视为相同。事实上，这两者之间有一些重大区别（毕竟，如果它们相同，为什么还要有方法呢？）。实际上，方法和过程之间的区别在你想开发面向对象程序时至关重要。方法提供了支持真正多态所需的第二个特性：虚拟过程调用。^([[136](#ftn.CHP-12-FN-5)])
    虚拟过程调用只不过是间接过程调用（使用与对象关联的指针）的一个花哨名称。虚拟过程的关键好处是，当使用指向通用对象的指针时，系统会自动调用正确的方法。
- en: 'Consider the following declarations using the `point` class from the previous
    sections:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用前面章节中`point`类的声明：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Given the declarations above, the following assembly statements are all legal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述声明，以下汇编语句都是合法的：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that HLA lets you call a method via a pointer to an object rather than
    directly via an object variable. This is a crucial feature of objects in HLA and
    a key to implementing *virtual method calls*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HLA允许你通过指向对象的指针而不是通过对象变量直接调用方法。这是HLA中对象的一个关键特性，也是实现*虚拟方法调用*的关键。
- en: 'The magic behind polymorphism and inheritance is that object pointers are *generic*.
    In general, when your program references data indirectly through a pointer, the
    value of the pointer should be the address of some value of the underlying data
    type associated with that pointer. For example, if you have a pointer to a 16-bit
    unsigned integer, you wouldn''t normally use that pointer to access a 32-bit signed
    integer value. Similarly, if you have a pointer to some record, you would not
    normally cast that pointer to some other record type and access the fields of
    that other type.^([[137](#ftn.CHP-12-FN-6)]) With pointers to class objects, however,
    we can lift this restriction a little. Pointers to objects may legally contain
    the address of the object''s type *or the address of any object that inherits
    the fields of that type*. Consider the following declarations that use the `point`
    and `point3D` types from the previous examples:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 多态和继承背后的魔力在于对象指针是*通用的*。通常，当你的程序通过指针间接引用数据时，指针的值应该是与该指针相关联的基础数据类型的某个值的地址。例如，如果你有一个指向16位无符号整数的指针，通常你不会用这个指针访问一个32位有符号整数值。类似地，如果你有一个指向某个记录的指针，通常你不会将该指针强制转换为其他记录类型并访问该类型的字段。^([[137](#ftn.CHP-12-FN-6)])
    然而，对于指向类对象的指针，我们可以稍微放宽这一限制。指向对象的指针可以合法地包含该对象类型的地址*或包含该类型字段的任何继承对象的地址*。考虑以下使用前面示例中的`point`和`point3D`类型的声明：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because `p` is a pointer to a `point` object, it might seem intuitive for `p.distance`
    to call the `point.distance` method. However, methods are *polymorphic*. If you
    have a pointer to an object and you call a method associated with that object,
    the system will call the actual (overridden) method associated with the object,
    not the method specifically associated with the pointer's class type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`p`是指向`point`对象的指针，所以直觉上看，`p.distance`应该调用`point.distance`方法。然而，方法是*多态的*。如果你有一个指向某个对象的指针，并且调用与该对象关联的方法，系统会调用与该对象关联的实际（重写的）方法，而不是与指针的类类型专门关联的方法。
- en: Class procedures behave differently than methods with respect to overridden
    procedures. When you call a class procedure indirectly through an object pointer,
    the system will always call the procedure associated with the underlying class.
    So had `distance` been a procedure rather than a method in the previous examples,
    the `p.distance()`; invocation would always call `point.distance`, even if `p`
    were pointing at a `point3D` object. [12.9 Constructors and Object Initialization](ch12s09.html
    "12.9 Constructors and Object Initialization") explains why methods and procedures
    are different.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类过程与方法在重写过程中行为有所不同。当通过对象指针间接调用类过程时，系统将始终调用与底层类相关联的过程。因此，如果在之前的示例中`distance`是一个过程而非方法，那么`p.distance()`的调用将始终调用`point.distance`，即使`p`指向的是`point3D`对象。[12.9
    构造函数和对象初始化](ch12s09.html "12.9 构造函数和对象初始化")解释了为什么方法和过程是不同的。
- en: '* * *'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[136](#CHP-12-FN-5)]) *Polymorphism* literally means "many-faced." In the
    context of object-oriented programming, polymorphism means that the same method
    name, for example, `distance`, refers to one of several different methods.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[136](#CHP-12-FN-5)]) *多态性*字面意思是“多面性”。在面向对象编程中，多态性意味着相同的方法名称，例如`distance`，可以指代多个不同的方法。
- en: ^([[137](#CHP-12-FN-6)]) Of course, assembly language programmers break rules
    like this all the time. For now, let's assume we're playing by the rules and access
    the data using only the data type associated with the pointer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[137](#CHP-12-FN-6)]) 当然，汇编语言程序员经常违反这种规则。暂时假设我们遵守规则，仅通过与指针相关的数据类型访问数据。
- en: 12.7 Writing Class Methods and Procedures
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.7 编写类方法和过程
- en: For each class procedure and method prototype appearing in a class definition,
    there must be a corresponding procedure or method appearing within the program
    (for the sake of brevity, this section will use the term *routine* to mean procedure
    or method from this point forward). If the prototype does not contain the `external`
    option, then the code must appear in the same compilation unit as the class declaration.
    If the `external` option does follow the prototype, then the code may appear in
    the same compilation unit or a different compilation unit (as long as you link
    the resulting object file with the code containing the class declaration). Like
    external (non-class) procedures, if you fail to provide the code, the linker will
    complain when you attempt to create an executable file. To reduce the size of
    the following examples, they will all define their routines in the same source
    file as the class declaration.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类定义中出现的每个类过程和方法原型，程序中必须有一个对应的过程或方法（为了简洁起见，本节将使用*例程*来指代过程或方法）。如果原型中没有包含`external`选项，则代码必须出现在与类声明相同的编译单元中。如果原型包含`external`选项，那么代码可以出现在相同的编译单元中，或者是不同的编译单元中（只要将生成的目标文件与包含类声明的代码链接起来）。像外部（非类）过程一样，如果未提供代码，链接器将在你尝试创建可执行文件时报错。为了减少以下示例的大小，它们将把例程定义在与类声明相同的源文件中。
- en: HLA class routines must always follow the class declaration in a compilation
    unit. If you are compiling your routines in a separate unit, the class declarations
    must still precede the implementation of the routines from the class (usually
    via an `#include` file). If you haven't defined the class by the time you define
    a routine like `point.distance`, HLA doesn't know that `point` is a class and,
    therefore, doesn't know how to handle the routine's definition.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: HLA类例程必须始终在编译单元中的类声明之后。如果你在一个单独的单元中编译你的例程，类声明仍然必须出现在类例程实现之前（通常通过`#include`文件）。如果在定义像`point.distance`这样的例程时尚未定义类，HLA将无法知道`point`是一个类，因此也不知道如何处理该例程的定义。
- en: 'Consider the following declarations for a `point2D` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下`point2D`类的声明：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `distance` function for this class should compute the distance from the
    object''s point to `(fromX,fromY)`. The following formula describes this computation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的`distance`函数应计算对象的点到`(fromX,fromY)`的距离。以下公式描述了该计算：
- en: '![12.7 Writing Class Methods and Procedures](tagoreillycom20100401nostarchimages578079.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![12.7 编写类方法和过程](tagoreillycom20100401nostarchimages578079.png)'
- en: 'A first pass at writing the `distance` method might produce the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`distance`方法的第一次尝试可能会产生如下代码：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code probably looks like it should work to someone who is familiar with
    an object-oriented programming language like C++ or Delphi. However, as the comments
    indicate, the instructions that push the `x` and `y` variables onto the FPU stack
    don't work; HLA doesn't automatically define the symbols associated with the data
    fields of a class within that class's routines.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来应该能够正常工作，对于熟悉面向对象编程语言（如C++或Delphi）的人来说。然而，正如注释所指出的，推送`x`和`y`变量到FPU堆栈的指令不起作用；HLA不会自动在类的例程中定义与类的数据字段相关的符号。
- en: 'To learn how to access the data fields of a class within that class''s routines,
    we need to back up a moment and discuss some very important implementation details
    concerning HLA''s classes. To do this, consider the following variable declarations:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何在类的例程中访问类的数据字段，我们需要稍微回顾一下，并讨论一些关于HLA类的非常重要的实现细节。为此，请考虑以下变量声明：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Remember, whenever you create two objects like `Origin` and `PtInSpace`, HLA
    reserves storage for the `x` and `y` data fields for both of these objects. However,
    there is only one copy of the `point2D.distance` method in memory. Therefore,
    were you to call `Origin.distance` and `PtInSpace.distance`, the system would
    call the same routine for both method invocations. Once inside that method, one
    has to wonder what an instruction like `fld( x );` would do. How does it associate
    `x` with `Origin.x` or `PtInSpace.x`? Worse still, how would this code differentiate
    between the data field `x` and a global object `x`? In HLA, the answer is, it
    doesn't. You do not specify the data field names within a class routine by simply
    using their names as though they were common variables.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每当你创建像`Origin`和`PtInSpace`这样的两个对象时，HLA会为这两个对象的`x`和`y`数据字段保留存储空间。然而，内存中只有一个`point2D.distance`方法的副本。因此，如果你调用`Origin.distance`和`PtInSpace.distance`，系统会为这两个方法调用调用相同的例程。一旦进入该方法，我们不得不想知道像`fld(
    x );`这样的指令会做什么。它如何将`x`与`Origin.x`或`PtInSpace.x`关联起来？更糟糕的是，这段代码如何区分数据字段`x`和全局对象`x`？在HLA中，答案是，它不会。你不能仅仅像使用普通变量一样通过名字来指定类例程中的数据字段名称。
- en: 'To differentiate `Origin.x` from `PtInSpace.x` within class routines, HLA automatically
    passes a pointer to an object''s data fields whenever you call a class routine.
    Therefore, you can reference the data fields indirectly off this pointer. HLA
    passes this object pointer in the ESI register. This is one of the few places
    where HLA-generated code will modify one of the 80x86 registers behind your back:
    *Anytime you call a class routine, HLA automatically loads the ESI register with
    the object''s address*. Obviously, you cannot count on ESI''s value being preserved
    across class routine calls, nor can you pass parameters to the class routine in
    the ESI register (though it is perfectly reasonable to specify `@use esi;` to
    allow HLA to use the ESI register when setting up other parameters). For class
    methods (but not procedures), HLA will also load the EDI register with the address
    of the classes'' *virtual method table*. While the virtual method table address
    isn''t as interesting as the object address, keep in mind that *HLA-generated
    code will overwrite any value in the EDI register when you call a class method
    or an iterator*. Again, "EDI" is a good choice for the `@use` operand for methods
    because HLA will wipe out the value in EDI anyway.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在类的例程中区分`Origin.x`和`PtInSpace.x`，HLA会自动在调用类例程时传递一个指向对象数据字段的指针。因此，你可以通过这个指针间接引用数据字段。HLA将此对象指针传递给ESI寄存器。这是HLA生成的代码会在你不注意的情况下修改80x86寄存器的少数几个地方之一：*每当你调用一个类例程时，HLA会自动加载ESI寄存器，指向对象的地址*。显然，你不能指望ESI的值在类例程调用之间被保留，也不能通过ESI寄存器向类例程传递参数（尽管指定`@use
    esi;`来允许HLA在设置其他参数时使用ESI寄存器是完全合理的）。对于类方法（但不是过程），HLA还会将EDI寄存器加载为类的*虚拟方法表*的地址。虽然虚拟方法表地址不像对象地址那样重要，但请记住，*HLA生成的代码在你调用类方法或迭代器时会覆盖EDI寄存器中的任何值*。同样，"EDI"是类方法的`@use`操作数的一个好选择，因为无论如何HLA都会清除EDI中的值。
- en: 'Upon entry into a class routine, ESI contains a pointer to the (nonstatic)
    data fields associated with the class. Therefore, to access fields like `x` and
    `y` (in our `point2D` example), you could use an address expression like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入类例程时，ESI包含一个指向与类相关的（非静态）数据字段的指针。因此，要访问像`x`和`y`这样的字段（在我们的`point2D`示例中），你可以使用如下的地址表达式：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because you use ESI as the base address of the object's data fields, it's a
    good idea not to disturb ESI's value within the class routines (or, at least,
    preserve ESI's value across the code where you must use ESI for some other purpose).
    Note that within a method you do not have to preserve EDI (unless, for some reason,
    you need access to the virtual method table, which is unlikely).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你使用ESI作为对象数据字段的基地址，所以最好不要在类例程中更改ESI的值（或者，至少在你必须使用ESI进行其他操作的代码段中保留ESI的值）。请注意，在方法内部你不必保留EDI（除非出于某种原因需要访问虚拟方法表，这种情况不太可能）。
- en: 'Accessing the fields of a data object within a class''s routines is such a
    common operation that HLA provides a shorthand notation for casting ESI as a pointer
    to the class object: `this`. Within a class in HLA, the reserved word `this` automatically
    expands to a string of the form `(type` *`classname`* `[esi])`, substituting,
    of course, the appropriate class name for *`classname`*. Using the this keyword,
    we can (correctly) rewrite the previous distance method as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的例程中访问数据对象的字段是非常常见的操作，HLA为此提供了简写符号，用于将ESI转换为指向类对象的指针：`this`。在HLA中的类内，保留字`this`会自动扩展为类似`(type`
    *`classname`* `[esi])`的字符串，当然会将适当的类名替换为*`classname`*。使用`this`关键字后，我们可以（正确地）将前面的distance方法重写如下：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Don''t forget that calling a class routine wipes out the value in the ESI register.
    This isn''t obvious from the syntax of the routine''s invocation. It is especially
    easy to forget this when calling some class routine from inside some other class
    routine; remember that if you do this, the internal call wipes out the value in
    ESI and on return from that call ESI no longer points at the original object.
    Always push and pop ESI (or otherwise preserve ESI''s value) in this situation.
    For example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，调用类例程会清除ESI寄存器中的值。这一点从例程调用的语法中并不明显。特别是在从另一个类例程内部调用某个类例程时，很容易忘记这一点；记住，如果你这样做，内部调用会清除ESI中的值，并且从该调用返回时，ESI将不再指向原始对象。在这种情况下，始终推送和弹出ESI（或以其他方式保留ESI的值）。例如：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `this` keyword provides access to the class variables you declare in the
    `var` section of a class. You can also use `this` to call other class routines
    associated with the current object. For example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字提供了对你在类的`var`部分声明的类变量的访问。你也可以使用`this`来调用与当前对象相关的其他类例程。例如：'
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To access class constants and `static` data fields, you generally do not use
    the `this` pointer. HLA associates constant and static data fields with the whole
    class, not a specific object ( just like `static` fields in a class). To access
    these class members, use the class name in place of the object name. For example,
    to access the `UnitDistance` constant in the `point2d` class you could use a statement
    like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问类常量和`static`数据字段，通常不使用`this`指针。HLA将常量和静态数据字段与整个类关联，而不是与特定对象关联（就像类中的`static`字段一样）。要访问这些类成员，请使用类名代替对象名。例如，要访问`point2d`类中的`UnitDistance`常量，可以使用如下语句：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As another example, if you wanted to update the `LastDistance` field in the
    `point2D` class each time you computed a distance, you could rewrite the `point2D.distance`
    method as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，如果你想在每次计算距离时更新`point2D`类中的`LastDistance`字段，可以将`point2D.distance`方法重写如下：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The next section will explain why you use the class name when referring to constants
    and static objects but you use `this` to access `var` objects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释为什么在引用常量和静态对象时使用类名，而在访问`var`对象时使用`this`。
- en: 'Class procedures are also static objects, so it is possible to call a class
    procedure by specifying the class name rather than an object name in the procedure
    invocation; for example, both of the following are legal:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法也是静态对象，因此可以通过指定类名而不是对象名来调用类方法；例如，以下两种写法都是合法的：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There is, however, a subtle difference between these two class procedure calls.
    The first call above loads ESI with the address of the `origin` object prior to
    actually calling the `InitLastDistance` procedure. The second call, however, is
    a direct call to the class procedure without referencing an object; therefore,
    HLA doesn't know what object address to load into the ESI register. In this case,
    HLA loads NULL (0) into ESI prior to calling the `InitLastDistance` procedure.
    Because you can call class procedures in this manner, it's always a good idea
    to check the value in ESI within your class procedures to verify that HLA contains
    a valid object address. Checking the value in ESI is a good way to determine which
    calling mechanism is in use. [12.9 Constructors and Object Initialization](ch12s09.html
    "12.9 Constructors and Object Initialization") discusses constructors and object
    initialization; then you will see a good use for static procedures and calling
    those procedures directly (rather than through the use of an object).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两个类过程调用之间有一个微妙的区别。上面的第一个调用会在实际调用 `InitLastDistance` 过程之前，先将 `origin` 对象的地址加载到
    ESI 寄存器中。第二个调用则是直接调用类过程，而不引用任何对象；因此，HLA 不知道要加载哪个对象地址到 ESI 寄存器中。在这种情况下，HLA 会在调用
    `InitLastDistance` 过程之前，将 NULL（0）加载到 ESI 中。由于可以以这种方式调用类过程，通常最好在你的类过程内部检查 ESI 的值，以验证
    HLA 是否包含有效的对象地址。检查 ESI 中的值是确定使用哪种调用机制的好方法。[12.9 构造函数和对象初始化](ch12s09.html "12.9
    构造函数和对象初始化")讨论了构造函数和对象初始化；接下来，你将看到静态过程和直接调用这些过程（而不是通过对象调用）的好处。
- en: 12.8 Object Implementation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.8 对象实现
- en: In a high-level object-oriented language like C++ or Delphi, it is quite possible
    to master the use of objects without really understanding how the machine implements
    them. One of the reasons for learning assembly language programming is to fully
    comprehend low-level implementation details so you can make educated decisions
    concerning the use of programming constructs like objects. Further, because assembly
    language allows you to poke around with data structures at a very low level, knowing
    how HLA implements objects can help you create certain algorithms that would not
    be possible without a detailed knowledge of object implementation. Therefore,
    this section and its corresponding subsections explain the low-level implementation
    details you will need to know in order to write object-oriented HLA programs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 C++ 或 Delphi 这样的高级面向对象语言中，完全有可能掌握对象的使用，而不真正理解机器是如何实现这些对象的。学习汇编语言编程的原因之一是为了完全理解低级实现细节，这样你可以在使用诸如对象之类的编程构造时做出有根据的决策。此外，汇编语言允许你在非常低级别操作数据结构，了解
    HLA 如何实现对象可以帮助你创建某些算法，而没有对对象实现的详细了解是无法实现这些算法的。因此，本节及其相应的小节将解释你需要了解的低级实现细节，以便编写面向对象的
    HLA 程序。
- en: HLA implements objects in a manner quite similar to records. In particular,
    HLA allocates storage for all `var` objects in a class in a sequential fashion,
    just like records. Indeed, if a class consists of only `var` data fields, the
    memory representation of that class is nearly identical to that of a corresponding
    `record` declaration. Consider the `student` record declaration taken from [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES") and the corresponding class
    (see [Figure 12-1](ch12s08.html#student_record_implementation_in_memory "Figure 12-1. student
    record implementation in memory") and [Figure 12-2](ch12s08.html#student_class_implementation_in_memory
    "Figure 12-2. student class implementation in memory"), respectively).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 实现对象的方式与记录类型非常相似。特别是，HLA 按顺序为类中的所有 `var` 对象分配存储空间，就像记录类型一样。实际上，如果一个类只包含
    `var` 数据字段，那么该类的内存表示与对应的 `record` 声明几乎完全相同。考虑从[第 4 章](ch04.html "第 4 章 常量、变量和数据类型")中提取的
    `student` 记录声明和相应的类（参见[图 12-1](ch12s08.html#student_record_implementation_in_memory
    "图 12-1 student 记录在内存中的实现")和[图 12-2](ch12s08.html#student_class_implementation_in_memory
    "图 12-2 student 类在内存中的实现")，分别）。
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![student record implementation in memory](tagoreillycom20100401nostarchimages578081.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![student 记录在内存中的实现](tagoreillycom20100401nostarchimages578081.png)'
- en: Figure 12-1. `student` record implementation in memory
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1. `student` 记录在内存中的实现
- en: '![student class implementation in memory](tagoreillycom20100401nostarchimages578083.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![student 类在内存中的实现](tagoreillycom20100401nostarchimages578083.png)'
- en: Figure 12-2. `student` class implementation in memory
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2. `student` 类在内存中的实现
- en: If you look carefully at [Figure 12-1](ch12s08.html#student_record_implementation_in_memory
    "Figure 12-1. student record implementation in memory") and [Figure 12-2](ch12s08.html#student_class_implementation_in_memory
    "Figure 12-2. student class implementation in memory"), you'll discover that the
    only difference between the class and the record implementations is the inclusion
    of the `VMT` (virtual method table) pointer field at the beginning of the class
    object. This field, which is always present in a class, contains the address of
    the class's virtual method table that, in turn, contains the addresses of all
    the class's methods and iterators. The `VMT` field, by the way, is present even
    if a class doesn't contain any methods or iterators.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察[图 12-1](ch12s08.html#student_record_implementation_in_memory "图 12-1.
    学生记录在内存中的实现")和[图 12-2](ch12s08.html#student_class_implementation_in_memory "图
    12-2. 学生类在内存中的实现")，你会发现类和记录实现之间的唯一区别是类对象开头包含了`VMT`（虚拟方法表）指针字段。这个字段在类中始终存在，包含了指向类虚拟方法表的地址，而虚拟方法表又包含了类的所有方法和迭代器的地址。顺便说一下，`VMT`字段即使类中没有任何方法或迭代器，仍然存在。
- en: 'As pointed out in previous sections, HLA does not allocate storage for `static`
    objects within the object. Instead, HLA allocates a single instance of each `static`
    data field that all objects share. As an example, consider the following class
    and object declarations:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面各节所指出的，HLA 不会为对象中的 `static` 对象分配存储空间。相反，HLA 为每个 `static` 数据字段分配一个单一实例，所有对象共享该实例。举个例子，考虑以下类和对象声明：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Figure 12-3](ch12s08.html#object_allocation_with_static_data_field "Figure 12-3. Object
    allocation with static data fields") shows the storage allocation for these two
    objects in memory.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-3](ch12s08.html#object_allocation_with_static_data_field "图 12-3. 带有静态数据字段的对象分配")展示了这两个对象在内存中的存储分配情况。'
- en: '![Object allocation with static data fields](tagoreillycom20100401nostarchimages578085.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![带有静态数据字段的对象分配](tagoreillycom20100401nostarchimages578085.png)'
- en: Figure 12-3. Object allocation with `static` data fields
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-3. 带有 `static` 数据字段的对象分配
- en: Of course, `const`, `val`, and `#macro` objects do not have any runtime memory
    requirements associated with them, so HLA does not allocate any storage for these
    fields. Like the `static` data fields, you may access `const`, `val`, and `#macro`
    fields using the class name as well as an object name. Hence, even if `tHasStatic`
    has these types of fields, the memory organization for `tHasStatic` objects would
    still be the same as shown in [Figure 12-3](ch12s08.html#object_allocation_with_static_data_field
    "Figure 12-3. Object allocation with static data fields").
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`const`、`val` 和 `#macro` 对象在运行时没有内存要求，因此 HLA 不会为这些字段分配存储空间。像 `static` 数据字段一样，你可以使用类名或对象名来访问
    `const`、`val` 和 `#macro` 字段。因此，即使 `tHasStatic` 包含这些类型的字段，其内存组织结构仍然与[图 12-3](ch12s08.html#object_allocation_with_static_data_field
    "图 12-3. 带有静态数据字段的对象分配")中显示的相同。
- en: Other than the presence of the virtual method table (`VMT`) pointer, the presence
    of methods and procedures has no impact on the storage allocation of an object.
    Of course, the machine instructions associated with these routines do appear somewhere
    in memory. So in a sense the code for the routines is quite similar to `static`
    data fields insofar as all the objects share a single instance of the routine.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了虚拟方法表（`VMT`）指针的存在外，方法和过程的存在对对象的存储分配没有影响。当然，与这些例程相关的机器指令确实会出现在内存的某个位置。所以在某种意义上，例程的代码与
    `static` 数据字段非常相似，因为所有对象共享一个例程的单一实例。
- en: 12.8.1 Virtual Method Tables
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.8.1 虚拟方法表
- en: When HLA calls a class procedure, it directly calls that procedure using a `call`
    instruction, just like any normal procedure call. Methods are another story altogether.
    Each object in the system carries a pointer to a virtual method table, which is
    an array of pointers to all the methods and iterators appearing within the object's
    class (see [Figure 12-4](ch12s08.html#virtual_method_table_organization "Figure 12-4. Virtual
    method table organization")).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HLA 调用类过程时，它会直接使用 `call` 指令调用该过程，就像任何正常的过程调用一样。方法则完全不同。系统中的每个对象都携带指向虚拟方法表的指针，虚拟方法表是指向该对象类中所有方法和迭代器的指针数组（见[图
    12-4](ch12s08.html#virtual_method_table_organization "图 12-4. 虚拟方法表组织结构")）。
- en: '![Virtual method table organization](tagoreillycom20100401nostarchimages578087.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟方法表组织结构](tagoreillycom20100401nostarchimages578087.png)'
- en: Figure 12-4. Virtual method table organization
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-4. 虚拟方法表组织结构
- en: 'Each iterator or method you declare in a class has a corresponding entry in
    the virtual method table. That double-word entry contains the address of the first
    instruction of that iterator or method. Calling a class method or iterator is
    a bit more work than calling a class procedure (it requires one additional instruction
    plus the use of the EDI register). Here is a typical calling sequence for a method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你在类中声明的每个迭代器或方法在虚方法表中都有一个对应的条目。这个双字条目包含了该迭代器或方法的第一条指令的地址。调用类方法或迭代器比调用类过程稍微复杂一些（它需要额外的一条指令并且使用EDI寄存器）。下面是一个典型的方法调用序列：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For a given class there is only one copy of the virtual method table in memory.
    This is a static object, so all objects of a given class type share the same virtual
    method table. This is reasonable because all objects of the same class type have
    exactly the same methods and iterators (see [Figure 12-5](ch12s08.html#all_objects_that_are_the_same_class_type
    "Figure 12-5. All objects that are the same class type share the same VMT.")).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个给定的类，内存中只有一份虚方法表。这是一个静态对象，因此所有该类类型的对象共享同一份虚方法表。这是合理的，因为同一类类型的所有对象拥有完全相同的方法和迭代器（参见[图12-5](ch12s08.html#all_objects_that_are_the_same_class_type
    "图12-5. 所有相同类类型的对象共享同一份VMT。")）。
- en: 'Although HLA builds the `VMT` record structure as it encounters methods and
    iterators within a class, HLA does not automatically create the virtual method
    table for you. You must explicitly declare this table in your program. To do this,
    you include a statement like the following in a `static` or `readonly` declaration
    section of your program. For example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管HLA在遇到类中的方法和迭代器时会构建`VMT`记录结构，HLA并不会自动为你创建虚方法表。你必须在程序中显式声明这个表。为此，你需要在程序的`static`或`readonly`声明部分中包括如下语句。例如：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![All objects that are the same class type share the same VMT.](tagoreillycom20100401nostarchimages578089.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![所有相同类类型的对象共享同一份VMT。](tagoreillycom20100401nostarchimages578089.png)'
- en: Figure 12-5. All objects that are the same class type share the same VMT.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-5. 所有相同类类型的对象共享同一份VMT。
- en: Because the addresses in a virtual method table should never change during program
    execution, the `readonly` section is probably the best choice for declaring virtual
    method tables. It should go without saying that changing the pointers in a virtual
    method table is, in general, a really bad idea. So putting `VMT`s in a `static`
    section is usually not a good idea.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因为虚方法表中的地址在程序执行期间不应该发生变化，所以`readonly`部分可能是声明虚方法表的最佳选择。毫无疑问，修改虚方法表中的指针通常是一个非常糟糕的主意。因此，将`VMT`放入`static`部分通常不是一个好主意。
- en: A declaration like the one above defines the variable *`classname`*`._VMT_`.
    In [12.9 Constructors and Object Initialization](ch12s09.html "12.9 Constructors
    and Object Initialization"), you will see that you need this name when initializing
    object variables. The class declaration automatically defines the *`classname`*`._VMT_`
    symbol as an external static variable. The declaration above just provides the
    actual definition for this external symbol.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示的声明定义了变量*`classname`*`._VMT_`。在[12.9 构造函数与对象初始化](ch12s09.html "12.9 构造函数与对象初始化")中，你将看到在初始化对象变量时需要这个名称。类声明自动将*`classname`*`._VMT_`符号定义为外部静态变量。上面的声明只是为这个外部符号提供了实际的定义。
- en: 'The declaration of a `VMT` uses a somewhat strange syntax because you aren''t
    actually declaring a new symbol with this declaration; you''re simply supplying
    the data for a symbol that you previously declared implicitly by defining a class.
    That is, the class declaration defines the static table variable *`classname`*`._VMT_`;
    all you''re doing with the `VMT` declaration is telling HLA to emit the actual
    data for the table. If, for some reason, you would like to refer to this table
    using a name other than *`classname`*`._VMT_`, HLA does allow you to prefix the
    declaration above with a variable name. For example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`VMT`的声明使用了一种有些奇怪的语法，因为你实际上并不是在声明一个新的符号；你只是为一个你之前通过定义类隐式声明的符号提供数据。也就是说，类声明定义了静态表变量*`classname`*`._VMT_`；你在`VMT`声明中所做的，仅仅是告诉HLA生成该表的实际数据。如果出于某种原因，你想用除了*`classname`*`._VMT_`以外的名称来引用这个表，HLA确实允许你在上面的声明前添加一个变量名。例如：'
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this declaration, `myVMT` is an alias of *`classname`*`._VMT_`. As a general
    rule, you should avoid using aliases in a program because they make the program
    more difficult to read and understand. Therefore, it is unlikely that you would
    ever need to use this type of declaration.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: As with any other global static variable, there should be only one instance
    of a virtual method table for a given class in a program. The best place to put
    the `VMT` declaration is in the same source file as the class's method, iterator,
    and procedure code (assuming they all appear in a single file). This way you will
    automatically link in the virtual method table whenever you link in the routines
    for a given class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 12.8.2 Object Representation with Inheritance
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, the discussion of the implementation of class objects has
    ignored the possibility of inheritance. Inheritance affects the memory representation
    of an object only by adding fields that are not explicitly stated in the class
    declaration.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding inherited fields from a *base class* to another class must be done carefully.
    Remember, an important attribute of a class that inherits fields from a base class
    is that you can use a pointer to the base class to access the inherited fields
    from that base class, even if the pointer contains the address of some other class
    (that inherits the fields from the base class). As an example, consider the following
    classes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Because both `tChildClassA` and `tChildClassB` inherit the fields of `tBaseClass`,
    these two child classes include the `i`, `j`, and `r` fields as well as their
    own specific fields. Furthermore, whenever you have a pointer variable whose base
    type is `tBaseClass`, it is legal to load this pointer with the address of any
    child class of `tBaseClass`; therefore, it is perfectly reasonable to load such
    a pointer with the address of a `tChildClassA` or `tChildClassB` variable. For
    example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Because `ptr` points at an object of type `tBaseClass`, you may legally (from
    a semantic sense) access the `i`, `j`, and `r` fields of the object where `ptr`
    is pointing. It is not legal to access the `c`, `b`, `w`, or `d` field of the
    `tChildClassA` or `tChildClassB` objects because at any one given moment the program
    may not know exactly what object type `ptr` references.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In order for inheritance to work properly, the `i`, `j`, and `r` fields must
    appear at the same offsets in all child classes as they do in `tBaseClass`. This
    way, an instruction of the form `mov((type tBaseClass [ebx]).i, eax)`; will correctly
    access the `i` field even if EBX points at an object of type `tChildClassA` or
    `tChildClassB`. [Figure 12-6](ch12s08.html#layout_of_base_and_child_class_objects_i
    "Figure 12-6. Layout of base and child class objects in memory") shows the layout
    of the child and base classes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Note that the new fields in the two child classes bear no relation to one another,
    even if they have the same name (for example, the `c` fields in the two child
    classes do not lie at the same offset). Although the two child classes share the
    fields they inherit from their common base class, any new fields they add are
    unique and separate. Two fields in different classes share the same offset only
    by coincidence if those fields are not inherited from a common base class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使两个子类中的新字段名称相同，它们也没有关系（例如，两个子类中的 `c` 字段并不位于相同的偏移量）。虽然两个子类共享它们从共同的基类继承的字段，但它们添加的任何新字段都是独立且唯一的。如果两个不同类中的字段共享相同的偏移量，那也只是巧合，前提是这些字段不是从共同的基类继承的。
- en: '![Layout of base and child class objects in memory](tagoreillycom20100401nostarchimages578091.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![基类和子类对象在内存中的布局](tagoreillycom20100401nostarchimages578091.png)'
- en: Figure 12-6. Layout of base and child class objects in memory
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-6. 基类和子类对象在内存中的布局
- en: All classes (even those that aren't related to one another) place the pointer
    to the virtual method table at offset 0 within the object. There is a single virtual
    method table associated with each class in a program; even classes that inherit
    fields from some base class have a virtual method table that is (generally) different
    than the base class's table. [Figure 12-7](ch12s08.html#virtual_method_table_references_from_obj
    "Figure 12-7. Virtual method table references from objects") shows how objects
    of type `tBaseClass`, `tChildClassA`, and `tChildClassB` point at their specific
    virtual method tables.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类（即使它们彼此之间没有关系）都会在对象的偏移量 0 处放置指向虚拟方法表的指针。程序中每个类都有一个唯一的虚拟方法表；即使是继承了某个基类字段的类，它们的虚拟方法表通常也与基类的表不同。[图
    12-7](ch12s08.html#virtual_method_table_references_from_obj "图 12-7. 从对象中引用虚拟方法表")
    展示了 `tBaseClass`、`tChildClassA` 和 `tChildClassB` 类型的对象如何指向它们各自的虚拟方法表。
- en: '![Virtual method table references from objects](tagoreillycom20100401nostarchimages578093.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![从对象中引用虚拟方法表](tagoreillycom20100401nostarchimages578093.png)'
- en: Figure 12-7. Virtual method table references from objects
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-7. 从对象中引用虚拟方法表
- en: 'A virtual method table is nothing more than an array of pointers to the methods
    and iterators associated with a class. The address of the first method or iterator
    that appears in a class is at offset 0, the address of the second appears at offset
    4, and so on. You can determine the offset value for a given iterator or method
    by using the `@offset` function. If you want to call a method directly (using
    80x86 syntax rather than HLA''s high-level syntax), you could use code like the
    following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟方法表不过是一个指向与类相关的各种方法和迭代器的指针数组。类中第一个方法或迭代器的地址位于偏移量 0，第二个方法的地址位于偏移量 4，依此类推。你可以使用
    `@offset` 函数来确定给定迭代器或方法的偏移值。如果你想直接调用一个方法（使用 80x86 语法，而不是 HLA 的高级语法），可以使用类似以下的代码：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Of course, if the method has any parameters, you must push them onto the stack
    before executing the code above. Don't forget when making direct calls to a method,
    you must load ESI with the address of the object. Any field references within
    the method will probably depend on ESI containing this address. The choice of
    EDI to contain the `VMT` address is nearly arbitrary. Unless you're doing something
    tricky (like using EDI to obtain runtime type information), you could use any
    register you please here. As a general rule, you should use EDI when simulating
    class method calls because this is the convention that HLA employs, and most programmers
    will expect this usage.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果方法有任何参数，你必须在执行上述代码之前将它们推入栈中。直接调用方法时，别忘了必须用对象的地址加载 ESI。方法中的任何字段引用可能都依赖于
    ESI 包含该地址。选择使用 EDI 来保存 `VMT` 地址几乎是任意的。除非你在做一些复杂的操作（比如使用 EDI 获取运行时类型信息），否则可以在这里使用任何你喜欢的寄存器。作为一般规则，当模拟类方法调用时，应该使用
    EDI，因为这是 HLA 使用的约定，大多数程序员会预期这种用法。
- en: 'Whenever a child class inherits fields from some base class, the child class''s
    virtual method table also inherits entries from the base class''s table. For example,
    the virtual method table for class `tBaseClass` contains only a single entry—a
    pointer to method `tBaseClass.mBase`. The virtual method table for class `tChildClassA`
    contains two entries: a pointer to `tBaseClass.mBase` and `tChildClassA.mA`. Because
    `tChildClassB` doesn''t define any new methods or iterators, `tChildClassB`''s
    virtual method table contains only a single entry, a pointer to the `tBaseClass.mBase`
    method. Note that `tChildClassB`''s virtual method table is identical to `tBaseclass`''s
    table. Nevertheless, HLA produces two distinct virtual method tables. This is
    a critical fact that we will make use of a little later. [Figure 12-8](ch12s08.html#virtual_method_tables_for_inherited_clas
    "Figure 12-8. Virtual method tables for inherited classes") shows the relationship
    between these virtual method tables.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每当子类从某个基类继承字段时，子类的虚拟方法表也会继承基类表中的条目。例如，类`tBaseClass`的虚拟方法表只包含一个条目——指向方法`tBaseClass.mBase`的指针。类`tChildClassA`的虚拟方法表包含两个条目：指向`tBaseClass.mBase`和`tChildClassA.mA`的指针。由于`tChildClassB`没有定义任何新方法或迭代器，`tChildClassB`的虚拟方法表只包含一个条目，即指向`tBaseClass.mBase`方法的指针。请注意，`tChildClassB`的虚拟方法表与`tBaseClass`的表是相同的。然而，HLA
    会生成两个不同的虚拟方法表。这是一个至关重要的事实，我们稍后会用到它。[图 12-8](ch12s08.html#virtual_method_tables_for_inherited_clas
    "图 12-8. 继承类的虚拟方法表") 显示了这些虚拟方法表之间的关系。
- en: '![Virtual method tables for inherited classes](tagoreillycom20100401nostarchimages578095.png.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![继承类的虚拟方法表](tagoreillycom20100401nostarchimages578095.png.jpg)'
- en: Figure 12-8. Virtual method tables for inherited classes
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-8. 继承类的虚拟方法表
- en: 'Although the virtual method table pointer always appears at offset 0 in an
    object (and, therefore, you can access the pointer using the address expression
    `[ESI]` if ESI points at an object), HLA actually inserts a symbol into the symbol
    table so you may refer to the virtual method table pointer symbolically. The symbol
    `_pVMT_` (pointer to virtual method table) provides this capability. So a more
    readable way to access the pointer (as in the previous code example) is:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管虚拟方法表指针总是出现在对象的偏移量 0 处（因此，如果 ESI 指向一个对象，你可以使用地址表达式 `[ESI]` 来访问指针），HLA 实际上会在符号表中插入一个符号，这样你就可以象征性地引用虚拟方法表指针。符号`_pVMT_`（指向虚拟方法表的指针）提供了这个能力。因此，更具可读性的一种访问指针的方式（如前面的代码示例所示）是：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you need to access the virtual method table directly, there are a couple
    of ways to do this. Whenever you declare a class object, HLA automatically includes
    a field named `_VMT_` as part of that class. `_VMT_` is a static array of double-word
    objects. Therefore, you may refer to the virtual method table using an identifier
    of the form *`classname`*`._VMT_`. Generally, you shouldn't access the virtual
    method table directly, but as you'll see shortly, there are some good reasons
    why you need to know the address of this object in memory.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要直接访问虚拟方法表，有几种方法可以做到这一点。每当你声明一个类对象时，HLA 会自动在该类中包含一个名为`_VMT_`的字段。`_VMT_`是一个静态的双字对象数组。因此，你可以通过类似
    *`classname`*`._VMT_` 的标识符来引用虚拟方法表。通常，你不应该直接访问虚拟方法表，但正如你将很快看到的，确实有一些合理的理由需要知道此对象在内存中的地址。
- en: 12.9 Constructors and Object Initialization
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.9 构造函数和对象初始化
- en: If you've tried to get a little ahead of the game and write a program that uses
    objects prior to this point, you've probably discovered that the program inexplicably
    crashes whenever you attempt to run it. We've covered a lot of material in this
    chapter thus far, but you are still missing one crucial piece of information—how
    to properly initialize objects prior to use. This section will put the final piece
    into the puzzle and allow you to begin writing programs that use classes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图提前写一个使用对象的程序，你可能已经发现，每当你尝试运行它时，程序会莫名其妙地崩溃。到目前为止，我们已经涵盖了本章的大量内容，但你仍然缺少一个关键的信息——如何在使用之前正确初始化对象。本节将为你解开最后一个谜题，并允许你开始编写使用类的程序。
- en: 'Consider the following object declaration and code fragment:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下对象声明和代码片段：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Remember that variables you declare in the `var` section are uninitialized
    at runtime. Therefore, when the program containing these statements gets around
    to executing `bc.mBase`, it executes the three-statement sequence you''ve seen
    several times already:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The problem with this sequence is that it loads EDI with an undefined value
    assuming you haven''t previously initialized the `bc` object. Because EDI contains
    a garbage value, attempting to call a subroutine at address `[EDI+@offset(tBaseClass.mBase)]`
    will likely crash the system. Therefore, before using an object, you must initialize
    the `_pVMT_` field with the address of that object''s virtual method table. One
    easy way to do this is with the following statement:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Always remember, before using an object, be sure to initialize the virtual method
    table pointer for that object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you must initialize the virtual method table pointer for all objects
    you use, this may not be the only field you need to initialize in those objects.
    Each specific class may have its own application-specific initialization. Although
    the initialization may vary by class, you need to perform the same initialization
    on each object of a specific class that you use. If you ever create more than
    a single object from a given class, it is probably a good idea to create a procedure
    to do this initialization for you. This is such a common operation that object-oriented
    programmers have given these initialization procedures a special name: *constructors*.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Some object-oriented languages (e.g., C++) use a special syntax to declare
    a constructor. Others (e.g., Delphi) simply use existing procedure declarations
    to define a constructor. One advantage to employing a special syntax is that the
    language knows when you define a constructor and can automatically generate code
    to call that constructor for you (whenever you declare an object). Languages like
    Delphi require that you explicitly call the constructor; this can be a minor inconvenience
    and a source of defects in your programs. HLA does not use a special syntax to
    declare constructors: you define constructors using standard class procedures.
    Thus, you will need to explicitly call the constructors in your program; however,
    you''ll see an easy method for automating this in [12.11 HLA''s _initialize_ and
    _finalize_ Strings](ch12s11.html "12.11 HLA''s _initialize_ and _finalize_ Strings").'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most important fact you must remember is that *constructors must
    be class procedures*. You must not define constructors as methods. The reason
    is quite simple: one of the tasks of the constructor is to initialize the pointer
    to the virtual method table, and you cannot call a class method or iterator until
    after you''ve initialized the `VMT` pointer. Because class procedures don''t use
    the virtual method table, you can call a class procedure prior to initializing
    the `VMT` pointer for an object.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: By convention, HLA programmers use the name `create` for the class constructor.
    There is no requirement that you use this name, but by doing so you will make
    your programs easier to read and follow by other programmers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，HLA 程序员使用 `create` 作为类构造函数的名称。虽然没有要求你必须使用这个名称，但这样做可以使你的程序更易于阅读，并且其他程序员也能更轻松地理解。
- en: As you may recall, you can call a class procedure via an object reference or
    a class reference. For example, if `clsProc` is a class procedure of class `tClass`
    and `Obj` is an object of type `tClass`, then the following two class procedure
    invocations are both legal.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，你可以通过对象引用或类引用调用类过程。例如，如果 `clsProc` 是 `tClass` 类的类过程，而 `Obj` 是 `tClass`
    类型的对象，那么以下两个类过程调用都是合法的。
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There is a big difference between these two calls. The first one calls `clsProc`
    with ESI containing 0 (NULL), while the second invocation loads the address of
    `Obj` into ESI before the call. We can use this fact to determine within a method
    the particular calling mechanism.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个调用之间有很大区别。第一个调用时，`clsProc` 的 ESI 中包含 0（NULL），而第二个调用会在调用之前将 `Obj` 的地址加载到 ESI
    中。我们可以利用这一点来确定方法内部的具体调用机制。
- en: 12.9.1 Dynamic Object Allocation Within the Constructor
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.9.1 构造函数中的动态对象分配
- en: 'As it turns out, most programs allocate objects dynamically using `mem.alloc`
    and refer to those objects indirectly using pointers. This adds one more step
    to the initialization process—allocating storage for the object. The constructor
    is the perfect place to allocate this storage. Because you probably won''t need
    to allocate all objects dynamically, you''ll need two types of constructors: one
    that allocates storage and then initializes the object, and another that simply
    initializes an object that already has storage.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，大多数程序都使用 `mem.alloc` 动态分配对象，并通过指针间接引用这些对象。这增加了初始化过程中的一步——为对象分配存储。构造函数是分配存储的最佳位置。因为你可能不需要动态分配所有对象，所以你需要两种类型的构造函数：一种是分配存储并初始化对象，另一种则是初始化已经有存储的对象。
- en: 'Another constructor convention is to merge these two constructors into a single
    constructor and differentiate the type of constructor call by the value in ESI.
    On entry into the class''s `create` procedure, the program checks the value in
    ESI to see if it contains NULL (0). If so, the constructor calls `mem.alloc` to
    allocate storage for the object and returns a pointer to the object in ESI. If
    ESI does not contain NULL upon entry into the procedure, then the constructor
    assumes that ESI points at a valid object and skips over the memory allocation
    statements. At the very least, a constructor initializes the pointer to the virtual
    method table; therefore, the minimalist constructor will look like the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种构造函数的惯例是将这两种构造函数合并为一个，并通过 ESI 中的值来区分构造函数调用的类型。在进入类的 `create` 过程时，程序检查 ESI
    中的值，看看它是否包含 NULL（0）。如果是，构造函数会调用 `mem.alloc` 来为对象分配存储并将指针返回到 ESI。如果进入过程时 ESI 不包含
    NULL，那么构造函数就认为 ESI 指向一个有效的对象，并跳过内存分配的语句。最起码，构造函数会初始化指向虚拟方法表的指针；因此，最简单的构造函数看起来像下面这样：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After you write a constructor like the preceding, you choose an appropriate
    calling mechanism based on whether your object''s storage is already allocated.
    For preallocated objects (such as those you''ve declared in `var`, `static`, or
    `storage` sections^([[138](#ftn.CHP-12-FN-7)]) or those you''ve previously allocated
    storage for via `mem.alloc`), you simply load the address of the object into ESI
    and call the constructor. For those objects you declare as a variable, this is
    very easy; just call the appropriate `create` constructor:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写像上面这样的构造函数后，你可以根据对象存储是否已经分配来选择合适的调用机制。对于预分配的对象（比如在 `var`、`static` 或 `storage`
    部分声明的对象^([[138](#ftn.CHP-12-FN-7)])，或那些你通过 `mem.alloc` 预先分配存储的对象），你只需将对象的地址加载到
    ESI 中并调用构造函数。对于你声明为变量的对象，这很简单；只需调用合适的 `create` 构造函数：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that although `bcp` is a pointer to a `tBaseClass` object, the create
    method does not automatically allocate storage for this object. The program already
    allocated the storage earlier. Therefore, when the program calls `bcp.create`,
    it loads ESI with the address contained within `bcp`; because this is not NULL,
    the `tBaseClass.create` procedure does not allocate storage for a new object.
    By the way, the call to `bcp.create` emits the following sequence of machine instructions:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然`bcp`是一个指向`tBaseClass`对象的指针，但`create`方法并不会自动为此对象分配存储空间。程序已经在之前分配了存储空间。因此，当程序调用`bcp.create`时，它会加载ESI，其中包含在`bcp`内的地址；因为这不是NULL，所以`tBaseClass.create`过程不会为新对象分配存储空间。顺便说一句，对`bcp.create`的调用会发出以下一系列机器指令：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Until now, the code examples for a class procedure call always began with an
    `lea` instruction. This is because all the examples to this point have used object
    variables rather than pointers to object variables. Remember, a class procedure
    (method) call passes the address of the object in the ESI register. For object
    variables HLA emits an `lea` instruction to obtain this address. For pointers
    to objects, however, the actual object address is the *value* of the pointer variable;
    therefore, to load the address of the object into ESI, HLA emits a `mov` instruction
    that copies the value of the pointer into the ESI register.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，关于类过程调用的代码示例总是以`lea`指令开始。这是因为到目前为止的所有示例都使用了对象变量，而不是对象变量的指针。请记住，类过程（方法）调用会将对象的地址传递给ESI寄存器。对于对象变量，HLA会发出`lea`指令以获取此地址。然而，对于对象的指针，实际的对象地址是指针变量的*值*；因此，为了将对象的地址加载到ESI中，HLA会发出一个`mov`指令，将指针的值复制到ESI寄存器中。
- en: 'In the preceding example, the program preallocates the storage for an object
    prior to calling the object constructor. While there are several reasons for preallocating
    object storage (for example, you''re creating a dynamic array of objects), you
    can achieve most simple object allocations like the one above by calling a standard
    `create` procedure (such as one that allocates storage for an object if ESI contains
    `NULL`). The following example demonstrates this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，程序在调用对象构造函数之前预先分配了对象的存储空间。虽然有多种预分配对象存储空间的原因（例如，创建对象的动态数组），但您可以通过调用标准的`create`过程（例如，如果ESI包含`NULL`，则分配对象存储空间的过程）来实现大多数简单的对象分配，就像上面的示例一样。以下示例演示了这一点：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Remember, a call to a `tBaseClass.create` constructor returns a pointer to the
    new object in the ESI register. It is the caller's responsibility to save the
    pointer this function returns into the appropriate pointer variable; the constructor
    does not automatically do this for you. Likewise, it is the caller's responsibility
    to free the storage associated with this object when the application has finished
    using the object (see the discussion of destructors in [12.10 Destructors](ch12s10.html
    "12.10 Destructors")).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于`tBaseClass.create`构造函数的调用会将新对象的指针存储在ESI寄存器中。调用者有责任将此函数返回的指针保存到适当的指针变量中；构造函数不会自动完成此操作。同样，当应用程序结束使用对象时，调用者有责任释放与该对象关联的存储空间（请参阅[12.10
    析构函数](ch12s10.html "12.10 Destructors")中对析构函数的讨论）。
- en: 12.9.2 Constructors and Inheritance
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.9.2 构造函数与继承
- en: Constructors for derived (child) classes that inherit fields from a base class
    represent a special case. Each class must have its own constructor but needs the
    ability to call the base class constructor. This section explains the reasons
    for this and how to do it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自基类的派生（子）类构造函数代表了一种特殊情况。每个类必须有自己的构造函数，但需要调用基类的构造函数。本节解释了这一点的原因以及如何实现。
- en: A derived class inherits the `create` procedure from its base class. However,
    you must override this procedure in a derived class because the derived class
    probably requires more storage than the base class, and therefore you will probably
    need to use a different call to `mem.alloc` to allocate storage for a dynamic
    object. Hence, it is very unusual for a derived class not to override the definition
    of the `create` procedure.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类会继承其基类的`create`过程。但是，在派生类中必须重写此过程，因为派生类可能需要比基类更多的存储空间，因此可能需要使用不同的调用来为动态对象分配存储空间。因此，派生类不重写`create`过程是非常不寻常的。
- en: However, overriding a base class's `create` procedure has problems of its own.
    When you override the base class's `create` procedure, you take the full responsibility
    of initializing the (entire) object, including all the initialization required
    by the base class. At the very least, this involves putting duplicate code in
    the overridden procedure to handle the initialization usually done by the base
    class constructor. In addition to making your program larger (by duplicating code
    already present in the base class constructor), this also violates information-hiding
    principles because the derived class must be aware of all the fields in the base
    class (including those that are logically private to the base class). What we
    need here is the ability to call a base class's constructor from within the derived
    class's constructor and let that call do the lower-level initialization of the
    base class's fields. Fortunately, this is an easy thing to do in HLA.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following class declarations (which do things the hard way):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's take a closer look at the `tDerived.create` procedure above. Like a conventional
    constructor, it begins by checking ESI and allocates storage for a new object
    if ESI contains NULL. Note that the size of a `tDerived` object includes the size
    required by the inherited fields, so this properly allocates the necessary storage
    for all fields in a `tDerived` object.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `tDerived.create` procedure initializes the `VMT` pointer field of
    the object. Remember, each class has its own `virtual method table` and, specifically,
    derived classes do not use the `virtual method table` of their base class. Therefore,
    this constructor must initialize the `_pVMT_` field with the address of the `tDerived
    virtual method table`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: After initializing the `virtual method table` pointer, the `tDerived` constructor
    initializes the value of the `r` field to 0.0 (remember, `fldz` loads 0 onto the
    FPU stack). This concludes the `tDerived`-specific initialization.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The remaining instructions in `tDerived.create` are the problem. These statements
    duplicate some of the code appearing in the `tBase.create` procedure. The problem
    with code duplication becomes apparent when you decide to modify the initial values
    of these fields; if you've duplicated the initialization code in derived classes,
    you will need to change the initialization code in more than one `create` procedure.
    More often than not, however, this results in defects in the derived class `create`
    procedures, especially if those derived classes appear in different source files
    than the base class.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with burying base class initialization in derived class constructors
    is the violation of the information-hiding principle. Some fields of the base
    class may be *logically private*. Although HLA does not explicitly support the
    concept of public and private fields in a class (as, say, C++ does), well-disciplined
    programmers will still partition the fields as private or public and then use
    the private fields only in class routines belonging to that class. Initializing
    these private fields in derived classes is not acceptable to such programmers.
    Doing so will make it very difficult to change the definition and implementation
    of some base class at a later date.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, HLA provides an easy mechanism for calling the inherited constructor
    within a derived class's constructor. All you have to do is call the base constructor
    using the class name syntax; for example, you could call `tBase.create` directly
    from within `tDerived.create`. By calling the base class constructor, your derived
    class constructors can initialize the base class fields without worrying about
    the exact implementation (or initial values) of the base class.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there are two types of initialization that every (conventional)
    constructor does that will affect the way you call a base class constructor: All
    conventional constructors allocate memory for the class if ESI contains 0, and
    all conventional constructors initialize the `VMT` pointer. Fortunately, it is
    very easy to deal with these two problems.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The memory required by an object of some base class is usually less than the
    memory required for an object of a class you derive from that base class (because
    the derived classes usually add more fields). Therefore, you cannot allow the
    base class constructor to allocate the storage when you call it from inside the
    derived class's constructor. You can easily solve this problem by checking ESI
    within the derived class constructor and allocating any necessary storage for
    the object *before* calling the base class constructor.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is the initialization of the `VMT` pointer. When you call
    the base class's constructor, it will initialize the `VMT` pointer with the address
    of the base class's virtual method table. A derived class object's `_pVMT_` field,
    however, must point at the virtual method table for the derived class. Calling
    the base class constructor will always initialize the `_pVMT_` field with the
    wrong pointer. To properly initialize the `_pVMT_` field with the appropriate
    value, the derived class constructor must store the address of the derived class's
    virtual method table into the `_pVMT_` field *after* the call to the base class
    constructor (so that it overwrites the value written by the base class constructor).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tDerived.create` constructor, rewritten to call the `tBase.create` constructors,
    follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This solution solves all the above concerns with derived class constructors.
    Note that the call to the base constructor uses the syntax `(type tBase [esi]).create();`
    rather than `tBase.create();`. The problem with calling `tBase.create` directly
    is that it will load `NULL` into ESI and overwrite the pointer to the storage
    allocated in `tDerived.create`. The scheme above uses the existing value in ESI
    when calling `tBase.create`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 12.9.3 Constructor Parameters and Procedure Overloading
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: None of the constructor examples to this point have had any parameters. However,
    there is nothing special about constructors that prevents the use of parameters.
    Constructors are procedures; therefore, you can specify any number and any type
    of parameters you choose. You can use these parameter values to initialize certain
    fields or control how the constructor initializes the fields. Of course, you may
    use constructor parameters for any purpose you'd use parameters for in any other
    procedure. In fact, about the only issue you need concern yourself with is the
    use of parameters whenever you have a derived class. This section deals with those
    issues.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The first, and probably most important, problem with parameters in derived
    class constructors actually applies to all overridden procedures and methods:
    The parameter list of an overridden routine must exactly match the parameter list
    of the corresponding routine in the base class. In fact, HLA doesn''t even give
    you the chance to violate this rule because `override` routine prototypes don''t
    allow parameter list declarations: They automatically inherit the parameter list
    of the base routine. Therefore, you cannot use a special parameter list in the
    constructor prototype for one class and a different parameter list for the constructors
    appearing in base or derived classes. Sometimes it would be nice if this weren''t
    the case, but there are some sound and logical reasons why HLA does not support
    this.^([[139](#ftn.CHP-12-FN-8)])'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: HLA supports a special `overloads` declaration that lets you call one of several
    different procedures, methods, or iterators using a single identifier (with the
    number of types of parameters specifying which function to call). This would allow
    you, for example, to create multiple constructors for a given class (or derived
    class) and invoke the desired constructor using a matching parameter list for
    that constructor. Interested readers should consult the chapter on procedures
    in the HLA documentation for more details concerning the `overloads` declaration.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: ^([[138](#CHP-12-FN-7)]) You generally do not declare objects in `readonly`
    sections because you cannot initialize them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: ^([[139](#CHP-12-FN-8)]) Calling virtual methods and iterators would be a real
    problem because you don't really know which routine a pointer references. Therefore,
    you couldn't know the proper parameter list. While the problems with procedures
    aren't quite as drastic, there are some subtle problems that could creep into
    your code if base or derived classes allowed overridden procedures with different
    parameter lists.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 12.10 Destructors
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *destructor* is a class routine that cleans up an object once a program finishes
    using that object. As for constructors, HLA does not provide a special syntax
    for creating destructors, nor does HLA automatically call a destructor. Unlike
    constructors, a destructor is usually a method rather than a procedure (because
    virtual destructors make a lot of sense, whereas virtual constructors do not).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: A typical destructor might close any files opened by the object, free the memory
    allocated during the use of the object, and, finally, free the object itself if
    it was created dynamically. The destructor also handles any other cleanup chores
    the object may require before it ceases to exist.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'By convention, most HLA programmers name their destructors `destroy`. About
    the only code that most destructors have in common is the code to free the storage
    associated with the object. The following destructor demonstrates how to do this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The HLA Standard Library routine `mem.isInHeap` returns true if its parameter
    is an address that `mem.alloc` returned. Therefore, this code automatically frees
    the storage associated with the object if the program originally allocated storage
    for the object by calling `mem.alloc`. Obviously, on return from this method call,
    ESI will no longer point at a legal object in memory if you allocated it dynamically.
    Note that this code will not affect the value in ESI nor will it modify the object
    if the object wasn't one you've previously allocated via a call to `mem.alloc`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 12.11 HLA's _initialize_ and _finalize_ Strings
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although HLA does not automatically call constructors and destructors associated
    with your classes, HLA does provide a mechanism whereby you can force HLA to automatically
    emit these calls: by using the `_initialize_` and `_finalize_` compile-time string
    variables (i.e., `val` constants) that HLA automatically declares in every procedure.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you write a procedure, iterator, or method, HLA automatically declares
    several local symbols in that routine. Two such symbols are `_initialize_` and
    `_finalize_`. HLA declares these symbols as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'HLA emits the `_initialize_` string as text at the very beginning of the routine''s
    body, that is, immediately after the routine''s `begin` clause.^([[140](#ftn.CHP-12-FN-9)])
    Similarly, HLA emits the `_finalize_` string at the very end of the routine''s
    body, just before the `end` clause. This is comparable to the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Because `_initialize_` and `_finalize_` initially contain the empty string,
    these expansions have no effect on the code that HLA generates unless you explicitly
    modify the value of `_initialize_` prior to the `begin` clause or you modify `_finalize_`
    prior to the `end` clause of the procedure. So if you modify either of these string
    objects to contain a machine instruction, HLA will compile that instruction at
    the beginning or end of the procedure. The following example demonstrates how
    to use this technique:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Of course, these examples don't save you much. It would be easier to type the
    actual statements at the beginning and end of the procedure than to assign a string
    containing these statements to the `_initialize_` and `_finalize_` compile-time
    variables. However, if we could automate the assignment of some string to these
    variables, so that we don't have to explicitly assign them in each procedure,
    then this feature might be useful. In a moment, you'll see how we can automate
    the assignment of values to the `_initialize_` and `_finalize_` strings. For the
    time being, consider the case where we load the name of a constructor into the
    `_initialize_` string and we load the name of a destructor in to the `_finalize_`
    string. By doing this, the routine will "automatically" call the constructor and
    destructor for that particular object.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example has a minor problem. If we can automate the assignment
    of some value to `_initialize_` or `_finalize_`, what happens if these variables
    already contain some value? For example, suppose we have two objects we use in
    a routine, and the first one loads the name of its constructor into the `_initialize_`
    string; what happens when the second object attempts to do the same thing? The
    solution is simple: Don''t directly assign any string to the `_initialize_` or
    `_finalize_` compile-time variables; instead, always concatenate your strings
    to the end of the existing string in these variables. The following is a modification
    to the above example that demonstrates how to do this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When you assign values to the `_initialize_` and `_finalize_` strings, HLA guarantees
    that the `_initialize_` sequence will execute upon entry into the routine. Sadly,
    the same is not true for the `_finalize_` string upon exit. HLA simply emits the
    code for the `_finalize_` string at the end of the routine, immediately before
    the code that cleans up the activation record and returns. Unfortunately, "falling
    off the end of the routine" is not the only way that you could return from that
    routine. You could explicitly return from somewhere in the middle of the code
    by executing a `ret` instruction. Because HLA emits the `_finalize_` string only
    at the very end of the routine, returning from that routine in this manner bypasses
    the `_finalize_` code. Unfortunately, other than manually emitting the `_finalize_`
    code, there is nothing you can do about this.^([[141](#ftn.CHP-12-FN-10)]) Fortunately,
    this mechanism for exiting a routine is completely under your control. If you
    never exit a routine except by "falling off the end," then you won't have to worry
    about this problem (note that you can use the `exit` control structure to transfer
    control to the end of a routine if you really want to return from that routine
    from somewhere in the middle of the code).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to prematurely exit a routine, over which, unfortunately, you don''t
    have any control, is by raising an exception. Your routine could call some other
    routine (e.g., a Standard Library routine) that raises an exception and then transfers
    control immediately to whomever called your routine. Fortunately, you can easily
    trap and handle exceptions by putting a `try..endtry` block in your procedure.
    Here is an example that demonstrates this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Although the previous code handles some problems that exist with `_finalize_`,
    by no means does it handle every possible case. Always be on the lookout for ways
    your program could inadvertently exit a routine without executing the code found
    in the `_finalize_` string. You should explicitly expand `_finalize_` if you encounter
    such a situation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important place you can get into trouble with respect to exceptions:
    within the code the routine emits for the `_initialize_` string. If you modify
    the `_initialize_` string so that it contains a constructor call and the execution
    of that constructor raises an exception, this will probably force an exit from
    that routine without executing the corresponding `_finalize_` code. You could
    bury the `try..endtry` statement directly into the `_initialize_` and `_finalize_`
    strings, but this approach has several problems, not the least of which is the
    fact that one of the first constructors you call might raise an exception that
    transfers control to the exception handler that calls the destructors for all
    objects in that routine (including those objects whose constructors you have yet
    to call). Although no single solution that handles all problems exists, probably
    the best approach is to put a `try..endtry` block within each constructor call
    if it is possible for that constructor to raise some exception that is possible
    to handle (that is, doesn''t require the immediate termination of the program).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus far this discussion of `_initialize_` and `_finalize_` has failed to address
    one important point: Why use this feature to implement the "automatic" calling
    of constructors and destructors, because it apparently involves more work than
    simply calling the constructors and destructors directly? Clearly there must be
    a way to automate the assignment of the `_initialize_` and `_finalize_` strings
    or this section wouldn''t exist. The way to accomplish this is by using a macro
    to define the class type. So now it''s time to take a look at another HLA feature
    that makes it possible to automate this activity: the `forward` keyword.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ve seen how to use the `forward` reserved word to create procedure prototypes
    (see the discussion in [5.9 Forward Procedures](ch05s09.html "5.9 Forward Procedures"));
    it turns out that you can declare forward `const`, `val`, `type`, and variable
    declarations as well. The syntax for such declarations takes the following form:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This declaration is completely equivalent to the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Especially note that this expansion does not actually define the symbol *`ForwardSymbolName`*.
    It just converts this symbol to a string and assigns this string to the specified
    `text` object *`undefinedID`*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you''re probably wondering how something like the above is equivalent to
    a forward declaration. The truth is, it isn''t. However, forward declarations
    let you create macros that simulate type names by allowing you to defer the actual
    declaration of an object''s type until some later point in the code. Consider
    the following example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Note, and this is very important, that a semicolon does not follow the `varID:
    myClass` declaration at the end of this macro. You''ll find out why this semicolon
    is missing in a little while.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have the above class and macro declarations in your program, you can
    now declare variables of type `_myClass` that automatically invoke the constructor
    and destructor upon entry and exit of the routine containing the variable declarations.
    To see how, take a look at the following procedure shell:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Because `_myClass` is a macro, the procedure above expands to the following
    text during compilation:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You might notice that a semicolon appears after the `mco: myClass` declaration
    in the example above. This semicolon is not actually a part of the macro; instead
    it is the semicolon that follows the `mco: _myClass;` declaration in the original
    code.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create an array of objects, you could legally declare that array
    as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Because the last statement in the `_myClass` macro doesn''t end with a semicolon,
    the declaration above will expand to something like the following (almost correct)
    code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The only problem with this expansion is that it calls the constructor only for
    the first object of the array. There are several ways to solve this problem; one
    is to append a macro name to the end of `_initialize_` and `_finalize_` rather
    than the constructor name. That macro would check the object's name (`mcoArray`
    in this example) to determine if it is an array. If so, that macro could expand
    to a loop that calls the constructor for each element of the array.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Another solution to this problem is to use a macro parameter to specify the
    dimensions for arrays of `myClass`. This scheme is easier to implement than the
    one above, but it does have the drawback of requiring a different syntax for declaring
    object arrays (you have to use parentheses rather than square brackets around
    the array dimension).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The `forward` directive is quite powerful and lets you achieve all kinds of
    tricks. However, there are a few problems of which you should be aware. First,
    because HLA emits the `_initialize_` and `_finalize_` code transparently, you
    can be easily confused if there are any errors in the code appearing within these
    strings. If you start getting error messages associated with the `begin` or `end`
    statements in a routine, you might want to take a look at the `_initialize_` and
    `_finalize_` strings within that routine. The best defense here is to always append
    very simple statements to these strings so that you reduce the likelihood of an
    error.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Fundamentally, HLA doesn''t support automatic constructor and destructor calls.
    This section has presented several tricks to attempt to automate the calls to
    these routines. However, the automation isn''t perfect and, indeed, the aforementioned
    problems with the `_finalize_` strings limit the applicability of this approach.
    The mechanism this section presents is probably fine for simple classes and simple
    programs. One piece of advice is probably worth following: If your code is complex
    or correctness is critical, it''s probably a good idea to explicitly call the
    constructors and destructors manually.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: ^([[140](#CHP-12-FN-9)]) If the routine automatically emits code to construct
    the activation record, HLA emits `_initialize_`'s text after the code that builds
    the activation record.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: ^([[141](#CHP-12-FN-10)]) Note that you can manually emit the `_finalize_` code
    using the statement `@text( _finalize_ );`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 12.12 Abstract Methods
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An *abstract base class* is one that exists solely to supply a set of common
    fields to its derived classes. You never declare variables whose type is an abstract
    base class; you always use one of the derived classes. The purpose of an abstract
    base class is to provide a template for creating other classes, nothing more.
    As it turns out, the only difference in syntax between a standard base class and
    an abstract base class is the presence of at least one *abstract method* declaration.
    An abstract method is a special method that does not have an actual implementation
    in the abstract base class. Any attempt to call that method will raise an exception.
    If you're wondering what possible good an abstract method could be, keep on reading.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to create a set of classes to hold numeric values. One class
    could represent unsigned integers, another class could represent signed integers,
    a third could implement BCD values, and a fourth could support `real64` values.
    While you could create four separate classes that function independently of one
    another, doing so passes up an opportunity to make this set of classes more convenient
    to use. To understand why, consider the following possible class declarations:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The implementation of these classes is not unreasonable. They have fields for
    the data and they have a `put` method (which, presumably, writes the data to the
    standard output device). They probably have other methods and procedures to implement
    various operations on the data. There are, however, two problems with these classes,
    one minor and one major, both occurring because these classes do not inherit any
    fields from a common base class.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The first problem, which is relatively minor, is that you have to repeat the
    declaration of several common fields in these classes. For example, the `put`
    method declaration appears in each of these classes.^([[142](#ftn.CHP-12-FN-11)])
    This duplication of effort results in a harder-to-maintain program because it
    doesn't encourage you to use a common name for a common function since it's easy
    to use a different name in each of the classes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: A bigger problem with this approach is that it is not generic. That is, you
    can't create a generic pointer to a "numeric" object and perform operations like
    addition, subtraction, and output on that value (regardless of the underlying
    numeric representation).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily solve these two problems by turning the previous class declarations
    into a set of derived classes. The following code demonstrates an easy way to
    do this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This scheme solves both the problems. First, by inheriting the `put` method
    from numeric, this code encourages the derived classes to always use the name
    *`put`*, thereby making the program easier to maintain. Second, because this example
    uses derived classes, it's possible to create a pointer to the `numeric` type
    and load this pointer with the address of a `uint`, `sint`, or `r64` object. That
    pointer can invoke the methods found in the `numeric` class to do functions like
    addition, subtraction, or numeric output. Therefore, the application that uses
    this pointer doesn't need to know the exact data type; it deals with numeric values
    only in a generic fashion.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: One problem with this scheme is that it's possible to declare and use variables
    of type `numeric`. Unfortunately, such numeric variables don't have the ability
    to represent any type of number (notice that the data storage for the numeric
    fields actually appears in the derived classes). Worse, because you've declared
    the `put` method in the `numeric` class, you actually have to write some code
    to implement that method even though you should never really call it; the actual
    implementation should occur only in the derived classes. While you could write
    a dummy method that prints an error message (or, better yet, raises an exception),
    there shouldn't be any need to write "dummy" procedures like this. Fortunately,
    there is no reason to do so—if you use *abstract* methods.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'The `abstract` keyword, when it follows a method declaration, tells HLA that
    you are not going to provide an implementation of the method for this class. Instead,
    it is the responsibility of all derived classes to provide a concrete implementation
    for the abstract method. HLA will raise an exception if you attempt to call an
    abstract method directly. The following is the modification to the `numeric` class
    to convert `put` to an abstract method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: An abstract base class is a class that has at least one abstract method. Note
    that you don't have to make all methods abstract in an abstract base class; it
    is perfectly legal to declare some standard methods (and, of course, provide their
    implementation) within the abstract base class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Abstract method declarations provide a mechanism by which a base class can specify
    some generic methods that the derived classes must implement. In theory, all derived
    classes must provide concrete implementations of all abstract methods, or those
    derived classes are themselves abstract base classes. In practice, it's possible
    to bend the rules a little and use abstract methods for a slightly different purpose.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: A little earlier, you read that you should never create variables whose type
    is an abstract base class. If you attempt to execute an abstract method, the program
    would immediately raise an exception to complain about this illegal method call.
    In practice, you actually can declare variables of an abstract base type and get
    away with this as long as you don't call any abstract methods in that class.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: ^([[142](#CHP-12-FN-11)]) Note, by the way, that `TheValue` is not a common
    field because this field has a different type in the `r64` class.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 12.13 Runtime Type Information
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with an object variable (as opposed to a pointer to an object),
    the type of that object is obvious: It''s the variable''s declared type. Therefore,
    at both compile time and runtime the program knows the type of the object. When
    working with pointers to objects you cannot, in the general case, determine the
    type of an object a pointer references. However, at runtime it is possible to
    determine the object''s actual type. This section discusses how to detect the
    underlying object''s type and how to use this information.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a pointer to an object and that pointer''s type is some base class,
    at runtime the pointer could point at an object of the base class or any derived
    type. At compile time it is not possible to determine the exact type of an object
    at any instant. To see why, consider the following short example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The routine *`ReturnSomeObject`* returns a pointer to an object in ESI. This
    could be the address of some base class object or a derived class object. At compile
    time there is no way for the program to know what type of object this function
    returns. For example, *`ReturnSomeObject`* could ask the user what value to return
    so the exact type could not be determined until the program actually runs and
    the user makes a selection.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: In a perfectly designed program, there probably is no need to know a generic
    object's actual type. After all, the whole purpose of object-oriented programming
    and inheritance is to produce general programs that work with lots of different
    objects without having to make substantial changes to the program. In the real
    world, however, programs may not have a perfect design, and sometimes it's nice
    to know the exact object type a pointer references. Runtime type information,
    or RTTI, gives you the capability of determining an object's type at runtime,
    even if you are referencing that object using a pointer to some base class of
    that object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most fundamental RTTI operation you need is the ability to ask
    if a pointer contains the address of some specific object type. Many object-oriented
    languages (e.g., Delphi) provide an `is` operator that provides this functionality.
    `is` is a boolean operator that returns true if its left operand (a pointer) points
    at an object whose type matches the right operand (which must be a type identifier).
    The typical syntax is generally the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This operator returns true if the variable is of the specified class; it returns
    false otherwise. Here is a typical use of this operator (in the Delphi language):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It''s actually quite simple to implement this functionality in HLA. As you
    may recall, each class is given its own virtual method table. Whenever you create
    an object, you must initialize the pointer to the virtual method table with the
    address of that class''s virtual method table. Therefore, the `VMT` pointer field
    of all objects of a given class type contains the same pointer value, and this
    pointer value is different from the `VMT` pointer field of all other classes.
    We can use this fact to see if an object is some specific type. The following
    code demonstrates how to implement the Delphi statement above in HLA:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This `if` statement simply compares the object's `_pVMT_` field (the pointer
    to the virtual method table) against the address of the desired classes' virtual
    method table. If they are equal, then the *`ptrToNumeric`* variable points at
    an object of type `uint`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the body of a class method or iterator, there is a slightly easier way
    to see if the object is a certain class. Remember, upon entry into a method or
    an iterator, the EDI register contains the address of the virtual method table.
    Therefore, assuming you haven''t modified EDI''s value, you can easily test to
    see if the method or iterator is a specific class type using an `if` statement
    like the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Remember, however, that EDI will contain a pointer to the virtual method table
    only when you call a class method. This is not the case when calling a class procedure.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 12.14 Calling Base Class Methods
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the section on constructors you saw that it is possible to call an ancestor
    class's procedure within the derived class's overridden procedure. To do this,
    all you need to do is to invoke the procedure using the call `(type` *`classname`*
    `[esi]).`*`procedureName`*`(` *`parameters`* `);`. On occasion you may want to
    do this same operation with a class's methods as well as its procedures (that
    is, have an overridden method call the corresponding base class method in order
    to do some computation you'd rather not repeat in the derived class's method).
    Unfortunately, HLA does not let you directly call methods as it does procedures.
    You will need to use an indirect mechanism to achieve this; specifically, you
    will have to call the method using the address in the base class's virtual method
    table. This section describes how to do this.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever your program calls a method it does so indirectly, using the address
    found in the virtual method table for the method''s class. The virtual method
    table is nothing more than an array of 32-bit pointers, with each entry containing
    the address of one of that class''s methods. So to call a method, all you need
    is the index into this array (or, more properly, the offset into the array) of
    the address of the method you wish to call. The HLA compile-time function `@offset`
    comes to the rescue: It will return the offset into the virtual method table of
    the method whose name you supply as a parameter. Combined with the `call` instruction,
    you can easily call any method associated with a class. Here''s an example of
    how you would do this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `call` instruction above calls the method whose address appears at the specified
    entry in the virtual method table for *`myCls`*. The `@offset` function call returns
    the offset (i.e., index times 4) of the address of `myCls.m` within the virtual
    method table. Hence, this code indirectly calls the `m` method by using the virtual
    method table entry for `m`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one major drawback to calling methods using this scheme: You don''t
    get to use the high-level syntax for procedure/method calls. Instead, you must
    use the low-level `call` instruction. In the example above, this isn''t much of
    an issue because the `m` procedure doesn''t have any parameters. If it did have
    parameters, you would have to manually push those parameters onto the stack yourself.
    Fortunately, you''ll rarely need to call ancestor class methods from a derived
    class, so this won''t be much of an issue in real-world programs.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 12.15 For More Information
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HLA reference manual at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/) contains additional information
    about HLA's class implementation. Check out this document for additional low-level
    implementation features. This chapter hasn't really attempted to teach the object-oriented
    programming paradigm. See a generic text on object-oriented design for more details
    about this subject.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
