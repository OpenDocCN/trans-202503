- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 10 TABLE LOOKUPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the early days of assembly language programming, replacing expensive computations
    with table lookups was a common way to improve program performance. Today, memory
    speeds in modern systems limit the performance gains that can be obtained by using
    table lookups. However, for very complex calculations, this is still a viable
    technique for writing high-performance code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses how to use table lookups to speed up or reduce the complexity
    of computations, demonstrating the space and speed trade-offs involved.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 Using Tables in Assembly Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To an assembly language programmer, a *table* is an array containing initialized
    values that do not change after they’re created. In assembly language, you can
    use tables for a variety of purposes: computing functions, controlling program
    flow, or simply looking up data. In general, tables provide a fast mechanism for
    performing an operation, at the expense of space in your program (the extra space
    holds the tabular data).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore some of the many possible uses of tables in an
    assembly language program. Keep in mind that because tables typically contain
    initialized data that does not change during program execution, the .section .rodata,
    "" section is a good place to put your table objects.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.1 Function Computation via Table Lookup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A simple-looking HLL arithmetic expression can be equivalent to a considerable
    amount of ARM assembly language code and may therefore be expensive to compute.
    Assembly language programmers often precompute many values and use a table lookup
    of those values to speed up their programs, which is easier and often more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Pascal statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This if statement converts the character variable’s value from lowercase to
    uppercase if the character is in the range a to z. Comparable assembly code requires
    a total of seven machine instructions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The NZCV constant 0b0010 sets the carry flag and clears the 0 so that the branch
    will be taken if W0 is less than 'a' (if W0 is less than 'a', the carry is set
    and the zero flag is clear, which is “higher or same” without the same component,
    so just higher) ❶. Note that the conditional compare instruction allows only 5-bit
    immediate constants; this is why the code loads the character constant 'z' into
    W1 and conditionally compares against W1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual method for converting lowercase to uppercase is to clear bit 5 of
    the ASCII character code. However, and w0, w0, #0x5F is not a legal instruction
    because 0x5F is not a legal logical constant. This code uses the eor (exclusive-OR)
    instruction to invert bit 5 ❷. Because this bit is guaranteed to be set at this
    point (bit 5 is set for all lowercase characters), the eor instruction will clear
    this bit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lookup table solution uses only four instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The conversion logic is completely buried in the lookup table (xlatTbl). This
    is a 256-byte array; each index contains the index value (element 0 contains the
    value 0, element 1 contains the value 1, and so on) except for the indices corresponding
    to the ASCII codes for the lowercase characters (indices 97 through 122). Those
    particular array elements contain the ASCII codes for the uppercase characters
    (values 65 through 90).
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you can guarantee that you’ll load only 7-bit ASCII characters
    into this code, you can get by with a 128-byte (rather than a 256-byte) array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a typical (128-byte) lookup table that converts lowercase characters
    to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you want a full 256-byte table, elements 128 through 255 would contain the
    values 128 through 255.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ldrb w0, [x1, w0, uxtw #0] instruction loads W0 with the byte at the index
    specified by the (original) value held in W0, assuming X1 holds the address of
    xlatTbl. If W0 holds a non-lowercase character code, that index into the table
    will load the same value into W0 (so this instruction does not change W0’s value
    if it is not a lowercase letter). If W0 contains a lowercase letter, the index
    into this table fetches the ASCII code of the corresponding uppercase character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 10-1 demonstrates these two forms of case conversion: if...eor and
    table lookup.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the build command and sample output for Listing 10-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I didn’t attempt to time the two versions, because the call to printf() dominates
    the execution time of the two algorithms. However, because the table-lookup algorithm
    accesses memory on each character (to fetch a byte from the lookup table), the
    process is no shorter even though it uses fewer instructions. The lookup table
    adds 128 bytes (or 256 bytes) to the size of the program’s code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a lookup table for a simple computation such as lowercase-to-uppercase
    conversion carries little benefit. But as the complexity of the computation increases,
    the table lookup algorithm could become faster. Consider the following code that
    swaps cases (converts lowercase to uppercase and uppercase to lowercase):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The lookup-table version is almost identical to Listing 10-1\. Only the values
    in the lookup table change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The xlatTbl2 array will contain the lowercase ASCII codes at the indices corresponding
    to the uppercase characters, in addition to having the uppercase ASCII codes at
    the indices corresponding to the lowercase ASCII codes.
  prefs: []
  type: TYPE_NORMAL
- en: This case-conversion algorithm still might not be complex enough to justify
    using a lookup table to improve performance. However, it demonstrates that as
    the complexity of the algorithm increases (taking longer to execute without a
    lookup table), the lookup table algorithm’s execution time remains constant.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.2 Function Domains and Ranges
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Functions computed via table lookup have a limited *domain*, the set of possible
    input values they accept. This is because each element in the domain of a function
    requires an entry in the lookup table. For example, the previous uppercase/lowercase
    conversion functions have the 256-character extended ASCII character set as their
    domain. A function such as sin() or cos() accepts the (infinite) set of real numbers
    as possible input values. You won’t find it very practical to implement a function
    via table lookup whose domain is the set of real numbers, because you must limit
    the domain to a small set.
  prefs: []
  type: TYPE_NORMAL
- en: Most lookup tables are quite small, usually 10 to 256 entries. Rarely do they
    grow beyond 1,000 entries. Most programmers don’t have the patience to create
    and verify the correctness of a 1,000-entry table (but see section 10.1.4, “Table
    Generation,” on [page 615](chapter10.xhtml#pg_615) for a discussion of generating
    tables programmatically).
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation of functions based on lookup tables is that the elements
    in the domain must be fairly contiguous. Table lookups use the input value to
    a function as an index into the table and return the value at that entry in the
    table. A function that accepts values 0, 100, 1,000, and 10,000 would require
    10,001 elements in the lookup table because of the range of input values. You
    cannot, therefore, efficiently create such a function via a table lookup. This
    section on tables assumes throughout that the domain of the function is a fairly
    contiguous set of values.
  prefs: []
  type: TYPE_NORMAL
- en: The *range* of a function is the set of possible output values it produces.
    From the perspective of a table lookup, a function’s range determines the size
    of each table entry. For example, if a function’s range is the integer values
    0 through 255, each table entry requires a single byte; if the range is 0 through
    65,535, each table entry requires 2 bytes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best functions you can implement via table lookups are those whose domain
    and range are always 0 to 255 (or a subset of this range). Any such function can
    be computed using the same two instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that changes is the lookup table. The uppercase/lowercase conversion
    routines presented earlier are good examples of such functions.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup tables become slightly less efficient if the domain or range is not 0
    to 255\. If the domain of a function is outside 0 to 255 but the range of the
    function falls within this set of values, your lookup table will require more
    than 256 entries, but you can represent each entry with a single byte. Therefore,
    the lookup table can be an array of bytes. The C/C++ function invocation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: where Func is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'which is easily converted to the following ARM code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code loads the function parameter into W0, uses this value (in the range
    0 to *maxParmValue*) as an index into the FuncTbl table, fetches the byte at that
    location, and stores the result into B. Obviously, the table must contain a valid
    entry for each possible value of X (up to *maxParmValue*). For example, suppose
    you want to map a cursor position on an 80 × 25 text-based video display in the
    range 0 to 1,999 (an 80 × 25 video display has 2,000 character positions) to its
    X (0 to 79) or Y (0 to 24) coordinate on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: You could compute the X coordinate via this function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'and the Y coordinate with this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code, which realizes these two functions via table lookup, may
    improve the performance of your code, particularly if you access the table frequently
    and it is sitting in the processor’s cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Given appropriate values in xTbl and yTbl, this will leave the x-coordinate
    in W0 and the y-coordinate in W1.
  prefs: []
  type: TYPE_NORMAL
- en: If the domain of a function is within 0 to 255 but the range is outside this
    set, the lookup table will contain 256 or fewer entries, but each entry will require
    2 or more bytes. If both the range and domains of the function are outside 0 to
    255, each entry will require 2 or more bytes, and the table will contain more
    than 256 entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from [Chapter 4](chapter4.xhtml) that the formula for indexing into
    a single-dimensional array (of which a table is a special case) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If elements in the range of the function require 2 bytes, you must multiply
    the index by 2 before indexing into the table. Likewise, if each entry requires
    3, 4, or more bytes, the index must be multiplied by the size of each table entry
    before being used as an index into the table. For example, suppose you have a
    function F(x), defined by the following C/C++ declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create this function by using the following ARM code (and, of course,
    the appropriate table named F):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Any function whose domain is small and mostly contiguous is a good candidate
    for computation via table lookup. In some cases, noncontiguous domains are acceptable
    as well, as long as the domain can be coerced into an appropriate set of values
    (a previously discussed example is processing switch statement expressions). Such
    operations are called *conditioning* and are the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.3 Domain Conditioning
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Domain conditioning* is taking a set of values in the domain of a function
    and massaging them so that they are more acceptable as inputs to that function.
    Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This says that the (computer) function sin(x) is equivalent to the (mathematical)
    function sin *x* where:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you know, sine is a circular function, which will accept any real-value input.
    The formula used to compute sine, however, accepts only a small set of these values.
    This range limitation doesn’t present any real problems; by simply computing sin(y
    mod (2π)), you can compute the sine of any input value. Modifying an input value
    so that you can easily compute a function is called *conditioning the input*.
    The preceding example computed (x % 2) * pi and used the result as the input to
    the sin() function. This truncates x to the domain sin() needs without affecting
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply input conditioning to table lookups as well. In fact, scaling
    the index to handle word entries is a form of input conditioning. Consider the
    following C/C++ function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This function computes a value for x in the range 0 to 4 and returns 0 if x
    is outside this range. Since x can take on 65,536 values (being a 16-bit hword),
    creating a table containing 65,536 hwords where only the first five entries are
    nonzero seems to be quite wasteful. However, you can still compute this function
    by using a table lookup if you use input conditioning. The following assembly
    language code presents this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code checks whether x is outside the range 0 to 4\. If so, it manually
    sets W0 to 0; otherwise, it looks up the function value through the valTbl table.
    With input conditioning, you can implement several functions that would otherwise
    be impractical to do via table lookup.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.4 Table Generation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One big problem with using table lookups is creating the table in the first
    place. This is particularly true if the table has many entries. Figuring out the
    data to place in the table, then laboriously entering the data, and finally checking
    that data to make sure it is valid is a time-consuming and boring process.
  prefs: []
  type: TYPE_NORMAL
- en: 'For many tables, there is no way around this. For other tables, however, you
    can use the computer to generate the table for you. I’ll explain this by example.
    Consider the following modification to the sine function:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$![](../images/pg615.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'This states that *x* is an integer in the range 0 to 359 (degrees) and that
    *r* must be an integer. The computer can easily compute this with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that integer multiplication and division are not associative. You cannot
    remove the multiplication by 1,000 and the division by 1,000 because they appear
    to cancel each other out. Furthermore, this code must compute this function in
    exactly this order.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to complete this function is Sines, a table containing 360 values
    corresponding to the sine of the angle (in degrees) times 1,000\. The C/C++ program
    in Listing 10-2 generates this table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program in Listing 10-2 produces the file *sines.inc*
    containing the following text (truncated for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, writing the C program that generated this data is much easier than
    entering and verifying this data by hand. You can also use Pascal/Delphi, Java,
    C#, Swift, or another HLL to write the table-generation program. Because the program
    will execute only once, its performance is not an issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you run the table-generation program, the only step left is to cut and
    paste the table from the file (*sines.inc* in this example) into the program that
    will actually use the table (or, alternatively, use the #include "sines.inc" directive
    to include the text in your source file).'
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Table-Lookup Performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the early days of PCs, table lookups were a preferred way to do high-performance
    computations. Today, it is common for a CPU to be 10 to 100 times faster than
    main memory. As a result, using a table lookup may not be faster than doing the
    same calculation with machine instructions. However, the on-chip CPU cache memory
    subsystems operate at near-CPU speeds. Therefore, table lookups can be cost-effective
    if your table resides in cache memory on the CPU. This means that the way to get
    good performance from table lookups is to use small tables (because the cache
    has only so much room) and to use tables whose entries you reference frequently
    (so the tables stay in the cache).
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the best way to determine whether a table lookup is faster than
    a calculation is to write both versions of the code and time them. Although the
    “10 million loop and time” approach is probably good enough for coarse measurements,
    you might also want to find and use a decent profiler program that will produce
    much better timing results. See “For More Information” for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using table lookups to optimize applications has grown out of favor as CPU speeds
    have increased and memory access times have not kept pace. Nevertheless, this
    short chapter covered the instances when table lookups are still useful. It began
    with a discussion of basic table lookup operations, then covered domain conditioning
    and using software to automatically generate tables. It concluded with a few notes
    on how to decide whether table lookups are the right choice for a particular project.
  prefs: []
  type: TYPE_NORMAL
- en: On modern CPUs, multiple cores and SIMD instruction sets are the common way
    of improving application performance. The next chapter discusses the ARM Neon/SIMD
    instruction set and how you can use it to improve program performance.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Donald Knuth’s *The Art of Computer Programming, Volume 3: Searching and Sorting*,
    2nd edition (Addison-Wesley Professional, 1998), contains a lot of useful information
    about searching for data in tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See my book *Write Great Code*, Volume 1, 2nd edition (No Starch Press, 2020)
    or the electronic version of *The Art of Assembly Language* at *[https://<wbr>www<wbr>.randallhyde<wbr>.com](https://www.randallhyde.com)*
    for details concerning the operation of cache memory and how you can optimize
    its use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For information on profiler programs, see “Getting Started with dotTrace on
    macOS and Linux” by Maarten Balliauw at *[https://<wbr>blog<wbr>.jetbrains<wbr>.com<wbr>/dotnet<wbr>/2023<wbr>/02<wbr>/22<wbr>/getting<wbr>-started<wbr>-with<wbr>-dottrace<wbr>-on<wbr>-macos<wbr>-and<wbr>-linux](https://blog.jetbrains.com/dotnet/2023/02/22/getting-started-with-dottrace-on-macos-and-linux)*.
    You can also check out “13 Profiling Software to Debug Application Performance
    Issue” by Amrita Pathak at *[https://<wbr>geekflare<wbr>.com<wbr>/application<wbr>-profiling<wbr>-software<wbr>/](https://geekflare.com/application-profiling-software/)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
