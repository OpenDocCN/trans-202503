<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="193" id="Page_193"/>11</span><br/>
<span class="ChapterTitle">Foreign Function Interfaces</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<p class="ChapterIntro">Not all code is written in Rust. It’s shocking, I know. Every so often, you’ll need to interact with code written in other languages, either by calling into such code from Rust or by allowing that code to call your Rust code. You can achieve this through <em>foreign function interfaces (FFI)</em>.</p>
<p>In this chapter we’ll first look at the primary mechanism Rust provides for FFI: the <code>extern</code> keyword. We’ll see how to use <code>extern</code> both to expose Rust functions and statics to other languages and to give Rust access to functions and static variables provided from outside the Rust bubble. Then, we’ll walk through how to align Rust types with types defined in other languages and explore some of the intricacies of allowing data to flow across the FFI boundary. Finally, we’ll talk about some of the tools you’ll likely want to use if you’re doing any nontrivial amount of FFI.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="194" id="Page_194"/><h2><span class="NoteHead">Note</span></h2>
<p>	While I often refer to FFI as being about crossing the boundary between one language and another, FFI can also occur entirely inside Rust-land. If one Rust program shares memory with another Rust program but the two aren’t compiled together—say, if you’re using a dynamically linked library in your Rust program that happens to be written in Rust, but you just have the C-compatible <em>.so</em> file—the same complications arise.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1--0001">Crossing Boundaries with extern</h2>
<p class="BodyFirst">FFI is, ultimately, all about accessing bytes that originate somewhere outside your application’s Rust code. For that, Rust provides two primary building blocks: <em>symbols</em>, which are names assigned to particular addresses in a given segment of your binary that allow you to share memory (be it for data or code) between the external origin and your Rust code, and <em>calling conventions </em>that provide a common understanding of how to call functions stored in such shared memory. We’ll look at each of these in turn.</p>
<h3 id="h2--0001">Symbols</h3>
<p class="BodyFirst">Any binary artifact that the compiler produces from your code is filled with symbols—every function or static variable you define has a symbol that points to its location in the compiled binary. Generic functions may even have multiple symbols, one for each monomorphization of the function the compiler generates!</p>
<p>Normally, you don’t have to think about symbols—they’re used internally by the compiler to pass around the final address of a function or static variable in your binary. This is how the compiler knows what location in memory each function call should target when it generates the final machine code, or where to read from if your code accesses a static variable. Since you don’t usually refer to symbols directly in your code, the compiler defaults to choosing semirandom names for them—you may have two functions called <code>foo</code> in different parts of your code, but the compiler will generate distinct symbols from them so that there’s no confusion.</p>
<p>However, using random names for symbols won’t work when you want to call a function or access a static variable that isn’t compiled at the same time, such as code that’s written in a different language and thus compiled by a different compiler. You can’t tell Rust about a static variable defined in C if the symbol for that variable has a semirandom name that keeps changing. Conversely, you can’t tell Python’s FFI interface about a Rust function if you can’t produce a stable name for it.</p>
<p>To use a symbol with an external origin, we also need some way to tell Rust about a variable or function in such a manner that the compiler will look for that same symbol defined elsewhere rather than defining its own (we’ll talk about how that search happens later). Otherwise, we would just end up with two identical symbols for that function or static variable, and no sharing would take place. In fact, in all likelihood, compilation would fail since any code that referred to that symbol wouldn’t know which definition (that is, which address) to use for it!</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="195" id="Page_195"/><h2><span class="NoteHead">Note</span></h2>
<p>	A quick note about terminology: a symbol can be <em>declared</em> multiple times but <em>defined</em> only once. Every declaration of a symbol will link to the same single definition for that symbol at linking time. If no definition for a declaration is found, or if there are multiple definitions, the linker will complain.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3--0001">An Aside on Compilation and Linking</h4>
<p class="BodyFirst">Compiler crash course time! Having a rough idea of the complicated process of turning code into a runnable binary will help you understand FFI better. You see, the compiler isn’t one monolithic program but is (typically) broken down into a handful of smaller programs that each perform distinct tasks and run one after the other. At a high level, there are three distinct phases to compilation—<em>compilation</em>, <em>code generation</em>, and <em>linking</em>—handled by three different components.</p>
<p>The first phase is performed by what most people tend to think of as “the compiler”; it deals with type checking, borrow checking, monomorphization, and other features we associate with a given programming language. This phase generates no machine code but rather a low-level representation of the code that uses heavily annotated abstract machine operations. That low-level representation is then passed to the code generation tool, which is what produces machine code that can actually run on a given CPU.</p>
<p>These two operations, taken together, do not have to be run in a single big pass over the whole codebase all at once. Instead, the codebase can be sliced into smaller chunks that are then run through compilation concurrently. For example, Rust generally compiles different crates independently and in parallel as long as there isn’t a dependency between them. It can also invoke the code generation tool for independent crates separately to process them in parallel. Rust can often even compile multiple smaller slices of a single crate separately!</p>
<p>Once the machine code for every piece of the application has been generated, those pieces can then be wired together. This is done in the linking phase by, unsurprisingly, the linker. The linker’s primary job is to take all the binary artifacts, called <em>object files</em>, produced by code generation, stitch them together into a single file, and then replace every reference to a symbol with the final memory address of that symbol. This is how you can define a function in one crate and call it from another but still compile the two crates separately.</p>
<p>The linker is what enables FFI to work. It doesn’t care how each of the input object files were constructed; it just dutifully links together all the object files and then resolves any shared symbols. One object file may originally have been Rust code, one originally C code, and one may be a binary blob downloaded from the internet; as long as they all use the same symbol names, the linker will make sure that the resulting machine code uses the correct cross-referenced addresses for any shared symbols.</p>
<p>A symbol can be linked either <em>statically</em> or <em>dynamically</em>. Static linking is the simplest, as each reference to a symbol is simply replaced with the address of that symbol’s definition. Dynamic linking, on the other hand, <span epub:type="pagebreak" title="196" id="Page_196"/>ties each reference to a symbol to a bit of generated code that tries to find the symbol’s definition when the program <em>runs</em>. We’ll talk more about these linking modes a little later. Rust generally defaults to static linking for Rust code, and dynamic linking for FFI.</p>
<h4 id="h3--0002">Using extern</h4>
<p class="BodyFirst">The <code>extern</code> keyword is the mechanism that allows us to declare a symbol as residing within a foreign interface. Specifically, it declares the existence of a symbol that’s defined elsewhere. In <a href="#listing11-1" id="listinganchor11-1">Listing 11-1</a> we define a static variable called <code>RS_DEBUG</code> in Rust that we make available to other code via FFI. We also declare a static variable called <code>FOREIGN_DEBUG</code> whose definition is unspecified but will be resolved at linking time.</p>
<pre><code>#[no_mangle]
pub static RS_DEBUG: bool = true;

extern {
    static FOREIGN_DEBUG: bool;
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-1">Listing 11-1</a>: Exposing a Rust static variable, and accessing one declared elsewhere, through FFI</p>
<p>The <code>#[no_mangle]</code> attribute ensures that <code>RS_DEBUG</code> retains that name during compilation rather than having the compiler assign it another symbol name to, for example, distinguish it from another (non-FFI) <code>RS_DEBUG</code> static variable elsewhere in the program. The variable is also declared as <code>pub</code> since it’s a part of the crate’s public API, though that annotation isn’t strictly necessary on items marked <code>#[no_mangle]</code>. Note that we don’t use <code>extern</code> for <code>RS_DEBUG</code>, since it’s defined here. It will still be accessible to link against from other languages.</p>
<p>The <code>extern</code> block surrounding the <code>FOREIGN_DEBUG</code> static variable denotes that this declaration refers to a location that Rust will learn at linking time based on where the definition of the same symbol is located. Since it’s defined elsewhere, we don’t give it an initialization value, just a type, which should match the type used at the definition site. Because Rust doesn’t know anything about the  code that defines the static variable, and thus can’t check that you’ve declared the correct type for the symbol, <code>FOREIGN_DEBUG</code> can be accessed only inside an <code>unsafe</code> block.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Static variables in Rust aren’t mutable by default, regardless of whether they’re in an <code>extern</code> block. These variables are always available from any thread, so mutable access would pose a data race risk. You can declare a <code>static</code> as <code>mut</code>, but if you do, it becomes unsafe to access.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The procedure to declare FFI functions is very similar. In <a href="#listing11-2" id="listinganchor11-2">Listing 11-2</a>, we make <code>hello_rust</code> accessible to non-Rust code and pull in the external <code>hello_foreign</code> function.</p>
<pre><code><span epub:type="pagebreak" title="197" id="Page_197"/>#[no_mangle]
pub extern fn hello_rust(i: i32) { ... }

extern {
    fn hello_foreign(i: i32);
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-2">Listing 11-2</a>: Exposing a Rust function, and accessing one defined elsewhere, through FFI</p>
<p>The building blocks are all the same as in <a href="#listing11-1">Listing 11-1</a> with the exception that the Rust function is declared using <code>extern fn</code>, which we’ll explore in the next section.</p>
<p>If there are multiple definitions of a given extern symbol like <code>FOREIGN_DEBUG</code> or <code>hello_foreign</code>, you can explicitly specify which library the symbol should link against using the <code>#[link]</code> attribute. If you don’t, the linker will give you an error saying that it’s found multiple definitions for the symbol in question. For example, if you prefix an <code>extern</code> block with <code>#[link(name = "crypto")]</code>, you’re telling the linker to resolve any symbols (whether statics or functions) against a linked library named “crypto.” You can also rename an external static or function in your Rust code by annotating its declaration with <code>#[link_name = "</code><var>&lt;actual_symbol_name&gt;</var><code>"]</code>, and then the item links to whatever name you wish. Similarly, you can rename a Rust item for export using <code>#[export_name = "</code><var>&lt;export_symbol_name&gt;</var><code>"]</code>.</p>
<h4 id="h3--0003">Link Kinds</h4>
<p class="BodyFirst"><code>#[link]</code> also accepts the argument <code>kind</code>, which dictates how the items in the block should be linked. The argument defaults to <code>"dylib"</code>, which signifies C-compatible dynamic linking. The alternative <code>kind</code> value is <code>"static"</code>, which indicates that the items in the block should be linked fully at compile time (that is, statically). This essentially means that the external code is wired directly into the binary produced by the compiler , and thus doesn’t need to exist at runtime. There are a few other <code>kind</code>s as well, but they are much less common and outside the scope of this book.</p>
<p>There are several trade-offs between static and dynamic linking, but the main considerations are security, binary size, and distribution. First, dynamic linking tends to be more secure because it makes it easier to upgrade libraries independently. Dynamic linking allows whoever deploys a binary that contains your code to upgrade libraries your code links against without having to recompile your code. If, say, <code>libcrypto</code> gets a security update, the user can update the crypto library on the host and restart the binary, and the updated library code will be used automatically. With static compilation, the library’s code is hardwired into the binary, so the user would have to recompile your code against an upgraded version of the library to get the update.</p>
<p>Dynamic linking also tends to produce smaller binaries. Since static compilation includes any linked code into the final binary output, and any code that code in turn pulls in, it produces larger binaries. With dynamic linking, each external item includes just a small bit of wrapper code that loads the indicated library at runtime and then forwards the access.</p>
<p><span epub:type="pagebreak" title="198" id="Page_198"/>So far, static linking may not seem very attractive, but it has one big advantage over dynamic linking: ease of distribution. With dynamic linking, anyone who wants to run a binary that includes your code must <em>also</em> have any libraries your code links against. Not only that, but they must make sure the version of each such library they have is compatible with what your code expects. This may be fine for libraries like <code>glibc</code> or OpenSSL that are available on most systems, but it poses a problem for more obscure libraries. The user then needs to be aware that they should install that library and must hunt for it in order to run your code! With static linking, the library’s code is embedded directly into the binary output, so the user doesn’t need to install it themselves.</p>
<p>Ultimately, there isn’t a <em>right</em> choice between static and dynamic linking. Dynamic linking is usually a good default, but static compilation may be a better option for particularly constrained deployment environments or for very small or niche library dependencies. Use your best judgment!</p>
<h3 id="h2--0002">Calling Conventions</h3>
<p class="BodyFirst">Symbols dictate <em>where</em> a given function or variable is defined, but that’s not enough to allow function calls across FFI boundaries. To call a foreign function in any language, the compiler also needs to know its <em>calling convention</em>, which dictates the assembly code to use to invoke the function. We won’t get into the actual technical details of each calling convention here, but as a general overview, the convention dictates:</p>
<ul>
<li>How the stack frame for the call is set up</li>
<li>How arguments are passed (whether on the stack or in registers, in order or in reverse)</li>
<li>How the function is told where to jump back to when it returns</li>
<li>How various CPU states, like registers, are restored in the caller after the function completes</li>
</ul>
<p>Rust has its own unique calling convention that isn’t standardized and is allowed to be changed by the compiler over time. This works fine as long as all function definitions and calls are compiled by the same Rust compiler, but it is problematic if you want interoperability with external code because that external code doesn’t know about the Rust calling convention.</p>
<p>Every Rust function is implicitly declared with <code>extern "Rust"</code> if you don’t declare anything else. Using <code>extern</code> on its own, as in <a href="#listing11-2">Listing 11-2</a>, is shorthand for <code>extern "C"</code>, which means “use the standard C calling convention.” The shorthand is there because the C calling convention is what you want in nearly every case of FFI.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Unwinding generally works only with regular Rust functions. If you unwind across the end of a Rust function that isn’t <code>extern "Rust"</code>, your program will abort. Unwinding across the FFI boundary into external code is undefined behavior. With RFC 2945, Rust gained a new <code>extern</code> declaration, <code>extern "C-unwind"</code>; this permits unwinding across FFI boundaries in particular situations, but if you wish to use it you should read the RFC carefully.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="199" id="Page_199"/>Rust also supports a number of other calling conventions that you supply as a string following the <code>extern</code> keyword (in both <code>fn</code> and block context). For example, <code>extern "system"</code> says to use the calling convention of the operating system’s standard library interface, which at the time of writing is the same as <code>"C"</code> everywhere except on Win32, which uses the <code>"stdcall"</code> calling convention. In general, you’ll rarely need to supply a calling convention explicitly unless you’re working with particularly platform-specific or highly optimized external interfaces, so just <code>extern</code> (which is <code>extern "C"</code>) will be fine.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	A function’s calling convention is part of its type. That is, the type <code>extern "C" fn()</code> is not the same as <code>fn()</code> (or <code>extern "Rust" fn()</code>), which is different again from <code>extern "system" fn()</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Other Binary Artifacts</h2>
<p class="BoxBodyFirst">Normally, you compile Rust code only to run its tests or build a binary that you’re then going to distribute or run. Unlike in many other languages, you don’t generally compile a Rust library to distribute it to others—if you run a command like <code>cargo pu</code><code>blish</code>, it just wraps up your crate’s source code and uploads it to <em>crates.io</em>. This is mostly because it is difficult to distribute generic code as anything but source code. Since the compiler monomorphizes each generic function to the provided type arguments, and those types may be defined in the caller’s crate, the compiler must have access to the function’s <em>generic</em> form, which means no optimized machine code!</p>
<p>Technically speaking, Rust does compile binary library artifacts, called <em>rlibs</em>, of each dependency that it combines in the end. These rlibs include the information necessary to resolve generic types, but they are specific to the exact compiler used and can’t generally be distributed in any meaningful way.</p>
<p>So what do you do if you want to write a library in Rust that you then want to interface with from another programming language? The solution is to produce C-compatible library files in the form of dynamically linked libraries (<em>.so</em> files on Unix, <em>.dylib</em> files on macOS, and <em>.dll</em> files on Windows) and statically linked libraries (<em>.a</em> files on Unix/macOS and <em>.lib</em> files on Windows). Those files look like files produced by C code, so they can also be used by other languages that know how to interact with C.</p>
<p>To produce these C-compatible binary artifacts, you set the <code>crate-type</code> field of the <code>[lib]</code> section of your <em>Cargo.toml</em> file. The field takes an array of values, which would normally just be <code>"lib"</code> to indicate a standard Rust library (an rlib). Cargo applies some heuristics that will set this value automatically if your crate is clearly not a library (for example, if it's a procedural macro), but best practice is to set this value explicitly if you’re producing anything but a good ol’ Rust library.</p>
<p>There are a number of different crate types, but the relevant ones here are <code>"cdylib"</code> and <code>"staticlib"</code>, which produce C-compatible library files that are dynamically and statically linked, respectively. Keep in mind that when you <span epub:type="pagebreak" title="200" id="Page_200"/>produce one of these artifact types, only publicly available symbols are available—that is, public and <code>#[no_mangle]</code> static variables and functions. Things like types and constants won’t be available, even if they’re marked <code>pub</code>, since they have no meaningful representation in a binary library file.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1--0002">Types Across Language Boundaries</h2>
<p class="BodyFirst">With FFI, type layout is crucial; if one language lays out the memory for some shared data one way but the language on the other side of the FFI boundary expects it to be laid out differently, then the two sides will interpret the data inconsistently. In this section, we’ll look at how to make types match up over FFI, and other aspects of types to be aware of when you cross the boundaries between languages.</p>
<h3 id="h2--0003">Type Matching</h3>
<p class="BodyFirst">Types aren’t shared across the FFI boundary. When you declare a type in Rust, that type information is lost entirely upon compilation. All that’s communicated to the other side is the bits that make up values of that type. You therefore need to declare the type for those bits on both sides of the boundary. When you declare the Rust version of the type, you first must make sure the primitives contained within the type match up. For example, if C is used on the other side of the boundary, and the C type uses an <code>int</code>, the Rust code had better use the exact Rust equivalent: an <code>i32</code>. To take some of the guesswork out of that process, for interfaces that use C-like types the Rust standard library provides you with the correct C types in the <code>std::os::raw</code> module, which defines <code>type c_int = i32</code>, <code>type c_char = i8/u8</code> depending on whether <code>char</code> is signed, <code>type c_long = i32/i64</code> depending on the target pointer width, and so on.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Take particular note of quirky integer types in C like <code>__be32</code>. These often do not translate directly to Rust types and may be best left as something like <code>[u8; 4]</code>. For example, <code>__be32</code> is always encoded as big-endian, whereas Rust’s <code>i32</code> uses the endianness of the current platform.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>With more complex types like vectors and strings, you usually need to do the mapping manually. For example, since C tends to represent a string as a sequence of bytes terminated with a 0 byte, rather than a UTF-8–encoded string with the length stored separately, you cannot generally use Rust’s string types over FFI. Instead, assuming the other side uses a C-style string representation, you should use the <code>std::ffi::CStr</code> and <code>std::ffi::CString</code> types for borrowed and owned strings, respectively. For vectors, you’ll likely want to use a raw pointer to the first element and then pass the length separately—the <code>Vec::into_raw_parts</code> method may come in handy for that.</p>
<p><span epub:type="pagebreak" title="201" id="Page_201"/>For types that contain other types, such as structs and unions, you also need to deal with layout and alignment. As we discussed in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, Rust lays out types in an undefined way by default, so at the very least you will want to use <code>#[repr(C)]</code> to ensure that the type has a deterministic layout and alignment that mirrors what’s (likely and hopefully) used across the FFI boundary. If the interface also specifies other configurations for the type, such as manually setting its alignment or removing padding, you’ll need to adjust your <code>#[repr]</code> accordingly.</p>
<p>A Rust enum has multiple possible C-style representations depending on whether the enum contains data or not. Consider an enum without data, like this:</p>
<pre><code>enum Foo { Bar, Baz }</code></pre>
<p>With <code>#[repr(C)]</code>, the type <code>Foo</code> is encoded using just a single integer of the same size that a C compiler would choose for an enum with the same number of variants. The first variant has the value <code>0</code>, the second the value <code>1</code>, and so on. You can also manually assign values to each variant, as shown in <a href="#listing11-3" id="listinganchor11-3">Listing 11-3</a>.</p>
<pre><code>#[repr(C)]
enum Foo {
    Bar = 1,
    Baz = 2,
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-3">Listing 11-3</a>: Defining explicit variant values for a dataless enum</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Technically, the specification says that the first variant’s value is <code>0</code> and every subsequent variant’s value is one greater than that of the previous one. This makes a difference if you manually set the value for some variants but not others—those you do not set will continue from the last one you did set.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You should be careful about mapping enum-like types in C to Rust this way, however, as only the values for defined variants are valid for an instance of the enum type. This tends to get you into trouble with C-style enumerations that often function more like bitsets, where variants can be bitwise ORed together to produce a value that encapsulates multiple variants at once. In the example from <a href="#listing11-3">Listing 11-3</a>, for instance, a value of <code>3</code> produced by taking <code>Bar | Baz</code> would not be valid for <code>Foo</code> in Rust! If you need to model a C API that uses an enumeration for a set of bitflags that can be set and unset individually, consider using a newtype wrapper around an integer type, with associated constants for each variant and implementations of the various <code>Bit*</code> traits for improved ergonomics. Or use the <code>bitflags</code> crate.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	For fieldless enums, you can also pass a numeric type to <code>#[repr]</code> to use a different type than <code>isize</code> for the discriminator. For example, <code>#[repr(u8)]</code> will encode the discriminator using a single unsigned byte. For a data-carrying enum, you can pass <code>#[repr(C, u8)]</code> to get the same effect.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="202" id="Page_202"/>On an enum that contains data, the <code>#[repr(C)]</code> attribute causes the enum to be represented using a <em>tagged union</em>. That is, it is represented in memory by a <code>#[repr(C)]</code> struct with two fields, where the first is the discriminator as it would be encoded if none of the variants had fields, and the second is a union of the data structures for each variant. For a concrete example, consider the enum and associated representation in <a href="#listing11-4" id="listinganchor11-4">Listing 11-4</a>.</p>
<pre><code>#[repr(C)]
enum Foo {
    Bar(i32),
    Baz { a: bool, b: f64 }
}
<span class="LiteralGray">// is represented as</span>
#[repr(C)]
enum FooTag { Bar, Baz }
#[repr(C)]
struct FooBar(i32);
#[repr(C)]
struct FooBaz{ a: bool, b: f64 }
#[repr(C)]
union FooData {
  bar: FooBar,
  baz: FooBaz,
}
#[repr(C)]
struct Foo {
    tag: FooTag,
    data: FooData
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-4">Listing 11-4</a>: Rust enums with <code>#[repr(C)]</code> are represented as tagged unions.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>The Niche Optimization in FFI</h2>
<p class="BoxBodyFirst">In <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> we talked about the niche optimization, where the Rust compiler uses invalid bit patterns to represent enum variants that hold no data. The fact that this optimization is guaranteed leads to an interesting interaction with FFI. Specifically, it means that nullable pointers can always be represented in FFI types using an <code>Option</code>-wrapped pointer type. For example, a nullable function pointer can be represented as <code>Option&lt;extern fn(...)&gt;</code>, and a nullable data pointer can be represented as <code>Option&lt;NotNull&lt;T&gt;&gt;</code>. These will transparently do the right thing if an all-zero bit pattern value is provided, and will represent it as <code>None</code> in Rust.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2--0004">Allocations</h3>
<p class="BodyFirst">When you allocate memory, that allocation belongs to its allocator and can be freed only by that same allocator. This is the case if you use multiple <span epub:type="pagebreak" title="203" id="Page_203"/>allocators within Rust and also if you are allocating memory both in Rust and with some allocator on the other side of the FFI boundary. You’re free to send pointers across the boundary and access that memory to your heart’s content, but when it comes to releasing the memory again, it needs to be returned to the appropriate allocator.</p>
<p>Most FFI interfaces will have one of two configurations for handling allocation: either the caller provides data pointers to chunks of memory or the interface exposes dedicated freeing methods to which any allocated resources should be returned when they are no longer needed. <a href="#listing11-5" id="listinganchor11-5">Listing 11-5</a> shows an example of Rust declarations of some signatures from the OpenSSL library that use implementation-managed memory.</p>
<pre><code><span class="LiteralGray">// One function allocates memory for a new object.</span>
extern fn ECDSA_SIG_new() -&gt; *mut ECDSA_SIG;

<span class="LiteralGray">// And another accepts a pointer created by new</span>
<span class="LiteralGray">// and deallocates it when the caller is done with it.</span>
extern fn ECDSA_SIG_free(sig: *mut ECDSA_SIG);</code></pre>
<p class="CodeListingCaption"><a id="listing11-5">Listing 11-5</a>: An implementation-managed memory interface</p>
<p> The functions <code>ECDSA_SIG_new</code> and <code>ECDSA_SIG_free</code> form a pair, where the caller is expected to call the <code>new</code> function, use the returned pointer for as long as it needs (likely by passing it to other functions in turn), and then finally pass the pointer to the <code>free</code> function once it’s done with the referenced resource. Presumably, the implementation allocates memory in the <code>new</code> function and deallocates it in the <code>free</code> function. If these functions were defined in Rust, the <code>new</code> function would likely use <code>Box::new</code>, and the <code>free</code> function would invoke <code>Box::from_raw</code> and then drop the value to run its destructor.</p>
<p><a href="#listing11-6" id="listinganchor11-6">Listing 11-6</a> shows an example of caller-managed memory.</p>
<pre><code><span class="LiteralGray">// An example of caller-managed memory.</span>
<span class="LiteralGray">// The caller provides a pointer to a chunk of memory,</span>
<span class="LiteralGray">// which the implementation then uses to instantiate its own types.</span>
<span class="LiteralGray">// No free function is provided, as that happens in the caller.</span>
extern fn BIO_new_mem_buf(buf: *const c_void, len: c_int) -&gt; *mut BIO</code></pre>
<p class="CodeListingCaption"><a id="listing11-6">Listing 11-6</a>: A caller-managed memory interface</p>
<p>Here, the <code>BIO_new_mem_buf</code> function instead has the caller supply the backing memory. The caller can choose to allocate memory on the heap, or use whatever other mechanism it deems fit for obtaining the required memory, and then passes it to the library. The onus is then on the caller to ensure that the memory is later deallocated, but only once it is no longer needed by the FFI implementation!</p>
<p>You can use either of these approaches in your FFI APIs or even mix and match them if you wish. As a general rule of thumb, allow the caller to pass in memory when doing so is feasible, since it gives the caller more freedom to manage memory as it deems appropriate. For example, the caller may be using a highly specialized allocator on some custom operating <span epub:type="pagebreak" title="204" id="Page_204"/>system, and may not want to be forced to use the standard allocator your implementation would use. If the caller can pass in the memory, it might even avoid allocations entirely if it can instead use stack memory or reuse already allocated memory. However, keep in mind that the ergonomics of a caller-managed interface are often more convoluted, since the caller must now do all the work to figure out how much memory to allocate and then set that up before it can call into your library.</p>
<p>In some instances, it may even be impossible for the caller to know ahead of time how much memory to allocate—for example, if your library’s types are opaque (and thus not known to the caller) or can change over time, the caller won’t be able to predict the size of the allocation. Similarly, if your code has to allocate more memory while it is running, such as if you’re building a graph on the fly, the amount of memory needed may vary dynamically at runtime. In such cases, you will have to use implementation-managed memory.</p>
<p>When you’re forced to make a trade-off, go with caller-allocated memory for anything that is either <em>large</em> or <em>frequent</em>. In those cases the caller is likely to care the most about controlling the allocations itself. For anything else, it’s probably okay for your code to allocate and then expose destructor functions for each relevant type.</p>
<h3 id="h2--0005">Callbacks</h3>
<p class="BodyFirst">You can pass function pointers across the FFI boundary and call the referenced function through those pointers as long as the function pointer’s type has an <code>extern</code> annotation that matches the function’s calling convention. That is, you can define an <code>extern "C" fn(c_int) -&gt; c_int</code> in Rust and then pass a reference to that function to C code as a callback that the C code will eventually invoke.</p>
<p>You do need to be careful using callbacks around panics, as having a panic unwind past the end of a function that is anything but <code>extern "Rust"</code> is undefined behavior. The Rust compiler will currently automatically abort if it detects such a panic, but that may not always be the behavior you want. Instead, you may want to use <code>std::panic::catch_unwind</code> to detect the panic in any function marked <code>extern</code>, and then translate the panic into an error that is FFI-compatible.</p>
<h3 id="h2--0006">Safety</h3>
<p class="BodyFirst">When you write Rust FFI bindings, most of the code that actually interfaces with the FFI will be unsafe and will mainly revolve around raw pointers. However, your goal should be to ultimately present a <em>safe</em> Rust interface on top of the FFI. Doing so mainly comes down to reading carefully through the invariants of the unsafe interface you are wrapping and then ensuring you uphold them all through the Rust type system in the safe interface. The three most important elements of safely encapsulating a foreign interface are capturing <code>&amp;</code> versus <code>&amp;mut</code> accurately, implementing <code>Send</code> and <code>Sync</code> appropriately, and ensuring that pointers cannot be accidentally confused. I’ll go over how to enforce each of these next.</p>
<h4 id="h3--0004"><span epub:type="pagebreak" title="205" id="Page_205"/>References and Lifetimes</h4>
<p class="BodyFirst">If there’s a chance external code will modify data behind a given pointer, make sure that the safe Rust interface has an exclusive reference to the relevant data by taking <code>&amp;mut</code>. Otherwise a user of your safe wrapper might accidentally read from memory that the external code is simultaneously modifying, and all hell will break loose!</p>
<p>You’ll also want to make good use of Rust lifetimes to ensure that all pointers live for as long as the FFI requires. For example, imagine an external interface that lets you create a <code>Context</code> and then lets you create a <code>Device</code> from that <code>Context</code> with the requirement that the <code>Context</code> remain valid for as long as the <code>Device</code> lives. In that case, any safe wrapper for the interface should enforce that requirement in the type system by having <code>Device</code> hold a lifetime associated with the borrow of <code>Context</code> that the <code>Device</code> was created from.</p>
<h4 id="h3--0005">Send and Sync</h4>
<p class="BodyFirst">Do not implement <code>Send</code> and <code>Sync</code> for types from an external library unless that library explicitly documents that those types are thread-safe! It is the safe Rust wrapper’s job to ensure that safe Rust code <em>cannot</em> violate the invariants of the external code and thus trigger undefined behavior.</p>
<p>Sometimes, you may even want to introduce dummy types to enforce external invariants. For example, say you have an event loop library with the interface given in <a href="#listing11-7" id="listinganchor11-7">Listing 11-7</a>.</p>
<pre><code>extern fn start_main_loop();
extern fn next_event() -&gt; *mut Event;</code></pre>
<p class="CodeListingCaption"><a id="listing11-7">Listing 11-7</a>: A library that expects single-threaded use</p>
<p>Now suppose that the documentation for the external library states that <code>next_event</code> may be called only by the same thread that called <code>start_main_loop</code>. However, here we have no type that we can avoid implementing <code>Send</code> for! Instead, we can take a page out of <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> and introduce additional marker state to enforce the invariant, as shown in <a href="#listing11-8" id="listinganchor11-8">Listing 11-8</a>.</p>
<pre><code>pub struct EventLoop(std::marker::PhantomData&lt;*const ()&gt;);
pub fn start() -&gt; EventLoop {
    unsafe { ffi::start_main_loop() };
    EventLoop(std::marker::PhantomData)
}
impl EventLoop {
    pub fn next_event(&amp;self) -&gt; Option&lt;Event&gt; {
        let e = unsafe { ffi::next_event() };
        <span class="LiteralGray">// ...</span>
    }
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-8">Listing 11-8</a>: Enforcing an FFI invariant by introducing auxiliary types</p>
<p>The empty type <code>EventLoop</code> doesn’t actually connect with anything in the underlying external interface but rather enforces the contract that you call <code/><span epub:type="pagebreak" title="206" id="Page_206"/>next_event only after calling <code>start_main_loop</code>, and only on the same thread. You enforce the “same thread” part by making <code>EventLoop</code> neither <code>Send</code> nor <code>Sync</code>, by having it hold a phantom raw pointer (which itself is neither <code>Send</code> nor <code>Sync</code>).</p>
<p>Using <code>PhantomData&lt;*const ()&gt;</code> to “undo” the <code>Send</code> and <code>Sync</code> auto-traits as we do here is a bit ugly and indirect. Rust does have an unstable compiler feature that enables negative trait implementations like <code>impl !Send for EventLoop {}</code>, but it’s surprisingly difficult to get its implementation right, and it likely won’t stabilize for some time.</p>
<p>You may have noticed that nothing prevents the caller from invoking <code>start_main_loop</code> multiple times, either from the same thread or from another thread. How you’d handle that would depend on the semantics of the library in question, so I’ll leave it to you as an exercise.</p>
<h4 id="h3--0006">Pointer Confusion</h4>
<p class="BodyFirst">In many FFI APIs, you don’t necessarily want the caller to know the internal representation for each and every chunk of memory you give it pointers to. The type might have internal state that the caller shouldn’t fiddle with, or the state might be difficult to express in a cross-language-compatible way. For these kinds of situations, C-style APIs usually expose <em>void pointers</em>, written out as the C type <code>void*</code>, which is equivalent to <code>*mut std::ffi::c_void</code> in Rust. A type-erased pointer like this is, effectively, <em>just</em> a pointer, and does not convey anything about the thing it points to. For that reason, these kinds of pointers are often referred to as <em>opaque</em>.</p>
<p>Opaque pointers effectively serve the role of visibility modifiers for types across FFI boundaries—since the method signature does not say what’s being pointed to, the caller has no option but to pass around the pointer as is and use any available FFI methods to provide visibility into the referenced data. Unfortunately, since one <code>*mut c_void</code> is indistinguishable from another, there’s nothing stopping a user from taking an opaque pointer as is returned from one FFI method and supplying it to a method that expects a pointer to a <em>different</em> opaque type.</p>
<p>We can do better than this in Rust. To mitigate this kind of pointer type confusion, we can avoid using <code>*mut c_void</code> directly for opaque pointers in FFI, even if the actual interface calls for a <code>void*</code>, and instead construct different empty types for each distinct opaque type. For example, in <a href="#listing11-9" id="listinganchor11-9">Listing 11-9</a> I use two distinct opaque pointer types that cannot be confused.</p>
<pre><code>#[non_exhaustive] #[repr(transparent)] pub struct Foo(c_void);
#[non_exhaustive] #[repr(transparent)] pub struct Bar(c_void);
extern {
    pub fn foo() -&gt; *mut Foo;
    pub fn take_foo(arg: *mut Foo);
    pub fn take_bar(arg: *mut Bar);
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-9">Listing 11-9</a>: Opaque pointer types that cannot be confused</p>
<p><span epub:type="pagebreak" title="207" id="Page_207"/>Since <code>Foo</code> and <code>Bar</code> are both zero-sized types, they can be used in place of <code>()</code> in the <code>extern</code> method signatures. Even better, since they are now distinct types, Rust won’t let you use one where the other is required, so it’s now impossible to call <code>take_bar</code> with a pointer you got back from <code>foo</code>. Adding the <code>#[non_exhaustive]</code> annotation ensures that the <code>Foo</code> and <code>Bar</code> types cannot be constructed outside of this crate.</p>
<h2 id="h1--0003">bindgen and Build Scripts</h2>
<p class="BodyFirst">Mapping out the Rust types and <code>extern</code>s for a larger external library can be quite a chore. Big libraries tend to have a large enough number of type and method signatures to match up that writing out all the Rust equivalents is time-consuming. They also have enough corner cases and C oddities that some patterns are bound to require more careful thought to translate.</p>
<p>Luckily, the Rust community has developed a tool called <code>bindgen</code> that significantly simplifies this process as long as you have C header files available for the library you want to interface with. <code>bindgen</code> essentially encodes all the rules and best practices we’ve discussed in this chapter, plus a number of others, and wraps them up in a configurable code generator that takes in C header files and spits out appropriate Rust equivalents.</p>
<p><code>bindgen</code> provides a stand-alone binary that generates the Rust code for C headers once, which is convenient when you want to check in the bindings. This process allows you to hand-tune the generated bindings, should that be necessary. If, on the other hand, you want to generate the bindings automatically on every build and just include the C header files in your source code, <code>bindgen</code> also ships as a library that you can invoke in a custom <em>build script </em>for your package.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	If you check in the bindings directly, keep in mind that they will be correct only on the platform they were generated for. Generating the bindings in a build script will generate them specifically for the current target platform, which is less likely to cause platform-related layout inconsistencies.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You declare a build script by adding <code>build = "</code><var>&lt;some-file.rs&gt;</var><code>"</code> to the <code>[package]</code> section of your <em>Cargo.toml</em>. This tells Cargo that, before compiling your crate, it should compile <em>&lt;some-file.rs&gt; </em>as a stand-alone Rust program and run it; only then should it compile the source code of your crate. The build script also gets its own dependencies, which you declare in the <code>[build-dependencies]</code> section of your <em>Cargo.toml</em>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	If you name your build script <em>build.rs</em>, you don’t need to declare it in your <em>Cargo.toml</em>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Build scripts come in very handy with FFI—they can compile a bundled C library from source, dynamically discover and declare additional build flags to be passed to the compiler, declare additional files that Cargo should check for changes for the purposes of recompilation, and, you guessed it, generate additional source files on the fly!</p>
<p><span epub:type="pagebreak" title="208" id="Page_208"/>Though build scripts are very versatile, beware of making them too aware of the environment they run in. While you can use a build script to detect if the Rust compiler version is a prime or if it’s going to rain in Istanbul tomorrow, making your compilation dependent on such conditions may make builds fail unexpectedly for other developers, which leads to a poor development experience.</p>
<p>The build script can write files to a special directory supplied through the <code>OUT_DIR</code> environment variable. The same directory and environment variable are also accessible in the Rust source code at compile time so that it can pick up files generated by the build script. To generate and use Rust types from a C header, you first have your build script use the library version of <code>bindgen</code> to read in a <em>.h</em> file and turn it into a file called, say, <em>bindings.rs</em> inside <code>OUT_DIR</code>. You then add the following line to any Rust file in your crate to include <em>bindings.rs</em> at compilation time:</p>
<pre><code>include!(concat!(env!("OUT_DIR"), "/bindings.rs"));</code></pre>
<p>Since the code in <em>bindings.rs</em> is autogenerated, it’s generally best practice to place the bindings in their own crate and give the crate the same name as the library the bindings are for, with the suffix <code>-sys</code> (for example, <code>openssl-sys</code>). If you don’t follow this practice, releasing new versions of your library will be much more painful, as it is illegal for two crates that link against the same external library through the <code>links</code> key in <em>Cargo.toml</em> to coexist in a given build. You would essentially have to upgrade the entire ecosystem to the new major version of your library all at once. Separating just the bindings into their own crate allows you to issue new major versions of the wrapper crate that can be adopted incrementally. The separation also allows you to cut a breaking release of the crate with those bindings if the Rust bindings change—say, if the header files themselves are upgraded or a <code>bindgen</code> upgrade causes the generated Rust code to change slightly—without <em>also</em> having to cut a breaking release of the crate that safely wraps the FFI bindings.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Remember that if you include any of the types from the <code>-sys</code> crate in the public interface of your main library crate, changing the dependency on the <code>-sys</code> crate to a new major version still constitutes a breaking change for your main library!</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If your crate instead produces a library file that you intend others to use through FFI, you should also publish a C header file for its interface to make it easier to generate native bindings to your library from other languages. However, that C header file then needs to be kept up to date as your crate changes, which can become cumbersome as your library grows in size. Fortunately, the Rust community has also developed a tool to automate this task: <code>cbindgen</code>. Like <code>bindgen</code>, <code>cbindgen</code> is a build tool, and it also comes as both a binary and a library for use in build scripts. Instead of taking in a C header file and producing Rust, it takes Rust in and produces a C header file. Since the C header file represents the main computer-readable <span epub:type="pagebreak" title="209" id="Page_209"/>description of your crate’s FFI, I recommend manually looking it over to make sure the autogenerated C code isn’t too unwieldy, though in general <code>cbindgen</code> tends to produce fairly reasonable code. If it doesn’t, file a bug!</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>C++</h2>
<p class="BoxBodyFirst">I’ve mainly focused on C in this chapter as it’s the language most commonly used to describe cross-language interfaces for libraries you can link against. Nearly every programming language provides some way to interact with C libraries, since they are so ubiquitous. While C++ feels closely related to C, and many high-profile libraries are written in C++, it’s a very different beast when it comes to FFI. Generating types and signatures to match a C header is relatively straightforward, but that is not at all the case for C++. At the time of writing, <code>bindgen</code> has decent support for generating bindings to C++, but they are often lacking in ergonomics. For example, you generally have to manually call constructors, destructors, overloaded operators, and the like. Some C++ features like template specialization also aren’t supported at all. If you do have to interface with C++, I recommend you give the <code>cxx</code> crate a try.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1--0004">Summary</h2>
<p class="BodyFirst">In this chapter, we’ve covered how to use the <code>extern</code> keyword to call out of Rust into external code, as well as how to use it to make Rust code accessible to external code. We’ve also discussed how to align Rust types with types on the other side of the FFI boundary, and some of the common pitfalls in trying to get code written in two different languages to mesh well. Finally, we talked about the <code>bindgen</code> and <code>cbindgen</code> tools, which make the experience of keeping FFI bindings up to date much more pleasant. In the next chapter, we’ll look at how to use Rust in more restricted environments, like embedded devices, where the standard library may not be available and where even a simple operation like allocating memory may not be possible.</p>
</section>
</div></body></html>