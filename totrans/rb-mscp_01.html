<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Tokenization and Parsing"><div class="titlepage"><div><div><h1 class="title"><a id="tokenization_and_parsing"/>Chapter 1. Tokenization and Parsing</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00002"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>Your code has a long road to take before Ruby ever runs it.</em></span></p></blockquote></div><p><a class="indexterm" id="iddle1779"/><a class="indexterm" id="iddle2044"/>How many times do you think Ruby reads and transforms your code before running it? Once? Twice?</p><p>The correct answer is three times. Whenever you run a Ruby script—whether it’s a large Rails application, a simple Sinatra website, or a background worker job—Ruby rips your code apart into small pieces and then puts them back together in a different format <span class="emphasis"><em>three times</em></span>! Between the time you type <span class="emphasis"><em>ruby</em></span> and the time you start to see actual output on the console, your Ruby code has a long road to take—a journey involving a variety of different technologies, techniques, and open source tools.</p><p><a class="xref" href="ch01.html#your_codeapostrophes_journey_through_rub" title="Figure 1-1. Your code’s journey through Ruby">Figure 1-1</a> shows what this journey looks like at a high level.</p><div class="figure"><a id="your_codeapostrophes_journey_through_rub"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00003"/><img alt="Your code’s journey through Ruby" src="httpatomoreillycomsourcenostarchimages1853821.png.jpg"/></div></div><p class="title">Figure 1-1. Your code’s journey through Ruby</p></div><p>First, Ruby <span class="emphasis"><em>tokenizes</em></span> your code, which means it reads the text characters in your code file and converts them into <span class="emphasis"><em>tokens</em></span>, the words used in the Ruby <a class="indexterm" id="iddle1580"/><a class="indexterm" id="iddle1582"/><a class="indexterm" id="iddle1703"/><a class="indexterm" id="iddle1780"/><a class="indexterm" id="iddle2046"/>language. Next, Ruby <span class="emphasis"><em>parses</em></span> these tokens; that is, it groups the tokens into meaningful Ruby statements just as one might group words into sentences. Finally, Ruby compiles these statements into low-level instructions that it can execute later using a virtual machine.</p><p>I’ll cover Ruby’s virtual machine, called “Yet Another Ruby Virtual Machine” (YARV), in <a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a>. But first, in this chapter, I’ll describe the tokenizing and parsing processes that Ruby uses to understand your code. After that, in <a class="xref" href="ch02.html" title="Chapter 2. Compilation">Chapter 2</a>, I’ll show you how Ruby compiles your code by translating it into a completely different language.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note01"/>Note</h3><p><span class="emphasis"><em>Throughout most of this book we’ll learn about the original, standard implementation of Ruby, known as</em></span> Matz’s Ruby Interpreter (MRI) <span class="emphasis"><em>after Yukihiro Matsumoto, who invented Ruby in 1993. There are many other implementations of Ruby available in addition to MRI, including Ruby Enterprise Edition, MagLev, MacRuby, RubyMotion, mruby, and many, many others. Later, in <a class="xref" href="ch10.html" title="Chapter 10. JRuby: Ruby on the JVM">Chapter 10</a>, <a class="xref" href="ch11.html" title="Chapter 11. Rubinius: Ruby Implemented with Ruby">Chapter 11</a>, and <a class="xref" href="ch12.html" title="Chapter 12. Garbage Collection in MRI, JRuby, and Rubinius">Chapter 12</a>, we’ll look at two of these alternative Ruby implementations: JRuby and Rubinius.</em></span></p></div><div class="sidebar"><a id="roadmap"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch01.html#tokens_the_words_that_make_up_the_ruby_l" title="Tokens: The Words That Make Up the Ruby Language">Tokens: The Words That Make Up the Ruby Language</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch01.html#parserunderscoreyylex_function" title="The parser_yylex Function">The parser_yylex Function</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch01.html#experiment_1-1_using_ripper_to_tokenize" title="Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts">Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts</a></strong></span></p></li><li class="listitem"><p><a class="xref" href="ch01.html#parsing_how_ruby_understands_your_code" title="Parsing: How Ruby Understands Your Code">Parsing: How Ruby Understands Your Code</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch01.html#understanding_the_lalr_parse_algorithm" title="Understanding the LALR Parse Algorithm">Understanding the LALR Parse Algorithm</a></p></li><li class="listitem"><p><a class="xref" href="ch01.html#some_actual_ruby_grammar_rules" title="Some Actual Ruby Grammar Rules">Some Actual Ruby Grammar Rules</a></p></li><li class="listitem"><p><a class="xref" href="ch01.html#reading_a_bison_grammar_rule" title="Reading a Bison Grammar Rule">Reading a Bison Grammar Rule</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch01.html#experiment_1-2_using_ripper_to_parse_dif" title="Experiment 1-2: Using Ripper to Parse Different Ruby Scripts">Experiment 1-2: Using Ripper to Parse Different Ruby Scripts</a></strong></span></p></li><li class="listitem"><p><a class="xref" href="ch01.html#summary-id00004" title="Summary">Summary</a></p></li></ul></div></div><div class="sect1" title="Tokens: The Words That Make Up the Ruby Language"><div class="titlepage"><div><div><h1 class="title"><a id="tokens_the_words_that_make_up_the_ruby_l"/>Tokens: The Words That Make Up the Ruby Language</h1></div></div></div><p>Suppose you write a simple Ruby program and save it in a file called <span class="emphasis"><em>simple.rb</em></span>, shown in <a class="xref" href="ch01.html#very_simple_ruby_program_left_parenthe" title="Example 1-1. A very simple Ruby program (simple.rb)">Example 1-1</a>.</p><div class="example"><a id="very_simple_ruby_program_left_parenthe"/><p class="title">Example 1-1. A very simple Ruby program <span class="emphasis"><em>(simple.rb)</em></span></p><div class="example-contents"><pre class="programlisting">10.times do |n|
  puts n
end</pre></div></div><p><a class="xref" href="ch01.html#executing_listing_1-1" title="Example 1-2. Executing Example 1-1">Example 1-2</a> shows the output you would see after executing the program from the command line.</p><div class="example"><a id="executing_listing_1-1"/><p class="title">Example 1-2. Executing <a class="xref" href="ch01.html#very_simple_ruby_program_left_parenthe" title="Example 1-1. A very simple Ruby program (simple.rb)">Example 1-1</a></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ruby simple.rb</strong></span>
0
1
2
3
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>What happens after you type <code class="literal">ruby simple.rb</code> and press <span class="smaller">enter</span>? Aside from general initialization, processing your command line parameters, and so on, the first thing Ruby does is open <span class="emphasis"><em>simple.rb</em></span> and read in all the text from the code file. Next, it needs to make sense of this text: your Ruby code. How does it do this?</p><p>After reading in <span class="emphasis"><em>simple.rb</em></span>, Ruby encounters the series of text characters shown in <a class="xref" href="ch01.html#first_line_of_text_in_simpledotrb" title="Figure 1-2. The first line of text in simple.rb">Figure 1-2</a>. (To keep things simple, I’m showing only the first line of text here.)</p><div class="figure"><a id="first_line_of_text_in_simpledotrb"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00004"/><img alt="The first line of text in simple.rb" src="httpatomoreillycomsourcenostarchimages1853823.png"/></div></div><p class="title">Figure 1-2. The first line of text in <span class="emphasis"><em>simple.rb</em></span></p></div><p>When Ruby sees these characters, it tokenizes them. That is, it converts them into a series of tokens or words that it understands by stepping through the characters one at a time. In <a class="xref" href="ch01.html#ruby_starts_to_tokenize_your_codedot" title="Figure 1-3. Ruby starts to tokenize your code.">Figure 1-3</a>, Ruby starts scanning at the first character’s position.</p><div class="figure"><a id="ruby_starts_to_tokenize_your_codedot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00005"/><img alt="Ruby starts to tokenize your code." src="httpatomoreillycomsourcenostarchimages1853825.png.jpg"/></div></div><p class="title">Figure 1-3. Ruby starts to tokenize your code.</p></div><p>The Ruby C source code contains a loop that reads in one character at a time and processes it based on what that character is.</p><p>To keep things simple, I’m describing tokenization as an independent process. In fact, the parsing engine I describe next calls this C tokenize code whenever it needs a new token. Tokenization and parsing are separate processes that actually occur at the same time. For now, let’s just continue to see how Ruby tokenizes the characters in your Ruby file.</p><p>Ruby realizes that the character 1 is the start of a number and continues to iterate over the characters that follow until it finds a nonnumeric character. First, in <a class="xref" href="ch01.html#ruby_steps_to_the_second_text_characterd" title="Figure 1-4. Ruby steps to the second text character.">Figure 1-4</a>, it finds a 0.</p><div class="figure"><a id="ruby_steps_to_the_second_text_characterd"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00006"/><img alt="Ruby steps to the second text character." src="httpatomoreillycomsourcenostarchimages1853827.png.jpg"/></div></div><p class="title">Figure 1-4. Ruby steps to the second text character.</p></div><p><a class="indexterm" id="iddle2043"/>And stepping forward again, in <a class="xref" href="ch01.html#ruby_finds_a_period_characterdot" title="Figure 1-5. Ruby finds a period character.">Figure 1-5</a>, Ruby finds a period character.</p><div class="figure"><a id="ruby_finds_a_period_characterdot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00007"/><img alt="Ruby finds a period character." src="httpatomoreillycomsourcenostarchimages1853829.png.jpg"/></div></div><p class="title">Figure 1-5. Ruby finds a period character.</p></div><p>Ruby actually considers the period character to be numeric because it might be part of a floating-point value. In <a class="xref" href="ch01.html#ruby_finds_the_first_nonnumeric_characte" title="Figure 1-6. Ruby finds the first nonnumeric character.">Figure 1-6</a>, Ruby steps to the next character, t.</p><div class="figure"><a id="ruby_finds_the_first_nonnumeric_characte"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00008"/><img alt="Ruby finds the first nonnumeric character." src="httpatomoreillycomsourcenostarchimages1853831.png.jpg"/></div></div><p class="title">Figure 1-6. Ruby finds the first nonnumeric character.</p></div><p>Now Ruby stops iterating because it has found a nonnumeric character. Because there are no more numeric characters after the period, Ruby considers the period to be part of a separate token, and it steps back one, as shown in <a class="xref" href="ch01.html#ruby_steps_back_one_characterdot" title="Figure 1-7. Ruby steps back one character.">Figure 1-7</a>.</p><div class="figure"><a id="ruby_steps_back_one_characterdot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00009"/><img alt="Ruby steps back one character." src="httpatomoreillycomsourcenostarchimages1853833.png.jpg"/></div></div><p class="title">Figure 1-7. Ruby steps back one character.</p></div><p>Finally, in <a class="xref" href="ch01.html#ruby_converts_the_first_two_text_charact" title="Figure 1-8. Ruby converts the first two text characters into a tINTEGER token.">Figure 1-8</a>, Ruby converts the numeric characters that it found into the first token from your program, called <code class="literal">tINTEGER</code>.</p><div class="figure"><a id="ruby_converts_the_first_two_text_charact"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00010"/><img alt="Ruby converts the first two text characters into a tINTEGER token." src="httpatomoreillycomsourcenostarchimages1853835.png.jpg"/></div></div><p class="title">Figure 1-8. Ruby converts the first two text characters into a <code class="literal">tINTEGER</code> token.</p></div><p><a class="indexterm" id="iddle1361"/><a class="indexterm" id="iddle1402"/><a class="indexterm" id="iddle1435"/><a class="indexterm" id="iddle1500"/><a class="indexterm" id="iddle1905"/><a class="indexterm" id="iddle2041"/>Ruby continues to step through the characters in your code file, converting them into tokens and grouping characters as necessary. The second token, shown in <a class="xref" href="ch01.html#ruby_converts_the_period_character_into" title="Figure 1-9. Ruby converts the period character into a token.">Figure 1-9</a>, is a single character: a period.</p><div class="figure"><a id="ruby_converts_the_period_character_into"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00011"/><img alt="Ruby converts the period character into a token." src="httpatomoreillycomsourcenostarchimages1853837.png.jpg"/></div></div><p class="title">Figure 1-9. Ruby converts the period character into a token.</p></div><p>Next, in <a class="xref" href="ch01.html#ruby_tokenizes_the_word_timesdot" title="Figure 1-10. Ruby tokenizes the word times.">Figure 1-10</a>, Ruby encounters the word <span class="emphasis"><em>times</em></span> and creates an identifier token.</p><div class="figure"><a id="ruby_tokenizes_the_word_timesdot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00012"/><img alt="Ruby tokenizes the word times." src="httpatomoreillycomsourcenostarchimages1853839.png.jpg"/></div></div><p class="title">Figure 1-10. Ruby tokenizes the word <span class="emphasis"><em>times</em></span>.</p></div><p><span class="emphasis"><em>Identifiers</em></span> are words in your Ruby code that are not reserved words. Identifiers usually refer to variable, method, or class names.</p><p>Next, Ruby sees <span class="emphasis"><em>do</em></span> and creates a reserved word token, as indicated by <code class="literal">keyword_do</code> in <a class="xref" href="ch01.html#ruby_creates_a_reserved_word_token_keywo" title="Figure 1-11. Ruby creates a reserved word token: keyword_do.">Figure 1-11</a>.</p><div class="figure"><a id="ruby_creates_a_reserved_word_token_keywo"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00013"/><img alt="Ruby creates a reserved word token: keyword_do." src="httpatomoreillycomsourcenostarchimages1853841.png.jpg"/></div></div><p class="title">Figure 1-11. Ruby creates a reserved word token: <code class="literal">keyword_do</code>.</p></div><p><span class="emphasis"><em>Reserved words</em></span> are keywords that carry significant meaning in Ruby because they provide the structure, or framework, of the language. They are called <span class="emphasis"><em>reserved words</em></span> because you can’t use them as normal identifiers, although you can use them as method names, global variable names (such as <code class="literal">$do</code>), or instance variable names (for example, <code class="literal">@do</code> or <code class="literal">@@do</code>).</p><p>Internally, the Ruby C code maintains a constant table of reserved words. <a class="xref" href="ch01.html#first_few_reserved_wordscomma_listed" title="Example 1-3. The first few reserved words, listed alphabetically">Example 1-3</a> shows the first few, in alphabetical order.</p><div class="example"><a id="first_few_reserved_wordscomma_listed"/><p class="title">Example 1-3. The first few reserved words, listed alphabetically</p><div class="example-contents"><pre class="programlisting">alias
and
begin
break
case
class</pre></div></div><div class="sidebar"><a id="parserunderscoreyylex_function"/><p class="title">The parser_yylex Function</p><p><a class="indexterm" id="iddle1233"/><a class="indexterm" id="iddle1363"/><a class="indexterm" id="iddle1377"/><a class="indexterm" id="iddle1535"/><a class="indexterm" id="iddle1769"/><a class="indexterm" id="iddle1776"/><a class="indexterm" id="iddle1874"/>If you’re familiar with C and are interested in learning more about the detailed way in which Ruby tokenizes your code file, see the <span class="emphasis"><em>parse.y</em></span> file in your version of Ruby. The <span class="emphasis"><em>.y</em></span> extension indicates that <span class="emphasis"><em>parse.y</em></span> is a <span class="emphasis"><em>grammar rule file</em></span>—one that contains a series of rules for the Ruby parser engine. (I’ll discuss these in the next section.) <span class="emphasis"><em>parse.y</em></span> is an extremely large and complex file with over 10,000 lines of code!</p><p>For now, ignore the grammar rules, and search for a C function called <code class="literal">parser_yylex</code>, about two-thirds of the way down the file, around line 6500. This complex C function contains the code that actually tokenizes your code. Look closely and you should see a very large <code class="literal">switch</code> statement that starts with the code shown in <a class="xref" href="ch01.html#c_code_inside_ruby_that_reads_in_eac" title="Example 1-4. The C code inside Ruby that reads in each character from your code file">Example 1-4</a>.</p><div class="example"><a id="c_code_inside_ruby_that_reads_in_eac"/><p class="title">Example 1-4. The C code inside Ruby that reads in each character from your code file</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> retry:
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> last_state = lex_state;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/> switch (c = nextc()) {</pre></div></div><p>The <code class="literal">nextc()</code> function <span class="inlinemediaobject"><a id="inline_id00004"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> returns the next character in the code file text stream. Think of this function as the arrow in the previous diagrams. The <code class="literal">lex_state</code> variable <span class="inlinemediaobject"><a id="inline_id00005"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> keeps information about what state or type of code Ruby is processing at the moment.</p><p>The large <code class="literal">switch</code> statement inspects each character of your code file and takes a different action based on what it is. For example, the code shown in <a class="xref" href="ch01.html#this_c_code_checks_for_whitespace_charac" title="Example 1-5. This C code checks for whitespace characters in your code and ignores them.">Example 1-5</a> looks for whitespace characters and ignores them by jumping back up to the <code class="literal">retry</code> label <span class="inlinemediaobject"><a id="inline_id00006"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> just above the <code class="literal">switch</code> statement in <a class="xref" href="ch01.html#c_code_inside_ruby_that_reads_in_eac" title="Example 1-4. The C code inside Ruby that reads in each character from your code file">Example 1-4</a>.</p><div class="example"><a id="this_c_code_checks_for_whitespace_charac"/><p class="title">Example 1-5. This C code checks for whitespace characters in your code and ignores them.</p><div class="example-contents"><pre class="programlisting">  /* white spaces */
case ' ': case '\t': case '\f': case '\r':
case '\13': /* '\v' */
  space_seen = 1;
--<span class="emphasis"><em>snip</em></span>--
  goto retry;</pre></div></div><p>Ruby’s reserved words are defined in the file called <span class="emphasis"><em>defs/keywords</em></span>. If you open this file, you’ll see a complete list of all of Ruby’s reserved words (see a partial list in <a class="xref" href="ch01.html#first_few_reserved_wordscomma_listed" title="Example 1-3. The first few reserved words, listed alphabetically">Example 1-3</a>). The <span class="emphasis"><em>keywords</em></span> file is used by an open source package called <span class="emphasis"><em>gperf</em></span> to produce C code that can quickly and efficiently look up strings in a table—in this case, a table of reserved words. You can find the generated C code that looks up reserved words in <span class="emphasis"><em>lex.c</em></span>, which defines a function named <code class="literal">rb_reserved_word</code>, called from <span class="emphasis"><em>parse.y</em></span>.</p><p>One final detail about tokenization: Ruby doesn’t use the Lex tokenization tool that C programmers commonly use in conjunction with a parser generator like Yacc or Bison. Instead, the Ruby core team wrote the Ruby tokenization code by hand, whether for performance reasons or because Ruby’s tokenization rules required special logic that Lex couldn’t provide.</p></div><p><a class="indexterm" id="iddle1141"/><a class="indexterm" id="iddle1282"/><a class="indexterm" id="iddle1283"/><a class="indexterm" id="iddle1649"/><a class="indexterm" id="iddle1781"/><a class="indexterm" id="iddle1910"/><a class="indexterm" id="iddle1912"/><a class="indexterm" id="iddle1914"/><a class="indexterm" id="iddle1971"/><a class="indexterm" id="iddle2045"/>Finally, as shown in <a class="xref" href="ch01.html#ruby_finishes_tokenizing_the_first_line" title="Figure 1-12. Ruby finishes tokenizing the first line of text.">Figure 1-12</a>, Ruby converts the remaining characters to tokens.</p><div class="figure"><a id="ruby_finishes_tokenizing_the_first_line"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00014"/><img alt="Ruby finishes tokenizing the first line of text." src="httpatomoreillycomsourcenostarchimages1853849.png.jpg"/></div></div><p class="title">Figure 1-12. Ruby finishes tokenizing the first line of text.</p></div><p>Ruby continues to step through your code until it has tokenized the entire Ruby script. At this point, it has processed your code for the first time, ripping it apart and putting it back together again in a completely different way. Your code began as a stream of text characters, and Ruby converted it to a stream of tokens, words that it will later combine into sentences.</p></div><div class="sect1" title="Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_1-1_using_ripper_to_tokenize"/>Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts</h1></div></div></div><p>Now that we’ve learned the basic idea behind tokenization, let’s look at how Ruby actually tokenizes different Ruby scripts. After all, how else will you know that the previous explanation is actually correct?</p><p>As it turns out, a tool called <span class="emphasis"><em>Ripper</em></span> makes it very easy to see what tokens Ruby creates for different code files. Shipped with Ruby 1.9 and Ruby 2.0, the <code class="literal">Ripper</code> class allows you to call the same tokenization and parsing code that Ruby uses to process text from code files. (Ripper is not available in Ruby 1.8.)</p><p><a class="xref" href="ch01.html#example_of_how_to_call_ripperdotlex_l" title="Example 1-6. An example of how to call Ripper.lex (lex1.rb)">Example 1-6</a> shows how simple using Ripper is.</p><div class="example"><a id="example_of_how_to_call_ripperdotlex_l"/><p class="title">Example 1-6. An example of how to call <code class="literal">Ripper.lex</code> <span class="emphasis"><em>(lex1.rb)</em></span></p><div class="example-contents"><pre class="programlisting">    require 'ripper'
    require 'pp'
    code = &lt;&lt;STR
    10.times do |n|
      puts n
    end
    STR
    puts code
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> pp Ripper.lex(code)</pre></div></div><p>After requiring the Ripper code from the standard library, you call it by passing some code as a string to the <code class="literal">Ripper.lex</code> method <span class="inlinemediaobject"><a id="inline_id00008"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. <a class="xref" href="ch01.html#output_generated_by_ripperdotlex" title="Example 1-7. The output generated by Ripper.lex">Example 1-7</a> shows the output from Ripper.</p><div class="example"><a id="output_generated_by_ripperdotlex"/><p class="title">Example 1-7. The output generated by <code class="literal">Ripper.lex</code></p><div class="example-contents"><pre class="programlisting">    $ <span class="strong"><strong>ruby lex1.rb</strong></span>
    10.times do |n|
      puts n
    end
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> [[[1, 0], :on_int, "10"],
    [[1, 2], :on_period, "."],
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> [[1, 3], :on_ident, "times"],
    [[1, 8], :on_sp, " "],
    [[1, 9], :on_kw, "do"],
    [[1, 11], :on_sp, " "],
    [[1, 12], :on_op, "|"],
    [[1, 13], :on_ident, "n"],
    [[1, 14], :on_op, "|"],
    [[1, 15], :on_ignored_nl, "\n"],
    [[2, 0], :on_sp, "  "],
    [[2, 2], :on_ident, "puts"],
    [[2, 6], :on_sp, " "],
    [[2, 7], :on_ident, "n"],
    [[2, 8], :on_nl, "\n"],
    [[3, 0], :on_kw, "end"],
    [[3, 3], :on_nl, "\n"]]</pre></div></div><p><a class="indexterm" id="iddle1751"/><a class="indexterm" id="iddle1752"/>Each line corresponds to a single token that Ruby found in your code string. On the left, we have the line number (<code class="literal">1</code>, <code class="literal">2</code>, or <code class="literal">3</code> in this short example) and the text column number. Next, we see the token itself displayed as a symbol, such as <code class="literal">:on_int</code> <span class="inlinemediaobject"><a id="inline_id00011"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> or <code class="literal">:on_ident</code> <span class="inlinemediaobject"><a id="inline_id00012"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. Finally, Ripper displays the text characters that correspond to each token.</p><p>The token symbols that Ripper displays are somewhat different from the token identifiers I used in <a class="xref" href="ch01.html#first_line_of_text_in_simpledotrb" title="Figure 1-2. The first line of text in simple.rb">Figure 1-2</a> through <a class="xref" href="ch01.html#ruby_finishes_tokenizing_the_first_line" title="Figure 1-12. Ruby finishes tokenizing the first line of text.">Figure 1-12</a> that showed Ruby tokenizing the <code class="literal">10.times do</code> code. I used the same names you would find in Ruby’s internal parse code, such as <code class="literal">tIDENTIFIER</code>, while Ripper used <code class="literal">:on_ident</code> instead.</p><p>Regardless, Ripper will still give you a sense of what tokens Ruby finds in your code and how tokenization works.</p><p><a class="xref" href="ch01.html#another_example_of_using_ripperdotlex" title="Example 1-8. Another example of using Ripper.lex">Example 1-8</a> shows another example of using Ripper.</p><div class="example"><a id="another_example_of_using_ripperdotlex"/><p class="title">Example 1-8. Another example of using <code class="literal">Ripper.lex</code></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ruby lex2.rb</strong></span>
10.times do |n|
  puts n/4+6
end
--<span class="emphasis"><em>snip</em></span>--
 [[2, 2], :on_ident, "puts"],
 [[2, 6], :on_sp, " "],
 [[2, 7], :on_ident, "n"],
 [[2, 8], :on_op, "/"],
 [[2, 9], :on_int, "4"],
 [[2, 10], :on_op, "+"],
 [[2, 11], :on_int, "6"],
 [[2, 12], :on_nl, "\n"],
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>This time Ruby converts the expression <code class="literal">n/4+6</code> into a series of tokens in a very straightforward way. The tokens appear in exactly the same order they did inside the code file.</p><p><a class="xref" href="ch01.html#third_example_of_running_ripperdotlex" title="Example 1-9. A third example of running Ripper.lex">Example 1-9</a> shows a third, slightly more complex example.</p><div class="example"><a id="third_example_of_running_ripperdotlex"/><p class="title">Example 1-9. A third example of running <code class="literal">Ripper.lex</code></p><div class="example-contents"><pre class="programlisting">    $ <span class="strong"><strong>ruby lex3.rb</strong></span>
    array = []
    10.times do |n|
      array &lt;&lt; n if n &lt; 5
    end
    p array
    --<span class="emphasis"><em>snip</em></span>--
     [[3, 2], :on_ident, "array"],
     [[3, 7], :on_sp, " "],
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>  [[3, 8], :on_op, "&lt;&lt;"],
     [[3, 10], :on_sp, " "],
     [[3, 11], :on_ident, "n"],
     [[3, 12], :on_sp, " "],
     [[3, 13], :on_kw, "if"],
     [[3, 15], :on_sp, " "],
     [[3, 16], :on_ident, "n"],
     [[3, 17], :on_sp, " "],
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>  [[3, 18], :on_op, "&lt;"],
     [[3, 19], :on_sp, " "],
     [[3, 20], :on_int, "5"],
    --<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>As you can see, Ruby is smart enough to distinguish between <code class="literal">&lt;&lt;</code> and <code class="literal">&lt;</code> in the following line: <code class="literal">array &lt;&lt; n if n &lt; 5</code>. The characters <code class="literal">&lt;&lt;</code> are converted to a single operator token <span class="inlinemediaobject"><a id="inline_id00015"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, while the single <code class="literal">&lt;</code> character that appears later is converted into a simple less-than operator <span class="inlinemediaobject"><a id="inline_id00016"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. Ruby’s tokenize code is smart enough to look ahead for a second <code class="literal">&lt;</code> character when it finds one <code class="literal">&lt;</code>.</p><p>Finally, notice that Ripper has no idea whether the code you give it is valid Ruby or not. If you pass in code that contains a syntax error, Ripper will just tokenize it as usual and not complain. It’s the parser’s job to check syntax.</p><p>Suppose you forget the <code class="literal">|</code> symbol after the block parameter <code class="literal">n</code> <span class="inlinemediaobject"><a id="inline_id00017"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, as shown in <a class="xref" href="ch01.html#this_code_contains_a_syntax_errordot" title="Example 1-10. This code contains a syntax error.">Example 1-10</a>.</p><div class="example"><a id="this_code_contains_a_syntax_errordot"/><p class="title">Example 1-10. This code contains a syntax error.</p><div class="example-contents"><pre class="programlisting">    require 'ripper'
    require 'pp'
    code = &lt;&lt;STR
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> 10.times do |n
      puts n
    end
    STR
    puts code
    pp Ripper.lex(code)</pre></div></div><p><a class="indexterm" id="iddle1074"/><a class="indexterm" id="iddle1770"/><a class="indexterm" id="iddle1775"/><a class="indexterm" id="iddle2107"/><a class="indexterm" id="iddle2133"/>Running this, you get the output shown in <a class="xref" href="ch01.html#ripper_does_not_detect_syntax_errorsdot" title="Example 1-11. Ripper does not detect syntax errors.">Example 1-11</a>.</p><div class="example"><a id="ripper_does_not_detect_syntax_errorsdot"/><p class="title">Example 1-11. Ripper does not detect syntax errors.</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ruby lex4.rb</strong></span>
10.times do |n
  puts n
end
--<span class="emphasis"><em>snip</em></span>--
[[[1, 0], :on_int, "10"],
 [[1, 2], :on_period, "."],
 [[1, 3], :on_ident, "times"],
 [[1, 8], :on_sp, " "],
 [[1, 9], :on_kw, "do"],
 [[1, 11], :on_sp, " "],
 [[1, 12], :on_op, "|"],
 [[1, 13], :on_ident, "n"],
 [[1, 14], :on_nl, "\n"],
--<span class="emphasis"><em>snip</em></span>--</pre></div></div></div><div class="sect1" title="Parsing: How Ruby Understands Your Code"><div class="titlepage"><div><div><h1 class="title"><a id="parsing_how_ruby_understands_your_code"/>Parsing: How Ruby Understands Your Code</h1></div></div></div><p>Once Ruby converts your code into a series of tokens, what does it do next? How does it actually understand and run your program? Does Ruby simply step through the tokens and execute each one in order?</p><p>No. Your code still has a long way to go before Ruby can run it. The next step on its journey through Ruby is called <span class="emphasis"><em>parsing</em></span>, where words or tokens are grouped into sentences or phrases that make sense to Ruby. When parsing, Ruby takes into account the order of operations, methods, blocks, and other larger code structures.</p><p>But how can Ruby actually understand what you’re telling it with your code? Like many programming languages, Ruby uses a <span class="emphasis"><em>parser generator</em></span>. Ruby uses a parser to process tokens, but the parser itself is generated with a parser generator. Parser generators take a series of grammar rules as input that describe the expected order and patterns in which the tokens will appear.</p><p>The most widely used and well-known parser generator is Yacc (Yet Another Compiler Compiler), but Ruby uses a newer version of Yacc called <span class="emphasis"><em>Bison</em></span>. The grammar rule file for Bison and Yacc has a<span class="emphasis"><em>.y</em></span> extension. In the Ruby source code, the grammar rule file is <span class="emphasis"><em>parse.y</em></span> (introduced earlier). The <span class="emphasis"><em>parse.y</em></span> file defines the actual syntax and grammar that you have to use while writing your Ruby code; it’s really the heart and soul of Ruby and where the language itself is actually defined!</p><div class="informalfigure"><a id="med_id00015a"/><div class="mediaobject"><a id="med_id00015"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853851.png.jpg"/><div class="caption"><p><span class="emphasis"><em>Ruby uses an LALR parser</em></span></p></div></div></div><p><a class="indexterm" id="iddle1009"/><a class="indexterm" id="iddle1521"/><a class="indexterm" id="iddle1557"/><a class="indexterm" id="iddle1768"/>Ruby doesn’t use Bison to actually process tokens; instead, it runs Bison ahead of time, during the build process, to create the actual parser code. In effect, there are two separate steps to the parsing process, shown in <a class="xref" href="ch01.html#ruby_build_process_runs_bison_ahead" title="Figure 1-13. The Ruby build process runs Bison ahead of time.">Figure 1-13</a>.</p><p>Before you run your Ruby program, the Ruby build process uses Bison to generate the parser code (<span class="emphasis"><em>parse.c</em></span>) from the grammar rule file (<span class="emphasis"><em>parse.y</em></span>). Later, at run time, this generated parser code parses the tokens returned by Ruby’s tokenizer code.</p><div class="figure"><a id="ruby_build_process_runs_bison_ahead"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00016"/><img alt="The Ruby build process runs Bison ahead of time." src="httpatomoreillycomsourcenostarchimages1853853.png.jpg"/></div></div><p class="title">Figure 1-13. The Ruby build process runs Bison ahead of time.</p></div><p>Because the <span class="emphasis"><em>parse.y</em></span> file and the generated <span class="emphasis"><em>parse.c</em></span> file also contain the tokenization code, <a class="xref" href="ch01.html#ruby_build_process_runs_bison_ahead" title="Figure 1-13. The Ruby build process runs Bison ahead of time.">Figure 1-13</a> has a diagonal arrow from <span class="emphasis"><em>parse.c</em></span> to the tokenize process on the lower left. (In fact, the parse engine I’m about to describe calls the tokenization code whenever it needs a new token.) The tokenization and parsing processes actually occur simultaneously.</p><div class="sect2" title="Understanding the LALR Parse Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="understanding_the_lalr_parse_algorithm"/>Understanding the LALR Parse Algorithm</h2></div></div></div><p>How does the parser code analyze and process the incoming tokens? With an algorithm known as <span class="emphasis"><em>LALR</em></span>, or <span class="emphasis"><em>Look-Ahead Left Reversed Rightmost Derivation</em></span>. Using the LALR algorithm, the parser code processes the token stream from left to right, trying to match their order and the pattern in which they appear against one or more of the grammar rules from <span class="emphasis"><em>parse.y</em></span>. The parser code also “looks ahead” when necessary to decide which grammar rule to match.</p><p>The best way to become familiar with the way Ruby grammar rules work is with an example. To keep things simple for now, we’ll look at an abstract example. Later on, I’ll show that Ruby actually works in precisely the same way when it parses your code.</p><p><a class="indexterm" id="iddle1256"/><a class="indexterm" id="iddle1364"/><a class="indexterm" id="iddle1371"/>Suppose you want to translate from the Spanish:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; " valign="top"><p>Me gusta el Ruby.</p></td><td style="" valign="top"><p>[Phrase 1]</p></td></tr></tbody></table></div><p>to the English:</p><div class="blockquote"><blockquote class="blockquote"><p>I like Ruby.</p></blockquote></div><p>And suppose that to translate Phrase 1, you use Bison to generate a C language parser from a grammar file. Using the Bison/Yacc grammar rule syntax, you can write the simple grammar shown in <a class="xref" href="ch01.html#simple_grammar_rule_matching_the_spani" title="Example 1-12. A simple grammar rule matching the Spanish Phrase 1">Example 1-12</a>, with the rule name on the left and the matching tokens on the right.</p><div class="example"><a id="simple_grammar_rule_matching_the_spani"/><p class="title">Example 1-12. A simple grammar rule matching the Spanish Phrase 1</p><div class="example-contents"><pre class="programlisting">SpanishPhrase : me gusta el ruby {
  printf("I like Ruby\n");
}</pre></div></div><p>This grammar rule says the following: If the token stream is equal to <code class="literal">me</code>, <code class="literal">gusta</code>, <code class="literal">el</code>, and <code class="literal">ruby</code>—in that order—we have a match. If there’s a match, the Bison generated parser will run the given C code, and the <code class="literal">printf</code> statement (similar to <code class="literal">puts</code> in Ruby) will print the translated English phrase.</p><p><a class="xref" href="ch01.html#matching_tokens_with_a_grammar_rule" title="Figure 1-14. Matching tokens with a grammar rule">Figure 1-14</a> shows the parsing process in action.</p><div class="figure"><a id="matching_tokens_with_a_grammar_rule"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00017"/><img alt="Matching tokens with a grammar rule" src="httpatomoreillycomsourcenostarchimages1853855.png.jpg"/></div></div><p class="title">Figure 1-14. Matching tokens with a grammar rule</p></div><p>There are four input tokens at the top, and the grammar rule is underneath. It should be clear that there’s a match because each input token corresponds directly to one of the terms on the right side of the grammar rule. We have a match on the <code class="literal">SpanishPhrase</code> rule.</p><p>Now let’s improve on this example. Suppose you need to enhance your parser to match Phrase 1 and Phrase 2:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; " valign="top"><p>Me gusta el Ruby.</p></td><td style="" valign="top"><p>[Phrase 1]</p></td></tr></tbody></table></div><p>and:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; " valign="top"><p>Le gusta el Ruby.</p></td><td style="" valign="top"><p>[Phrase 2]</p></td></tr></tbody></table></div><p>In English, Phrase 2 means “She/He/It likes Ruby.”</p><p><a class="indexterm" id="iddle1118"/><a class="indexterm" id="iddle1369"/>The modified grammar file in <a class="xref" href="ch01.html#these_grammar_rules_match_both_phrase_1" title="Example 1-13. These grammar rules match both Phrase 1 and Phrase 2.">Example 1-13</a> can parse both Spanish phrases.</p><div class="example"><a id="these_grammar_rules_match_both_phrase_1"/><p class="title">Example 1-13. These grammar rules match both Phrase 1 and Phrase 2.</p><div class="example-contents"><pre class="programlisting">SpanishPhrase: VerbAndObject el ruby {
  printf("%s Ruby\n", $1);
};
VerbAndObject: SheLikes | ILike {
  $$ = $1;
};
SheLikes: le gusta {
  $$ = "She likes";
}
ILike: me gusta {
  $$ = "I like";
}</pre></div></div><p>As you can see, there are four grammar rules here instead of just one. Also, you’re using the Bison directive <code class="literal">$$</code> to return a value from a child grammar rule to a parent and <code class="literal">$1</code> to refer to a child’s value from a parent.</p><p>Unlike with Phrase 1, the parser can’t immediately match Phrase 2 with any of the grammar rules.</p><p>In <a class="xref" href="ch01.html#first_two_tokens_donapostrophet_matc" title="Figure 1-15. The first two tokens don’t match.">Figure 1-15</a>, we can see the <code class="literal">el</code> and <code class="literal">ruby</code> tokens match the <code class="literal">SpanishPhrase</code> rule, but <code class="literal">le</code> and <code class="literal">gusta</code> do not. (Ultimately, we’ll see that the child rule <code class="literal">VerbAndObject</code> does match <code class="literal">le gusta</code>, but never mind that for now.) With four grammar rules, how does the parser know which other rules to try to match against? And against which tokens?</p><div class="figure"><a id="first_two_tokens_donapostrophet_matc"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00018"/><img alt="The first two tokens don’t match." src="httpatomoreillycomsourcenostarchimages1853857.png.jpg"/></div></div><p class="title">Figure 1-15. The first two tokens don’t match.</p></div><p>This is where the intelligence of the LALR parser comes in. As I mentioned earlier, the acronym LALR stands for <span class="emphasis"><em>Look-Ahead LR</em></span> parser, and it <a class="indexterm" id="iddle1378"/><a class="indexterm" id="iddle1990"/>describes the algorithm the parser uses to find matching grammar rules. We’ll get to the <span class="emphasis"><em>look ahead</em></span> part in a minute. For now, let’s start with LR:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>L</strong></span> (left) means the parser moves from left to right while processing the token stream. In this example, that would be <code class="literal">le</code>, <code class="literal">gusta</code>, <code class="literal">el</code>, and <code class="literal">ruby</code>, in that order.</p></li><li class="listitem"><p><span class="strong"><strong>R</strong></span> (reversed rightmost derivation) means the parser takes a bottom-up strategy, using a shift/reduce technique, to find matching grammar rules.</p></li></ul></div><p>Here’s how the algorithm works for Phrase 2. First, the parser takes the input token stream, shown again in <a class="xref" href="ch01.html#input_stream_of_tokens" title="Figure 1-16. The input stream of tokens">Figure 1-16</a>.</p><div class="figure"><a id="input_stream_of_tokens"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00019"/><img alt="The input stream of tokens" src="httpatomoreillycomsourcenostarchimages1853859.png.jpg"/></div></div><p class="title">Figure 1-16. The input stream of tokens</p></div><p>Next, it shifts the tokens to the left, creating what I’ll call the <span class="emphasis"><em>grammar rule stack</em></span>, as shown <a class="xref" href="ch01.html#parser_moves_the_first_token_onto_th" title="Figure 1-17. The parser moves the first token onto the grammar rule stack.">Figure 1-17</a>.</p><div class="figure"><a id="parser_moves_the_first_token_onto_th"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00020"/><img alt="The parser moves the first token onto the grammar rule stack." src="httpatomoreillycomsourcenostarchimages1853861.png.jpg"/></div></div><p class="title">Figure 1-17. The parser moves the first token onto the grammar rule stack.</p></div><p>Because the parser has processed only the token <code class="literal">le</code>, it places this token in the stack alone for the moment. The term g<span class="emphasis"><em>rammar rule stack</em></span> is a bit of an oversimplification; while the parser uses a stack, instead of grammar rules, it pushes numbers onto its stack to indicate which grammar rule it has just parsed. These numbers, or <span class="emphasis"><em>states</em></span>, help the parser keep track of which grammar rules it has matched as it processes tokens.</p><p>Next, as shown in <a class="xref" href="ch01.html#parser_moves_another_token_onto_the" title="Figure 1-18. The parser moves another token onto the stack.">Figure 1-18</a>, the parser shifts another token to the left.</p><div class="figure"><a id="parser_moves_another_token_onto_the"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00021"/><img alt="The parser moves another token onto the stack." src="httpatomoreillycomsourcenostarchimages1853863.png.jpg"/></div></div><p class="title">Figure 1-18. The parser moves another token onto the stack.</p></div><p><a class="indexterm" id="iddle1894"/>Now there are two tokens in the stack on the left. At this point, the parser stops to search the different grammar rules for a match. <a class="xref" href="ch01.html#parser_matches_the_shelikes_rule_and" title="Figure 1-19. The parser matches the SheLikes rule and reduces.">Figure 1-19</a> shows the parser matching the <code class="literal">SheLikes</code> rule.</p><div class="figure"><a id="parser_matches_the_shelikes_rule_and"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00022"/><img alt="The parser matches the SheLikes rule and reduces." src="httpatomoreillycomsourcenostarchimages1853865.png.jpg"/></div></div><p class="title">Figure 1-19. The parser matches the <code class="literal">SheLikes</code> rule and reduces.</p></div><p>This operation is called <span class="emphasis"><em>reduce</em></span> because the parser is replacing the pair of tokens with a single matching rule. The parser looks through the available rules and reduces, or applies the single matching rule.</p><p>Now the parser can reduce again because there’s another matching rule: <code class="literal">VerbAndObject</code>! The <code class="literal">VerbAndObject</code> rule matches because its use of the <code class="literal">OR</code> (<code class="literal">|</code>) operator matches <span class="emphasis"><em>either</em></span> the <code class="literal">SheLikes</code> <span class="emphasis"><em>or</em></span> <code class="literal">ILike</code> child rules.</p><p>You can see in <a class="xref" href="ch01.html#parser_reduces_againcomma_matching_t" title="Figure 1-20. The parser reduces again, matching the VerbAndObject rule.">Figure 1-20</a> that the parser replaces <code class="literal">SheLikes</code> with <code class="literal">VerbAndObject</code>.</p><div class="figure"><a id="parser_reduces_againcomma_matching_t"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00023"/><img alt="The parser reduces again, matching the VerbAndObject rule." src="httpatomoreillycomsourcenostarchimages1853867.png.jpg"/></div></div><p class="title">Figure 1-20. The parser reduces again, matching the <code class="literal">VerbAndObject</code> rule.</p></div><p>But think about this: How did the parser know to reduce and not continue to shift tokens? Also, if in the real world there are actually many matching rules, how does the parser know which one to use? How does it decide whether to shift or reduce? And if it reduces, how does it decide which grammar rule to reduce with?</p><p>In other words, suppose at this point in the process multiple matching rules included <code class="literal">le gusta</code>. How would the parser know which rule to apply or whether to shift in the <code class="literal">el</code> token first before looking for a match? (See <a class="xref" href="ch01.html#how_does_the_parser_know_to_shift_or_red" title="Figure 1-21. How does the parser know to shift or reduce?">Figure 1-21</a>.)</p><div class="figure"><a id="how_does_the_parser_know_to_shift_or_red"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00024"/><img alt="How does the parser know to shift or reduce?" src="httpatomoreillycomsourcenostarchimages1853869.png.jpg"/></div></div><p class="title">Figure 1-21. How does the parser know to shift or reduce?</p></div><p><a class="indexterm" id="iddle1522"/><a class="indexterm" id="iddle1556"/><a class="indexterm" id="iddle1558"/><a class="indexterm" id="iddle2017"/>Here’s where the <span class="emphasis"><em>look ahead</em></span> portion of LALR comes in. In order to find the correct matching rule, the parser looks ahead at the next token. The arrow in <a class="xref" href="ch01.html#looking_ahead_at_the_next_token_in_the_i" title="Figure 1-22. Looking ahead at the next token in the input stream">Figure 1-22</a> shows the parser looking ahead at the <code class="literal">el</code> token.</p><div class="figure"><a id="looking_ahead_at_the_next_token_in_the_i"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00025"/><img alt="Looking ahead at the next token in the input stream" src="httpatomoreillycomsourcenostarchimages1853871.png.jpg"/></div></div><p class="title">Figure 1-22. Looking ahead at the next token in the input stream</p></div><p>Additionally, the parser maintains a state table of possible outcomes depending on what the next token is and which grammar rule was just parsed. In this case, the table would contain a series of states, describing which grammar rules have been parsed so far and which states to move to next depending on the next token. (LALR parsers are complex state machines that match patterns in the token stream. When you use Bison to generate the LALR parser, Bison calculates what this state table should contain based on the grammar rules you provided.)</p><p>In this example, the state table would contain an entry indicating that if the next token was <code class="literal">el</code>, the parser should first reduce using the <code class="literal">SheLikes</code> rule before shifting a new token.</p><p>Rather than waste your time with the details of what a state table looks like (you’ll find the actual LALR state table for Ruby in the generated <span class="emphasis"><em>parse.c</em></span> file), let’s continue the shift/reduce operations for Phrase 2, “Le gusta el Ruby.” After matching the <code class="literal">VerbAndObject</code> rule, the parser would shift another token to the left, as shown in <a class="xref" href="ch01.html#parser_shifts_another_token_onto_the" title="Figure 1-23. The parser shifts another token onto the stack.">Figure 1-23</a>.</p><div class="figure"><a id="parser_shifts_another_token_onto_the"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00026"/><img alt="The parser shifts another token onto the stack." src="httpatomoreillycomsourcenostarchimages1853873.png.jpg"/></div></div><p class="title">Figure 1-23. The parser shifts another token onto the stack.</p></div><p>At this point, no rules would match, and the state machine would shift another token to the left (see <a class="xref" href="ch01.html#parser_shifts_another_token_onto-id00001" title="Figure 1-24. The parser shifts another token onto the stack.">Figure 1-24</a>).</p><div class="figure"><a id="parser_shifts_another_token_onto-id00001"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00027"/><img alt="The parser shifts another token onto the stack." src="httpatomoreillycomsourcenostarchimages1853875.png.jpg"/></div></div><p class="title">Figure 1-24. The parser shifts another token onto the stack.</p></div><p><a class="indexterm" id="iddle1771"/><a class="indexterm" id="iddle1954"/><a class="indexterm" id="iddle2137"/><a class="xref" href="ch01.html#parser_matches_the_spanishphrase_rul" title="Figure 1-25. The parser matches the SpanishPhrase rule—and the entire input stream!">Figure 1-25</a> shows how the parent grammar rule <code class="literal">SpanishPhrase</code> would match after a final reduce operation.</p><div class="figure"><a id="parser_matches_the_spanishphrase_rul"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00028"/><img alt="The parser matches the SpanishPhrase rule—and the entire input stream!" src="httpatomoreillycomsourcenostarchimages1853877.png.jpg"/></div></div><p class="title">Figure 1-25. The parser matches the <code class="literal">SpanishPhrase</code> rule—and the entire input stream!</p></div><p>I’ve shown you this Spanish-to-English example because Ruby parses your program in exactly the same way! Inside the Ruby <span class="emphasis"><em>parse.y</em></span> source code file, you’ll see hundreds of rules that define the structure and syntax of the Ruby language. There are parent and child rules, and the child rules return values the parent rules can refer to in exactly the same way our <code class="literal">SpanishPhrase</code> grammar rules do, using the symbols <code class="literal">$$</code>, <code class="literal">$1</code>, <code class="literal">$2</code>, and so on. The only real difference is scale: Our <code class="literal">SpanishPhrase</code> grammar example is trivial, really. In contrast, Ruby’s grammar is very complex; it’s an intricate series of interrelated parent and child grammar rules, which sometimes refer to each other in circular, recursive patterns. But this complexity just means that the generated state table in <span class="emphasis"><em>parse.c</em></span> is quite large. The basic LALR algorithm, which describes how the parser processes tokens and uses the state table, is the same in our Spanish example as it is in Ruby.</p><p>To get a sense of just how complex the state table is for Ruby, you can try using Ruby’s <code class="literal">-y</code> option, which displays internal debug information every time the parser jumps from one state to another. <a class="xref" href="ch01.html#ruby_optionally_displays_debug_informati" title="Example 1-14. Ruby optionally displays debug information, showing how the parser jumps from one state to another.">Example 1-14</a> shows a small portion of the output generated when you run the <code class="literal">10.times do</code> example from <a class="xref" href="ch01.html#very_simple_ruby_program_left_parenthe" title="Example 1-1. A very simple Ruby program (simple.rb)">Example 1-1</a>.</p><div class="example"><a id="ruby_optionally_displays_debug_informati"/><p class="title">Example 1-14. Ruby optionally displays debug information, showing how the parser jumps from one state to another.</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ruby -y simple.rb</strong></span>
Starting parse
Entering state 0
Reducing stack by rule 1 (line 850):
-&gt; $$ = nterm @1 ()
Stack now 0
Entering state 2
Reading a token: Next token is token tINTEGER ()
Shifting token tINTEGER ()
Entering state 41
Reducing stack by rule 498 (line 4293):
   $1 = token tINTEGER ()
-&gt; $$ = nterm numeric ()
Stack now 0 2
Entering state 109
--<span class="emphasis"><em>snip</em></span>--</pre></div></div></div><div class="sect2" title="Some Actual Ruby Grammar Rules"><div class="titlepage"><div><div><h2 class="title"><a id="some_actual_ruby_grammar_rules"/>Some Actual Ruby Grammar Rules</h2></div></div></div><p><a class="indexterm" id="iddle1365"/><a class="indexterm" id="iddle1376"/><a class="indexterm" id="iddle1772"/><a class="indexterm" id="iddle1840"/><a class="indexterm" id="iddle2051"/>Let’s look at some actual Ruby grammar rules from <span class="emphasis"><em>parse.y</em></span>. <a class="xref" href="ch01.html#simple_ruby_program_from_listing_1-1" title="Example 1-15. The simple Ruby program from Example 1-1.">Example 1-15</a> contains the simple example Ruby script from <a class="xref" href="ch01.html#very_simple_ruby_program_left_parenthe" title="Example 1-1. A very simple Ruby program (simple.rb)">Example 1-1</a>.</p><div class="example"><a id="simple_ruby_program_from_listing_1-1"/><p class="title">Example 1-15. The simple Ruby program from <a class="xref" href="ch01.html#very_simple_ruby_program_left_parenthe" title="Example 1-1. A very simple Ruby program (simple.rb)">Example 1-1</a>.</p><div class="example-contents"><pre class="programlisting">10.times do |n|
  puts n
end</pre></div></div><p><a class="xref" href="ch01.html#grammar_rules_on_the_right_match_the" title="Figure 1-26. The grammar rules on the right match the Ruby code on the left.">Figure 1-26</a> shows how Ruby’s parsing process works with this script.</p><div class="figure"><a id="grammar_rules_on_the_right_match_the"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00029"/><img alt="The grammar rules on the right match the Ruby code on the left." src="httpatomoreillycomsourcenostarchimages1853879.png.jpg"/></div></div><p class="title">Figure 1-26. The grammar rules on the right match the Ruby code on the left.</p></div><p>On the left is the code that Ruby is trying to parse. On the right are the actual matching grammar rules from the Ruby <span class="emphasis"><em>parse.y</em></span> file, shown simplified. The first rule, <code class="literal">program: top_compstmt</code>, is the root grammar rule that matches every Ruby program in its entirety.</p><p>As you go down the list, you see a complex series of child rules that also match the entire Ruby script: top statements, a single statement, an expression, an argument, and, finally, a primary value. Once Ruby’s parse reaches the primary grammar rule, it encounters a rule with two matching child rules: <code class="literal">method_call</code> and <code class="literal">brace_block</code>. Let’s look at <code class="literal">method_call</code> first (see <a class="xref" href="ch01.html#one0dottimes_matches_the_methodunderscore" title="Figure 1-27. 10.times matches the method_call grammar rule.">Figure 1-27</a>).</p><div class="figure"><a id="one0dottimes_matches_the_methodunderscore"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00030"/><img alt="10.times matches the method_call grammar rule." src="httpatomoreillycomsourcenostarchimages1853881.png.jpg"/></div></div><p class="title">Figure 1-27. <code class="literal">10.times</code> matches the <code class="literal">method_call</code> grammar rule.</p></div><p>The <code class="literal">method_call</code> rule matches the <code class="literal">10.times</code> portion of the Ruby code—that is, where we call the <code class="literal">times</code> method on the <code class="literal">10 Fixnum</code> object. You can <a class="indexterm" id="iddle1087"/><a class="indexterm" id="iddle1185"/><a class="indexterm" id="iddle1368"/><a class="indexterm" id="iddle1370"/><a class="indexterm" id="iddle1372"/><a class="indexterm" id="iddle1374"/><a class="indexterm" id="iddle1375"/><a class="indexterm" id="iddle1499"/><a class="indexterm" id="iddle1501"/><a class="indexterm" id="iddle1754"/><a class="indexterm" id="iddle1832"/>see that the <code class="literal">method_call</code> rule matches another primary value, followed by a period character, followed by an <code class="literal">operation2</code> rule.</p><p><a class="xref" href="ch01.html#value_10_matches_the_primaryundersco" title="Figure 1-28. The value 10 matches the primary_value grammar rule.">Figure 1-28</a> shows that the <code class="literal">primary_value</code> rule first matches the value <code class="literal">10.</code></p><div class="figure"><a id="value_10_matches_the_primaryundersco"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00031"/><img alt="The value 10 matches the primary_value grammar rule." src="httpatomoreillycomsourcenostarchimages1853883.png.jpg"/></div></div><p class="title">Figure 1-28. The value <code class="literal">10</code> matches the <code class="literal">primary_value</code> grammar rule.</p></div><p>Then, in <a class="xref" href="ch01.html#times_method_name_matches_the_operat" title="Figure 1-29. The times method name matches the operation2 grammar rule.">Figure 1-29</a>, the <code class="literal">operation2</code> rule matches the method name <code class="literal">times</code>.</p><div class="figure"><a id="times_method_name_matches_the_operat"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00032"/><img alt="The times method name matches the operation2 grammar rule." src="httpatomoreillycomsourcenostarchimages1853885.png.jpg"/></div></div><p class="title">Figure 1-29. The <code class="literal">times</code> method name matches the <code class="literal">operation2</code> grammar rule.</p></div><p>How does Ruby parse the contents of the <code class="literal">do ... puts ... end</code> block that’s passed to the <code class="literal">times</code> method? It uses the <code class="literal">brace_block</code> rule we saw in <a class="xref" href="ch01.html#grammar_rules_on_the_right_match_the" title="Figure 1-26. The grammar rules on the right match the Ruby code on the left.">Figure 1-26</a>. <a class="xref" href="ch01.html#entire_block_matches_the_braceunders" title="Figure 1-30. The entire block matches the brace_block rule.">Figure 1-30</a> shows the definition of the <code class="literal">brace_block</code> rule.</p><div class="figure"><a id="entire_block_matches_the_braceunders"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00033"/><img alt="The entire block matches the brace_block rule." src="httpatomoreillycomsourcenostarchimages1853887.png.jpg"/></div></div><p class="title">Figure 1-30. The entire block matches the <code class="literal">brace_block</code> rule.</p></div><p>I don’t have space here to go through all the remaining child grammar rules, but you can see how this rule, in turn, contains a series of other matching child rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">keyword_do</code> matches the <code class="literal">do</code> reserved keyword.</p></li><li class="listitem"><p><code class="literal">opt_block_param</code> matches the block parameter <code class="literal">|n|</code>.</p></li><li class="listitem"><p><code class="literal">compstmt</code> matches the contents of the block itself, <code class="literal">puts n</code>.</p></li><li class="listitem"><p><code class="literal">keyword_end</code> matches the <code class="literal">end</code> reserved keyword.</p></li></ul></div><div class="sidebar"><a id="reading_a_bison_grammar_rule"/><p class="title">Reading a Bison Grammar Rule</p><p><a class="indexterm" id="iddle1041"/><a class="indexterm" id="iddle1075"/><a class="indexterm" id="iddle1142"/><a class="indexterm" id="iddle1366"/><a class="indexterm" id="iddle1367"/><a class="indexterm" id="iddle1373"/><a class="indexterm" id="iddle1595"/><a class="indexterm" id="iddle1718"/><a class="indexterm" id="iddle1773"/><a class="indexterm" id="iddle1886"/><a class="indexterm" id="iddle1911"/><a class="indexterm" id="iddle1913"/>To give you a taste of the actual Ruby <span class="emphasis"><em>parse.y</em></span> source code, take a look at <a class="xref" href="ch01.html#rubyapostrophes_actual_methodunderscorec" title="Example 1-16. Ruby’s actual method_call grammar rule from parse.y">Example 1-16</a>, which shows part of the <code class="literal">method_call</code> <span class="inlinemediaobject"><a id="inline_id00019"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> grammar rule definition.</p><div class="example"><a id="rubyapostrophes_actual_methodunderscorec"/><p class="title">Example 1-16. Ruby’s actual <code class="literal">method_call</code> grammar rule from <span class="emphasis"><em>parse.y</em></span></p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> method_call        :
    --<span class="emphasis"><em>snip</em></span>--
          primary_value '.' operation2
          {
          /*%%%*/
              $&lt;num&gt;$ = ruby_sourceline;
          /*% %*/
          }
        opt_paren_args
          {
          /*%%%*/
              $$ = NEW_CALL($1, $3, $5);
              nd_set_line($$, $&lt;num&gt;4);
          /*%
              $$ = dispatch3(call, $1, ripper_id2sym('.'), $3);
              $$ = method_optarg($$, $5);
          %*/
          }</pre></div></div><p>As with the preceding Spanish-to-English example grammar file, you can see that there are snippets of complex C code after each of the terms in the grammar rule. <a class="xref" href="ch01.html#ruby_calls_this_c_code_when_the_optunder" title="Example 1-17. Ruby calls this C code when the opt_paren_args grammar rule matches.">Example 1-17</a> shows one example of this.</p><div class="example"><a id="ruby_calls_this_c_code_when_the_optunder"/><p class="title">Example 1-17. Ruby calls this C code when the <code class="literal">opt_paren_args</code> grammar rule matches.</p><div class="example-contents"><pre class="programlisting">$$ = NEW_CALL($1, $3, $5);
nd_set_line($$, $&lt;num&gt;4);</pre></div></div><p>The Bison-generated parser will execute one of these snippets when there’s a match for a rule on the tokens found in the target Ruby script. However, these C code snippets also contain Bison directives, such as <code class="literal">$$</code> and <code class="literal">$1</code>, that allow the code to create return values and to refer to values returned by other grammar rules. We end up with a confusing mix of C and Bison directives.</p><p>To make things worse, Ruby uses a trick during its build process to divide these C/Bison code snippets into separate pieces. Some of these pieces are used by Ruby, while others are used only by the Ripper tool from <a class="xref" href="ch01.html#experiment_1-1_using_ripper_to_tokenize" title="Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts">Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts</a>. Here’s how that trick works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The C code that appears between the <code class="literal">/*%%%*/</code> line and the <code class="literal">/*%</code> line in <a class="xref" href="ch01.html#rubyapostrophes_actual_methodunderscorec" title="Example 1-16. Ruby’s actual method_call grammar rule from parse.y">Example 1-16</a> is actually compiled into Ruby during the Ruby build process.</p></li><li class="listitem"><p>The C code between <code class="literal">/*%</code> and <code class="literal">%*/</code> in <a class="xref" href="ch01.html#rubyapostrophes_actual_methodunderscorec" title="Example 1-16. Ruby’s actual method_call grammar rule from parse.y">Example 1-16</a> is dropped when Ruby is built. This code is used only by the Ripper tool, which is built separately during the Ruby build process.</p></li></ul></div><p><a class="indexterm" id="iddle1004"/><a class="indexterm" id="iddle1035"/><a class="indexterm" id="iddle1037"/><a class="indexterm" id="iddle1042"/><a class="indexterm" id="iddle1650"/><a class="indexterm" id="iddle1721"/><a class="indexterm" id="iddle1915"/><a class="indexterm" id="iddle1949"/>Ruby uses this very confusing syntax to allow the Ripper tool and Ruby itself to share the same grammar rules inside <span class="emphasis"><em>parse.y</em></span>.</p><p>What are these snippets actually doing? As you might guess, Ruby uses the Ripper code snippets to allow the Ripper tool to display information about what Ruby is parsing. (We’ll try that next, in <a class="xref" href="ch01.html#experiment_1-2_using_ripper_to_parse_dif" title="Experiment 1-2: Using Ripper to Parse Different Ruby Scripts">Experiment 1-2: Using Ripper to Parse Different Ruby Scripts</a>.) There’s also some bookkeeping code: Ruby uses the <code class="literal">ruby_sourceline</code> variable to keep track of which source code line corresponds to each portion of the grammar.</p><p>But more importantly, the snippets Ruby actually uses at run time when parsing your code create a series of <span class="emphasis"><em>nodes</em></span>, or temporary data structures, that form an internal representation of your Ruby code. These nodes are saved in a tree structure called an <span class="emphasis"><em>abstract syntax tree (AST)</em></span> (more about this in <a class="xref" href="ch01.html#experiment_1-2_using_ripper_to_parse_dif" title="Experiment 1-2: Using Ripper to Parse Different Ruby Scripts">Experiment 1-2: Using Ripper to Parse Different Ruby Scripts</a>). You can see one example of creating an AST node in <a class="xref" href="ch01.html#ruby_calls_this_c_code_when_the_optunder" title="Example 1-17. Ruby calls this C code when the opt_paren_args grammar rule matches.">Example 1-17</a>, where Ruby calls the <code class="literal">NEW_CALL</code> C macro/function. This call creates a new <code class="literal">NODE_CALL</code> node, which represents a method call. (In <a class="xref" href="ch02.html" title="Chapter 2. Compilation">Chapter 2</a> we’ll see how Ruby eventually compiles this into bytecode that can be executed by a virtual machine.)</p></div></div></div><div class="sect1" title="Experiment 1-2: Using Ripper to Parse Different Ruby Scripts"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_1-2_using_ripper_to_parse_dif"/>Experiment 1-2: Using Ripper to Parse Different Ruby Scripts</h1></div></div></div><p>In <a class="xref" href="ch01.html#experiment_1-1_using_ripper_to_tokenize" title="Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts">Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts</a>, you learned how to use Ripper to display the tokens that Ruby converts your code into, and we’ve just seen how the Ruby grammar rules in <span class="emphasis"><em>parse.y</em></span> are also included in the Ripper tool. Now let’s learn how to use Ripper to display information about how Ruby parses your code. <a class="xref" href="ch01.html#example_of_how_to_call_ripperdotsexp" title="Example 1-18. An example of how to call Ripper.sexp">Example 1-18</a> shows how to do it.</p><div class="example"><a id="example_of_how_to_call_ripperdotsexp"/><p class="title">Example 1-18. An example of how to call <code class="literal">Ripper.sexp</code></p><div class="example-contents"><pre class="programlisting">    require 'ripper'
    require 'pp'
    code = &lt;&lt;STR
    10.times do |n|
      puts n
    end
    STR
    puts code
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> pp Ripper.sexp(code)</pre></div></div><p>This is exactly the same code from <a class="xref" href="ch01.html#experiment_1-1_using_ripper_to_tokenize" title="Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts">Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts</a>, except that we call <code class="literal">Ripper.sexp</code> <span class="inlinemediaobject"><a id="inline_id00022"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> instead of <code class="literal">Ripper.lex</code>. Running this gives the output shown in <a class="xref" href="ch01.html#output_generated_by_ripperdotsexp" title="Example 1-19. The output generated by Ripper.sexp">Example 1-19</a>.</p><div class="example"><a id="output_generated_by_ripperdotsexp"/><p class="title">Example 1-19. The output generated by <code class="literal">Ripper.sexp</code></p><div class="example-contents"><pre class="programlisting">[:program,
  [[:method_add_block,
     [:call,
       [:@int, "10", [1, 0]], :".",
       [:@ident, "times", [1, 3]]],
     [:do_block,
       [:block_var,
         [:params, [[:@ident, "n", [1, 13]]],
                   nil, nil, nil, nil, nil, nil],
         false],
       [[:command,
          [:@ident, "puts", [2, 2]],
          [:args_add_block, [[:var_ref, [:@ident, "n", [2, 7]]]],
                            false]]]]]]]</pre></div></div><p>You can see some bits and pieces from the Ruby script in this cryptic text, but what do all of the other symbols and arrays mean?</p><p>It turns out that the output from Ripper is a textual representation of your Ruby code. As Ruby parses your code, matching one grammar rule after another, it converts the tokens in your code file into a complex internal data structure called an <span class="emphasis"><em>abstract syntax tree (AST)</em></span>. (You can see some of the C code that produces this structure in <a class="xref" href="ch01.html#reading_a_bison_grammar_rule" title="Reading a Bison Grammar Rule">Reading a Bison Grammar Rule</a>.) The AST is used to record the structure and syntactical meaning of your Ruby code.</p><p>To see what I mean, look at <a class="xref" href="ch01.html#portion_of_the_ast_corresponding_to" title="Figure 1-31. The portion of the AST corresponding to puts n">Figure 1-31</a>, which shows a graphical view of part of the output that Ripper generated for us: the <code class="literal">puts n</code> statement inside the block.</p><div class="figure"><a id="portion_of_the_ast_corresponding_to"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00034"/><img alt="The portion of the AST corresponding to puts n" src="httpatomoreillycomsourcenostarchimages1853889.png.jpg"/></div></div><p class="title">Figure 1-31. The portion of the AST corresponding to <code class="literal">puts n</code></p></div><p><a class="indexterm" id="iddle1015"/><a class="indexterm" id="iddle1039"/>This diagram corresponds to the last three lines of the Ripper output, repeated here in <a class="xref" href="ch01.html#last_three_lines_of_the_ripperdotsex" title="Example 1-20. The last three lines of the Ripper.sexp output">Example 1-20</a>.</p><div class="example"><a id="last_three_lines_of_the_ripperdotsex"/><p class="title">Example 1-20. The last three lines of the <code class="literal">Ripper.sexp</code> output</p><div class="example-contents"><pre class="programlisting">    [[:command,
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>    [:@ident, "puts", [2, 2]],
       [:args_add_block, [[:var_ref, [:@ident, "n", [2, 7]]]],
                         false]]]</pre></div></div><p>As in <a class="xref" href="ch01.html#experiment_1-1_using_ripper_to_tokenize" title="Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts">Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts</a>, when we displayed token information from Ripper, you can see that the source code file line and column information are displayed as integers. For example, <code class="literal">[2, 2]</code> <span class="inlinemediaobject"><a id="inline_id00024"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> indicates that Ripper found the <code class="literal">puts</code> call on line 2 at column 2 of the code file. You can also see that Ripper outputs an array for each of the nodes in the AST—with <code class="literal">[:@ident, "puts", [2, 2]]</code> <span class="inlinemediaobject"><a id="inline_id00025"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, for example.</p><p>Now your Ruby program is beginning to “make sense” to Ruby. Instead of a simple stream of tokens, which could mean anything, Ruby now has a detailed description of what you meant when you wrote <code class="literal">puts n</code>. You see a function call (a command), followed by an identifier node that indicates which function to call.</p><p>Ruby uses the <code class="literal">args_add_block</code> node because you could pass a block to a command/function call like this. Even though you’re not passing a block in this case, the <code class="literal">args_add_block</code> node is still saved into the AST. (Notice, too, how the <code class="literal">n</code> identifier is recorded as a <code class="literal">:var_ref</code>, or variable reference node, not as a simple identifier.)</p><p><a class="xref" href="ch01.html#portion_of_the_ast_corresponding-id00002" title="Figure 1-32. The portion of the AST corresponding to the entire block">Figure 1-32</a> represents more of the Ripper output.</p><div class="figure"><a id="portion_of_the_ast_corresponding-id00002"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00035"/><img alt="The portion of the AST corresponding to the entire block" src="httpatomoreillycomsourcenostarchimages1853891.png.jpg"/></div></div><p class="title">Figure 1-32. The portion of the AST corresponding to the entire block</p></div><p><a class="indexterm" id="iddle1043"/><a class="indexterm" id="iddle1722"/>You can see that Ruby now understands that <code class="literal">do |n| ... end</code> is a block, with a single block parameter called <code class="literal">n</code>. The <code class="literal">puts n</code> box on the right represents the other part of the AST shown earlier—the parsed version of the <code class="literal">puts</code> call.</p><p>Finally, <a class="xref" href="ch01.html#ast_for_the_entire_ruby_program" title="Figure 1-33. The AST for the entire Ruby program">Figure 1-33</a> shows the entire AST for the sample Ruby code.</p><div class="figure"><a id="ast_for_the_entire_ruby_program"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00036"/><img alt="The AST for the entire Ruby program" src="httpatomoreillycomsourcenostarchimages1853893.png.jpg"/></div></div><p class="title">Figure 1-33. The AST for the entire Ruby program</p></div><p>Here, <code class="literal">method add block</code> means that you’re calling a method, but with a block parameter: <code class="literal">10.times do</code>. The <code class="literal">call</code> tree node obviously represents the actual method call <code class="literal">10.times</code>. This is the <code class="literal">NODE_CALL</code> node that we saw earlier in the C code snippet. Ruby’s understanding of what you meant with your code is saved in the way the nodes are arranged in the AST.</p><p>To clarify things, suppose you pass the Ruby expression <code class="literal">2 + 2</code> to Ripper, as shown in <a class="xref" href="ch01.html#this_code_will_display_the_ast_for_2_plu" title="Example 1-21. This code will display the AST for 2 + 2.">Example 1-21</a>.</p><div class="example"><a id="this_code_will_display_the_ast_for_2_plu"/><p class="title">Example 1-21. This code will display the AST for <code class="literal">2 + 2</code>.</p><div class="example-contents"><pre class="programlisting">require 'ripper'
require 'pp'
code = &lt;&lt;STR
2 + 2
STR
puts code
pp Ripper.sexp(code)</pre></div></div><p><a class="indexterm" id="iddle1040"/><a class="indexterm" id="iddle1069"/>Running this code gives the output in <a class="xref" href="ch01.html#output_of_ripperdotsexp_for_2_plus_2" title="Example 1-22. The output of Ripper.sexp for 2 + 2">Example 1-22</a>.</p><div class="example"><a id="output_of_ripperdotsexp_for_2_plus_2"/><p class="title">Example 1-22. The output of <code class="literal">Ripper.sexp</code> for <code class="literal">2 + 2</code></p><div class="example-contents"><pre class="programlisting">[:program,
  [[:binary,
     [:@int, "2", [1, 0]],
     :+,
     [:@int, "2", [1, 4]]]]]</pre></div></div><p>As you can see in <a class="xref" href="ch01.html#ast_for_2_plus_2" title="Figure 1-34. The AST for 2 + 2">Figure 1-34</a> below, the <code class="literal">+</code> is represented with an AST node called <code class="literal">binary</code>.</p><div class="figure"><a id="ast_for_2_plus_2"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00037"/><img alt="The AST for 2 + 2" src="httpatomoreillycomsourcenostarchimages1853895.png.jpg"/></div></div><p class="title">Figure 1-34. The AST for <code class="literal">2 + 2</code></p></div><p>But see what happens when I pass the expression <code class="literal">2 + 2 * 3</code> into Ripper, as in <a class="xref" href="ch01.html#code_to_display_the_ast_for_2_plus_2_ast" title="Example 1-23. Code to display the AST for 2 + 2 * 3">Example 1-23</a>.</p><div class="example"><a id="code_to_display_the_ast_for_2_plus_2_ast"/><p class="title">Example 1-23. Code to display the AST for <code class="literal">2 + 2 * 3</code></p><div class="example-contents"><pre class="programlisting">require 'ripper'
require 'pp'
code = &lt;&lt;STR
2 + 2 * 3
STR
puts code
pp Ripper.sexp(code)</pre></div></div><p><a class="xref" href="ch01.html#output_of_ripperdotsexp_for_2_pl-id00003" title="Example 1-24. The output of Ripper.sexp for 2 + 2 * 3">Example 1-24</a> shows that you get a second binary node for the <code class="literal">*</code> operator at <span class="inlinemediaobject"><a id="inline_id00026"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>.</p><div class="example"><a id="output_of_ripperdotsexp_for_2_pl-id00003"/><p class="title">Example 1-24. The output of <code class="literal">Ripper.sexp</code> for <code class="literal">2 + 2 * 3</code></p><div class="example-contents"><pre class="programlisting">    [:program,
     [[:binary,
       [:@int, "2", [1, 0]],
       :+,
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>    [:binary,
         [:@int, "2", [1, 4]],
         :*,
         [:@int, "3", [1, 8]]]]]]</pre></div></div><p><a class="xref" href="ch01.html#ast_for_2_plus_2_asterisk_3" title="Figure 1-35. The AST for 2 + 2 * 3">Figure 1-35</a> shows what that looks like.</p><div class="figure"><a id="ast_for_2_plus_2_asterisk_3"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00038"/><img alt="The AST for 2 + 2 * 3" src="httpatomoreillycomsourcenostarchimages1853897.png.jpg"/></div></div><p class="title">Figure 1-35. The AST for <code class="literal">2 + 2 * 3</code></p></div><p>Ruby was smart enough to realize that multiplication has a higher precedence than addition, but what’s really interesting is how the AST tree structure captures the information about the order of operations. The token stream <code class="literal">2 + 2 * 3</code> simply indicates what you wrote in your code file. But the parsed version that’s saved to the AST structure now contains the <span class="emphasis"><em>meaning</em></span> of your code—that is, all of the information Ruby will need later to execute it.</p><p><a class="indexterm" id="iddle1237"/><a class="indexterm" id="iddle1778"/><a class="indexterm" id="iddle1943"/>One final note: Ruby actually contains some debug code that can display information about the AST node structure. To use it, run your Ruby script with the <code class="literal">parsetree</code> option (see <a class="xref" href="ch01.html#display_debug_information_about_your_cod" title="Example 1-25. Display debug information about your code’s AST using the parsetree option.">Example 1-25</a>).</p><div class="example"><a id="display_debug_information_about_your_cod"/><p class="title">Example 1-25. Display debug information about your code’s AST using the <code class="literal">parsetree</code> option.</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ruby --dump parsetree your_script.rb</strong></span></pre></div></div><p>This will display the same information we’ve just seen, but instead of showing symbols, the <code class="literal">parsetree</code> option should show the actual node names from the C source code. (In <a class="xref" href="ch02.html" title="Chapter 2. Compilation">Chapter 2</a>, I’ll also use the actual node names.)</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00004"/>Summary</h1></div></div></div><p>In <a class="xref" href="ch01.html" title="Chapter 1. Tokenization and Parsing">Chapter 1</a>, we looked at one of the most fascinating areas of computer science: how Ruby can <span class="emphasis"><em>understand</em></span> the text that you give it—your Ruby program. In order to do this, Ruby converts your code into two different formats. First, it converts the text in your Ruby program into a series of <span class="emphasis"><em>tokens</em></span>. Next, it uses an LALR parser to convert the input stream of tokens into a data structure called an <span class="emphasis"><em>abstract syntax tree</em></span>.</p><p>In <a class="xref" href="ch02.html" title="Chapter 2. Compilation">Chapter 2</a>, we’ll see that Ruby converts your code into a third format: a series of <span class="emphasis"><em>bytecode instructions</em></span> that are later used when your program is actually executed.</p></div></div></body></html>